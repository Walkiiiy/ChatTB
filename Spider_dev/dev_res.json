{
    "0": {
        "db_id": "concert_singer",
        "question": "How many singers do we have?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `songs` table in the FROM clause. Do count records from the correct table `singer` instead of the incorrect table `songs`. The amended query now correctly counts records from the singer table as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": []
    },
    "1": {
        "db_id": "concert_singer",
        "question": "What is the total number of singers?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of `singers` to use the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistent function casing. Do remove the `WHERE name IS NOT NULL` filter instead of keeping it to count all records regardless of null values. The amended query now correctly counts all rows in the singer table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM singers WHERE name IS NOT NULL;",
            "SELECT count(*) FROM singer"
        ],
        "rule_sql": []
    },
    "2": {
        "db_id": "concert_singer",
        "question": "Show name, country, age for all singers ordered by age from the oldest to the youngest.",
        "ground_truth": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use `ORDER BY age DESC` instead of `ORDER BY age ASC` to sort in descending order rather than ascending. The amended query now correctly references the intended table and sorts the results by age in descending order as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, country, age FROM singers ORDER BY age ASC;",
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ],
        "rule_sql": []
    },
    "3": {
        "db_id": "concert_singer",
        "question": "What are the names, countries, and ages for every singer in descending order of age?",
        "ground_truth": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use `ORDER BY age DESC` instead of `ORDER BY age ASC` to sort in descending order rather than ascending order. The amended query now correctly references the intended table and produces the desired descending age ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, country, age FROM singers ORDER BY age ASC;",
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ],
        "rule_sql": []
    },
    "4": {
        "db_id": "concert_singer",
        "question": "What is the average, minimum, and maximum age of all singers from France?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do maintain the same aggregate functions `AVG(age)`, `MIN(age)`, and `MAX(age)` with identical column references. Do preserve the WHERE filter `country = 'France'` without changes. The amended query now correctly references the intended table while maintaining the same aggregation logic and filtering criteria, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singers WHERE country = 'France';",
            "SELECT AVG(Age) AS average_age, MIN(Age) AS minimum_age, MAX(Age) AS maximum_age FROM singer WHERE Country = 'France';"
        ],
        "rule_sql": []
    },
    "5": {
        "db_id": "concert_singer",
        "question": "What is the average, minimum, and maximum age for all French singers?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use filter condition `country = 'France'` instead of `nationality = 'France'` in the WHERE clause. The amended query now correctly calculates age statistics for French singers from the appropriate table with the correct country filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singers WHERE nationality = 'France';",
            "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age, MAX(Age) AS Maximum_Age FROM singer WHERE Country = 'France';"
        ],
        "rule_sql": []
    },
    "6": {
        "db_id": "concert_singer",
        "question": "Show the name and the release year of the song by the youngest singer.",
        "ground_truth": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",
        "amends": [
            "Do select `song_name` and `song_release_year` instead of `name` and `release_year`. Do use table `singer` instead of `songs`. Do order by `age` instead of `singer_age`. The amended query now correctly retrieves song information from the singer table ordered by age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, release_year FROM songs ORDER BY singer_age ASC LIMIT 1;",
            "SELECT Song_Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7": {
        "db_id": "concert_singer",
        "question": "What are the names and release years for all the songs of the youngest singer?",
        "ground_truth": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",
        "amends": [
            "Do select `song_name` and `song_release_year` instead of `s.name` and `s.release_year`. Do use `FROM singer` instead of joining `songs` and `singers` tables. Do remove the `WHERE` clause with subquery for maximum age instead of keeping it. Do add `ORDER BY age` and `LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the song details from the oldest singer by ordering by age and limiting to one result instead of using a complex join with subquery."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name, s.release_year \nFROM songs s \nJOIN singers si ON s.singer_id = si.id \nWHERE si.age = (SELECT MAX(age) FROM singers);",
            "SELECT Song_Name, Song_release_year FROM singer ORDER BY Age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8": {
        "db_id": "concert_singer",
        "question": "What are all distinct countries where singers above age 20 are from?",
        "ground_truth": "SELECT DISTINCT country FROM singer WHERE age  >  20",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause while keeping the same SELECT list with `DISTINCT country` and WHERE filter `age > 20` unchanged. The amended query now correctly references the singular table name and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country FROM singers WHERE age > 20;",
            "SELECT DISTINCT country FROM singer WHERE age > 20"
        ],
        "rule_sql": []
    },
    "9": {
        "db_id": "concert_singer",
        "question": "What are  the different countries with singers above age 20?",
        "ground_truth": "SELECT DISTINCT country FROM singer WHERE age  >  20",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause while keeping all other elements identical including the SELECT DISTINCT country and WHERE age > 20 filter, as the table name correction is the only change needed to match the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country FROM singers WHERE age > 20;",
            "SELECT DISTINCT Country FROM singer WHERE Age > 20"
        ],
        "rule_sql": []
    },
    "10": {
        "db_id": "concert_singer",
        "question": "Show all countries and the number of singers in each country.",
        "ground_truth": "SELECT country ,  count(*) FROM singer GROUP BY country",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause, correcting the table name to match the intended data source. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Country, COUNT(*) AS NumberOfSingers FROM singer GROUP BY Country;"
        ],
        "rule_sql": []
    },
    "11": {
        "db_id": "concert_singer",
        "question": "How many singers are from each country?",
        "ground_truth": "SELECT country ,  count(*) FROM singer GROUP BY country",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause, as the correct table name is singular rather than plural. The amended query now correctly counts records by country from the singer table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Country, COUNT(*) AS Singer_Count FROM singer GROUP BY Country;"
        ],
        "rule_sql": []
    },
    "12": {
        "db_id": "concert_singer",
        "question": "List all song names by singers above the average age.",
        "ground_truth": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)",
        "amends": [
            "Do reference table `singer` instead of `songs` in the FROM clause. Do use column `age` instead of `singer_age` in both the main query and subquery. Do reference table `singer` instead of `singers` in the subquery's FROM clause. Do use aggregate function `avg(age)` instead of `AVG(singer_age)` in the subquery. The amended query now correctly filters songs based on singers whose age exceeds the average age of all singers, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE singer_age > (SELECT AVG(singer_age) FROM singers);",
            "SELECT Song_Name FROM singer WHERE Age > (SELECT AVG(Age) FROM singer)"
        ],
        "rule_sql": []
    },
    "13": {
        "db_id": "concert_singer",
        "question": "What are all the song names by singers who are older than average?",
        "ground_truth": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)",
        "amends": [
            "Do reference table `singer` instead of `songs` in the FROM clause. Do use column `age` instead of `singer_age` for the comparison. Do reference table `singer` instead of `singers` in the subquery. Do use column `age` instead of `singer_age` in the subquery's AVG function. The amended query now correctly filters songs based on singers whose age exceeds the average age of all singers, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE singer_age > (SELECT AVG(singer_age) FROM singers);",
            "SELECT s.Song_Name FROM singer s WHERE s.Age > (SELECT AVG(age) FROM singer)"
        ],
        "rule_sql": []
    },
    "14": {
        "db_id": "concert_singer",
        "question": "Show location and name for all stadiums with a capacity between 5000 and 10000.",
        "ground_truth": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",
        "amends": [
            "Do use the table name `stadium` instead of `stadiums`. Do use `BETWEEN 5000 AND 10000` instead of `capacity < 5000 OR capacity > 10000` to select stadiums with capacity within the specified range rather than outside it. Do capitalize `LOCATION` instead of `location` while keeping the same column selection. The amended query now correctly filters for stadiums with capacity between 5000 and 10000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, name FROM stadiums WHERE capacity < 5000 OR capacity > 10000;",
            "SELECT LOCATION, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ],
        "rule_sql": []
    },
    "15": {
        "db_id": "concert_singer",
        "question": "What are the locations and names of all stations with capacity between 5000 and 10000?",
        "ground_truth": "SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",
        "amends": [
            "Do reference table `stadium` instead of `stations` in the FROM clause. Do use `BETWEEN 5000 AND 10000` instead of `capacity > 10000 OR capacity < 5000` in the WHERE filter to select capacities within the range rather than outside it. Do capitalize `LOCATION` instead of `location` in the SELECT list while keeping the same column semantics. The amended query now correctly selects stadium locations and names within the specified capacity range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, name FROM stations WHERE capacity > 10000 OR capacity < 5000;",
            "SELECT Location, Name FROM stadium WHERE Capacity BETWEEN 5000 AND 10000;"
        ],
        "rule_sql": []
    },
    "16": {
        "db_id": "concert_singer",
        "question": "What is the maximum capacity and the average of all stadiums ?",
        "ground_truth": "select max(capacity), average from stadium",
        "amends": [
            "Do `max(capacity)` instead of `MIN(capacity)` for the maximum value calculation. Do `average` instead of `AVG(capacity)` for the average column alias. Do `stadium` instead of `stadiums` for the correct table name. The amended query now correctly calculates maximum capacity with proper table reference and column aliasing.",
            "Do include the `average` column directly in the SELECT list instead of calculating it with `AVG(Capacity) AS average`. Do remove the alias `maximum` from the `MAX(Capacity)` expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting the maximum capacity and the average column directly from the stadium table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(capacity), AVG(capacity) FROM stadiums;",
            "SELECT MAX(Capacity) AS maximum, AVG(Capacity) AS average FROM stadium;",
            "SELECT MAX(Capacity), average FROM stadium"
        ],
        "rule_sql": []
    },
    "17": {
        "db_id": "concert_singer",
        "question": "What is the average and maximum capacities for all stadiums ?",
        "ground_truth": "select avg(capacity) ,  max(capacity) from stadium",
        "amends": [
            "Do use `max(capacity)` instead of `min(capacity)` in the SELECT list to calculate the maximum capacity rather than the minimum. Do reference table `stadium` instead of `stadiums` to correctly identify the data source. The amended query now correctly calculates both average and maximum capacity values from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(capacity), MIN(capacity) FROM stadiums;",
            "SELECT AVG(Capacity) AS Average_Capacity, MAX(Capacity) AS Maximum_Capacity FROM stadium;"
        ],
        "rule_sql": []
    },
    "18": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity for the stadium with highest average attendance?",
        "ground_truth": "SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",
        "amends": [
            "Do reference table `stadium` instead of `stadiums` in the FROM clause. Do order by column `average` instead of `attendance` in the ORDER BY clause. The amended query now correctly references the intended table and ordering column to match the desired behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY attendance DESC LIMIT 1;",
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "19": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity for the stadium with the highest average attendance?",
        "ground_truth": "SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",
        "amends": [
            "Do reference table `stadium` instead of `stadiums` in the FROM clause. Do order by `average` instead of `capacity` in the ORDER BY clause. The amended query now correctly references the intended table and sorts by the average column rather than capacity, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY capacity DESC LIMIT 1;",
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "20": {
        "db_id": "concert_singer",
        "question": "How many concerts are there in year 2014 or 2015?",
        "ground_truth": "SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015",
        "amends": [
            "Do use `OR` instead of `AND` for the year filter to correctly count concerts from either 2014 or 2015 instead of incorrectly requiring concerts to be from both years simultaneously. Do reference table `concert` instead of `concerts` to match the correct table name. The amended query now correctly counts concerts from either 2014 or 2015, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE year = 2014 AND year = 2015;",
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015'"
        ],
        "rule_sql": []
    },
    "21": {
        "db_id": "concert_singer",
        "question": "How many concerts occurred in 2014 or 2015?",
        "ground_truth": "SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015",
        "amends": [
            "Do reference table `concert` instead of `concerts` in the FROM clause. Do use consistent case for the `YEAR` column instead of lowercase `year`. The amended query now correctly references the intended table and maintains consistent column naming to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE year = 2014 OR year = 2015;",
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015';"
        ],
        "rule_sql": []
    },
    "22": {
        "db_id": "concert_singer",
        "question": "Show the stadium name and the number of concerts in each stadium.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",
        "amends": [
            "Do join `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of querying only the `concerts` table. Do select `T2.name` instead of `stadium_name` to properly reference the joined table's column. Do group by `T1.stadium_id` instead of `stadium_name` to ensure correct aggregation with the join relationship. The amended query now correctly counts concerts per stadium by joining the necessary tables and using proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stadium_name, COUNT(*) FROM concerts GROUP BY stadium_name;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS number_of_concerts\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID;"
        ],
        "rule_sql": []
    },
    "23": {
        "db_id": "concert_singer",
        "question": "For each stadium, how many concerts play there?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",
        "amends": [
            "Do join `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of omitting the stadium table entirely. Do select `T2.name` instead of `stadium_name` since the stadium name should come from the joined stadium table rather than a non-existent column. Do reference `concert AS T1` instead of `concerts` to use the correct table alias. Do group by `T1.stadium_id` instead of `stadium_id` to use the aliased column reference. The amended query now correctly joins the necessary tables and selects the stadium name from the appropriate source, matching the RIGHT_SQL's behavior.",
            "Do use `JOIN` instead of `RIGHT JOIN` to properly match stadiums with concerts. Do reference `T2.name` instead of `T2.Name` for case consistency. Do use `count(*)` instead of `COUNT(T1.concert_ID)` to count all rows including those where concert_ID might be NULL. Do group by `T1.stadium_id` instead of `T1.Stadium_ID` for case consistency. The amended query now correctly counts concerts per stadium using an inner join that only includes stadiums with associated concerts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stadium_name, COUNT(*) FROM concerts GROUP BY stadium_id;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS concert_count\nFROM concert AS T1\nRIGHT JOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID",
            "SELECT T2.Name, COUNT(*) AS concert_count\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID"
        ],
        "rule_sql": []
    },
    "24": {
        "db_id": "concert_singer",
        "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.",
        "ground_truth": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` and `T2.capacity` instead of `stadium_name` and `capacity`. Do join `concert AS T1` with `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of querying `stadiums` alone. Do filter on `T1.year >= 2014` instead of `year >= 2014`. Do add `GROUP BY T2.stadium_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `capacity DESC` to find the stadium with the most concerts. The amended query now correctly identifies the stadium with the highest number of concerts since 2014 rather than simply the largest stadium capacity."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stadium_name, capacity \nFROM stadiums \nWHERE year >= 2014 \nORDER BY capacity DESC \nLIMIT 1;",
            "SELECT T2.Name, T2.Capacity\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year >= '2014'\nGROUP BY T2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "25": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity of the stadium with the most concerts after 2013 ?",
        "ground_truth": "select t2.name ,  t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id  =  t2.stadium_id where t1.year  >  2013 group by t2.stadium_id order by count(*) desc limit 1",
        "amends": [
            "Do select `t2.name` and `t2.capacity` from the `stadium` table instead of selecting `name` and `capacity` directly from `stadiums`. Do join `concert` as `t1` with `stadium` as `t2` on `t1.stadium_id = t2.stadium_id` instead of querying only the `stadiums` table. Do add a WHERE filter for `t1.year > 2013` instead of omitting any year condition. Do add GROUP BY on `t2.stadium_id` instead of not grouping. Do order by `count(*)` descending instead of ordering by `concerts_after_2013` descending. The amended query now correctly identifies the stadium with the most concerts after 2013 by joining concert data and counting events per stadium."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY concerts_after_2013 DESC LIMIT 1;",
            "SELECT t2.Name, t2.Capacity\nFROM concert AS t1\nJOIN stadium AS t2 ON t1.Stadium_ID = t2.Stadium_ID\nWHERE t1.Year > '2013'\nGROUP BY t2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "26": {
        "db_id": "concert_singer",
        "question": "Which year has most number of concerts?",
        "ground_truth": "SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `concert_count`. Do use `concert` as the table name instead of `concerts`. Do order by `count(*) DESC` instead of `concert_count ASC` to find the year with the most concerts rather than the fewest. Do remove the explicit alias `concert_count` since it's not needed in the ORDER BY clause. The amended query now correctly identifies the year with the highest number of concerts by counting records per year and ordering descending by count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as concert_count FROM concerts GROUP BY year ORDER BY concert_count ASC LIMIT 1;",
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "27": {
        "db_id": "concert_singer",
        "question": "What is the year that had the most concerts?",
        "ground_truth": "SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `concert_count`. Do use `count(*)` in the ORDER BY clause instead of selecting it as an alias. Do order by `DESC` instead of `ASC` to find the year with the most concerts. Do reference table `concert` instead of `concerts`. The amended query now correctly identifies the year with the highest number of concerts by counting records per year and ordering descending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as concert_count FROM concerts GROUP BY year ORDER BY concert_count ASC LIMIT 1;",
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "28": {
        "db_id": "concert_singer",
        "question": "Show the stadium names without any concert.",
        "ground_truth": "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)",
        "amends": [
            "Do select `name` instead of `stadium_name` and use a subquery with `NOT IN` instead of checking `IS NULL` on `concert_id`. Do reference table `stadium` instead of `stadiums` and use `stadium_id` as the correlation key instead of `concert_id`. Do remove the direct null check filter and instead implement a subquery that identifies stadiums not present in the concert table, which correctly handles the case where stadiums may have no associated concerts. The amended query now matches the right SQL's behavior by properly identifying stadiums without any concerts through a correlated subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stadium_name FROM stadiums WHERE concert_id IS NULL;",
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert)"
        ],
        "rule_sql": []
    },
    "29": {
        "db_id": "concert_singer",
        "question": "What are the names of the stadiums without any concerts?",
        "ground_truth": "SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert)",
        "amends": [
            "Do reference the correct table name `stadium` instead of the incorrect plural `stadiums`. Do use a subquery with `NOT IN` to filter stadiums not associated with any concerts instead of checking for `IS NULL` on a non-existent `concert_id` column. Do filter by `stadium_id NOT IN (SELECT stadium_id FROM concert)` instead of the incorrect `concert_id IS NULL` condition. The amended query now correctly identifies stadiums without concerts by checking the absence of stadium IDs in the concert table rather than relying on a missing column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE concert_id IS NULL;",
            "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert);"
        ],
        "rule_sql": []
    },
    "30": {
        "db_id": "concert_singer",
        "question": "Show countries where a singer above age 40 and a singer below 30 are from.",
        "ground_truth": "SELECT country FROM singer WHERE age  >  40 INTERSECT SELECT country FROM singer WHERE age  <  30",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and do use `INTERSECT` with two separate queries instead of `OR` in the `WHERE` clause. Do change the table name from `singers` to `singer` instead of using the plural form. Do split the age conditions into separate queries for `age > 40` and `age < 30` instead of combining them with `OR`, and do use `INTERSECT` to find countries that appear in both result sets instead of finding countries where either condition is true. The amended query now correctly finds countries that have both singers over 40 and singers under 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM singers \nWHERE age > 40 OR age < 30;",
            "SELECT Country FROM singer WHERE Age > 40 INTERSECT SELECT Country FROM singer WHERE Age < 30"
        ],
        "rule_sql": []
    },
    "31": {
        "db_id": "concert_singer",
        "question": "Show names for all stadiums except for stadiums having a concert in year 2014.",
        "ground_truth": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "amends": [
            "Do use `EXCEPT` to filter out stadiums with concerts in 2014 instead of a simple inequality filter on year. Do add a join between `concert` and `stadium` tables on `stadium_id` instead of querying only the `stadiums` table. Do include the condition `T1.year = 2014` to specifically exclude stadiums hosting concerts in that year instead of filtering stadiums by their own year attribute. Do reference the correct table name `stadium` instead of `stadiums` throughout the query. The amended query now correctly identifies stadiums that did not host any concerts in 2014, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE year != 2014;",
            "SELECT Name FROM stadium EXCEPT SELECT s.Name FROM stadium s JOIN concert c ON s.Stadium_ID = c.Stadium_ID WHERE c.Year = '2014'"
        ],
        "rule_sql": []
    },
    "32": {
        "db_id": "concert_singer",
        "question": "What are the names of all stadiums that did not have a concert in 2014?",
        "ground_truth": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add explicit table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with `ON T1.stadium_id = T2.stadium_id` instead of a correlated subquery. Do reference `T2.name` in the second part instead of just `name`. Do specify `FROM concert AS T1` and `FROM stadium AS T2` instead of the singular table names `concerts` and `stadiums`. The amended query now correctly handles potential NULL values in the stadium_id comparison and matches the RIGHT_SQL's behavior using set operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE stadium_id NOT IN (SELECT stadium_id FROM concerts WHERE year = 2014);",
            "SELECT T2.Name\nFROM stadium AS T2\nEXCEPT\nSELECT T2.Name\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'"
        ],
        "rule_sql": []
    },
    "33": {
        "db_id": "concert_singer",
        "question": "Show the name and theme for all concerts and the number of singers in each concert.",
        "ground_truth": "SELECT T2.concert_name ,  T2.theme ,  count(*) FROM singer_in_concert AS T1 JOIN concert AS T2 ON T1.concert_id  =  T2.concert_id GROUP BY T2.concert_id",
        "amends": [
            "Do select `concert_name` and `theme` instead of `name` and `theme`. Do join `singer_in_concert` with `concert` on `concert_id` instead of querying only the `concerts` table. Do count all rows with `count(*)` instead of counting `singer_id`. Do group by `T2.concert_id` instead of `concert_id` without table qualification. The amended query now correctly aggregates singer counts per concert by properly joining the concert and singer association tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, theme, COUNT(singer_id) AS singer_count FROM concerts GROUP BY concert_id",
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS singer_count\nFROM concert c\nLEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID\nGROUP BY c.concert_ID, c.concert_Name, c.Theme"
        ],
        "rule_sql": []
    },
    "34": {
        "db_id": "concert_singer",
        "question": "What are the names , themes , and number of singers for every concert ?",
        "ground_truth": "select t2.concert_name ,  t2.theme ,  count(*) from singer_in_concert as t1 join concert as t2 on t1.concert_id  =  t2.concert_id group by t2.concert_id",
        "amends": [
            "Do select `concert_name` and `theme` from the `concert` table instead of `name` and `theme` from an unspecified source. Do join `singer_in_concert` with `concert` on `concert_id` instead of querying only the `concerts` table. Do use `count(*)` to count all rows instead of `COUNT(singer_id)` which might miss null values. Do group by `t2.concert_id` from the joined table instead of grouping by `concert_id` from a single table. The amended query now correctly counts singers per concert by properly joining the relationship tables and grouping on the concert identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, theme, COUNT(singer_id) AS number_of_singers FROM concerts GROUP BY concert_id;",
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS number_of_singers\nFROM concert c\nJOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID\nGROUP BY c.concert_ID, c.concert_Name, c.Theme;"
        ],
        "rule_sql": []
    },
    "35": {
        "db_id": "concert_singer",
        "question": "List singer names and number of concerts for each singer.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
        "amends": [
            "Do select `T2.name` instead of `singer_name` and join `singer_in_concert AS T1` with `singer AS T2` on `T1.singer_id = T2.singer_id` instead of querying `singers` directly, then group by `T2.singer_id` instead of `singer_id` to correctly count concerts per singer while preserving the intended aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT singer_name, COUNT(*) FROM singers GROUP BY singer_id;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS number_of_concerts\nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T2.Singer_ID"
        ],
        "rule_sql": []
    },
    "36": {
        "db_id": "concert_singer",
        "question": "What are the names of the singers and number of concerts for each person?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
        "amends": [
            "Do join `singer_in_concert` and `singer` tables with `JOIN` on `T1.singer_id = T2.singer_id` instead of querying only the `singers` table. Do select from `singer_in_concert AS T1` and `singer AS T2` instead of the single `singers` table. Do group by `T2.singer_id` instead of `name` to ensure proper aggregation. Do reference `T2.name` in the SELECT list instead of just `name` to make the column reference explicit. The amended query now correctly counts concert appearances per singer by joining the relevant tables and grouping by singer ID instead of name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM singers GROUP BY name;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS Number_of_Concerts\nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T2.Singer_ID"
        ],
        "rule_sql": []
    },
    "37": {
        "db_id": "concert_singer",
        "question": "List all singer names in concerts in year 2014.",
        "ground_truth": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014",
        "amends": [
            "Do select `T2.name` from the `singer` table instead of `singer_name` from a non-existent source. Do join `singer_in_concert AS T1` to `singer AS T2` on `T1.singer_id = T2.singer_id` instead of missing this relationship entirely. Do add a second join to `concert AS T3` on `T1.concert_id = T3.concert_id` instead of omitting the concert table. Do filter on `T3.year = 2014` instead of filtering on a non-existent `year` column in the wrong table. The amended query now correctly retrieves singer names for concerts in 2014 by properly joining through the relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT singer_name FROM concerts WHERE year = 2014;",
            "SELECT T2.Name \nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nJOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ],
        "rule_sql": []
    },
    "38": {
        "db_id": "concert_singer",
        "question": "What are the names of the singers who performed in a concert in 2014?",
        "ground_truth": "SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014",
        "amends": [
            "Do select `T2.name` from the `singer` table instead of `name` from the `singers` table. Do add joins to `singer_in_concert AS T1` and `concert AS T3` instead of querying only the `singers` table. Do use `LEFT JOIN` on `T1.singer_id = T2.singer_id` and `LEFT JOIN` on `T1.concert_id = T3.concert_id` instead of no joins. Do filter on `T3.year = 2014` instead of `concert_year = 2014` since the year column exists in the concert table rather than the singers table. The amended query now correctly joins through the association table to find singers who performed in concerts during 2014."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE concert_year = 2014;",
            "SELECT T2.Name \nFROM singer AS T2\nLEFT JOIN singer_in_concert AS T1 ON T1.Singer_ID = T2.Singer_ID\nLEFT JOIN concert AS T3 ON T1.concert_ID = T3.concert_ID\nWHERE T3.Year = '2014'"
        ],
        "rule_sql": []
    },
    "39": {
        "db_id": "concert_singer",
        "question": "what is the name and nation of the singer who have a song having 'Hey' in its name?",
        "ground_truth": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",
        "amends": [
            "Do use column alias `country` instead of `nation` in the SELECT list while keeping the same `name` column and maintaining the identical WHERE filter `song_name LIKE '%Hey%'` without any changes to table sources, join conditions, grouping, ordering, or other clauses. The amended query now correctly retrieves the country information using the proper column name while preserving all other query logic and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, nation FROM singer WHERE song_name LIKE '%Hey%'",
            "SELECT name, country FROM singer WHERE song_name LIKE '%Hey%'"
        ],
        "rule_sql": []
    },
    "40": {
        "db_id": "concert_singer",
        "question": "What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?",
        "ground_truth": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do filter on column `song_name` instead of `title` in the WHERE condition with the LIKE pattern '%Hey%'. The amended query now correctly retrieves artist names and countries from the singer table based on song titles containing 'Hey'."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, country FROM singers WHERE title LIKE '%Hey%';",
            "SELECT Name, Country FROM singer WHERE Song_Name LIKE '%Hey%';"
        ],
        "rule_sql": []
    },
    "41": {
        "db_id": "concert_singer",
        "question": "Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
        "ground_truth": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "amends": [
            "Do use `concert` and `stadium` tables with `JOIN` on `stadium_id` instead of querying only `stadiums` table. Do filter by `Year = 2014` in one branch and `Year = 2015` in another instead of the impossible `year = 2014 AND year = 2015`. Do use `INTERSECT` to find stadiums that hosted concerts in both years instead of attempting to find a single row satisfying both year conditions simultaneously. Do reference columns with table aliases `T2.name` and `T2.location` instead of unqualified `name` and `location`. The amended query now correctly identifies stadiums that hosted concerts in both 2014 and 2015 by using intersection logic instead of the contradictory WHERE clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM stadiums WHERE year = 2014 AND year = 2015;",
            "SELECT T2.Name, T2.Location\nFROM concert T1\nJOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'\nINTERSECT\nSELECT T2.Name, T2.Location\nFROM concert T1\nJOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2015'"
        ],
        "rule_sql": []
    },
    "42": {
        "db_id": "concert_singer",
        "question": "What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
        "ground_truth": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "amends": [
            "Do use `concert` and `stadium` tables with `JOIN` on `stadium_id` instead of querying `stadiums` table alone. Do filter by `Year = 2014` in one branch and `Year = 2015` in another instead of the impossible `year = 2014 AND year = 2015`. Do use `INTERSECT` to find stadiums that hosted concerts in both years instead of attempting to find a single row satisfying both year conditions simultaneously. Do reference columns with table aliases `T1` and `T2` instead of direct column names. The amended query now correctly identifies stadiums that hosted concerts in both 2014 and 2015, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM stadiums WHERE year = 2014 AND year = 2015;",
            "SELECT DISTINCT s.Name, s.Location\nFROM stadium s\nJOIN concert c1 ON s.Stadium_ID = c1.Stadium_ID\nJOIN concert c2 ON s.Stadium_ID = c2.Stadium_ID\nWHERE c1.Year = '2014' AND c2.Year = '2015'"
        ],
        "rule_sql": []
    },
    "43": {
        "db_id": "concert_singer",
        "question": "Find the number of concerts happened in the stadium with the highest capacity .",
        "ground_truth": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
        "amends": [
            "Do reference table `concert` instead of `concerts` and use `stadium` instead of `stadiums` in the subquery to match the correct schema. The amended query now correctly counts concerts at the stadium with the highest capacity by using the proper table names while maintaining the same logical structure and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE stadium_id = (SELECT stadium_id FROM stadiums ORDER BY capacity DESC LIMIT 1);",
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID = (\n    SELECT Stadium_ID \n    FROM stadium \n    ORDER BY Capacity DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "44": {
        "db_id": "concert_singer",
        "question": "What are the number of concerts that occurred in the stadium with the largest capacity ?",
        "ground_truth": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
        "amends": [
            "Do reference table `concert` instead of `concerts` and use `stadium` instead of `stadiums` in the subquery to match the correct schema. The amended query now correctly counts concerts at the stadium with the highest capacity by fixing the table names while preserving the same logical structure and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE stadium_id = (SELECT stadium_id FROM stadiums ORDER BY capacity DESC LIMIT 1);",
            "SELECT COUNT(*) \nFROM concert \nWHERE Stadium_ID IN (\n    SELECT Stadium_ID \n    FROM stadium \n    WHERE Capacity = (SELECT MAX(Capacity) FROM stadium)\n)"
        ],
        "rule_sql": []
    },
    "45": {
        "db_id": "pets_1",
        "question": "Find the number of pets whose weight is heavier than 10.",
        "ground_truth": "SELECT count(*) FROM pets WHERE weight  >  10",
        "amends": [
            "Do use the comparison operator `>` instead of `<` in the WHERE filter condition, changing `weight < 10` to `weight > 10` to count pets with weight greater than 10 instead of less than 10. The amended query now correctly matches the intended behavior of counting records where weight exceeds the threshold value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE weight < 10;",
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ],
        "rule_sql": []
    },
    "46": {
        "db_id": "pets_1",
        "question": "How many pets have a greater weight than 10?",
        "ground_truth": "SELECT count(*) FROM pets WHERE weight  >  10",
        "amends": [
            "Do use the comparison operator `>` instead of `<` in the WHERE filter, changing the condition from `weight < 10` to `weight > 10` to count pets weighing more than 10 units instead of less than 10 units. The amended query now correctly matches the intended behavior of counting records where weight exceeds the threshold value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE weight < 10;",
            "SELECT COUNT(*) FROM Pets WHERE weight > 10;"
        ],
        "rule_sql": []
    },
    "47": {
        "db_id": "pets_1",
        "question": "Find the weight of the youngest dog.",
        "ground_truth": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do select `weight` instead of `MAX(weight)` and change the source table from `dogs` to `pets`. Do remove the WHERE clause with subquery that found maximum weight for minimum age instead of keeping it. Do add `ORDER BY pet_age LIMIT 1` instead of omitting it to directly get the weight of the youngest pet. The amended query now correctly retrieves the weight of the youngest pet by ordering by age and taking the first result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM dogs WHERE age = (SELECT MIN(age) FROM dogs);",
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age LIMIT 1"
        ],
        "rule_sql": []
    },
    "48": {
        "db_id": "pets_1",
        "question": "How much does the youngest dog weigh?",
        "ground_truth": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do select `weight` instead of `MAX(weight)` and change the source table from `dogs` to `pets`. Do remove the WHERE filter with subquery that found `age = (SELECT MIN(age) FROM dogs)` instead of keeping it. Do add `ORDER BY pet_age LIMIT 1` instead of omitting ordering and limiting, which now correctly retrieves the weight of the youngest pet by sorting by age and taking the first result. The amended query now matches RIGHT_SQL's behavior by directly fetching the weight of the youngest pet rather than finding the maximum weight among dogs of minimum age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM dogs WHERE age = (SELECT MIN(age) FROM dogs);",
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age LIMIT 1"
        ],
        "rule_sql": []
    },
    "49": {
        "db_id": "pets_1",
        "question": "Find the maximum weight for each type of pet. List the maximum weight and pet type.",
        "ground_truth": "SELECT max(weight) ,  petType FROM pets GROUP BY petType",
        "amends": [
            "Do use `max(weight)` instead of `AVG(weight) as max_weight` to correctly calculate maximum weight rather than average weight. Do use `petType` instead of `pet_type` to match the correct column name. Do remove the alias `max_weight` instead of keeping it since the aggregate function name clearly indicates the calculation. Do maintain the `GROUP BY petType` clause instead of `GROUP BY pet_type` to ensure proper grouping by the correct column name. The amended query now correctly calculates maximum weight per pet type instead of incorrectly calculating average weight.",
            "Do place `max(weight)` first in the SELECT list instead of `PetType` first. Do use lowercase `petType` instead of uppercase `PetType` for the column reference. Do use lowercase `pets` instead of uppercase `Pets` for the table name. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_type, AVG(weight) as max_weight FROM pets GROUP BY pet_type;",
            "SELECT PetType, MAX(weight) FROM Pets GROUP BY PetType;",
            "SELECT max(weight), petType FROM pets GROUP BY petType"
        ],
        "rule_sql": []
    },
    "50": {
        "db_id": "pets_1",
        "question": "List the maximum weight and type for each type of pet.",
        "ground_truth": "SELECT max(weight) ,  petType FROM pets GROUP BY petType",
        "amends": [
            "Do use `petType` instead of `type` as the grouping column. Do place `max(weight)` before `petType` in the SELECT list instead of after it. Do use `petType` as the column alias in the GROUP BY clause instead of `type`. The amended query now correctly groups by the petType column and returns the maximum weight for each pet type, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, MAX(weight) FROM pets GROUP BY type;",
            "SELECT MAX(weight) AS max_weight, PetType FROM Pets GROUP BY PetType;"
        ],
        "rule_sql": []
    },
    "51": {
        "db_id": "pets_1",
        "question": "Find number of pets owned by students who are older than 20.",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
        "amends": [
            "Do add `student AS T1 JOIN has_pet AS T2 ON T1.stuid = T2.stuid` as the FROM source instead of just `pets`. Do change the WHERE filter to `T1.age > 20` instead of `student_age > 20` to reference the correct table and column. The amended query now correctly joins the student and has_pet tables and filters on student age, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE student_age > 20",
            "SELECT COUNT(*) AS number_of_pets\nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ],
        "rule_sql": []
    },
    "52": {
        "db_id": "pets_1",
        "question": "How many pets are owned by students that have an age greater than 20?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
        "amends": [
            "Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the `pets` table. Do change the table reference to `student AS T1` instead of `pets` as the primary source. Do use `T1.age > 20` instead of `student_age > 20` to filter on the correct table's column. Do remove the incorrect `pets` table reference and replace it with the proper join structure between student and has_pet tables. The amended query now correctly counts students over age 20 who have pets by joining the appropriate tables with the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE student_age > 20;",
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ],
        "rule_sql": []
    },
    "53": {
        "db_id": "pets_1",
        "question": "Find the number of dog pets that are raised by female students (with sex F).",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
        "amends": [
            "Do use a three-table join chain starting with `student` instead of a direct two-table join between `pets` and `students`. Do join through `has_pet` as an intermediate table with `ON T1.stuid = T2.stuid` instead of directly joining `pets` to `students`. Do then join `pets` with `ON T2.petid = T3.petid` instead of `ON p.owner_id = s.student_id`. Do filter on `T1.sex = 'F'` instead of `s.sex = 'M'` to count female students instead of male students. Do filter on `T3.pettype = 'dog'` instead of `p.type = 'dog'` using the correct column name. The amended query now correctly counts female students who own dogs through the proper relationship table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets p JOIN students s ON p.owner_id = s.student_id WHERE p.type = 'dog' AND s.sex = 'M';",
            "SELECT COUNT(*) \nFROM Student s\nJOIN Has_Pet hp ON s.StuID = hp.StuID\nJOIN Pets p ON hp.PetID = p.PetID\nWHERE s.Sex = 'F' AND p.PetType = 'dog'"
        ],
        "rule_sql": []
    },
    "54": {
        "db_id": "pets_1",
        "question": "How many dog pets are raised by female students?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
        "amends": [
            "Do join `has_pet` as an intermediate table between `students` and `pets` instead of directly joining `pets` to `students`. Do use `T1.stuid = T2.stuid` for the student join condition instead of `p.owner_id = s.student_id`. Do use `T2.petid = T3.petid` for the pet join condition instead of missing this relationship. Do reference `T1.sex` instead of `s.gender` for the gender filter. Do reference `T3.pettype` instead of `p.pet_type` for the pet type filter. Do use value 'F' instead of 'female' for the gender condition. The amended query now correctly models the many-to-many relationship between students and pets through the has_pet junction table and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets p JOIN students s ON p.owner_id = s.student_id WHERE p.pet_type = 'dog' AND s.gender = 'female';",
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ],
        "rule_sql": []
    },
    "55": {
        "db_id": "pets_1",
        "question": "Find the number of distinct type of pets.",
        "ground_truth": "SELECT count(DISTINCT pettype) FROM pets",
        "amends": [
            "Do `count(DISTINCT pettype)` instead of `COUNT(*)` to count distinct pet types rather than all rows. Do add the `DISTINCT` modifier and specify the `pettype` column instead of using a wildcard count. The amended query now correctly counts unique pet types instead of total records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets;",
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ],
        "rule_sql": []
    },
    "56": {
        "db_id": "pets_1",
        "question": "How many different types of pet are there?",
        "ground_truth": "SELECT count(DISTINCT pettype) FROM pets",
        "amends": [
            "Do `count(DISTINCT pettype)` instead of `COUNT(*)` to count distinct pet types rather than all rows. Do add the `DISTINCT` modifier and specify the `pettype` column instead of using a wildcard count. The amended query now correctly counts unique pet types and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets;",
            "SELECT COUNT(DISTINCT PetType) FROM Pets;"
        ],
        "rule_sql": []
    },
    "57": {
        "db_id": "pets_1",
        "question": "Find the first name of students who have cat or dog pet.",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "amends": [
            "Do use `DISTINCT T1.Fname` instead of `first_name` to select unique first names. Do join `student AS T1` with `has_pet AS T2` on `T1.stuid = T2.stuid` and `pets AS T3` on `T3.petid = T2.petid` instead of querying only the `students` table. Do filter with `T3.pettype = 'cat' OR T3.pettype = 'dog'` instead of the contradictory `pet = 'cat' AND pet = 'dog'` to find students who have either cats or dogs. The amended query now correctly identifies students with either pet type by properly joining through the relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' AND pet = 'dog';",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ],
        "rule_sql": []
    },
    "58": {
        "db_id": "pets_1",
        "question": "What are the first names of every student who has a cat or dog as a pet?",
        "ground_truth": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "amends": [
            "Do use `DISTINCT T1.Fname` instead of `first_name` to select from the correct table with deduplication. Do join three tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` instead of querying only a single `students` table. Do use `JOIN` relationships `T1.stuid = T2.stuid` and `T3.petid = T2.petid` instead of incorrect direct column references. Do change the condition to `T3.pettype = 'cat' OR T3.pettype = 'dog'` instead of the impossible `pet = 'cat' AND pet = 'dog'` that could never return results. The amended query now correctly identifies students who have either cats or dogs as pets through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' AND pet = 'dog';",
            "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' OR T3.PetType = 'dog'"
        ],
        "rule_sql": []
    },
    "59": {
        "db_id": "pets_1",
        "question": "Find the first name of students who have both cat and dog pets .",
        "ground_truth": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "amends": [
            "Do use `t1.fname` from the `student` table instead of `first_name` from a non-existent `students` table. Do join three tables (`student`, `has_pet`, and `pets`) with proper relationships through `stuid` and `petid` instead of querying a single table with a direct `pet` column. Do filter for `t3.pettype = 'cat'` in one branch and `t3.pettype = 'dog'` in another instead of using `OR` conditions on a single column. Do use `INTERSECT` to find students who have both cats and dogs instead of using `OR` which would find students with either pets. The amended query now correctly identifies students who own both cats and dogs by intersecting two separate queries for each pet type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' OR pet = 'dog';",
            "SELECT t1.Fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'cat'\nINTERSECT\nSELECT t1.Fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'dog'"
        ],
        "rule_sql": []
    },
    "60": {
        "db_id": "pets_1",
        "question": "What are the students' first names who have both cats and dogs as pets?",
        "ground_truth": "SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog'",
        "amends": [
            "Do use `T1.Fname` instead of `first_name` for the column selection. Do join `student AS T1` with `has_pet AS T2` on `T1.stuid = T2.stuid` and then join `pets AS T3` on `T3.petid = T2.petid` instead of querying a single `students` table. Do filter for `T3.pettype = 'cat'` in one query branch and `T3.pettype = 'dog'` in another instead of using contradictory `AND` conditions `pet_type = 'cat' AND pet_type = 'dog'`. Do use `INTERSECT` to find students who have both cat and dog pets instead of trying to find records where a single pet is both a cat and dog simultaneously. The amended query now correctly identifies students who have both types of pets by intersecting two separate queries for each pet type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet_type = 'cat' AND pet_type = 'dog'",
            "SELECT T1.Fname\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'\nINTERSECT\nSELECT T1.Fname\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'"
        ],
        "rule_sql": []
    },
    "61": {
        "db_id": "pets_1",
        "question": "Find the major and age of students who do not have a cat pet.",
        "ground_truth": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter to exclude students with cats. Do add joins between `student`, `has_pet`, and `pets` tables instead of querying only the `students` table. Do reference `stuid` as the join condition instead of filtering directly on `pet`. Do use proper table aliases `T1`, `T2`, and `T3` instead of no aliases. Do filter on `pettype = 'cat'` in the subquery instead of `pet != 'cat'` in the main query. The amended query now correctly identifies students without cats by checking the pet relationships through proper table joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major, age FROM students WHERE pet != 'cat';",
            "SELECT T1.Major, T1.Age\nFROM Student T1\nWHERE T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T2.PetID = T3.PetID\n    WHERE T3.PetType = 'cat'\n)"
        ],
        "rule_sql": []
    },
    "62": {
        "db_id": "pets_1",
        "question": "What major is every student who does not own a cat as a pet, and also how old are they?",
        "ground_truth": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter to exclude students with cats. Do add joins between `student`, `has_pet`, and `pets` tables instead of querying only the `students` table. Do reference `stuid` as the join condition instead of assuming direct pet ownership in the main table. Do filter on `pettype = 'cat'` in the subquery instead of checking `pet != 'cat'` directly. Do use proper table aliases `T1`, `T2`, and `T3` instead of unspecified table references. The amended query now correctly identifies students without cats by checking through the relationship tables instead of making incorrect assumptions about pet data storage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT major, age FROM students WHERE pet != 'cat';",
            "SELECT T1.Major, T1.Age\nFROM Student T1\nWHERE T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T2.PetID = T3.PetID\n    WHERE T3.PetType = 'cat'\n);"
        ],
        "rule_sql": []
    },
    "63": {
        "db_id": "pets_1",
        "question": "Find the id of students who do not have a cat pet.",
        "ground_truth": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "amends": [
            "Do select `stuid` instead of `id` and use `EXCEPT` set operation instead of a simple `WHERE` filter. Do change the source from `students` to `student` instead of the original table name. Do add joins with `has_pet` and `pets` tables instead of omitting them, specifically using `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` and `JOIN pets AS T3 ON T3.petid = T2.petid` instead of no joins. Do move the pet filter condition to `WHERE T3.pettype = 'cat'` instead of `WHERE pet = 'cat'`, and use `pettype` instead of `pet` as the column reference. The amended query now correctly identifies students without cats by using an EXCEPT operation to remove those who have cats, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM students WHERE pet = 'cat';",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT T1.StuID FROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'"
        ],
        "rule_sql": []
    },
    "64": {
        "db_id": "pets_1",
        "question": "What are the ids of the students who do not own cats as pets?",
        "ground_truth": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "amends": [
            "Do use `EXCEPT` set operation instead of simple `WHERE` filtering to exclude students with cats. Do reference `stuid` instead of `student_id` and `student` table instead of `students`. Do add joins to `has_pet` and `pets` tables through `T1.stuid = T2.stuid` and `T3.petid = T2.petid` instead of directly filtering on a non-existent `pet_type` column. Do filter with `T3.pettype = 'cat'` in the exclusion subquery instead of `pet_type != 'cat'` in the main query. Do use table aliases `T1`, `T2`, `T3` for clarity instead of no aliases. The amended query now correctly identifies students without cats by excluding those who have cat pets through the proper relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id FROM students WHERE pet_type != 'cat';",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT T1.StuID\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T3.PetType = 'cat'"
        ],
        "rule_sql": []
    },
    "65": {
        "db_id": "pets_1",
        "question": "Find the first name and age of students who have a dog but do not have a cat as a pet.",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use explicit table aliases `T1.fname` and `T1.age` instead of direct column references `first_name` and `age`. Do join tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` with proper join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of querying a single table. Do filter on `T3.pettype = 'dog'` instead of `pet = 'dog'`. Do add a subquery exclusion with `T1.stuid NOT IN` to find students with dogs but not cats instead of the incorrect `pet != 'cat'` filter that would never match due to the contradictory `pet = 'dog'` condition. The amended query now correctly identifies students who have dogs but no cats by properly joining across multiple tables and using a subquery for exclusion logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE pet = 'dog' AND pet != 'cat';",
            "SELECT T1.Fname, T1.Age\nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'\nAND T1.StuID NOT IN (\n    SELECT T4.StuID\n    FROM Has_Pet AS T4\n    JOIN Pets AS T5 ON T5.PetID = T4.PetID\n    WHERE T5.PetType = 'cat'\n)"
        ],
        "rule_sql": []
    },
    "66": {
        "db_id": "pets_1",
        "question": "What is the first name of every student who has a dog but does not have a cat?",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do select `T1.fname` and `T1.age` instead of just `first_name`. Do use explicit table aliases with `student AS T1` instead of the base table name. Do add `JOIN has_pet AS T2` and `JOIN pets AS T3` instead of omitting these tables. Do use join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of simple boolean flags. Do filter with `T3.pettype = 'dog'` instead of `has_dog = 1`. Do add a subquery exclusion with `NOT IN` for students who have cats instead of including them with `has_cat = 1`. Do remove the direct boolean column references and instead use proper relational joins through the has_pet and pets tables to determine pet ownership. The amended query now correctly identifies students who have dogs but not cats by using proper table relationships instead of boolean flags."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE has_dog = 1 AND has_cat = 1;",
            "SELECT T1.fname, T1.age\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.stuid = T2.stuid\nJOIN pets AS T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'dog'\nAND T1.stuid NOT IN (\n    SELECT T4.stuid\n    FROM student AS T4\n    JOIN has_pet AS T5 ON T4.stuid = T5.stuid\n    JOIN pets AS T6 ON T6.petid = T5.petid\n    WHERE T6.pettype = 'cat'\n)"
        ],
        "rule_sql": []
    },
    "67": {
        "db_id": "pets_1",
        "question": "Find the type and weight of the youngest pet.",
        "ground_truth": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do use column name `pettype` instead of `type` in the SELECT list. Do use column name `pet_age` instead of `age` in the ORDER BY clause. The amended query now correctly references the actual column names and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, weight FROM pets ORDER BY age ASC LIMIT 1;",
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "68": {
        "db_id": "pets_1",
        "question": "What type of pet is the youngest animal, and how much does it weigh?",
        "ground_truth": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do reference table `pets` instead of `animals` in the FROM clause. Do select column `pettype` instead of `pet_type` and use `pet_age` for ordering instead of `age`. Do maintain the `weight` column selection and `LIMIT 1` clause without changes. The amended query now correctly references the appropriate table schema and columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_type, weight FROM animals ORDER BY age ASC LIMIT 1;",
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "69": {
        "db_id": "pets_1",
        "question": "Find the id and weight of all pets whose age is older than 1.",
        "ground_truth": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1",
        "amends": [
            "Do select `petid` instead of `id` and change the filter to `pet_age > 1` instead of `age < 1` while keeping the same table source and column selection structure, ensuring the query now correctly retrieves pets older than one year rather than younger than one year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, weight FROM pets WHERE age < 1;",
            "SELECT PetID, weight FROM Pets WHERE pet_age > 1"
        ],
        "rule_sql": []
    },
    "70": {
        "db_id": "pets_1",
        "question": "What is the id and weight of every pet who is older than 1?",
        "ground_truth": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1",
        "amends": [
            "Do select `petid` instead of `id` and maintain `weight` in the SELECT list. Do change the WHERE filter to `pet_age > 1` instead of `age < 1`, both altering the column reference from `age` to `pet_age` and reversing the comparison operator from less than to greater than. The amended query now correctly retrieves pets with age greater than 1 using the appropriate column names and comparison logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, weight FROM pets WHERE age < 1;",
            "SELECT PetID, weight FROM Pets WHERE pet_age > 1"
        ],
        "rule_sql": []
    },
    "71": {
        "db_id": "pets_1",
        "question": "Find the average and maximum age for each type of pet.",
        "ground_truth": "SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do use column name `pet_age` instead of `age` in aggregate functions. Do use `max` function instead of `MIN` for maximum age calculation. Do use column name `pettype` instead of `pet_type` in both SELECT list and GROUP BY clause. Do remove the alias `average_age` instead of keeping it. Do remove the alias `max_age` instead of keeping it. The amended query now correctly calculates average and maximum pet ages grouped by pet type using the appropriate column names.",
            "Do use lowercase `avg(pet_age)` and `max(pet_age)` instead of uppercase `AVG(pet_age)` and `MAX(pet_age)`. Do place `pettype` at the end of the SELECT list instead of at the beginning. Do use lowercase `pettype` in GROUP BY instead of uppercase `PetType`. Do use lowercase table name `pets` instead of uppercase `Pets`. The amended query now matches RIGHT_SQL's behavior with identical aggregation logic and grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_age, MIN(age) as max_age FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(pet_age) AS average_age, MAX(pet_age) AS max_age FROM Pets GROUP BY PetType;",
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": []
    },
    "72": {
        "db_id": "pets_1",
        "question": "What is the average and maximum age for each pet type?",
        "ground_truth": "SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do use column name `pet_age` instead of `age` in aggregate functions. Do use `max` function instead of `MIN` for calculating maximum age. Do remove the alias `average_age` instead of keeping it. Do remove the alias `maximum_age` instead of keeping it. Do use column name `pettype` instead of `pet_type` in GROUP BY clause. The amended query now correctly calculates average and maximum pet ages by pet type without unnecessary aliases.",
            "Do use lowercase `avg(pet_age)` and `max(pet_age)` instead of uppercase `AVG(pet_age)` and `MAX(pet_age)`. Do place `pettype` at the end of the SELECT list instead of at the beginning. Do use lowercase table name `pets` instead of uppercase `Pets` and lowercase column name `pettype` instead of uppercase `PetType` in both SELECT and GROUP BY clauses. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_age, MIN(age) as maximum_age FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(pet_age), MAX(pet_age) FROM Pets GROUP BY PetType;",
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": []
    },
    "73": {
        "db_id": "pets_1",
        "question": "Find the average weight for each pet type.",
        "ground_truth": "SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do calculate `avg(weight)` instead of `AVG(age)` as average_weight. Do select `pettype` instead of `pet_type` in the GROUP BY clause. Do remove the alias `as average_weight` instead of keeping it. The amended query now correctly calculates average weight by pet type rather than average age.",
            "Do use lowercase `avg(weight)` instead of uppercase `AVG(weight)` and lowercase `pettype` instead of uppercase `PetType` in the SELECT list. Do place `avg(weight)` before `pettype` instead of after it in the column order. Do use lowercase `pets` instead of uppercase `Pets` and lowercase `pettype` instead of uppercase `PetType` in the GROUP BY clause. The amended query now matches the correct behavior with proper lowercase identifiers and column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_weight FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(weight) FROM Pets GROUP BY PetType;",
            "SELECT avg(weight), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": []
    },
    "74": {
        "db_id": "pets_1",
        "question": "What is the average weight for each type of pet?",
        "ground_truth": "SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do select `avg(weight)` and `pettype` instead of `AVG(age)` as `average_weight` and `type`. Do group by `pettype` instead of `type`. The amended query now correctly calculates average weight grouped by pet type instead of incorrectly attempting to average age while mislabeling it as weight.",
            "Do use lowercase `avg(weight)` instead of uppercase `AVG(weight)` and place it first in the SELECT list instead of second. Do use lowercase `pettype` instead of uppercase `PetType` and place it second in the SELECT list instead of first. Do remove the alias `AS average_weight` instead of keeping it. Do use lowercase `pets` instead of uppercase `Pets` in the FROM clause. Do use lowercase `pettype` instead of uppercase `PetType` in the GROUP BY clause. The amended query now correctly calculates average weight by pet type without unnecessary aliasing and with consistent lowercase naming."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, AVG(age) as average_weight FROM pets GROUP BY type;",
            "SELECT PetType, AVG(weight) AS average_weight FROM Pets GROUP BY PetType;",
            "SELECT avg(weight), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": []
    },
    "75": {
        "db_id": "pets_1",
        "question": "Find the first name and age of students who have a pet.",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `fname` instead of `first_name` from the `student` table instead of `students`. Do add a `JOIN` with `has_pet` table on `stuid = stuid` instead of no join, and move the filter to check for pet existence through the join condition instead of using `WHERE pet IS NULL`. Do reference tables with aliases `T1` and `T2` instead of no aliases. The amended query now correctly identifies students who have pets by joining with the has_pet table rather than incorrectly checking for a NULL pet column in the students table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE pet IS NULL;",
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student T1 JOIN Has_Pet T2 ON T1.StuID = T2.StuID"
        ],
        "rule_sql": []
    },
    "76": {
        "db_id": "pets_1",
        "question": "What are the different first names and ages of the students who do have pets?",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
        "amends": [
            "Do reference columns as `T1.fname` and `T1.age` with table aliases instead of `first_name` and `age` without table qualification. Do use a `JOIN` with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of filtering directly on `pet IS NOT NULL` in the WHERE clause. Do remove the explicit `WHERE` filter condition since the join inherently ensures the existence of a pet relationship. The amended query now correctly identifies students with pets through the join relationship rather than relying on a potentially missing pet column in the students table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT first_name, age FROM students WHERE pet IS NOT NULL;",
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID"
        ],
        "rule_sql": []
    },
    "77": {
        "db_id": "pets_1",
        "question": "Find the id of the pet owned by student whose last name is \u2018Smith\u2019.",
        "ground_truth": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'",
        "amends": [
            "Do select `T2.petid` instead of `pet_id` and use table aliases `T1` and `T2` instead of direct table references. Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the students table. Do filter on `T1.Lname = 'Smith'` instead of `last_name = 'Smith'` to use the correct column name from the joined table structure. The amended query now correctly retrieves pet information through the relationship table instead of assuming pets are directly stored in the students table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_id FROM students WHERE last_name = 'Smith';",
            "SELECT T2.PetID \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nWHERE T1.LName = 'Smith'"
        ],
        "rule_sql": []
    },
    "78": {
        "db_id": "pets_1",
        "question": "What is the id of the pet owned by the student whose last name is 'Smith'?",
        "ground_truth": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'",
        "amends": [
            "Do select `T2.petid` instead of `pet_id` and use table aliases `T1` and `T2` instead of bare table names. Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the students table. Do reference `T1.Lname` instead of `last_name` and use the correct column name `Lname` instead of `last_name`. Do remove the direct reference to `pet_id` from the students table and instead join to the has_pet table to get the correct `petid` column. The amended query now correctly retrieves pet IDs by joining the student and has_pet tables and filtering on the student's last name, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pet_id FROM students WHERE last_name = 'Smith';",
            "SELECT T2.petid FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID WHERE T1.LName = 'Smith'"
        ],
        "rule_sql": []
    },
    "79": {
        "db_id": "pets_1",
        "question": "Find the number of pets for each student who has any pet and student id.",
        "ground_truth": "SELECT count(*) ,  T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid",
        "amends": [
            "Do select `count(*)` and `T1.stuid` instead of `student_id` and `COUNT(*)`. Do use `FROM student AS T1 JOIN has_pet AS T2` instead of `FROM pets`. Do add join condition `ON T1.stuid = T2.stuid` instead of omitting it. Do group by `T1.stuid` instead of `student_id`. The amended query now correctly counts pets per student by joining the student and has_pet tables instead of querying a non-existent pets table directly, matching the intended behavior.",
            "Do place `count(*)` first in the SELECT list instead of `T1.StuID`. Do use lowercase `stuid` for the column reference instead of `StuID`. Do remove the alias `T1.StuID` from the SELECT list instead of including it, as it's redundant when grouping by the same column. The amended query now correctly returns only the count of pets per student without duplicating the student ID in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM pets GROUP BY student_id",
            "SELECT T1.StuID, COUNT(*) \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nGROUP BY T1.StuID",
            "SELECT count(*), T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid = T2.stuid GROUP BY T1.stuid"
        ],
        "rule_sql": []
    },
    "80": {
        "db_id": "pets_1",
        "question": "For students who have pets , how many pets does each student have ? list their ids instead of names .",
        "ground_truth": "select count(*) ,  t1.stuid from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid group by t1.stuid",
        "amends": [
            "Do select `count(*)` and `t1.stuid` instead of `student_id` and `COUNT(*) as pet_count`. Do use `FROM student as t1 JOIN has_pet as t2` instead of `FROM students` to properly join the student and pet tables. Do apply the join condition `on t1.stuid = t2.stuid` instead of omitting the table relationship. Do remove the `HAVING pet_count > 0` filter instead of keeping it, as counting joined pet records inherently excludes students without pets. The amended query now correctly counts pets per student by joining the relevant tables and matches the RIGHT_SQL's behavior.",
            "Do place `count(*)` before `t1.stuid` in the SELECT list instead of having `t1.StuID` first. Do use lowercase `stuid` instead of mixed case `StuID` for consistency. Do maintain the same FROM clause with `student as t1` joining `has_pet as t2` on `t1.stuid = t2.stuid` instead of changing the join logic. Do keep the GROUP BY clause with `t1.stuid` instead of modifying the grouping. The amended query now correctly outputs the count of pets per student while maintaining the same logical behavior as the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) as pet_count FROM students GROUP BY student_id HAVING pet_count > 0",
            "SELECT t1.StuID, COUNT(*) \nFROM Student AS t1 \nJOIN Has_Pet AS t2 ON t1.StuID = t2.StuID \nGROUP BY t1.StuID",
            "SELECT count(*), t1.stuid FROM student as t1 JOIN has_pet as t2 ON t1.stuid = t2.stuid GROUP BY t1.stuid"
        ],
        "rule_sql": []
    },
    "81": {
        "db_id": "pets_1",
        "question": "Find the first name and gender of student who have more than one pet.",
        "ground_truth": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",
        "amends": [
            "Do select `fname` and `sex` instead of `first_name` and `gender`. Do use table alias `T1` for the `student` table instead of directly referencing `students`. Do add a `JOIN` with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of omitting this table relationship. Do add `GROUP BY T1.stuid` instead of grouping by the entire table. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE pet_count > 1`. The amended query now correctly counts pets per student and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, gender FROM students WHERE pet_count > 1;",
            "SELECT T1.Fname, T1.Sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "82": {
        "db_id": "pets_1",
        "question": "What is the first name and gender of the all the students who have more than one pet?",
        "ground_truth": "SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",
        "amends": [
            "Do select `fname` and `sex` with table aliases instead of `first_name` and `gender` without aliases. Do use `student AS T1` joined with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of querying only `students` without joins. Do add `GROUP BY T1.stuid` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 1` instead of using `WHERE COUNT(pets) > 1` which incorrectly applies aggregation in the WHERE clause. The amended query now correctly counts pet relationships through the join and applies the aggregation filter in the proper HAVING clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, gender FROM students WHERE COUNT(pets) > 1",
            "SELECT T1.Fname, T1.Sex FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID GROUP BY T1.StuID HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "83": {
        "db_id": "pets_1",
        "question": "Find the last name of the student who has a cat that is age 3.",
        "ground_truth": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
        "amends": [
            "Do use explicit table aliases `T1.lname` instead of ambiguous `last_name`. Do join three tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` instead of querying only the `students` table. Do use `JOIN` with proper join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of assuming direct relationships. Do filter on `T3.pet_age = 3` and `T3.pettype = 'cat'` instead of filtering on non-existent columns `pet_type` and `pet_age` in the students table. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping it since the correct query returns all matching records without ordering or limiting. The amended query now correctly joins the necessary tables and filters on the appropriate pet-related columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE pet_type = 'cat' AND pet_age = 3 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.LName \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ],
        "rule_sql": []
    },
    "84": {
        "db_id": "pets_1",
        "question": "What is the last name of the student who has a cat that is 3 years old?",
        "ground_truth": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
        "amends": [
            "Do use `T1.lname` instead of `last_name` for the column selection. Do join `student AS T1` instead of querying `students` table directly. Do add `has_pet AS T2` join on `T1.stuid = T2.stuid` instead of omitting this relationship table. Do add `pets AS T3` join on `T3.petid = T2.petid` instead of accessing pet attributes directly from students. Do filter on `T3.pet_age = 3` instead of `pet_age = 3` to reference the correct table. Do filter on `T3.pettype = 'cat'` instead of `pet_type = 'cat'` with the correct column name. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping the ordering and limiting as the query logic now correctly returns all matching records. The amended query now properly joins through the relationship tables to access pet information and returns all students with 3-year-old cats instead of just one student."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE pet_type = 'cat' AND pet_age = 3 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.LName FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ],
        "rule_sql": []
    },
    "85": {
        "db_id": "pets_1",
        "question": "Find the average age of students who do not have any pet .",
        "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
        "amends": [
            "Do reference the `student` table instead of `students` in the FROM clause. Do use a subquery with `stuid not in (select stuid from has_pet)` instead of the `pet_count > 0` WHERE filter. Do remove the aggregate function reference to `pet_count` instead of keeping it, as the correct logic checks for absence in the has_pet relationship table rather than counting pets. The amended query now correctly identifies students without pets by checking their absence in the has_pet table rather than relying on a potentially incorrect or missing pet_count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE pet_count > 0;",
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ],
        "rule_sql": []
    },
    "86": {
        "db_id": "pets_1",
        "question": "What is the average age for all students who do not own any pets ?",
        "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
        "amends": [
            "Do reference the `student` table instead of `students` in the FROM clause. Do use a subquery with `stuid not in (select stuid from has_pet)` instead of filtering on `pet_count = 0` in the WHERE clause. Do maintain the same `AVG(age)` aggregate function in the SELECT list. The amended query now correctly identifies students without pets by checking their absence from the has_pet table rather than relying on a potentially incorrect pet_count column, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE pet_count = 0;",
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ],
        "rule_sql": []
    },
    "87": {
        "db_id": "car_1",
        "question": "How many continents are there?",
        "ground_truth": "SELECT count(*) FROM CONTINENTS;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM continents;"
        ],
        "rule_sql": []
    },
    "88": {
        "db_id": "car_1",
        "question": "What is the number of continents?",
        "ground_truth": "SELECT count(*) FROM CONTINENTS;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM continents;"
        ],
        "rule_sql": []
    },
    "89": {
        "db_id": "car_1",
        "question": "How many countries does each continent have? List the continent id, continent name and the number of countries.",
        "ground_truth": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select from `CONTINENTS AS T1` instead of only `countries`. Do add `JOIN COUNTRIES AS T2 ON T1.ContId = T2.Continent` instead of omitting the join condition. Do change the SELECT list to `T1.ContId, T1.Continent, count(*)` instead of `continent_id, continent_name, COUNT(*) as country_count`. Do modify the GROUP BY clause to `GROUP BY T1.ContId` instead of grouping by both `continent_id` and `continent_name`. The amended query now correctly joins continents with countries and counts countries per continent, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent_id, continent_name, COUNT(*) as country_count \nFROM countries \nGROUP BY continent_id, continent_name",
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents AS T1 \nJOIN countries AS T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId"
        ],
        "rule_sql": []
    },
    "90": {
        "db_id": "car_1",
        "question": "For each continent, list its id, name, and how many countries it has?",
        "ground_truth": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",
        "amends": [
            "Do add table `COUNTRIES AS T2` with a `JOIN` on `T1.ContId = T2.Continent` instead of querying only the `continents` table. Do change the SELECT list to use `T1.ContId` and `T1.Continent` instead of `continent_id` and `continent_name`. Do remove `continent_name` from the GROUP BY clause instead of including it, since the join with COUNTRIES table requires grouping only by continent identifier. Do maintain the `COUNT(*)` aggregate function but now applied to the joined result set instead of just the continents table. The amended query now correctly counts countries per continent by joining the tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent_id, continent_name, COUNT(*) FROM continents GROUP BY continent_id, continent_name",
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents AS T1 \nJOIN countries AS T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId, T1.Continent"
        ],
        "rule_sql": []
    },
    "91": {
        "db_id": "car_1",
        "question": "How many countries are listed?",
        "ground_truth": "SELECT count(*) FROM COUNTRIES;",
        "amends": [
            "Do reference table `COUNTRIES` instead of `cities` to count records from the correct data source. The amended query now correctly counts records from the COUNTRIES table instead of cities, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM countries;"
        ],
        "rule_sql": []
    },
    "92": {
        "db_id": "car_1",
        "question": "How many countries exist?",
        "ground_truth": "SELECT count(*) FROM COUNTRIES;",
        "amends": [
            "Do reference the `COUNTRIES` table instead of the `cities` table in the FROM clause. Do maintain the `COUNT(*)` aggregate function without changes. The amended query now correctly counts records from the COUNTRIES table instead of the cities table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM countries;"
        ],
        "rule_sql": []
    },
    "93": {
        "db_id": "car_1",
        "question": "How many models does each car maker produce? List maker full name, id and the number.",
        "ground_truth": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of unspecified table references. Do change the FROM clause to `CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2` instead of the single table `car_models`. Do add the join condition `ON T1.Id = T2.Maker` instead of omitting it. Do change the SELECT list to `T1.FullName, T1.Id, count(*)` instead of `maker, id, COUNT(*) as model_count`. Do remove the alias `model_count` instead of keeping it. Do change the GROUP BY clause to `T1.Id` instead of `maker, id`. The amended query now correctly joins the manufacturer and model tables and counts models per manufacturer."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, id, COUNT(*) as model_count FROM car_models GROUP BY maker, id",
            "SELECT T1.FullName, T1.Id, count(*)\nFROM CAR_MAKERS AS T1\nJOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id"
        ],
        "rule_sql": []
    },
    "94": {
        "db_id": "car_1",
        "question": "What is the full name of each car maker, along with its id and how many models it produces?",
        "ground_truth": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",
        "amends": [
            "Do join `MODEL_LIST` as `T2` on `T1.Id = T2.Maker` instead of querying only `car_makers` without any join. Do use `T1.Id` and `T1.FullName` in the SELECT list instead of `car_makers.id` and `car_makers.full_name`. Do group by only `T1.Id` instead of grouping by both `car_makers.id` and `car_makers.full_name`. Do remove the alias `model_count` from the count instead of keeping it. The amended query now correctly counts models per car maker by joining with the model table and matches the RIGHT_SQL's behavior.",
            "Do use `count(*)` instead of `COUNT(T2.ModelId)` to count all rows in each group rather than counting non-null ModelId values. Do reorder the SELECT list as `T1.FullName, T1.Id` instead of `T1.Id, T1.FullName` while maintaining the same logical output. Do add the `AS` keyword for table aliases as `CAR_MAKERS AS T1` and `MODEL_LIST AS T2` instead of omitting it, though this is purely syntactic. The amended query now correctly counts all car models per manufacturer regardless of null ModelId values and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT car_makers.id, car_makers.full_name, COUNT(*) as model_count \nFROM car_makers \nGROUP BY car_makers.id, car_makers.full_name",
            "SELECT T1.Id, T1.FullName, COUNT(T2.ModelId) \nFROM car_makers T1 \nJOIN model_list T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id",
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM car_makers AS T1 \nJOIN model_list AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id"
        ],
        "rule_sql": []
    },
    "95": {
        "db_id": "car_1",
        "question": "Which model of the car has the minimum horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
        "amends": [
            "Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do select `T1.Model` instead of `model` to reference the correct table. Do order by `T2.horsepower ASC` instead of `horsepower DESC` to get the minimum horsepower instead of maximum. The amended query now correctly retrieves the car model with the lowest horsepower by properly joining the car names and data tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "96": {
        "db_id": "car_1",
        "question": "What is the model of the car with the smallest amount of horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of selecting `model` from the `cars` table. Do join `CARS_DATA AS T2` with the condition `T1.MakeId = T2.Id` instead of querying a single table without any joins. Do order by `T2.horsepower ASC` in ascending order instead of `horsepower DESC` in descending order. The amended query now correctly retrieves the car model with the lowest horsepower by properly joining the car names and data tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "97": {
        "db_id": "car_1",
        "question": "Find the model of the car whose weight is below the average weight.",
        "ground_truth": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)",
        "amends": [
            "Do specify `T1.model` with table alias instead of just `model`. Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` instead of querying only `cars`. Do use `ON T1.MakeId = T2.Id` for the join condition instead of no join. Do filter on `T2.Weight` instead of `weight`. Do reference `CARS_DATA` in the subquery instead of `cars`. The amended query now correctly joins the necessary tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < (SELECT AVG(weight) FROM cars);",
            "SELECT T1.Model \nFROM CAR_NAMES AS T1\nJOIN CARS_DATA AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Weight < (SELECT AVG(Weight) FROM CARS_DATA)"
        ],
        "rule_sql": []
    },
    "98": {
        "db_id": "car_1",
        "question": "What is the model for the car with a weight smaller than the average?",
        "ground_truth": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)",
        "amends": [
            "Do select `T1.model` from the `CAR_NAMES` table instead of `model` from the `cars` table. Do join `CARS_DATA AS T2` with `T1.MakeId = T2.Id` instead of querying a single table. Do use `T2.Weight <` instead of `weight >` for the comparison. Do reference `CARS_DATA` in the subquery instead of `cars`. Do add proper table aliases and join conditions instead of assuming a single table structure. The amended query now correctly joins the car names with car data and uses the proper comparison logic to find models with below-average weight."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight > (SELECT AVG(weight) FROM cars);",
            "SELECT T1.Model \nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Weight < (SELECT AVG(Weight) FROM cars_data)"
        ],
        "rule_sql": []
    },
    "99": {
        "db_id": "car_1",
        "question": "Find the name of the makers that produced some cars in the year of 1970?",
        "ground_truth": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';",
        "amends": [
            "Do use `DISTINCT T1.Maker` instead of `maker` to eliminate duplicates. Do add joins to `CAR_MAKERS AS T1`, `MODEL_LIST AS T2`, `CAR_NAMES AS T3`, and `CARS_DATA AS T4` instead of querying only `cars`. Do join on `T1.Id = T2.Maker` and `T2.model = T3.model` and `T3.MakeId = T4.id` instead of no join conditions. Do filter on `T4.year = '1970'` instead of `year = 1970` with proper table qualification and string literal. The amended query now correctly identifies car makers from 1970 by traversing the proper relationship chain between tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker FROM cars WHERE year = 1970;",
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ],
        "rule_sql": []
    },
    "100": {
        "db_id": "car_1",
        "question": "What is the name of the different car makers who produced a car in 1970?",
        "ground_truth": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';",
        "amends": [
            "Do add explicit table joins with `CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker JOIN CAR_NAMES AS T3 ON T2.model = T3.model JOIN CARS_DATA AS T4 ON T3.MakeId = T4.id` instead of querying a single `cars` table. Do reference the maker column as `T1.Maker` instead of just `maker`. Do filter on `T4.year = '1970'` with string comparison instead of numeric `year = 1970`. The amended query now correctly joins multiple tables to establish the proper relationship between car makers and their 1970 models, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT maker FROM cars WHERE year = 1970;",
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ],
        "rule_sql": []
    },
    "101": {
        "db_id": "car_1",
        "question": "Find the make and production time of the cars that were produced in the earliest year?",
        "ground_truth": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",
        "amends": [
            "Do select `T2.Make` and `T1.Year` instead of `make` and `production_time`. Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do add a WHERE filter for `T1.Year = (SELECT min(YEAR) FROM CARS_DATA)` instead of ordering by `production_year DESC` with `LIMIT 1`. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly finds the car make with the earliest production year by joining the necessary tables and using a subquery to identify the minimum year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT make, production_time FROM cars ORDER BY production_year DESC LIMIT 1;",
            "SELECT T2.Make, T1.Year \nFROM cars_data AS T1 \nJOIN car_names AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Year = (SELECT MIN(Year) FROM cars_data)"
        ],
        "rule_sql": []
    },
    "102": {
        "db_id": "car_1",
        "question": "What is the maker of the carr produced in the earliest year and what year was it?",
        "ground_truth": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",
        "amends": [
            "Do select `T2.Make` and `T1.Year` instead of `maker` and `MIN(year)`. Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying a single table. Do use `WHERE T1.Year = (SELECT min(YEAR) FROM CARS_DATA)` instead of `WHERE year = (SELECT MAX(year) FROM cars)`. Do reference the correct table aliases `T1` and `T2` instead of the original table references. The amended query now correctly retrieves the make and year from joined tables using the proper minimum year calculation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, MIN(year) FROM cars WHERE year = (SELECT MAX(year) FROM cars);",
            "SELECT T2.Make, T1.Year \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T1.Year = (SELECT MIN(Year) FROM cars_data)"
        ],
        "rule_sql": []
    },
    "103": {
        "db_id": "car_1",
        "question": "Which distinct car models are the produced after 1980?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;",
        "amends": [
            "Do add `MODEL_LIST AS T1` joined to `CAR_NAMES AS T2` on `T1.model = T2.model` instead of querying `cars` directly. Do add another join to `CARS_DATA AS T3` on `T2.MakeId = T3.id` instead of missing these table relationships. Do move the year filter to `T3.year > 1980` instead of applying it to an unspecified source. Do specify the table alias with `T1.model` instead of just `model` to avoid ambiguity. The amended query now correctly joins the three required tables to filter cars by year while maintaining the distinct model selection, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT model FROM cars WHERE year > 1980;",
            "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980"
        ],
        "rule_sql": []
    },
    "104": {
        "db_id": "car_1",
        "question": "What are the different models for the cards produced after 1980?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;",
        "amends": [
            "Do use `DISTINCT T1.model` instead of just `model` to eliminate duplicates. Do add `MODEL_LIST AS T1` as the main table instead of just `cards`. Do add `JOIN CAR_NAMES AS T2 ON T1.model = T2.model` instead of omitting this join. Do add `JOIN CARS_DATA AS T3 ON T2.MakeId = T3.id` instead of omitting this second join. Do use `T3.year > 1980` instead of `production_year > 1980` to filter on the correct year column from the joined table. The amended query now correctly joins multiple tables to retrieve distinct car models from the appropriate year filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cards WHERE production_year > 1980",
            "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980"
        ],
        "rule_sql": []
    },
    "105": {
        "db_id": "car_1",
        "question": "How many car makers are there in each continents? List the continent name and the count.",
        "ground_truth": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",
        "amends": [
            "Do add `CONTINENTS AS T1` and `COUNTRIES AS T2` tables with proper joins instead of querying only `car_makers`. Do use `JOIN COUNTRIES AS T2 ON T1.ContId = T2.continent` to connect continents to countries instead of missing this relationship. Do add `JOIN car_makers AS T3 ON T2.CountryId = T3.Country` to properly associate car makers with countries instead of directly grouping by continent from car_makers. Do select `T1.Continent` from the continents table instead of the potentially incorrect `continent` column from car_makers. The amended query now correctly handles the hierarchical relationship between continents, countries, and car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, COUNT(*) FROM car_makers GROUP BY continent;",
            "SELECT T1.Continent, COUNT(T3.Id) AS CountOfCarMakers\nFROM continents AS T1\nJOIN countries AS T2 ON T1.ContId = T2.Continent\nJOIN car_makers AS T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent"
        ],
        "rule_sql": []
    },
    "106": {
        "db_id": "car_1",
        "question": "What is the name of each continent and how many car makers are there in each one?",
        "ground_truth": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",
        "amends": [
            "Do add `CONTINENTS AS T1` and `COUNTRIES AS T2` tables with proper joins instead of querying `car_makers` alone. Do use `JOIN COUNTRIES AS T2 ON T1.ContId = T2.continent` instead of missing the countries-continents relationship. Do use `JOIN car_makers AS T3 ON T2.CountryId = T3.Country` instead of directly grouping by continent from car_makers. Do select `T1.Continent` with proper table qualification instead of just `continent`. The amended query now correctly links continents to countries to car manufacturers and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, COUNT(*) FROM car_makers GROUP BY continent;",
            "SELECT T1.Continent, COUNT(T3.Id) AS NumberOfCarMakers\nFROM continents AS T1\nJOIN countries AS T2 ON T1.ContId = T2.Continent\nJOIN car_makers AS T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent"
        ],
        "rule_sql": []
    },
    "107": {
        "db_id": "car_1",
        "question": "Which of the countries has the most car makers? List the country name.",
        "ground_truth": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;",
        "amends": [
            "Do join `COUNTRIES` as `T2` on `T1.Country = T2.CountryId` instead of querying only `car_makers` without any join. Do select `T2.CountryName` instead of `country` to get the proper country name from the joined table. Do order by `Count(*) DESC` instead of `ASC` to find the country with the highest count rather than the lowest. Do use table aliases `T1` and `T2` instead of no aliases for clarity. The amended query now correctly identifies the country with the most car makers by joining to the countries table and ordering in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as maker_count FROM car_makers GROUP BY country ORDER BY maker_count ASC LIMIT 1;",
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "108": {
        "db_id": "car_1",
        "question": "What is the name of the country with the most car makers?",
        "ground_truth": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;",
        "amends": [
            "Do join `COUNTRIES` as `T2` instead of querying only `car_makers`. Do use `T1.Country = T2.CountryId` as the join condition instead of no join. Do select `T2.CountryName` instead of `country`. Do add `GROUP BY T1.Country` instead of omitting grouping. Do maintain `ORDER BY COUNT(*) DESC LIMIT 1` as in the original query. The amended query now correctly retrieves the country name from the joined COUNTRIES table while preserving the aggregation logic to find the country with the most car makers."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM car_makers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "109": {
        "db_id": "car_1",
        "question": "How many car models are produced by each maker ? Only list the count and the maker full name .",
        "ground_truth": "select count(*) ,  t2.fullname from model_list as t1 join car_makers as t2 on t1.maker  =  t2.id group by t2.id;",
        "amends": [
            "Do join `car_makers` as `t2` instead of omitting it, and use `model_list` as `t1` instead of `car_models`. Do join on `t1.maker = t2.id` instead of no join condition. Do select `t2.fullname` instead of `maker`, and remove the alias `model_count` instead of keeping it. Do group by `t2.id` instead of `maker`. The amended query now correctly counts models per maker by joining to the car_makers table and grouping on the maker's ID rather than the raw maker value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as model_count, maker FROM car_models GROUP BY maker;",
            "SELECT COUNT(t1.ModelId) AS count, t2.FullName \nFROM model_list t1 \nJOIN car_makers t2 ON t1.Maker = t2.Id \nGROUP BY t2.Id"
        ],
        "rule_sql": []
    },
    "110": {
        "db_id": "car_1",
        "question": "What is the number of car models that are produced by each maker and what is the id and full name of each maker?",
        "ground_truth": "SELECT Count(*) ,  T2.FullName ,  T2.id FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id GROUP BY T2.id;",
        "amends": [
            "Do select `Count(*)`, `T2.FullName`, and `T2.id` instead of `maker` and `COUNT(*) as num_models`. Do join `MODEL_LIST AS T1` with `CAR_MAKERS AS T2` on `T1.Maker = T2.Id` instead of querying only `car_models`. Do group by `T2.id` instead of `maker`. The amended query now correctly counts models per car maker while joining the appropriate tables to resolve maker information.",
            "Do remove the alias `num_models` from the count expression instead of keeping it. Do change the column order to place `T2.FullName` before `T2.id` instead of having `T2.Id` first. Do use lowercase `id` in both the select list and GROUP BY clause instead of uppercase `Id`. Do remove the table alias `AS` syntax from the FROM clause references instead of including it. The amended query now correctly groups by maker ID while selecting the count and full name in the proper order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, COUNT(*) as num_models FROM car_models GROUP BY maker;",
            "SELECT COUNT(*) AS num_models, T2.Id, T2.FullName FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id GROUP BY T2.Id",
            "SELECT COUNT(*) AS num_models, T2.FullName, T2.id\nFROM model_list T1\nJOIN car_makers T2 ON T1.Maker = T2.id\nGROUP BY T2.id"
        ],
        "rule_sql": []
    },
    "111": {
        "db_id": "car_1",
        "question": "What is the accelerate of the car make amc hornet sportabout (sw)?",
        "ground_truth": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';",
        "amends": [
            "Do join `CAR_NAMES` as `T2` on `T1.Id = T2.MakeId` instead of querying `cars` table directly. Do reference `Accelerate` from `T1` instead of `accelerate` from the base table. Do filter on `T2.Make = 'amc hornet sportabout (sw)'` instead of `make = 'amc hornet sportabout (sw)'` to properly correlate the make name with the corresponding acceleration data through the join relationship. The amended query now correctly retrieves acceleration data by joining through the proper table relationship instead of assuming the make column exists directly in the data table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT accelerate FROM cars WHERE make = 'amc hornet sportabout (sw)'",
            "SELECT T1.Accelerate \nFROM cars_data T1 \nJOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T2.Make = 'amc hornet sportabout (sw)'"
        ],
        "rule_sql": []
    },
    "112": {
        "db_id": "car_1",
        "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?",
        "ground_truth": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';",
        "amends": [
            "Do join `CAR_NAMES` as `T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do select `Accelerate` from `CARS_DATA` as `T1` instead of selecting `acceleration` from `cars`. Do filter on `T2.Make = 'amc hornet sportabout (sw)'` instead of filtering on both `model = 'amc hornet sportabout (sw)'` and `make = 'amc'`. Do remove the incorrect `make` filter condition instead of including it. The amended query now correctly joins the necessary tables and uses the proper column relationships to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT acceleration FROM cars WHERE model = 'amc hornet sportabout (sw)' AND make = 'amc';",
            "SELECT T1.Accelerate \nFROM cars_data T1\nJOIN car_names T2 ON T1.Id = T2.MakeId\nWHERE T2.Make = 'amc hornet sportabout (sw)'"
        ],
        "rule_sql": []
    },
    "113": {
        "db_id": "car_1",
        "question": "How many car makers are there in france?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';",
        "amends": [
            "Do add a `JOIN` with `COUNTRIES` table on `T1.Country = T2.CountryId` instead of querying only the `car_makers` table. Do filter on `T2.CountryName = 'france'` instead of directly filtering on `country = 'France'` to properly match country names through the relationship table. Do use table aliases `T1` and `T2` instead of referencing tables directly without aliases. The amended query now correctly joins the country reference table to filter by country name instead of relying on potentially inconsistent country codes in the main table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE country = 'France';",
            "SELECT COUNT(*) \nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ],
        "rule_sql": []
    },
    "114": {
        "db_id": "car_1",
        "question": "What is the number of makers of care in France?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';",
        "amends": [
            "Do join `CAR_MAKERS AS T1` with `COUNTRIES AS T2` on `T1.Country = T2.CountryId` instead of querying only the `makers` table. Do filter on `T2.CountryName = 'france'` instead of directly filtering `country = 'France'` to properly match country names through the relationship table. Do use table aliases `T1` and `T2` instead of omitting them for clarity. The amended query now correctly counts French car makers by joining with the countries reference table and matching on country name instead of assuming direct country values.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)`. Do use lowercase `'france'` instead of uppercase `'France'` for the country name filter. Do maintain the same join condition `T1.Country = T2.CountryId` and table aliases. The amended query now correctly counts car makers from France using case-insensitive matching for the country name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM makers WHERE country = 'France';",
            "SELECT COUNT(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'France'",
            "SELECT count(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'"
        ],
        "rule_sql": []
    },
    "115": {
        "db_id": "car_1",
        "question": "How many car models are produced in the usa?",
        "ground_truth": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';",
        "amends": [
            "Do add explicit table joins with `MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker = T2.Id JOIN COUNTRIES AS T3 ON T2.Country = T3.CountryId` instead of querying a single `cars` table. Do filter on `T3.CountryName = 'usa'` instead of `country = 'USA'` to properly reference the joined countries table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly joins multiple tables to count models from the specified country and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA';",
            "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'"
        ],
        "rule_sql": []
    },
    "116": {
        "db_id": "car_1",
        "question": "What is the count of the car models produced in the United States?",
        "ground_truth": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';",
        "amends": [
            "Do add joins to `MODEL_LIST AS T1`, `CAR_MAKERS AS T2`, and `COUNTRIES AS T3` instead of querying only the `cars` table. Do join `T1` to `T2` on `T1.Maker = T2.Id` instead of missing this relationship entirely. Do join `T2` to `T3` on `T2.Country = T3.CountryId` instead of omitting the country table connection. Do filter on `T3.CountryName = 'usa'` instead of filtering directly on `country = 'USA'` which referenced the wrong column. Do use proper table aliases and qualified column references instead of unqualified column names that caused ambiguity. The amended query now correctly counts models from USA manufacturers by properly joining through the manufacturer and country relationships instead of relying on incorrect column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA';",
            "SELECT COUNT(*) \nFROM model_list AS T1\nJOIN car_makers AS T2 ON T1.Maker = T2.Id\nJOIN countries AS T3 ON T2.Country = T3.CountryId\nWHERE T3.CountryName = 'usa'"
        ],
        "rule_sql": []
    },
    "117": {
        "db_id": "car_1",
        "question": "What is the average miles per gallon(mpg) of the cars with 4 cylinders?",
        "ground_truth": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;",
        "amends": [
            "Do select `avg(mpg)` instead of `AVG(horsepower)` to calculate the average miles per gallon rather than horsepower. Do reference table `CARS_DATA` instead of `cars` to use the correct table name. Do filter on `Cylinders = 4` instead of `cylinders = 4` to use the proper column name capitalization. The amended query now correctly calculates average MPG for 4-cylinder vehicles from the appropriate data source."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE cylinders = 4;",
            "SELECT AVG(MPG) FROM cars_data WHERE Cylinders = 4"
        ],
        "rule_sql": []
    },
    "118": {
        "db_id": "car_1",
        "question": "What is the average miles per gallon of all the cards with 4 cylinders?",
        "ground_truth": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to use the correct table name. Do use lowercase `avg` function instead of uppercase `AVG` for consistent function naming. Do maintain the same filter condition `cylinders = 4` without changes. The amended query now correctly references the proper table while preserving the same aggregation logic and filtering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(mpg) FROM cars WHERE cylinders = 4;",
            "SELECT avg(MPG) FROM cars_data WHERE Cylinders = 4"
        ],
        "rule_sql": []
    },
    "119": {
        "db_id": "car_1",
        "question": "What is the smallest weight of the car produced with 8 cylinders on 1974 ?",
        "ground_truth": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974",
        "amends": [
            "Do use `MIN(weight)` instead of `MAX(weight)` for the aggregate function. Do reference table `cars_data` instead of `cars` as the data source. The amended query now correctly finds the minimum weight of 8-cylinder cars from 1974 rather than the maximum weight."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM cars WHERE cylinders = 8 AND year = 1974;",
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ],
        "rule_sql": []
    },
    "120": {
        "db_id": "car_1",
        "question": "What is the minimum weight of the car with 8 cylinders produced in 1974 ?",
        "ground_truth": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974",
        "amends": [
            "Do reference table `cars_data` instead of `cars` while keeping the same MIN(weight) aggregation and WHERE filters on `cylinders = 8` and `year = 1974` unchanged. The amended query now correctly references the actual table name while maintaining the same logical behavior to find the minimum weight of 8-cylinder cars from 1974."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(weight) FROM cars WHERE cylinders = 8 AND year = 1974;",
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974"
        ],
        "rule_sql": []
    },
    "121": {
        "db_id": "car_1",
        "question": "What are all the makers and models?",
        "ground_truth": "SELECT Maker ,  Model FROM MODEL_LIST;",
        "amends": [
            "Do reference the `MODEL_LIST` table instead of the `products` table. Do remove the `WHERE model IS NULL` filter instead of keeping it. The amended query now correctly selects all makers and models from the appropriate table without unnecessary filtering.",
            "Do select only `Maker` and `Model` columns instead of including the table prefix `cm.` and `ml.` qualifiers. Do use a single table `MODEL_LIST` as the source instead of joining `car_makers` with `model_list` on `cm.Id = ml.Maker`. Do remove the unnecessary join condition entirely instead of maintaining the relationship between the tables. The amended query now correctly retrieves only the maker and model information directly from the MODEL_LIST table without the redundant join operation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, model FROM products WHERE model IS NULL;",
            "SELECT cm.Maker, ml.Model FROM car_makers cm JOIN model_list ml ON cm.Id = ml.Maker;",
            "SELECT Maker, Model FROM model_list"
        ],
        "rule_sql": []
    },
    "122": {
        "db_id": "car_1",
        "question": "What are the makers and models?",
        "ground_truth": "SELECT Maker ,  Model FROM MODEL_LIST;",
        "amends": [
            "Do select specific columns `Maker` and `Model` instead of using `*` to select all columns. Do query from table `MODEL_LIST` instead of table `products`. The amended query now correctly retrieves only the maker and model columns from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products;",
            "SELECT Maker, Model FROM model_list"
        ],
        "rule_sql": []
    },
    "123": {
        "db_id": "car_1",
        "question": "What are the countries having at least one car maker? List name and id.",
        "ground_truth": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",
        "amends": [
            "Do use explicit `JOIN` syntax with `T1.CountryId = T2.Country` instead of a correlated subquery with `EXISTS`. Do add table aliases `T1` and `T2` instead of using full table names. Do include `GROUP BY T1.CountryId` instead of omitting aggregation. Do move the existence check to `HAVING count(*) >= 1` instead of using `WHERE EXISTS`. Do select `T1.CountryName` and `T1.CountryId` instead of `country_id, country_name`. The amended query now correctly identifies countries with car makers using proper join semantics and aggregation.",
            "Do maintain the same `SELECT` list order with `CountryName` first instead of `CountryId` first. Do use `AS` for table aliases with `COUNTRIES AS T1` instead of omitting the `AS` keyword. Do use uppercase table names `COUNTRIES` and `CAR_MAKERS` instead of lowercase. Do preserve the same join condition `T1.CountryId = T2.Country` and grouping structure with identical `HAVING` clause `count(*) >= 1`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_id, country_name FROM countries WHERE EXISTS (SELECT 1 FROM car_makers WHERE car_makers.country_id = countries.country_id);",
            "SELECT T1.CountryId, T1.CountryName\nFROM countries T1\nJOIN car_makers T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) >= 1",
            "SELECT T1.CountryName, T1.CountryId\nFROM COUNTRIES AS T1\nJOIN CAR_MAKERS AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING count(*) >= 1"
        ],
        "rule_sql": []
    },
    "124": {
        "db_id": "car_1",
        "question": "What are the names and ids of all countries with at least one car maker?",
        "ground_truth": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",
        "amends": [
            "Do select `T1.CountryName` and `T1.CountryId` instead of `name` and `id`. Do add `JOIN CAR_MAKERS AS T2` instead of omitting the table. Do use `ON T1.CountryId = T2.Country` instead of the incorrect `car_makers > 0` filter. Do add `GROUP BY T1.CountryId` instead of omitting grouping. Do move the existence check to `HAVING count(*) >= 1` instead of using `WHERE car_makers > 0`. The amended query now correctly joins the tables and uses proper aggregation to find countries with car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, id FROM countries WHERE car_makers > 0;",
            "SELECT T1.CountryName, T1.CountryId \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId \nHAVING COUNT(*) >= 1"
        ],
        "rule_sql": []
    },
    "125": {
        "db_id": "car_1",
        "question": "What is the number of the cars with horsepower more than 150?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do use filter `horsepower > 150` instead of `horsepower < 150` in the WHERE clause, changing the comparison operator from less than to greater than. The amended query now correctly counts records where horsepower exceeds 150 rather than those below 150, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE horsepower < 150;",
            "SELECT COUNT(*) FROM cars_data WHERE horsepower > 150"
        ],
        "rule_sql": []
    },
    "126": {
        "db_id": "car_1",
        "question": "What is the number of cars with a horsepower greater than 150?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` and use filter `horsepower > 150` instead of `horsepower < 150` to count records with higher horsepower values rather than lower ones. The amended query now correctly counts vehicles exceeding 150 horsepower, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE horsepower < 150;",
            "SELECT COUNT(*) FROM cars_data WHERE horsepower > 150"
        ],
        "rule_sql": []
    },
    "127": {
        "db_id": "car_1",
        "question": "What is the average weight of cars each year?",
        "ground_truth": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",
        "amends": [
            "Do use `avg(Weight)` with uppercase column name instead of `AVG(weight)` with lowercase. Do place the aggregate function first in the SELECT list instead of the year column. Do reference the correct table name `CARS_DATA` instead of `cars`. Do maintain the same GROUP BY logic with `YEAR` instead of `year` while preserving the uppercase column reference. The amended query now correctly calculates average weight by year from the CARS_DATA table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, AVG(weight) FROM cars GROUP BY year;",
            "SELECT avg(Weight), Year FROM CARS_DATA GROUP BY Year"
        ],
        "rule_sql": []
    },
    "128": {
        "db_id": "car_1",
        "question": "What is the average weight and year for each year?",
        "ground_truth": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",
        "amends": [
            "Do select `avg(Weight)` and `YEAR` instead of `year` and `AVG(weight) as average_weight`. Do group by `YEAR` instead of `weight`. Do use table `CARS_DATA` instead of `table_name`. The amended query now correctly calculates average weight grouped by year rather than incorrectly grouping by weight itself, matching the intended behavior.",
            "Do place the `YEAR` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `AVG(Weight)` aggregate calculation and `GROUP BY YEAR` clause without changes. The amended query now correctly follows SQL syntax conventions where non-aggregated columns should appear after aggregate functions in the SELECT list when using GROUP BY, ensuring the query matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, AVG(weight) as average_weight FROM table_name GROUP BY weight;",
            "SELECT YEAR, AVG(Weight) FROM cars_data GROUP BY YEAR;",
            "SELECT AVG(Weight), YEAR FROM cars_data GROUP BY YEAR"
        ],
        "rule_sql": []
    },
    "129": {
        "db_id": "car_1",
        "question": "Which countries in europe have at least 3 car manufacturers?",
        "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
        "amends": [
            "Do select `T1.CountryName` from the `COUNTRIES` table instead of `country` from `car_manufacturers`. Do join `CONTINENTS AS T2` on `T1.Continent = T2.ContId` and `CAR_MAKERS AS T3` on `T1.CountryId = T3.Country` instead of querying a single table. Do filter with `T2.Continent = 'europe'` instead of `continent = 'Europe'` and maintain the same `GROUP BY T1.CountryName` and `HAVING count(*) >= 3` logic. The amended query now correctly joins multiple tables to establish proper relationships between countries, continents, and car manufacturers while maintaining the same grouping and filtering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM car_manufacturers WHERE continent = 'Europe' GROUP BY country HAVING COUNT(*) >= 3;",
            "SELECT T1.CountryName \nFROM countries AS T1\nJOIN continents AS T2 ON T1.Continent = T2.ContId\nJOIN car_makers AS T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": []
    },
    "130": {
        "db_id": "car_1",
        "question": "What are the names of all European countries with at least 3 manufacturers?",
        "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
        "amends": [
            "Do use `T1.CountryName` instead of `c.name` for the SELECT column. Do join `CONTINENTS AS T2` on `T1.Continent = T2.ContId` instead of omitting this table entirely. Do join `CAR_MAKERS AS T3` on `T1.CountryId = T3.Country` instead of joining `manufacturers m` on `c.id = m.country_id`. Do filter on `T2.Continent = 'europe'` instead of `c.continent = 'Europe'`. Do use `count(*) >= 3` instead of `COUNT(m.id) > 2` in the HAVING clause. The amended query now correctly joins through the continents table and uses proper threshold comparison for counting car makers per European country."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM countries c \nJOIN manufacturers m ON c.id = m.country_id \nWHERE c.continent = 'Europe' \nGROUP BY c.name \nHAVING COUNT(m.id) > 2;",
            "SELECT T1.CountryName\nFROM countries AS T1\nJOIN continents AS T2 ON T1.Continent = T2.ContId\nJOIN car_makers AS T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": []
    },
    "131": {
        "db_id": "car_1",
        "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?",
        "ground_truth": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do use explicit table aliases `T2.horsepower` and `T1.Make` instead of unqualified column names. Do join `CAR_NAMES AS T1` with `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying a single non-existent table `car_models`. Do filter on `T2.cylinders = 3` instead of `cylinders = 3` with proper table qualification. Do add `ORDER BY T2.horsepower DESC LIMIT 1` to get the maximum value instead of using `MAX()` aggregation without grouping. The amended query now correctly retrieves the maximum horsepower record with proper table relationships and explicit column qualifications."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(horsepower), make FROM car_models WHERE cylinders = 3",
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "132": {
        "db_id": "car_1",
        "question": "What is the largest amount of horsepower for the models with 3 cylinders and what make is it?",
        "ground_truth": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do reference `T2.horsepower` and `T1.Make` instead of `MAX(horsepower)` and `make`. Do join `CAR_NAMES AS T1` with `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying a single table `cars`. Do filter on `T2.cylinders = 3` instead of `cylinders = 3`. Do order by `T2.horsepower DESC` instead of `horsepower DESC`. The amended query now correctly joins the necessary tables and references the proper columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(horsepower), make FROM cars WHERE cylinders = 3 ORDER BY horsepower DESC LIMIT 1;",
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "133": {
        "db_id": "car_1",
        "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of selecting `model` from the `cars` table. Do join `CARS_DATA AS T2` using `ON T1.MakeId = T2.Id` instead of querying a single table without any joins. Do order by `T2.mpg` instead of ordering by `mpg` without table qualification. The amended query now correctly retrieves the car model with the highest MPG by properly joining the car names with their corresponding performance data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.MPG DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "134": {
        "db_id": "car_1",
        "question": "What is the car model with the highest mpg ?",
        "ground_truth": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;",
        "amends": [
            "Do select `t1.model` from `car_names as t1` instead of `car_model` from `cars`. Do join `cars_data as t2` on `t1.makeid = t2.id` instead of querying a single table without joins. Do order by `t2.mpg` instead of `mpg` to reference the joined table's column. The amended query now correctly joins the necessary tables to retrieve car model information with proper MPG data and matches the right SQL's behavior.",
            "Do remove the `CAST(t2.MPG AS REAL)` expression instead of keeping it, as the `MPG` column is already numeric and doesn't require casting for proper sorting. Do use direct `t2.mpg DESC` ordering instead of the unnecessary cast operation. The amended query now correctly sorts by the numeric MPG values in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT car_model FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY CAST(t2.MPG AS REAL) DESC LIMIT 1;",
            "SELECT t1.Model FROM car_names AS t1 JOIN cars_data AS t2 ON t1.MakeId = t2.Id ORDER BY t2.MPG DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "135": {
        "db_id": "car_1",
        "question": "What is the average horsepower of the cars before 1980?",
        "ground_truth": "SELECT avg(horsepower) FROM CARS_DATA WHERE YEAR  <  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do change the WHERE filter to `YEAR < 1980` instead of `year > 1980`, reversing the comparison operator and direction. Do use lowercase `avg` function instead of uppercase `AVG` for the aggregate calculation. The amended query now correctly calculates average horsepower for pre-1980 vehicles instead of post-1980 vehicles, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE year > 1980;",
            "SELECT avg(Horsepower) FROM cars_data WHERE Year < 1980"
        ],
        "rule_sql": []
    },
    "136": {
        "db_id": "car_1",
        "question": "What is the average horsepower for all cars produced before 1980 ?",
        "ground_truth": "select avg(horsepower) from cars_data where year  <  1980;",
        "amends": [
            "Do reference table `cars_data` instead of `cars` in the FROM clause. Do use filter condition `year < 1980` instead of `year >= 1980` in the WHERE clause, changing the comparison operator and threshold value to select pre-1980 vehicles rather than post-1980 ones. The amended query now correctly calculates the average horsepower for cars manufactured before 1980, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE year >= 1980;",
            "SELECT AVG(Horsepower) FROM cars_data WHERE Year < 1980"
        ],
        "rule_sql": []
    },
    "137": {
        "db_id": "car_1",
        "question": "What is the average edispl of the cars of model volvo?",
        "ground_truth": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';",
        "amends": [
            "Do join `CAR_NAMES AS T1` to `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do reference `T2.edispl` in the `AVG` function instead of just `edispl`. Do filter on `T1.Model = 'volvo'` instead of `model = 'volvo'` to correctly associate the model name with the appropriate table. The amended query now properly joins the necessary tables to match the model name with engine displacement data, ensuring accurate results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(edispl) FROM cars WHERE model = 'volvo';",
            "SELECT AVG(T2.Edispl) \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T1.Model = 'volvo'"
        ],
        "rule_sql": []
    },
    "138": {
        "db_id": "car_1",
        "question": "What is the average edispl for all volvos?",
        "ground_truth": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';",
        "amends": [
            "Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do filter on `T1.Model = 'volvo'` instead of `make = 'Toyota'`. Do select `avg(T2.edispl)` with explicit table qualification instead of `AVG(edispl)` without table reference. The amended query now correctly joins the necessary tables and filters by model rather than make, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(edispl) FROM cars WHERE make = 'Toyota';",
            "SELECT AVG(T2.Edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ],
        "rule_sql": []
    },
    "139": {
        "db_id": "car_1",
        "question": "What is the maximum accelerate for different number of cylinders?",
        "ground_truth": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",
        "amends": [
            "Do use column name `Accelerate` instead of `acceleration` and place it as the first argument to `MAX` instead of second. Do use column name `Cylinders` instead of `cylinders` and place it as the second column instead of first in the SELECT list. Do reference table `CARS_DATA` instead of `cars` in the FROM clause. The amended query now correctly retrieves the maximum acceleration grouped by cylinders from the specified table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cylinders, MAX(acceleration) FROM cars GROUP BY cylinders;",
            "SELECT MAX(Accelerate) AS MaxAccelerate, Cylinders FROM cars_data GROUP BY Cylinders"
        ],
        "rule_sql": []
    },
    "140": {
        "db_id": "car_1",
        "question": "What is the maximum accelerate for all the different cylinders?",
        "ground_truth": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",
        "amends": [
            "Do use `max(Accelerate)` with proper capitalization instead of `MAX(accelerate)` with lowercase column reference. Do place `Cylinders` in the SELECT list after the aggregate function instead of before it. Do reference the table as `CARS_DATA` instead of `cars` to match the correct table name. Do maintain the same GROUP BY logic with `Cylinders` instead of `cylinders` for consistent column naming. The amended query now correctly calculates maximum acceleration grouped by cylinder count using the proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cylinders, MAX(accelerate) FROM cars GROUP BY cylinders;",
            "SELECT max(Accelerate), Cylinders FROM cars_data GROUP BY Cylinders"
        ],
        "rule_sql": []
    },
    "141": {
        "db_id": "car_1",
        "question": "Which model has the most version(make) of cars?",
        "ground_truth": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do reference the table as `CAR_NAMES` instead of `cars` and use the column name `Model` instead of `model` in both the SELECT list and GROUP BY clause. Do remove the explicit `COUNT(*) as version_count` column from the SELECT list instead of including it, and instead rely on the aggregate function directly in the ORDER BY clause. Do order by `count(*) DESC` instead of ordering by the alias `version_count DESC`. The amended query now correctly identifies the most frequent model from the CAR_NAMES table while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model, COUNT(*) as version_count FROM cars GROUP BY model ORDER BY version_count DESC LIMIT 1;",
            "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "142": {
        "db_id": "car_1",
        "question": "What model has the most different versions?",
        "ground_truth": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do select `Model` instead of `model, COUNT(*) as version_count` to return only the model column without aggregation. Do use table `CAR_NAMES` instead of `car_models` as the data source. Do remove the explicit count aggregation and alias from the SELECT list instead of including them. Do maintain the GROUP BY on `Model` instead of `model` but with proper case. Do keep the ORDER BY `count(*) DESC` instead of `version_count DESC` to sort by the implicit count without an alias. Do preserve the LIMIT 1 instead of changing it. The amended query now correctly returns the most frequent model from the CAR_NAMES table by counting occurrences per model and selecting the top result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model, COUNT(*) as version_count FROM car_models GROUP BY model ORDER BY version_count DESC LIMIT 1;",
            "SELECT Model FROM car_names GROUP BY Model ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "143": {
        "db_id": "car_1",
        "question": "How many cars have more than 4 cylinders?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do change the WHERE filter to `Cylinders > 4` instead of `cylinders <= 4`, effectively counting vehicles with more than 4 cylinders rather than 4 or fewer cylinders. The amended query now correctly matches the RIGHT_SQL's behavior by counting high-cylinder vehicles."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 4;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 4"
        ],
        "rule_sql": []
    },
    "144": {
        "db_id": "car_1",
        "question": "What is the number of cars with more than 4 cylinders?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do use filter condition `Cylinders > 4` instead of `cylinders <= 4` in the WHERE clause, changing both the column name case and the inequality direction. The amended query now correctly counts records with more than 4 cylinders from the CARS_DATA table instead of counting those with 4 or fewer cylinders from a differently named table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 4;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 4"
        ],
        "rule_sql": []
    },
    "145": {
        "db_id": "car_1",
        "question": "how many cars were produced in 1980?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to correctly access the source data table. Do maintain the same filter condition `YEAR = 1980` to count records from the specified year. The amended query now correctly counts records from the appropriate data source table while preserving the same filtering logic and aggregation behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1980;",
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ],
        "rule_sql": []
    },
    "146": {
        "db_id": "car_1",
        "question": "In 1980, how many cars were made?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to correctly access the source data. Do maintain the same filter condition `YEAR = 1980` and aggregate function `count(*)` as they remain functionally identical. The amended query now correctly counts records from the appropriate table while preserving the same filtering logic and aggregation behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1980;",
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ],
        "rule_sql": []
    },
    "147": {
        "db_id": "car_1",
        "question": "How many car models were produced by the maker with full name American Motor Company?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';",
        "amends": [
            "Do add `JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker` instead of querying only the `car_makers` table. Do use table alias `T1` for `CAR_MAKERS` instead of referencing the table directly. Do reference `T1.FullName` instead of `full_name` to match the proper column casing. The amended query now correctly joins the model list table to count models from American Motor Company instead of just counting the manufacturer itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE full_name = 'American Motor Company';",
            "SELECT COUNT(*) FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'"
        ],
        "rule_sql": []
    },
    "148": {
        "db_id": "car_1",
        "question": "What is the number of car models created by the car maker American Motor Company?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';",
        "amends": [
            "Do add `JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker` instead of querying only the `car_makers` table. Do change the filter to `T1.FullName = 'American Motor Company'` instead of `maker = 'American Motor Company'` to use the correct column name for the full company name. The amended query now correctly joins the model list table and filters by the proper full name column, matching the RIGHT_SQL's behavior of counting models from American Motor Company rather than just counting the maker entry itself."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE maker = 'American Motor Company';",
            "SELECT COUNT(*) AS model_count\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nWHERE T1.FullName = 'American Motor Company'"
        ],
        "rule_sql": []
    },
    "149": {
        "db_id": "car_1",
        "question": "Which makers designed more than 3 car models? List full name and the id.",
        "ground_truth": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do join `MODEL_LIST` as `T2` on `T1.Id = T2.Maker` instead of querying only `car_makers` without any join. Do use `T1.FullName` and `T1.Id` instead of `maker_name` and `maker_id`. Do move the count filter to `HAVING count(*) > 3` instead of incorrectly placing `COUNT(model_id) > 3` in the `WHERE` clause. Do add proper table aliases with `AS T1` and `AS T2` instead of omitting them. The amended query now correctly counts models per maker and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker_name, maker_id FROM car_makers WHERE COUNT(model_id) > 3 GROUP BY maker_id;",
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.FullName\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "150": {
        "db_id": "car_1",
        "question": "What are the names and ids of all makers with more than 3 models?",
        "ground_truth": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do select `T1.FullName` and `T1.Id` instead of `maker_id` and `maker_name`. Do use `FROM CAR_MAKERS AS T1` joined with `MODEL_LIST AS T2` on `T1.Id = T2.Maker` instead of querying only the `makers` table. Do add `GROUP BY T1.Id` and move the count filter to `HAVING count(*) > 3` instead of using `WHERE model_count > 3` without grouping. The amended query now correctly counts models per maker and filters makers with more than 3 models, matching the intended behavior.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing the order. Do keep the identical `FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker` join structure instead of altering any join logic. Do preserve the exact `GROUP BY T1.Id` grouping and `HAVING COUNT(*) > 3` aggregation filter instead of modifying the grouping or filtering logic. The amended query now matches RIGHT_SQL's behavior with identical logical execution despite minor formatting differences.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing the order. Do keep the same table aliases `AS T1` and `AS T2` instead of modifying them. Do preserve the identical join condition `T1.Id = T2.Maker` instead of altering the relationship. Do retain the same grouping `GROUP BY T1.Id` instead of modifying the grouping criteria. Do continue using the same aggregate condition `HAVING COUNT(*) > 3` instead of changing the threshold. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing it. Do keep the same table sources `car_makers AS T1` and `model_list AS T2` with the same join type `JOIN` and identical join condition `T1.Id = T2.Maker` instead of altering them. Do preserve the identical `GROUP BY T1.Id` clause and `HAVING COUNT(*) > 3` condition instead of modifying them. The amended query now matches RIGHT_SQL's behavior as there are no substantive differences between the queries beyond potential case sensitivity in table names which should be ignored per the instructions.",
            "Do maintain the same column selection order with `T1.FullName, T1.Id` instead of `T1.Id, T1.FullName` to match the RIGHT_SQL's output format. Do preserve the identical join logic with `JOIN model_list AS T2 ON T1.Id = T2.Maker` as both queries use the same join condition and table relationships. Do keep the same grouping with `GROUP BY T1.Id` and identical aggregation condition `HAVING COUNT(*) > 3` to filter for makers with more than three models. The amended query now matches RIGHT_SQL's behavior with only the column order adjustment."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker_id, maker_name FROM makers WHERE model_count > 3;",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "151": {
        "db_id": "car_1",
        "question": "Which distinctive models are produced by maker with the full name General Motors or weighing more than 3500?",
        "ground_truth": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "amends": [
            "Do use explicit table joins with `CAR_NAMES AS T1 JOIN MODEL_LIST AS T2` instead of querying a single undefined table. Do reference specific columns `T2.Model` instead of the ambiguous `model`. Do add proper join conditions `ON T1.Model = T2.Model` and `ON T2.Maker = T3.Id` and `ON T1.MakeId = T4.Id` instead of missing table relationships. Do filter by `T3.FullName = 'General Motors'` instead of the incorrect `maker` reference. Do use `T4.weight > 3500` instead of the unqualified `weight` column. The amended query now correctly joins multiple tables and qualifies all column references to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT model FROM cars WHERE maker = 'General Motors' OR weight > 3500;",
            "SELECT DISTINCT T2.Model \nFROM car_names AS T1 \nJOIN model_list AS T2 ON T1.Model = T2.Model \nJOIN car_makers AS T3 ON T2.Maker = T3.Id \nJOIN cars_data AS T4 ON T1.MakeId = T4.Id \nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ],
        "rule_sql": []
    },
    "152": {
        "db_id": "car_1",
        "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?",
        "ground_truth": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "amends": [
            "Do use explicit table aliases `T2.Model` instead of ambiguous `model`. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do join multiple tables `CAR_NAMES AS T1`, `MODEL_LIST AS T2`, `CAR_MAKERS AS T3`, and `CARS_DATA AS T4` instead of querying a single `cars` table. Do use proper join conditions `T1.Model = T2.Model`, `T2.Maker = T3.Id`, and `T1.MakeId = T4.Id` instead of simple column references. Do filter on `T3.FullName = 'General Motors'` instead of `maker = 'General Motors'` to use the correct table relationship. Do maintain the weight filter `T4.weight > 3500` but reference it through the proper table join. The amended query now correctly handles the multi-table relationships and returns distinct models as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE maker = 'General Motors' OR weight > 3500",
            "SELECT DISTINCT T2.Model\nFROM CAR_NAMES AS T1\nJOIN MODEL_LIST AS T2 ON T1.Model = T2.Model\nJOIN CAR_MAKERS AS T3 ON T2.Maker = T3.Id\nLEFT JOIN CARS_DATA AS T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ],
        "rule_sql": []
    },
    "153": {
        "db_id": "car_1",
        "question": "In which years cars were produced weighing no less than 3000 and no more than 4000 ?",
        "ground_truth": "select distinct year from cars_data where weight between 3000 and 4000;",
        "amends": [
            "Do use `distinct` for unique years instead of omitting it. Do reference table `cars_data` instead of `cars`. Do apply filter `weight between 3000 and 4000` instead of `weight < 3000 OR weight > 4000` to select cars within the weight range rather than outside it. The amended query now correctly returns distinct years from the cars_data table for vehicles weighing between 3000 and 4000 pounds."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM cars WHERE weight < 3000 OR weight > 4000;",
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ],
        "rule_sql": []
    },
    "154": {
        "db_id": "car_1",
        "question": "What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?",
        "ground_truth": "select distinct year from cars_data where weight between 3000 and 4000;",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to access the correct data source. Do use `BETWEEN 3000 AND 4000` instead of `weight < 4000 OR weight > 3000` to properly filter for weights within the specified range rather than excluding them. The amended query now correctly returns distinct years for cars with weights between 3000 and 4000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT year FROM cars WHERE weight < 4000 OR weight > 3000;",
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ],
        "rule_sql": []
    },
    "155": {
        "db_id": "car_1",
        "question": "What is the horsepower of the car with the largest accelerate?",
        "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
        "amends": [
            "Do qualify the column reference as `T1.horsepower` instead of the unqualified `horsepower`, and do add the table alias `AS T1` to the `FROM CARS_DATA` clause instead of omitting it, while maintaining the same `ORDER BY accelerate DESC LIMIT 1` structure. The amended query now correctly references columns with explicit table qualification and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT horsepower FROM cars ORDER BY accelerate DESC LIMIT 1;",
            "SELECT T1.Horsepower FROM cars_data AS T1 ORDER BY T1.Accelerate DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "156": {
        "db_id": "car_1",
        "question": "What is the horsepower of the car with the greatest accelerate?",
        "ground_truth": "SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;",
        "amends": [
            "Do qualify the column reference as `T1.horsepower` instead of the unqualified `horsepower`, and do add the table alias `T1` in the `FROM` clause instead of omitting it, specifying `CARS_DATA AS T1` instead of just `cars`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT horsepower FROM cars ORDER BY accelerate DESC LIMIT 1;",
            "SELECT T1.horsepower FROM cars_data AS T1 ORDER BY T1.Accelerate DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "157": {
        "db_id": "car_1",
        "question": "For model volvo, how many cylinders does the car with the least accelerate have?",
        "ground_truth": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;",
        "amends": [
            "Do add `CAR_NAMES AS T2` table with `JOIN` instead of querying only `cars` table. Do use `ON T1.Id = T2.MakeId` join condition instead of no join. Do reference `T2.Model` in the WHERE filter instead of `model`. Do qualify columns with table aliases `T1.cylinders` and `T1.accelerate` instead of unqualified column names. The amended query now correctly joins the necessary tables to access the model information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cylinders FROM cars WHERE model = 'volvo' ORDER BY accelerate ASC LIMIT 1;",
            "SELECT T1.Cylinders \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T2.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "158": {
        "db_id": "car_1",
        "question": "For a volvo model, how many cylinders does the version with least accelerate have?",
        "ground_truth": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;",
        "amends": [
            "Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do filter on `T2.Model = 'volvo'` instead of `make = 'Volvo'`. Do reference `T1.cylinders` and `T1.accelerate` with table aliases instead of unqualified column names. The amended query now correctly joins the necessary tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cylinders FROM cars WHERE make = 'Volvo' ORDER BY accelerate ASC LIMIT 1;",
            "SELECT T1.Cylinders \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T2.Model = 'volvo'\nORDER BY T1.Accelerate ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "159": {
        "db_id": "car_1",
        "question": "How many cars have a larger accelerate than the car with the largest horsepower?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );",
        "amends": [
            "Do reference the correct table name `CARS_DATA` instead of `cars` in both the main query and subquery. Do use the column `Accelerate` instead of `horsepower` in the WHERE filter condition. Do change the subquery logic to select `Accelerate` ordered by `Horsepower DESC` with `LIMIT 1` instead of using `MAX(horsepower)` aggregate function. The amended query now correctly counts records where acceleration exceeds the acceleration value from the car with the highest horsepower, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cars \nWHERE accelerate > (SELECT MAX(horsepower) FROM cars);",
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY Horsepower DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "160": {
        "db_id": "car_1",
        "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );",
        "amends": [
            "Do reference the correct table name `CARS_DATA` instead of `cars`. Do use the column `Accelerate` in the outer query filter instead of `accelerate`. Do change the subquery to select `Accelerate` instead of `MAX(horsepower)` and use `ORDER BY Horsepower DESC LIMIT 1` instead of an aggregate function to find the maximum value. The amended query now correctly counts records where acceleration exceeds the acceleration value from the car with the highest horsepower, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cars \nWHERE accelerate > (SELECT MAX(horsepower) FROM cars)",
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY Horsepower DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "161": {
        "db_id": "car_1",
        "question": "How many countries has more than 2 car makers ?",
        "ground_truth": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2",
        "amends": [
            "Do join `car_makers` as `t2` on `t1.countryid=t2.country` instead of querying only the `countries` table. Do add `GROUP BY t1.countryid` instead of aggregating without grouping. Do move the count filter to `HAVING count(*) > 2` instead of using `WHERE car_makers > 2` which incorrectly references a column that doesn't exist in the countries table. The amended query now correctly counts car makers per country and filters for countries with more than 2 car makers, matching the intended behavior.",
            "Do remove the subquery wrapper instead of keeping it, as the outer COUNT(*) was incorrectly counting the grouped rows rather than the actual country count. Do maintain the same `JOIN` on `t1.CountryId=t2.Country` instead of changing it. Do preserve the `GROUP BY t1.CountryId` and `HAVING COUNT(*) > 2` clauses instead of modifying them. The amended query now correctly counts countries with more than 2 car makers by eliminating the redundant subquery structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE car_makers > 2;",
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)",
            "SELECT COUNT(*) \nFROM countries t1 \nJOIN car_makers t2 ON t1.CountryId = t2.Country \nGROUP BY t1.CountryId \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "162": {
        "db_id": "car_1",
        "question": "What is the number of countries with more than 2 car makers ?",
        "ground_truth": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2",
        "amends": [
            "Do join `car_makers` as `t2` on `t1.countryid = t2.country` instead of querying only the `countries` table. Do add `GROUP BY t1.countryid` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 2` instead of using `WHERE car_makers > 2` which incorrectly references a column name rather than an aggregate result. The amended query now correctly counts car makers per country and filters for countries with more than 2 car makers, matching the intended behavior.",
            "Do remove the subquery wrapper instead of keeping it, as the outer `COUNT(*)` over the grouped results was incorrectly counting groups rather than individual countries. Do maintain the `JOIN` between `countries` and `car_makers` on `t1.CountryId = t2.Country` instead of changing the join condition. Do preserve the `GROUP BY t1.CountryId` and `HAVING COUNT(*) > 2` to filter for countries with more than two car makers, instead of altering the grouping or filtering logic. The amended query now correctly counts the number of countries that have more than two associated car makers, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE car_makers > 2;",
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId \n    FROM countries t1 \n    JOIN car_makers t2 ON t1.CountryId = t2.Country \n    GROUP BY t1.CountryId \n    HAVING COUNT(*) > 2\n)",
            "SELECT COUNT(*) \nFROM countries t1 \nJOIN car_makers t2 ON t1.CountryId = t2.Country \nGROUP BY t1.CountryId \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "163": {
        "db_id": "car_1",
        "question": "How many cars has over 6 cylinders?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` and do filter on `Cylinders > 6` instead of `cylinders <= 6`, changing both the table name and the filter condition to count vehicles with more than six cylinders rather than those with six or fewer. The amended query now correctly counts records from the CARS_DATA table where the Cylinders value exceeds six, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 6;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ],
        "rule_sql": []
    },
    "164": {
        "db_id": "car_1",
        "question": "What is the number of carsw ith over 6 cylinders?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;",
        "amends": [
            "Do reference the `CARS_DATA` table instead of the `cars` table. Do use the correct column name `Cylinders` instead of `cylinders`. The amended query now correctly counts records from the CARS_DATA table where the Cylinders value exceeds 6, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders > 6;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 6"
        ],
        "rule_sql": []
    },
    "165": {
        "db_id": "car_1",
        "question": "For the cars with 4 cylinders, which model has the largest horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of `model` from the `cars` table. Do join `CARS_DATA AS T2` with `ON T1.MakeId = T2.Id` instead of querying a single table. Do use `T2.Cylinders = 4` as the filter instead of `cylinders = 4`. Do order by `T2.horsepower DESC` instead of `horsepower ASC`. The amended query now correctly joins the car names with their corresponding data and sorts by descending horsepower to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE cylinders = 4 ORDER BY horsepower ASC LIMIT 1;",
            "SELECT T1.Model \nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY T2.Horsepower DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "166": {
        "db_id": "car_1",
        "question": "For all of the 4 cylinder cars, which model has the most horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` instead of `model, MAX(horsepower)` and remove the aggregate function. Do use `FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2` instead of `FROM cars` and add the required table join. Do specify `ON T1.MakeId = T2.Id` instead of omitting the join condition. Do move the filter to `WHERE T2.Cylinders = 4` instead of keeping it in WHERE but change the table reference. Do remove `GROUP BY model` since no aggregation is needed. Do order by `T2.horsepower DESC` instead of `MAX(horsepower) DESC` to use the direct column value. The amended query now correctly retrieves the model with the highest horsepower among 4-cylinder cars by properly joining the necessary tables and eliminating the unnecessary aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model, MAX(horsepower) FROM cars WHERE cylinders = 4 GROUP BY model ORDER BY MAX(horsepower) DESC LIMIT 1;",
            "SELECT T1.Model\nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY T2.Horsepower DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "167": {
        "db_id": "car_1",
        "question": "Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.",
        "ground_truth": "SELECT T2.MakeId ,  T2.Make FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Horsepower  >  (SELECT min(Horsepower) FROM CARS_DATA) AND T1.Cylinders  <=  3;",
        "amends": [
            "Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do reference columns with table aliases `T1.Horsepower` and `T1.Cylinders` instead of unqualified column names. Do use the correct table name `CARS_DATA AS T1` instead of `cars`. Do include the `Make` column instead of `make_name`. The amended query now correctly joins the data and names tables with proper column references, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT makeid, make_name \nFROM cars \nWHERE horsepower > (SELECT MIN(horsepower) FROM cars) \nAND cylinders <= 3;",
            "SELECT T2.MakeId, T2.Make \nFROM CARS_DATA AS T1 \nJOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId \nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM CARS_DATA) \nAND T1.Cylinders <= 3"
        ],
        "rule_sql": []
    },
    "168": {
        "db_id": "car_1",
        "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?",
        "ground_truth": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;",
        "amends": [
            "Do select `makeid` and `make` from `car_names` instead of `make_id` and `name` from `cars`. Do join `cars_data` with `car_names` on `t1.id=t2.makeid` instead of querying a single table. Do filter on `horsepower > (subquery)` instead of `horsepower != (subquery)`. Do keep the `cylinders < 4` filter but apply it to `cars_data` instead of the original table. Do use table aliases `t1` and `t2` instead of no aliases. The amended query now correctly joins the two tables and uses the proper inequality comparison to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT make_id, name FROM cars WHERE cylinders < 4 AND horsepower != (SELECT MIN(horsepower) FROM cars);",
            "SELECT t2.MakeId, t2.Make \nFROM cars_data t1 \nJOIN car_names t2 ON t1.Id = t2.MakeId \nWHERE t1.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) \nAND t1.Cylinders < 4"
        ],
        "rule_sql": []
    },
    "169": {
        "db_id": "car_1",
        "question": "What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?",
        "ground_truth": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to ensure querying the correct data source. The amended query now matches RIGHT_SQL's behavior by using the proper table name while maintaining the same aggregation and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(mpg) FROM cars WHERE cylinders = 8 OR year < 1980;",
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ],
        "rule_sql": []
    },
    "170": {
        "db_id": "car_1",
        "question": "What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980 ?",
        "ground_truth": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to ensure querying the correct data source. The amended query now correctly accesses the intended table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(mpg) FROM cars WHERE cylinders = 8 OR year < 1980;",
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ],
        "rule_sql": []
    },
    "171": {
        "db_id": "car_1",
        "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';",
        "amends": [
            "Do use `DISTINCT T1.model` instead of `model` without distinct. Do join `MODEL_LIST AS T1`, `CAR_NAMES AS T2`, `CARS_DATA AS T3`, and `CAR_MAKERS AS T4` instead of querying only `cars`. Do use `ON T1.Model = T2.Model` and `ON T2.MakeId = T3.Id` and `ON T1.Maker = T4.Id` instead of no join conditions. Do filter with `T3.weight < 3500` instead of `weight < 3500`. Do use `T4.FullName != 'Ford Motor Company'` instead of `manufacturer = 'Ford Motor Company'` to exclude rather than include Ford vehicles. The amended query now correctly identifies distinct car models under 3500 pounds from manufacturers other than Ford Motor Company."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < 3500 AND manufacturer = 'Ford Motor Company';",
            "SELECT DISTINCT T1.Model\nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nJOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company'"
        ],
        "rule_sql": []
    },
    "172": {
        "db_id": "car_1",
        "question": "What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';",
        "amends": [
            "Do use `DISTINCT T1.model` instead of just `model` to eliminate duplicates. Do join `MODEL_LIST AS T1`, `CAR_NAMES AS T2`, `CARS_DATA AS T3`, and `CAR_MAKERS AS T4` instead of querying only the `cars` table. Do use `JOIN CAR_NAMES AS T2 ON T1.Model = T2.Model` instead of no join condition. Do use `JOIN CARS_DATA AS T3 ON T2.MakeId = T3.Id` instead of no relationship. Do use `JOIN CAR_MAKERS AS T4 ON T1.Maker = T4.Id` instead of no manufacturer join. Do filter on `T3.weight < 3500` instead of just `weight < 3500` to reference the correct table. Do filter on `T4.FullName != 'Ford Motor Company'` instead of `manufacturer != 'Ford Motor Company'` to use the proper column name. The amended query now correctly joins multiple tables to establish proper relationships and returns distinct model names from the appropriate source table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < 3500 AND manufacturer != 'Ford Motor Company';",
            "SELECT DISTINCT T1.Model \nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nJOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500 \nAND T4.FullName != 'Ford Motor Company'"
        ],
        "rule_sql": []
    },
    "173": {
        "db_id": "car_1",
        "question": "What are the name of the countries where there is not a single car maker?",
        "ground_truth": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "amends": [
            "Do reference `CountryName` instead of `name` in the SELECT list. Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add table alias `T1` for the countries table instead of omitting it. Do join `countries AS T1` with `CAR_MAKERS AS T2` instead of using a subquery. Do use join condition `T1.countryId = T2.Country` instead of filtering by `country_id NOT IN`. Do remove the DISTINCT keyword from the subquery since EXCEPT handles deduplication automatically. The amended query now correctly identifies countries without car makers by using a proper join and set operation instead of a potentially problematic NOT IN subquery with NULL values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE country_id NOT IN (SELECT DISTINCT country_id FROM car_makers);",
            "SELECT T1.CountryName\nFROM countries AS T1\nEXCEPT\nSELECT T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country"
        ],
        "rule_sql": []
    },
    "174": {
        "db_id": "car_1",
        "question": "What are the names of the countries with no car makers?",
        "ground_truth": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `CountryName` instead of `name` in the SELECT list. Do add an explicit table alias `T1` for the countries table instead of using it without alias. Do include a `JOIN` between `countries AS T1` and `CAR_MAKERS AS T2` with the predicate `ON T1.countryId = T2.Country` instead of the subquery correlation. Do remove the `WHERE` clause with subquery entirely instead of keeping it. The amended query now correctly uses set semantics to find countries without car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE country_id NOT IN (SELECT country_id FROM car_makers);",
            "SELECT T1.CountryName\nFROM countries AS T1\nLEFT JOIN car_makers AS T2 ON T1.CountryId = T2.Country\nWHERE T2.Country IS NULL"
        ],
        "rule_sql": []
    },
    "175": {
        "db_id": "car_1",
        "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .",
        "ground_truth": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;",
        "amends": [
            "Do add `JOIN model_list as t2 on t1.id = t2.maker` instead of querying `car_makers` alone. Do change the filter to use `GROUP BY t1.id HAVING count(*) >= 2` instead of `WHERE models >= 2`. Do add a second query with `INTERSECT` that includes `JOIN car_names as t3 on t2.model = t3.model` and `HAVING count(*) > 3` instead of the incorrect `car_makers > 3` condition. Do use proper table aliases `t1` for `car_makers` instead of direct table references. The amended query now correctly finds car makers with at least 2 models and more than 3 car names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, maker FROM car_makers WHERE models >= 2 AND car_makers > 3;",
            "SELECT t1.Id, t1.Maker\nFROM car_makers t1\nJOIN model_list t2 ON t1.Id = t2.Maker\nGROUP BY t1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT t1.Id, t1.Maker\nFROM car_makers t1\nJOIN model_list t2 ON t1.Id = t2.Maker\nJOIN car_names t3 ON t2.Model = t3.Model\nGROUP BY t1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "176": {
        "db_id": "car_1",
        "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?",
        "ground_truth": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do use `SELECT T1.Id, T1.Maker` instead of `SELECT maker, COUNT(*) as model_count`. Do join `MODEL_LIST AS T2` on `T1.Id = T2.Maker` instead of querying only `car_makers`. Do remove the `WHERE` clause and instead use `HAVING count(*) >= 2` after grouping by `T1.Id`. Do add a second query with `INTERSECT` that joins `CAR_NAMES AS T3` on `T2.model = T3.model` and uses `HAVING count(*) > 3` instead of the incorrect `cars_produced > 3` filter. Do use proper table aliases `T1`, `T2`, and `T3` instead of bare table names. The amended query now correctly finds makers with at least 2 models and more than 3 cars produced by using intersection of two properly joined queries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, COUNT(*) as model_count FROM car_makers WHERE model_count >= 2 AND cars_produced > 3 GROUP BY maker",
            "SELECT T1.Id, T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": []
    },
    "177": {
        "db_id": "car_1",
        "question": "What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?",
        "ground_truth": "SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.countryId HAVING count(*)  >  3 UNION SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country JOIN MODEL_LIST AS T3 ON T2.Id  =  T3.Maker WHERE T3.Model  =  'fiat';",
        "amends": [
            "Do use explicit column references `T1.countryId` and `T1.CountryName` with table aliases instead of ambiguous `id` and `name`. Do join `CAR_MAKERS AS T2` on `T1.CountryId = T2.Country` instead of filtering on non-existent `car_makers` column. Do add `GROUP BY T1.countryId` and move the count condition to `HAVING count(*) > 3` instead of using `car_makers > 3`. Do add a second query with `UNION` that joins `MODEL_LIST AS T3` on `T2.Id = T3.Maker` with filter `T3.Model = 'fiat'` instead of the incorrect `model = 'fiat'` condition. The amended query now correctly finds countries with more than 3 car makers or containing the Fiat model, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM countries WHERE car_makers > 3 OR model = 'fiat';",
            "SELECT T1.CountryId, T1.CountryName \nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ],
        "rule_sql": []
    },
    "178": {
        "db_id": "car_1",
        "question": "What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?",
        "ground_truth": "select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  3 union select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country join model_list as t3 on t2.id  =  t3.maker where t3.model  =  'fiat';",
        "amends": [
            "Do join `car_makers as t2` on `t1.countryid = t2.country` instead of querying `countries` table alone. Do add `GROUP BY t1.countryid` and move the count filter to `HAVING count(*) > 3` instead of using `WHERE car_makers_count > 3`. Do add a second query with `UNION` that joins `model_list as t3` on `t2.id = t3.maker` with filter `t3.model = 'fiat'` instead of the simple `OR model = 'fiat'` condition. Do use explicit table aliases `t1.countryid` and `t1.countryname` instead of bare column names `id` and `name`. The amended query now correctly counts car makers per country and handles the Fiat model condition through proper table joins and union operation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM countries WHERE car_makers_count > 3 OR model = 'fiat'",
            "SELECT t1.CountryId, t1.CountryName\nFROM countries t1\nJOIN car_makers t2 ON t1.CountryId = t2.Country\nGROUP BY t1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT t1.CountryId, t1.CountryName\nFROM countries t1\nJOIN car_makers t2 ON t1.CountryId = t2.Country\nJOIN model_list t3 ON t2.Id = t3.Maker\nWHERE t3.Model = 'fiat'"
        ],
        "rule_sql": []
    },
    "179": {
        "db_id": "flight_2",
        "question": "Which country does Airline \"JetBlue Airways\" belong to?",
        "ground_truth": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the `Country` column instead of `country` to match the correct case sensitivity. Do reference the `Airline` column instead of `name` to use the proper column name for airline identification. Do use double quotes `\"JetBlue Airways\"` instead of single quotes `'JetBlue Airways'` for string literal formatting. The amended query now correctly retrieves the country information for JetBlue Airways by using the appropriate column names and string formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name = 'JetBlue Airways';",
            "SELECT Country FROM airlines WHERE Airline = \"JetBlue Airways\";"
        ],
        "rule_sql": []
    },
    "180": {
        "db_id": "flight_2",
        "question": "What country is Jetblue Airways affiliated with?",
        "ground_truth": "SELECT Country FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the column `Country` instead of `country` to match the correct case sensitivity. Do reference the column `Airline` instead of `name` to use the proper column name for airline identification. Do use the exact string value `\"JetBlue Airways\"` instead of `'Jetblue Airways'` to match the correct capitalization and spelling. Do reference the table `AIRLINES` instead of `airlines` to maintain consistent uppercase table naming convention. The amended query now correctly retrieves the country for the specified airline with proper column references and exact string matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM airlines WHERE name = 'Jetblue Airways';",
            "SELECT Country FROM AIRLINES WHERE Airline = 'JetBlue Airways';"
        ],
        "rule_sql": []
    },
    "181": {
        "db_id": "flight_2",
        "question": "What is the abbreviation of Airline \"JetBlue Airways\"?",
        "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the column `Abbreviation` instead of `abbreviation` to match the correct case sensitivity. Do reference the table `AIRLINES` instead of `Airlines` to match the correct table name case. Do use the filter condition `Airline = \"JetBlue Airways\"` instead of `name = 'JetBlue Airways'` to reference the correct column name and use double quotes instead of single quotes for the string literal. The amended query now correctly retrieves the abbreviation for JetBlue Airways by using the proper column and table names with appropriate case sensitivity and string quoting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT abbreviation FROM Airlines WHERE name = 'JetBlue Airways';",
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\""
        ],
        "rule_sql": []
    },
    "182": {
        "db_id": "flight_2",
        "question": "Which abbreviation corresponds to Jetblue Airways?",
        "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference column `Abbreviation` instead of `abbreviation` to match the correct case sensitivity. Do reference column `Airline` instead of `name` to use the proper column name for airline identification. Do reference table `AIRLINES` instead of `airlines` to maintain consistent uppercase naming convention. Do use double quotes `\"JetBlue Airways\"` instead of single quotes for string literal consistency. The amended query now correctly retrieves the abbreviation by matching the airline name in the appropriate column with proper case handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT abbreviation FROM airlines WHERE name = 'JetBlue Airways';",
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ],
        "rule_sql": []
    },
    "183": {
        "db_id": "flight_2",
        "question": "List all airline names and their abbreviations in \"USA\".",
        "ground_truth": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use column aliases `Airline` and `Abbreviation` instead of the original column names `name` and `abbreviation`. Do reference the table name `AIRLINES` in uppercase instead of lowercase `airlines`. Do use double quotes `\"USA\"` for the string literal instead of single quotes `'USA'`. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining the same logical result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, abbreviation FROM airlines WHERE country = 'USA';",
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": []
    },
    "184": {
        "db_id": "flight_2",
        "question": "What are the airline names and abbreviations for airlines in the USA?",
        "ground_truth": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use column aliases `Airline` and `Abbreviation` instead of the original column names `airline_name` and `abbreviation`. Do reference the table as `AIRLINES` instead of `airlines`. Do filter with country value `\"USA\"` instead of `'United States'` to match the correct country code format. The amended query now correctly retrieves US airlines using the standardized country code and proper column naming conventions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_name, abbreviation FROM airlines WHERE country = 'United States';",
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = 'USA';"
        ],
        "rule_sql": []
    },
    "185": {
        "db_id": "flight_2",
        "question": "List the airport code and name in the city of Anthony.",
        "ground_truth": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"",
        "amends": [
            "Do use `AirportCode` and `AirportName` column names instead of `airport_code` and `airport_name` to match the actual schema. Do use double quotes `\"Anthony\"` for the string literal instead of single quotes `'Anthony'` to maintain proper string formatting. The amended query now correctly retrieves airport information for the specified city while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code, airport_name FROM airports WHERE city = 'Anthony';",
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ],
        "rule_sql": []
    },
    "186": {
        "db_id": "flight_2",
        "question": "Give the airport code and airport name corresonding to the city Anthony.",
        "ground_truth": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"",
        "amends": [
            "Do use `AirportCode` and `AirportName` column names instead of `airport_code` and `airport_name` to match the actual schema. Do use double quotes `\"Anthony\"` for the string literal instead of single quotes `'Anthony'` to maintain proper string formatting. The amended query now correctly retrieves airport information for the specified city while using the proper column names and string syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code, airport_name FROM airports WHERE city = 'Anthony';",
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ],
        "rule_sql": []
    },
    "187": {
        "db_id": "flight_2",
        "question": "How many airlines do we have?",
        "ground_truth": "SELECT count(*) FROM AIRLINES",
        "amends": [
            "Do reference the `AIRLINES` table instead of the `flights` table in the FROM clause. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the AIRLINES table instead of flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT count(*) FROM airlines;"
        ],
        "rule_sql": []
    },
    "188": {
        "db_id": "flight_2",
        "question": "What is the total number of airlines?",
        "ground_truth": "SELECT count(*) FROM AIRLINES",
        "amends": [
            "Do query the `AIRLINES` table instead of the `flights` table. The amended query now correctly counts records from the AIRLINES table as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT COUNT(*) FROM airlines;"
        ],
        "rule_sql": []
    },
    "189": {
        "db_id": "flight_2",
        "question": "How many airports do we have?",
        "ground_truth": "SELECT count(*) FROM AIRPORTS",
        "amends": [
            "Do use the table name `AIRPORTS` instead of `airports` to match the correct case sensitivity, though this may be a cosmetic difference depending on database configuration. Do maintain the identical `COUNT(*)` aggregation and `WHERE country = 'USA'` filter without any changes to the SELECT list, FROM clause, WHERE conditions, or other query components. The amended query now matches RIGHT_SQL's behavior with proper table name casing.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches RIGHT_SQL's behavior with identical functionality.",
            "Do include all airports without any country filter instead of filtering for `country = 'USA'`. The amended query now matches RIGHT_SQL's behavior by counting all records in the AIRPORTS table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE country = 'USA';",
            "SELECT COUNT(*) FROM AIRPORTS WHERE country = 'USA';",
            "SELECT count(*) FROM AIRPORTS WHERE country = 'USA'",
            "SELECT count(*) FROM AIRPORTS"
        ],
        "rule_sql": []
    },
    "190": {
        "db_id": "flight_2",
        "question": "Return the number of  airports.",
        "ground_truth": "SELECT count(*) FROM AIRPORTS",
        "amends": [
            "Do query the `AIRPORTS` table instead of the `flights` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the correct query's formatting. The amended query now correctly counts records from the AIRPORTS table instead of flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights;",
            "SELECT count(*) FROM airports;"
        ],
        "rule_sql": []
    },
    "191": {
        "db_id": "flight_2",
        "question": "How many flights do we have?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS",
        "amends": [
            "Do query the `FLIGHTS` table instead of the `passengers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the FLIGHTS table instead of the passengers table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT count(*) FROM flights;"
        ],
        "rule_sql": []
    },
    "192": {
        "db_id": "flight_2",
        "question": "Return the number of flights.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS",
        "amends": [
            "Do query the `FLIGHTS` table instead of the `passengers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency, though this is purely cosmetic. The amended query now correctly counts records from the FLIGHTS table instead of the passengers table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT count(*) FROM flights"
        ],
        "rule_sql": []
    },
    "193": {
        "db_id": "flight_2",
        "question": "Which airline has abbreviation 'UAL'?",
        "ground_truth": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"",
        "amends": [
            "Do use the exact column name `Airline` instead of `name` to match the correct schema. Do use the exact table name `AIRLINES` instead of `airlines` to match the correct case sensitivity. Do use double quotes `\"UAL\"` instead of single quotes `'UAL'` for the string literal while maintaining the same filter condition. The amended query now correctly retrieves the airline name using the proper column and table identifiers while preserving the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airlines WHERE abbreviation = 'UAL';",
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ],
        "rule_sql": []
    },
    "194": {
        "db_id": "flight_2",
        "question": "Give the airline with abbreviation 'UAL'.",
        "ground_truth": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"",
        "amends": [
            "Do specify `Airline` column instead of `*` wildcard in the SELECT list. Do use table name `AIRLINES` instead of `airlines` with proper casing. Do use double quotes `\"UAL\"` instead of single quotes `'UAL'` for the string literal. Do maintain the same WHERE filter condition on `Abbreviation` column with proper casing instead of lowercase `abbreviation`. The amended query now correctly returns only the Airline column for United Airlines instead of all columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM airlines WHERE abbreviation = 'UAL';",
            "SELECT Airline FROM AIRLINES WHERE Abbreviation = \"UAL\""
        ],
        "rule_sql": []
    },
    "195": {
        "db_id": "flight_2",
        "question": "How many airlines are from USA?",
        "ground_truth": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent lowercase function naming. Do reference table `AIRLINES` instead of `airlines` to match the correct table name case. Do filter on `Country = \"USA\"` instead of `country = 'United States'` to use the correct column name case and proper country code value with double quotes instead of single quotes. The amended query now correctly counts airlines from the United States using the standardized country code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'United States';",
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": []
    },
    "196": {
        "db_id": "flight_2",
        "question": "Return the number of airlines in the USA.",
        "ground_truth": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent lowercase function naming. Do reference table `AIRLINES` instead of `airlines` to match the actual table name case. Do filter on `Country = \"USA\"` instead of `country = 'United States'` to use the correct column name with proper capitalization and the standardized country code value instead of the full country name. The amended query now correctly counts airlines from the United States using the proper country code identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'United States';",
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": []
    },
    "197": {
        "db_id": "flight_2",
        "question": "Which city and country is the Alton airport at?",
        "ground_truth": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
        "amends": [
            "Do use column aliases `City` and `Country` instead of the original column names `city` and `country`. Do reference the correct column name `AirportName` in the WHERE filter instead of `name`. Do use double quotes for the string literal \"Alton\" instead of single quotes. The amended query now correctly filters for airports with the specific name \"Alton\" and returns the properly aliased city and country columns, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, country FROM airports WHERE name = 'Alton';",
            "SELECT City AS City, Country AS Country FROM airports WHERE AirportName = \"Alton\""
        ],
        "rule_sql": []
    },
    "198": {
        "db_id": "flight_2",
        "question": "Give the city and country for the Alton airport.",
        "ground_truth": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
        "amends": [
            "Do use column aliases `City` and `Country` instead of lowercase `city` and `country`. Do reference the column `AirportName` in the WHERE filter instead of `name`. Do use double quotes around the string literal \"Alton\" instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column names and string literal formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, country FROM airports WHERE name = 'Alton';",
            "SELECT City, Country FROM airports WHERE AirportName = \"Alton\""
        ],
        "rule_sql": []
    },
    "199": {
        "db_id": "flight_2",
        "question": "What is the airport name for airport 'AKO'?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
        "amends": [
            "Do select `AirportName` instead of `name` and filter on `AirportCode` instead of `code`. Do use double quotes `\"AKO\"` instead of single quotes `'AKO'` for the string literal. The amended query now correctly references the actual column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE code = 'AKO';",
            "SELECT AirportName FROM airports WHERE AirportCode = \"AKO\""
        ],
        "rule_sql": []
    },
    "200": {
        "db_id": "flight_2",
        "question": "Return the name of the airport with code 'AKO'.",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
        "amends": [
            "Do select `AirportName` instead of `name` and filter on `AirportCode = \"AKO\"` instead of `code = 'DEN'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE code = 'DEN';",
            "SELECT AirportName FROM airports WHERE AirportCode = 'AKO';"
        ],
        "rule_sql": []
    },
    "201": {
        "db_id": "flight_2",
        "question": "What are airport names at City 'Aberdeen'?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"",
        "amends": [
            "Do reference `AirportName` instead of `name` in the SELECT list. Do reference `City` instead of `city` in the WHERE filter. Do use double quotes around 'Aberdeen' instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column naming and string literal formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Aberdeen';",
            "SELECT AirportName FROM airports WHERE City = \"Aberdeen\""
        ],
        "rule_sql": []
    },
    "202": {
        "db_id": "flight_2",
        "question": "What are the names of airports in Aberdeen?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"",
        "amends": [
            "Do reference the column as `AirportName` instead of `name` and use double quotes around the string literal `\"Aberdeen\"` instead of single quotes, while also changing the table reference to uppercase `AIRPORTS` and the column reference to `City` instead of `city`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column naming and string literal formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Aberdeen';",
            "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\";"
        ],
        "rule_sql": []
    },
    "203": {
        "db_id": "flight_2",
        "question": "How many flights depart from 'APG'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference `SourceAirport` instead of `arrival_airport` in the WHERE filter, and use double quotes instead of single quotes for the string literal value 'APG'. The amended query now correctly counts flights departing from APG airport instead of arriving at APG, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE arrival_airport = 'APG';",
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": []
    },
    "204": {
        "db_id": "flight_2",
        "question": "Count the number of flights departing from 'APG'.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference `SourceAirport` column instead of `destination` column in the WHERE filter. Do use double quotes around the literal value \"APG\" instead of single quotes. Do maintain the same aggregate function `count(*)` and table source `FLIGHTS` while correcting the column reference to match the intended logic of counting flights departing from APG rather than arriving at APG, ensuring the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'APG';",
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": []
    },
    "205": {
        "db_id": "flight_2",
        "question": "How many flights have destination ATO?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
        "amends": [
            "Do reference the column as `DestAirport` instead of `destination` to match the correct column name in the schema. Do use double quotes `\"ATO\"` instead of single quotes `'ATO'` for the string literal value. Do maintain the same aggregate function `count(*)` and table reference `FLIGHTS` while correcting the column reference and string formatting. The amended query now correctly counts flights where the destination airport code matches ATO, matching the behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'ATO';",
            "SELECT COUNT(*) FROM flights WHERE DestAirport = \"ATO\";"
        ],
        "rule_sql": []
    },
    "206": {
        "db_id": "flight_2",
        "question": "Count the number of flights into ATO.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
        "amends": [
            "Do use the correct column name `DestAirport` instead of `destination` to match the actual schema. Do use consistent case handling with uppercase `FLIGHTS` instead of lowercase `flights` for the table name. Do use double quotes `\"ATO\"` instead of single quotes `'ATO'` for the string literal while maintaining the same filter condition. The amended query now correctly counts flights with destination airport code ATO using the proper column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'ATO';",
            "SELECT COUNT(*) FROM FLIGHTS WHERE DestAirport = \"ATO\""
        ],
        "rule_sql": []
    },
    "207": {
        "db_id": "flight_2",
        "question": "How many flights depart from City Aberdeen?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since the city information is stored in the airports table rather than directly in flights. Do use proper table aliases `T1` and `T2` instead of referencing tables directly without aliases. The amended query now correctly joins the flights and airports tables to find flights departing from Aberdeen by matching airport codes rather than relying on a non-existent departure_city column, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "208": {
        "db_id": "flight_2",
        "question": "Return the number of flights departing from Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since the city information is stored in the airports table rather than directly in flights. Do use table alias `T1` for flights and `T2` for airports instead of referencing tables without aliases. The amended query now correctly joins the flights and airports tables to count flights departing from Aberdeen by matching airport codes and filtering on the city name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "209": {
        "db_id": "flight_2",
        "question": "How many flights arriving in Aberdeen city?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `FLIGHTS AS T1` with `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do filter on `T2.City = \"Aberdeen\"` instead of filtering directly on `departure_city = 'Aberdeen'` to correctly identify flights departing from Aberdeen by joining with the airports table. Do use the `JOIN` operation to properly correlate flight destination airports with their corresponding city information instead of relying on a potentially incorrect or non-existent `departure_city` column. The amended query now correctly counts flights with destinations in Aberdeen by properly joining the flights and airports tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "210": {
        "db_id": "flight_2",
        "question": "Return the number of flights arriving in Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `FLIGHTS` with `AIRPORTS` on `DestAirport = AirportCode` instead of querying `flights` alone. Do filter on `City = \"Aberdeen\"` instead of filtering directly on `departure_airport = 'Aberdeen'`. Do use proper table aliases `T1` and `T2` instead of omitting them. The amended query now correctly counts flights destined for Aberdeen by joining with the airports table to match on city name rather than assuming airport codes contain the city name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_airport = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "211": {
        "db_id": "flight_2",
        "question": "How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` and `AIRPORTS AS T3` on `T1.SourceAirport = T3.AirportCode` instead of querying `flights` directly without joins. Do filter on `T2.City = \"Ashley\"` and `T3.City = \"Aberdeen\"` instead of filtering directly on `departure_city = 'Aberdeen'` and `arrival_city = 'Ashley'`. Do use proper table aliases `T1`, `T2`, and `T3` instead of referencing base tables without aliases. The amended query now correctly joins through the airports table to match city names instead of assuming city names are stored directly in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen' AND arrival_city = 'Ashley';",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ],
        "rule_sql": []
    },
    "212": {
        "db_id": "flight_2",
        "question": "How many flights fly from Aberdeen to Ashley?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` and `AIRPORTS AS T3` on `T1.SourceAirport = T3.AirportCode` instead of querying `flights` directly without joins. Do filter on `T2.City = \"Ashley\"` and `T3.City = \"Aberdeen\"` instead of filtering `departure_city = 'Aberdeen'` and `arrival_city = 'Ashley'` directly on the flights table. The amended query now correctly joins through the airports table to validate city names against airport codes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen' AND arrival_city = 'Ashley';",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ],
        "rule_sql": []
    },
    "213": {
        "db_id": "flight_2",
        "question": "How many flights does airline 'JetBlue Airways' have?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
        "amends": [
            "Do join `AIRLINES AS T2` instead of omitting it, and do use `ON T1.Airline = T2.uid` instead of filtering directly on `airline = 'JetBlue Airways'`. Do filter on `T2.Airline = \"JetBlue Airways\"` instead of directly filtering the flights table, which correctly uses the airlines reference table for accurate airline identification. The amended query now matches RIGHT_SQL's behavior by properly joining to the airlines table and filtering through the reference relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'JetBlue Airways';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
        ],
        "rule_sql": []
    },
    "214": {
        "db_id": "flight_2",
        "question": "Give the number of Jetblue Airways flights.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
        "amends": [
            "Do add a `JOIN` with `AIRLINES AS T2` on `T1.Airline = T2.uid` instead of querying only the `flights` table. Do filter on `T2.Airline = \"JetBlue Airways\"` instead of directly filtering `flights.airline = 'JetBlue Airways'` to properly reference the airline name through the joined relationship. Do use table alias `T1` for `FLIGHTS` instead of referencing the table directly without an alias. The amended query now correctly joins the airline reference table to filter by airline name rather than relying on potentially inconsistent airline identifiers in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'JetBlue Airways';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
        ],
        "rule_sql": []
    },
    "215": {
        "db_id": "flight_2",
        "question": "How many 'United Airlines' flights go to Airport 'ASY'?",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `T2.Airline = T1.uid` instead of filtering directly on airline name. Do reference `T1.Airline` for the airline name filter instead of `airline` column. Do use `T2.DestAirport` for destination filter instead of `destination` column. Do add proper table aliases `T1` and `T2` instead of using unqualified column names. The amended query now correctly joins the airline reference data with flight records using the proper foreign key relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination = 'ASY';",
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
        ],
        "rule_sql": []
    },
    "216": {
        "db_id": "flight_2",
        "question": "Count the number of United Airlines flights arriving in ASY Airport.",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `T2.Airline = T1.uid` instead of filtering directly on airline name. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'`. Do filter on `T2.DestAirport = \"ASY\"` instead of `departure_airport = 'ASY'`. The amended query now correctly joins the airline reference table and filters on destination airport instead of departure airport, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'ASY'",
            "SELECT COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = 'United Airlines' \nAND T2.DestAirport = 'ASY'"
        ],
        "rule_sql": []
    },
    "217": {
        "db_id": "flight_2",
        "question": "How many 'United Airlines' flights depart from Airport 'AHD'?",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do join `AIRLINES AS T1` and `FLIGHTS AS T2` instead of querying only the `flights` table. Do use `ON T2.Airline = T1.uid` for the join condition instead of missing the table relationship entirely. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'` to reference the correct table and column. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to use the proper column name and table reference. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins the airlines and flights tables to count United Airlines flights departing from AHD airport."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'AHD';",
            "SELECT COUNT(*) FROM airlines AS T1 JOIN flights AS T2 ON T2.Airline = T1.uid WHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": []
    },
    "218": {
        "db_id": "flight_2",
        "question": "Return the number of United Airlines flights leaving from AHD Airport.",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables with an `INNER JOIN` on `T2.Airline = T1.uid` instead of querying only the `flights` table. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'` to reference the correct table and column. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to use the proper column name and table reference. Do use double quotes for string literals instead of single quotes to match the database's expected format. The amended query now correctly joins the airline and flight data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'AHD'",
            "SELECT COUNT(*) \nFROM airlines T1 \nINNER JOIN flights T2 ON T2.Airline = T1.uid \nWHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": []
    },
    "219": {
        "db_id": "flight_2",
        "question": "How many United Airlines flights go to City 'Aberdeen'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRPORTS` as `T2` on `T1.DestAirport = T2.AirportCode` and `AIRLINES` as `T3` on `T3.uid = T1.Airline` instead of querying only the `flights` table. Do filter on `T2.City = \"Aberdeen\"` instead of `destination_city = 'Aberdeen'` and on `T3.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'`. The amended query now correctly joins related tables to validate airport cities and airline names through proper foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights T1 JOIN airports T2 ON T1.DestAirport = T2.AirportCode JOIN airlines T3 ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'"
        ],
        "rule_sql": []
    },
    "220": {
        "db_id": "flight_2",
        "question": "Count the number of United Airlines flights that arrive in Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
        "amends": [
            "Do add explicit joins to `AIRPORTS` and `AIRLINES` tables instead of querying only the `flights` table. Do join `AIRPORTS` on `DestAirport = AirportCode` instead of filtering directly on destination. Do join `AIRLINES` on `uid = Airline` instead of filtering directly on airline name. Do filter on `City = \"Aberdeen\"` through the joined airports table instead of filtering destination directly. Do filter on `Airline = \"United Airlines\"` through the joined airlines table instead of filtering airline directly. The amended query now correctly joins related tables to validate airport cities and airline names through proper foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination = 'Aberdeen';",
            "SELECT COUNT(*) \nFROM flights f\nJOIN airlines a ON f.Airline = a.uid\nJOIN airports ap ON f.DestAirport = ap.AirportCode\nWHERE a.Airline = 'United Airlines' AND ap.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "221": {
        "db_id": "flight_2",
        "question": "Which city has most number of arriving flights?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRPORTS` and `FLIGHTS` tables instead of querying only `flights` table. Do use `JOIN` with `AIRPORTS.AirportCode = FLIGHTS.DestAirport` instead of no join condition. Do select `T1.City` instead of `city`. Do group by `T1.City` instead of `city`. Do order by `count(*) DESC` instead of `flight_count ASC`. Do remove the alias `flight_count` instead of keeping it. The amended query now correctly identifies cities with airports by joining the appropriate tables and finds the city with the most destination flights instead of the fewest flights overall."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM flights GROUP BY city ORDER BY flight_count ASC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nGROUP BY a.City\nORDER BY flight_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "222": {
        "db_id": "flight_2",
        "question": "Which city has the most frequent destination airport?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `FLIGHTS` table on `AirportCode=DestAirport` instead of querying only the `airports` table. Do select `City` instead of both `city` and `flight_count`. Do aggregate by counting all flights per city instead of counting airports per city. Do order by the flight count in descending order instead of ordering by the airport count. The amended query now correctly identifies cities with the most flight destinations by joining airport data with flight records and counting actual flights rather than airport occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM airports GROUP BY city ORDER BY flight_count DESC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nGROUP BY a.City\nORDER BY flight_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "223": {
        "db_id": "flight_2",
        "question": "Which city has most number of departing flights?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRPORTS` and `FLIGHTS` tables on `AirportCode = SourceAirport` instead of querying only the `flights` table without proper table relationships. Do select `T1.City` from the joined tables instead of selecting `city` directly from a single table. Do group by `T1.City` instead of grouping by an unspecified `city` column. Do order by `count(*) DESC` to find the city with the most flights instead of ordering by `flight_count ASC` which would find the city with the fewest flights. Do remove the column alias `flight_count` since it's not referenced in the ORDER BY clause. The amended query now correctly identifies the city with the most departing flights by joining airport data with flight data and counting flights per city in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM flights GROUP BY city ORDER BY flight_count ASC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.SourceAirport = a.AirportCode\nGROUP BY a.City\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "224": {
        "db_id": "flight_2",
        "question": "Which city is the most frequent source airport?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2 ON T1.AirportCode = T2.SourceAirport` instead of querying only the airports table. Do change the FROM clause to include `AIRPORTS AS T1` instead of just `airports`. Do use `T1.City` in the SELECT list instead of just `city`. Do maintain the `GROUP BY T1.City` instead of `GROUP BY city`. Do keep `ORDER BY count(*) DESC LIMIT 1` unchanged. The amended query now correctly identifies cities with the most departing flights by joining airports with flights data instead of just counting airports per city, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM airports GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.City\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.SourceAirport\nGROUP BY T1.City\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "225": {
        "db_id": "flight_2",
        "question": "What is the code of airport that has the highest number of flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.AirportCode` from the `AIRPORTS` table instead of `airport_code` from `flights`. Do add a `JOIN` with `FLIGHTS AS T2` instead of querying only one table. Do use join conditions `T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of no join predicate. Do add `GROUP BY T1.AirportCode` to aggregate by airport instead of no grouping. Do order by `count(*) DESC` to rank airports by flight count instead of ordering by non-existent `flight_count`. The amended query now correctly identifies the airport with the most flights by counting both departures and arrivals."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code FROM flights ORDER BY flight_count DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "226": {
        "db_id": "flight_2",
        "question": "What is the airport code of the airport with the most flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN FLIGHTS` with `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of omitting the join entirely. Do change the `SELECT` list to `T1.AirportCode` with proper table alias instead of just `airport_code`. Do add `GROUP BY T1.AirportCode` instead of missing the grouping clause. Do change the `ORDER BY` to `count(*) DESC` instead of `COUNT(flights) DESC` which referenced a non-existent column. Do add table alias `T1` for `AIRPORTS` instead of using the table name directly. The amended query now correctly counts flights per airport by joining and grouping, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code FROM airports ORDER BY COUNT(flights) DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "227": {
        "db_id": "flight_2",
        "question": "What is the code of airport that has fewest number of flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do specify `T1.AirportCode` with table alias instead of just `code` without qualification. Do add `FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2` with explicit table aliases instead of omitting the join. Do use join condition `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of missing join predicates. Do add `GROUP BY T1.AirportCode` to aggregate by airport instead of omitting grouping. Do use `count(*)` to count all flights instead of `COUNT(flights.id)` which would only count non-null IDs. Do remove the explicit `ASC` since it's the default ordering instead of specifying it. The amended query now correctly counts flights for each airport (both as source and destination) and returns the airport with the fewest total flights."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT code FROM airports ORDER BY COUNT(flights.id) ASC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*)\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "228": {
        "db_id": "flight_2",
        "question": "Give the code of the airport with the least flights.",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do add a `JOIN` with `FLIGHTS` table instead of querying `airports` alone. Do change the `SELECT` list to `T1.AirportCode` instead of `airport_code`. Do add grouping by `T1.AirportCode` instead of no grouping. Do change the `ORDER BY` to `count(*)` instead of `flight_count DESC`. Do remove the explicit `DESC` ordering and instead use the default ascending order. Do add join conditions `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of no join conditions. The amended query now correctly counts flights per airport by joining with the flights table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code FROM airports ORDER BY flight_count DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "229": {
        "db_id": "flight_2",
        "question": "Which airline has most number of flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables with `JOIN` on `T1.uid = T2.Airline` instead of querying only `flights` without any table join. Do select `T1.Airline` instead of `airline` to reference the joined table explicitly. Do use `ORDER BY count(*) DESC` instead of `ORDER BY flight_count ASC` to sort by descending count rather than ascending. Do remove the alias `flight_count` from the SELECT clause instead of keeping it, as it's not needed in the ORDER BY. The amended query now correctly identifies airlines with their flight counts through proper table joining and returns the airline with the highest count rather than the lowest, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.Airline` instead of selecting both `T1.Airline` and `COUNT(*)` in the SELECT list. Do maintain the same `JOIN` on `T1.uid=T2.Airline` without changing the join type or predicate. Do keep the `GROUP BY T1.Airline` and `ORDER BY count(*) DESC LIMIT 1` unchanged. The amended query now correctly returns only the airline name with the highest flight count instead of both the airline and count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count FROM flights GROUP BY airline ORDER BY flight_count ASC LIMIT 1;",
            "SELECT T1.Airline, COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T1.uid = T2.Airline \nGROUP BY T1.Airline \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "230": {
        "db_id": "flight_2",
        "question": "What airline serves the most flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRLINES` as `T1` to `FLIGHTS` as `T2` on `T1.uid=T2.Airline` instead of querying only the `flights` table. Do select `T1.Airline` instead of `airline` from the flights table. Do order by `count(*) DESC` instead of `flight_count ASC` to find the airline with the most flights rather than the fewest. Do remove the explicit column alias `flight_count` instead of keeping it since the ORDER BY clause now uses the aggregate function directly. The amended query now correctly identifies the airline with the highest number of flights by joining to the airlines table and sorting in descending order, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.Airline` instead of selecting both `T1.Airline` and `COUNT(*)` in the SELECT list. Do maintain the same `JOIN` on `T1.uid=T2.Airline` instead of changing the join condition. Do keep the `GROUP BY T1.Airline` grouping instead of altering the grouping criteria. Do preserve the `ORDER BY count(*) DESC` ordering instead of modifying the sort direction. Do retain the `LIMIT 1` constraint instead of changing the row limit. The amended query now correctly returns only the airline name with the highest flight count instead of returning both the airline name and the count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count FROM flights GROUP BY airline ORDER BY flight_count ASC LIMIT 1;",
            "SELECT T1.Airline, COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T1.uid = T2.Airline \nGROUP BY T1.Airline \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "231": {
        "db_id": "flight_2",
        "question": "Find the abbreviation and country of the airline that has fewest number of flights?",
        "ground_truth": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do join `AIRLINES AS T1` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of omitting the join condition. Do group by `T1.Airline` instead of omitting grouping. Do order by `count(*)` instead of ordering by `COUNT(flights.id)` without grouping. Do reference columns with table aliases `T1.Abbreviation` and `T1.Country` instead of bare column names. The amended query now correctly aggregates flight counts per airline and returns the airline with the fewest flights, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT abbreviation, country FROM airlines ORDER BY COUNT(flights.id) ASC LIMIT 1;",
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "232": {
        "db_id": "flight_2",
        "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?",
        "ground_truth": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do `SELECT T1.Abbreviation, T1.Country` instead of `SELECT airline_abbreviation, country`. Do `FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid = T2.Airline` instead of `FROM airlines` without any join. Do add `GROUP BY T1.Airline` instead of omitting it. Do `ORDER BY count(*)` instead of `ORDER BY COUNT(flights)`. The amended query now correctly joins the airlines and flights tables, groups by airline, and counts flights to find the airline with the fewest flights, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_abbreviation, country FROM airlines ORDER BY COUNT(flights) ASC LIMIT 1;",
            "SELECT T1.Abbreviation, T1.Country\nFROM AIRLINES AS T1\nJOIN FLIGHTS AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY count(*)\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "233": {
        "db_id": "flight_2",
        "question": "What are airlines that have some flight departing from airport 'AHD'?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do select only `T1.Airline` instead of all columns with `*`. Do join `FLIGHTS AS T2` instead of querying only the `airlines` table. Do use `ON T1.uid = T2.Airline` for the join condition instead of no join. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'`. The amended query now correctly joins airlines with flights and filters by source airport instead of using a non-existent departure_airport column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM airlines WHERE departure_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'"
        ],
        "rule_sql": []
    },
    "234": {
        "db_id": "flight_2",
        "question": "Which airlines have a flight with source airport AHD?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2 ON T1.uid = T2.Airline` instead of querying only the airlines table. Do change the column selection to `T1.Airline` instead of `airline_name`. Do move the filter condition to `T2.SourceAirport = \"AHD\"` instead of `source_airport = 'AHD'` and use double quotes instead of single quotes for the string literal. Do add table alias `T1` for the airlines table instead of using it directly. The amended query now correctly joins the airlines and flights tables to find airlines operating from the specified source airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_name FROM airlines WHERE source_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": []
    },
    "235": {
        "db_id": "flight_2",
        "question": "What are airlines that have flights arriving at airport 'AHD'?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
        "amends": [
            "Do select `T1.Airline` from the `AIRLINES` table instead of `airline_name` from `flights`. Do join `AIRLINES AS T1` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do filter on `T2.DestAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to correctly identify destination airports rather than departure airports. The amended query now properly joins airline information with flight data and filters for the correct destination airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_name FROM flights WHERE departure_airport = 'AHD';",
            "SELECT T1.Airline \nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nWHERE T2.DestAirport = 'AHD'"
        ],
        "rule_sql": []
    },
    "236": {
        "db_id": "flight_2",
        "question": "Which airlines have a flight with destination airport AHD?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2` instead of querying only the `airlines` table. Do use `ON T1.uid = T2.Airline` instead of missing the join condition entirely. Do change the column selection to `T1.Airline` instead of `airline_name`. Do change the filter to `T2.DestAirport = \"AHD\"` instead of `destination_airport = 'AHD'` to reference the correct table and column. Do add table alias `T1` for the airlines table instead of using the raw table name. The amended query now correctly joins the airlines and flights tables to find airlines serving the specified destination airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_name FROM airlines WHERE destination_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
        ],
        "rule_sql": []
    },
    "237": {
        "db_id": "flight_2",
        "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "amends": [
            "Do use `INTERSECT` to find airlines serving both airports instead of joining the same table twice with separate conditions. Do reference `T1.Airline` instead of `a.name` and use proper table aliases `T1` and `T2` instead of `a`, `f1`, and `f2`. Do join on `T1.uid = T2.Airline` instead of `a.id = f1.airline_id` and use `T2.SourceAirport` instead of `f1.departure_airport`. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns distinct results. Do structure the query as two separate `SELECT` statements combined with `INTERSECT` instead of a single query with multiple joins. The amended query now correctly identifies airlines that serve both APG and CVO airports using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM airlines a\nJOIN flights f1 ON a.id = f1.airline_id\nJOIN flights f2 ON a.id = f2.airline_id\nWHERE f1.departure_airport = 'APG' AND f2.departure_airport = 'CVO';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'"
        ],
        "rule_sql": []
    },
    "238": {
        "db_id": "flight_2",
        "question": "Which airlines have departing flights from both APG and CVO airports?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "amends": [
            "Do use `INTERSECT` to find airlines serving both airports instead of joining the same table twice with different conditions. Do select `T1.Airline` instead of `a.name` and use proper table aliases `T1` and `T2` instead of `a`, `f1`, and `f2`. Do join on `T1.uid = T2.Airline` instead of `a.id = f1.airline_id` and use `T2.SourceAirport` instead of `f1.departure_airport`. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns unique results instead of keeping it. Do use double quotes around airport codes \"APG\" and \"CVO\" instead of single quotes. The amended query now correctly identifies airlines that serve both specified airports using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM airlines a \nJOIN flights f1 ON a.id = f1.airline_id \nJOIN flights f2 ON a.id = f2.airline_id \nWHERE f1.departure_airport = 'APG' AND f2.departure_airport = 'CVO';",
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"APG\" INTERSECT SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"CVO\""
        ],
        "rule_sql": []
    },
    "239": {
        "db_id": "flight_2",
        "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "amends": [
            "Do use `T1.uid = T2.Airline` for the join condition instead of `a.Airline_ID = f.Airline_ID`. Do use `T2.SourceAirport = \"CVO\"` instead of `f.Source_Airport = 'CVO'` with proper column naming and quote style. Do remove the contradictory `AND f.Source_Airport != 'APG'` filter instead of keeping it, as this logic is handled through the EXCEPT operation. Do add an EXCEPT clause to exclude airlines that also serve APG instead of using a single query with conflicting conditions. Do use table aliases `T1` and `T2` consistently instead of `a` and `f`. The amended query now correctly identifies airlines that serve CVO but not APG by using set operations instead of contradictory WHERE conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.Airline FROM Airlines a JOIN Flights f ON a.Airline_ID = f.Airline_ID WHERE f.Source_Airport = 'CVO' AND f.Source_Airport != 'APG';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ],
        "rule_sql": []
    },
    "240": {
        "db_id": "flight_2",
        "question": "Which airlines have departures from CVO but not from APG airports?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do filter for `SourceAirport = \"CVO\"` instead of `departure_airport = 'CVO'`. Do use `EXCEPT` to exclude airlines that also serve `\"APG\"` instead of the contradictory `departure_airport != 'APG'` condition. Do select `T1.Airline` from the joined result instead of `airline` directly from flights. Do remove the `DISTINCT` modifier since `EXCEPT` inherently returns unique results. The amended query now correctly identifies airlines that serve CVO but not APG, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT airline FROM flights WHERE departure_airport = 'CVO' AND departure_airport != 'APG';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ],
        "rule_sql": []
    },
    "241": {
        "db_id": "flight_2",
        "question": "Find all airlines that have at least 10 flights.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
        "amends": [
            "Do add table `AIRLINES AS T1` and `FLIGHTS AS T2` in the FROM clause instead of only having `flights`. Do use `JOIN` with the predicate `T1.uid = T2.Airline` instead of no join condition. Do specify `T1.Airline` in the SELECT list instead of just `airline` to clarify the source table. The amended query now correctly joins the airlines and flights tables to count flights per airline and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 10",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) >= 10"
        ],
        "rule_sql": []
    },
    "242": {
        "db_id": "flight_2",
        "question": "Which airlines have at least 10 flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
        "amends": [
            "Do add a `FROM` clause with `AIRLINES AS T1` instead of omitting it, and do add a `JOIN` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do reference `T1.Airline` in the `SELECT` list instead of just `airline` to ensure the correct column from the joined table is selected. The amended query now correctly joins the airlines and flights tables to count flights per airline, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 10;",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) >= 10"
        ],
        "rule_sql": []
    },
    "243": {
        "db_id": "flight_2",
        "question": "Find all airlines that have fewer than 200 flights.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200",
        "amends": [
            "Do add a `JOIN` between `AIRLINES` and `FLIGHTS` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do reference `T1.Airline` in the SELECT list instead of just `airline` from the flights table. Do change the HAVING condition to `count(*) < 200` instead of `COUNT(*) > 200` to filter for airlines with fewer than 200 flights rather than more than 200. The amended query now correctly joins the airlines table to access airline information and filters for airlines with less than 200 flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 200;",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200"
        ],
        "rule_sql": []
    },
    "244": {
        "db_id": "flight_2",
        "question": "Which airlines have less than 200 flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200",
        "amends": [
            "Do add table `AIRLINES AS T1` and join it with `FLIGHTS AS T2` using `ON T1.uid = T2.Airline` instead of querying only the `flights` table without proper joins. Do move the aggregate filter to `HAVING count(*) < 200` instead of placing it in the `WHERE` clause where aggregate functions cannot be used. Do select `T1.Airline` from the joined airlines table instead of selecting `airline` directly from the flights table without proper table qualification. The amended query now correctly joins the airlines and flights tables and properly filters aggregated results using HAVING, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline FROM flights WHERE COUNT(*) < 200 GROUP BY airline",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) < 200"
        ],
        "rule_sql": []
    },
    "245": {
        "db_id": "flight_2",
        "question": "What are flight numbers of Airline \"United Airlines\"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRLINES` as `T2` on `T2.uid = T1.Airline` instead of querying only the `flights` table. Do reference `T1.FlightNo` instead of `flight_number` and filter on `T2.Airline = \"United Airlines\"` instead of `airline = 'Delta Airlines'`. The amended query now correctly joins to the airlines table to filter by airline name rather than assuming the airline name is stored directly in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE airline = 'Delta Airlines';",
            "SELECT T1.FlightNo FROM flights T1 JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'"
        ],
        "rule_sql": []
    },
    "246": {
        "db_id": "flight_2",
        "question": "Which flight numbers correspond to United Airlines flights?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRLINES` as `T2` on `T2.uid = T1.Airline` instead of querying only the `flights` table. Do filter on `T2.Airline = \"United Airlines\"` instead of `airline = 'Delta Airlines'`. Do select `T1.FlightNo` instead of `flight_number`. The amended query now correctly joins the airlines table to filter by airline name using the proper relationship and returns the appropriate flight number column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE airline = 'Delta Airlines';",
            "SELECT T1.FlightNo \nFROM flights T1 \nJOIN airlines T2 ON T2.uid = T1.Airline \nWHERE T2.Airline = 'United Airlines'"
        ],
        "rule_sql": []
    },
    "247": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights departing from Airport \"APG\"?",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `SourceAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly retrieves flight numbers from the FLIGHTS table where the source airport matches APG, using the proper column names and table reference as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": []
    },
    "248": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights leaving from APG.",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `SourceAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": []
    },
    "249": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights arriving at Airport \"APG\"?",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `DestAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause, changing the column reference from departure airport to destination airport. The amended query now correctly filters for flights with destination airport APG instead of departure airport APG, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = \"APG\""
        ],
        "rule_sql": []
    },
    "250": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights landing at APG.",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `DestAirport = 'APG'` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly selects flight numbers based on destination airport rather than departure airport, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = 'APG'"
        ],
        "rule_sql": []
    },
    "251": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights departing from City \"Aberdeen \"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.SourceAirport = T2.AirportCode` instead of querying `flights` table directly. Do change the column reference to `T1.FlightNo` instead of `flight_number`. Do change the filter condition to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'`, which correctly joins through the airports table to find flights departing from Aberdeen city rather than relying on a potentially incorrect or non-existent departure_city column. The amended query now properly correlates flights with their source airport's city information to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen'",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "252": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights leaving from Aberdeen.",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2` with `ON T1.SourceAirport = T2.AirportCode` instead of querying `flights` table alone. Do reference `T2.City` in the WHERE clause instead of directly filtering on `departure_city`. Do use table alias `T1.FlightNo` instead of `flight_number` column name. The amended query now correctly joins airport data to filter by city name instead of assuming departure city is stored directly in the flights table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "253": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights arriving at City \"Aberdeen\"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since we need to join with airports to get the city information. Do use `T1.FlightNo` with proper table alias instead of `flight_number` without qualification. The amended query now correctly finds flights destined for Aberdeen by joining with the airports table to match on city rather than incorrectly filtering on a departure city column that may not exist or contain the correct data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "254": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights arriving in Aberdeen.",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the column reference to `T1.FlightNo` instead of `flight_number`. Do move the filter condition to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` to correctly filter by destination city rather than departure city. The amended query now properly joins the flights and airports tables to find flights destined for Aberdeen, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo \nFROM flights AS T1 \nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode \nWHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": []
    },
    "255": {
        "db_id": "flight_2",
        "question": "Find the number of flights landing in the city of Aberdeen or Abilene.",
        "ground_truth": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
        "amends": [
            "Do add `JOIN Airports AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the flights table. Do change the filter to `T2.city = \"Aberdeen\" OR T2.city = \"Abilene\"` instead of `departure_city IN ('Aberdeen', 'Abilene')` to correctly reference the joined airports table's city column rather than a non-existent departure_city column. Do remove the incorrect direct column reference and instead filter through the proper join relationship between flights and airports tables. The amended query now correctly counts flights destined for Aberdeen or Abilene by joining with the airports table to match on city names through airport codes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city IN ('Aberdeen', 'Abilene');",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ],
        "rule_sql": []
    },
    "256": {
        "db_id": "flight_2",
        "question": "How many flights land in Aberdeen or Abilene?",
        "ground_truth": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
        "amends": [
            "Do add `JOIN Airports AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.city = \"Aberdeen\" OR T2.city = \"Abilene\"` instead of the impossible condition `destination = 'Aberdeen' AND destination = 'Abilene'`. Do use table alias `T1` for `Flights` and `T2` for `Airports` instead of no aliases. The amended query now correctly joins flights with airports and filters by city names instead of attempting to match a single destination to two different values simultaneously, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'Aberdeen' AND destination = 'Abilene';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OR T2.City = 'Abilene'"
        ],
        "rule_sql": []
    },
    "257": {
        "db_id": "flight_2",
        "question": "Find the name of airports which do not have any flight in and out.",
        "ground_truth": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "amends": [
            "Do reference `AirportName` instead of `name` and `AirportCode` instead of `airport_id` in the SELECT clause and WHERE condition. Do use `SourceAirport` instead of `departure_airport` and `DestAirport` instead of `arrival_airport` in the subquery. Do combine the two NOT IN subqueries into a single UNION operation instead of separate subqueries, which improves efficiency by scanning the Flights table only once. Do reference the correct table names `Airports` and `Flights` with proper capitalization instead of lowercase table names. The amended query now correctly identifies airports that have never been used as either source or destination in any flight, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM airports WHERE airport_id NOT IN (SELECT departure_airport FROM flights) AND airport_id NOT IN (SELECT arrival_airport FROM flights);",
            "SELECT AirportName \nFROM airports \nWHERE AirportCode NOT IN (\n    SELECT SourceAirport FROM flights\n    UNION\n    SELECT DestAirport FROM flights\n)"
        ],
        "rule_sql": []
    },
    "258": {
        "db_id": "flight_2",
        "question": "Which airports do not have departing or arriving flights?",
        "ground_truth": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "amends": [
            "Do select `AirportName` instead of `*` and use table alias `Airports` instead of `airports`. Do use column `AirportCode` instead of `airport_id` for the main filter. Do combine the two subqueries into a single `UNION` operation selecting `SourceAirport` and `DestAirport` instead of separate `NOT IN` clauses with `departure_airport` and `arrival_airport`. Do reference table `Flights` instead of `flights` with proper capitalization. The amended query now correctly identifies airports not used as either source or destination in any flight by using UNION to combine both airport types in a single subquery."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM airports WHERE airport_id NOT IN (SELECT departure_airport FROM flights) AND airport_id NOT IN (SELECT arrival_airport FROM flights);",
            "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights)"
        ],
        "rule_sql": []
    },
    "259": {
        "db_id": "employee_hire_evaluation",
        "question": "How many employees are there?",
        "ground_truth": "SELECT count(*) FROM employee",
        "amends": [
            "Do reference the `employee` table instead of the `customers` table in the FROM clause, changing the source data being queried. The amended query now correctly counts records from the employee table instead of the customers table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM employee;"
        ],
        "rule_sql": []
    },
    "260": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of employees",
        "ground_truth": "SELECT count(*) FROM employee",
        "amends": [
            "Do reference the `employee` table instead of `employees` to match the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do remove the `WHERE department = 'Sales'` filter instead of keeping it since the right query counts all employees without department filtering. The amended query now matches the right SQL's behavior of counting all records in the employee table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department = 'Sales';",
            "SELECT count(*) FROM employee"
        ],
        "rule_sql": []
    },
    "261": {
        "db_id": "employee_hire_evaluation",
        "question": "Sort employee names by their age in ascending order.",
        "ground_truth": "SELECT name FROM employee ORDER BY age",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do use ascending ORDER BY `age` instead of descending ORDER BY `age DESC`. The amended query now correctly references the single employee table and sorts by age in ascending order instead of descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY age DESC;",
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ],
        "rule_sql": []
    },
    "262": {
        "db_id": "employee_hire_evaluation",
        "question": "List the names of employees and sort in ascending order of age.",
        "ground_truth": "SELECT name FROM employee ORDER BY age",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do use ascending ORDER BY `age` instead of descending ORDER BY `age DESC`. The amended query now correctly references the single employee table and sorts by age in ascending order instead of descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY age DESC;",
            "SELECT Name FROM employee ORDER BY Age ASC;"
        ],
        "rule_sql": []
    },
    "263": {
        "db_id": "employee_hire_evaluation",
        "question": "What is the number of employees from each city?",
        "ground_truth": "SELECT count(*) ,  city FROM employee GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it. Do use the correct table name `employee` instead of `employees` in the FROM clause. The amended query now correctly counts employees by city using the proper table reference and column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees GROUP BY city;",
            "SELECT COUNT(*), City FROM employee GROUP BY City;"
        ],
        "rule_sql": []
    },
    "264": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of employees for each city.",
        "ground_truth": "SELECT count(*) ,  city FROM employee GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it. Do use table name `employee` instead of `employees` in the FROM clause. The amended query now correctly counts employees by city using the proper table reference and column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees GROUP BY city;",
            "SELECT COUNT(*), City FROM employee GROUP BY City;"
        ],
        "rule_sql": []
    },
    "265": {
        "db_id": "employee_hire_evaluation",
        "question": "Which cities do more than one employee under age 30 come from?",
        "ground_truth": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1",
        "amends": [
            "Do reference the table as `employee` instead of `employees` to match the correct table name. Do maintain the exact same query structure with `SELECT city`, `WHERE age < 30`, `GROUP BY city`, and `HAVING count(*) > 1` as the logic remains identical. The amended query now correctly references the intended table while preserving all filtering, grouping, and aggregation behavior to match the RIGHT_SQL's output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM employees WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING count(*) > 1"
        ],
        "rule_sql": []
    },
    "266": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the cities that have more than one employee under age 30.",
        "ground_truth": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause, as the correct table name is singular. Do maintain the same SELECT list with `city`, WHERE filter with `age < 30`, GROUP BY clause with `city`, and HAVING condition with `count(*) > 1` without any changes to the logic or structure. The amended query now matches RIGHT_SQL's behavior with the corrected table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM employees WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "267": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the number of shops in each location.",
        "ground_truth": "SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",
        "amends": [
            "Do select `count(*)` and `LOCATION` instead of `location` and `COUNT(*)`. Do use `GROUP BY LOCATION` instead of `GROUP BY shop_id`. Do reference table `shop` instead of `shops`. The amended query now correctly groups by location and counts records per location rather than incorrectly grouping by shop_id while selecting location.",
            "Do place the `count(*)` column before `LOCATION` in the SELECT list instead of having `LOCATION` first. Do maintain the same GROUP BY clause with `LOCATION` and keep the same table source and aggregation logic. The amended query now correctly matches the RIGHT_SQL's column ordering while preserving identical result behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM shops GROUP BY shop_id;",
            "SELECT LOCATION, COUNT(*) FROM shop GROUP BY LOCATION;",
            "SELECT count(*), LOCATION FROM shop GROUP BY LOCATION"
        ],
        "rule_sql": []
    },
    "268": {
        "db_id": "employee_hire_evaluation",
        "question": "How many shops are there in each location?",
        "ground_truth": "SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",
        "amends": [
            "Do select `count(*)` and `LOCATION` instead of `location` and `COUNT(*)`. Do use `GROUP BY LOCATION` instead of `GROUP BY shop_id`. Do reference table `shop` instead of `shops`. The amended query now correctly groups by location and counts records per location rather than incorrectly grouping by shop_id while selecting location.",
            "Do place `count(*)` before `LOCATION` in the SELECT list instead of after it, maintaining the same aggregation logic. Do keep the `GROUP BY LOCATION` clause unchanged as it correctly groups by location. The amended query now matches RIGHT_SQL's behavior with identical output results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM shops GROUP BY shop_id;",
            "SELECT LOCATION, COUNT(*) FROM shop GROUP BY LOCATION;",
            "SELECT count(*), LOCATION FROM shop GROUP BY LOCATION"
        ],
        "rule_sql": []
    },
    "269": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the manager name and district of the shop whose number of products is the largest.",
        "ground_truth": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `number_products` instead of `number_of_products` in the ORDER BY clause. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manager_name, district FROM shops ORDER BY number_of_products DESC LIMIT 1;",
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "270": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the manager name and district of the shop that sells the largest number of products?",
        "ground_truth": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do order by `number_products` instead of `product_count` in the ORDER BY clause. The amended query now correctly retrieves the manager name and district from the shop table ordered by product count in descending order with a limit of one result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manager_name, district FROM shops ORDER BY product_count DESC LIMIT 1;",
            "SELECT Manager_name, District FROM shop ORDER BY Number_products DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "271": {
        "db_id": "employee_hire_evaluation",
        "question": "find the minimum and maximum number of products of all stores.",
        "ground_truth": "SELECT min(Number_products) ,  max(Number_products) FROM shop",
        "amends": [
            "Do reference column `Number_products` instead of `product_count` and use table `shop` instead of `stores` while maintaining the same aggregate functions `MIN` and `MAX` with the same logic. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(product_count), MAX(product_count) FROM stores;",
            "SELECT MIN(Number_products) AS min_products, MAX(Number_products) AS max_products FROM shop;"
        ],
        "rule_sql": []
    },
    "272": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the minimum and maximum number of products across all the shops?",
        "ground_truth": "SELECT min(Number_products) ,  max(Number_products) FROM shop",
        "amends": [
            "Do reference the correct column name `Number_products` instead of the incorrect `products` column in both aggregate functions. Do use the correct table name `shop` instead of the pluralized `shops` table. Do remove the unnecessary column aliases `min_products` and `max_products` instead of keeping them, as the right query returns unnamed columns. The amended query now correctly calculates the minimum and maximum values from the Number_products column in the shop table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(products) AS min_products, MAX(products) AS max_products FROM shops;",
            "SELECT MIN(Number_products), MAX(Number_products) FROM shop;"
        ],
        "rule_sql": []
    },
    "273": {
        "db_id": "employee_hire_evaluation",
        "question": "Return the name, location and district of all shops in descending order of number of products.",
        "ground_truth": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",
        "amends": [
            "Do reference the correct table name `shop` instead of `shops` in the FROM clause. Do order by the column `number_products` instead of the aggregate function `COUNT(products)` which cannot be used in ORDER BY without GROUP BY. Do maintain the same column selection of `name`, `location`, and `district` without changes. The amended query now correctly references the existing table and orders by the appropriate product count column instead of attempting to use an aggregate function improperly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location, district FROM shops ORDER BY COUNT(products) DESC;",
            "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC;"
        ],
        "rule_sql": []
    },
    "274": {
        "db_id": "employee_hire_evaluation",
        "question": "Sort all the shops by number products in descending order, and return the name, location and district of each shop.",
        "ground_truth": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",
        "amends": [
            "Do reference the correct table name `shop` instead of `shops` in the FROM clause. Do order by the column `number_products` instead of the aggregate function `COUNT(products)` in the ORDER BY clause, as aggregates cannot be used directly in ORDER BY without being in the SELECT list or a GROUP BY clause. The amended query now correctly retrieves data from the intended table and sorts results based on the existing product count column rather than attempting to perform an invalid aggregation in the ORDER BY clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location, district FROM shops ORDER BY COUNT(products) DESC;",
            "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC;"
        ],
        "rule_sql": []
    },
    "275": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the names of stores whose number products is more than the average number of products.",
        "ground_truth": "SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop)",
        "amends": [
            "Do reference table `shop` instead of `stores` in both the main query and subquery. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly filters shops where the number of products exceeds the average across all shops, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stores WHERE number_products > (SELECT AVG(number_products) FROM stores);",
            "SELECT Name FROM shop WHERE Number_products > (SELECT avg(Number_products) FROM shop)"
        ],
        "rule_sql": []
    },
    "276": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shops' number products is above the average? Give me the shop names.",
        "ground_truth": "SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop)",
        "amends": [
            "Do reference column `name` instead of `shop_name` and use `number_products` instead of `products` in the main query. Do reference table `shop` instead of `shops` in both the main query and subquery. Do use the aggregate function `avg()` instead of `AVG()` and reference `number_products` instead of `products` in the subquery. Do remove the incorrect `COUNT()` function wrapping around `number_products` in the main filter condition instead of using it, as the comparison should be between the column value and the average rather than counting products. The amended query now correctly compares each shop's product count against the average product count across all shops."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name FROM shops WHERE COUNT(products) > (SELECT AVG(COUNT(products)) FROM shops);",
            "SELECT name FROM shop WHERE number_products > (SELECT AVG(number_products) FROM shop)"
        ],
        "rule_sql": []
    },
    "277": {
        "db_id": "employee_hire_evaluation",
        "question": "find the name of employee who was awarded the most times in the evaluation.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `t1.name` with table alias instead of just `name`. Do add `FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID` instead of omitting the join and table aliases. Do add `GROUP BY t2.Employee_ID` instead of omitting grouping. Do use `count(*)` instead of `COUNT(evaluation.award)` for proper counting of all evaluation records. Do maintain `ORDER BY count(*) DESC LIMIT 1` but with the corrected aggregate function. The amended query now correctly joins the tables, groups by employee, and counts all evaluations to find the employee with the most evaluations, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employee ORDER BY COUNT(evaluation.award) DESC LIMIT 1;",
            "SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "278": {
        "db_id": "employee_hire_evaluation",
        "question": "Which employee received the most awards in evaluations? Give me the employee name.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `employee` table instead of `employee_name` from `evaluations`. Do join `evaluation AS t2` with an `INNER JOIN` on `t1.Employee_ID = t2.Employee_ID` instead of querying only the `evaluations` table. Do add `GROUP BY t2.Employee_ID` to aggregate by employee instead of omitting grouping. Do order by `count(*) DESC` to rank by evaluation count instead of `awards DESC`. The amended query now correctly identifies the employee with the most evaluations by joining employee data with evaluation records and counting occurrences per employee."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_name FROM evaluations ORDER BY awards DESC LIMIT 1;",
            "SELECT t1.Name\nFROM employee AS t1\nINNER JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "279": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the name of the employee who got the highest one time bonus.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1",
        "amends": [
            "Do specify `t1.name` with table alias instead of just `name`. Do add `employee AS t1` and `evaluation AS t2` as FROM sources instead of just `employees`. Do add `JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID` instead of omitting the join. Do order by `t2.bonus` with table alias instead of just `bonus`. The amended query now correctly joins the employee and evaluation tables to access the bonus field and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY bonus DESC LIMIT 1;",
            "SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.Bonus DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "280": {
        "db_id": "employee_hire_evaluation",
        "question": "Which employee received the biggest bonus? Give me the employee name.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` from the `employee` table instead of `employee_name` from `employees`. Do add a `JOIN` with the `evaluation` table on `t1.Employee_ID = t2.Employee_ID` instead of querying a single table. Do order by `t2.bonus` instead of just `bonus` to specify the table source. The amended query now correctly joins employee and evaluation tables to access bonus data and returns the expected result matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_name FROM employees ORDER BY bonus DESC LIMIT 1;",
            "SELECT t1.Name \nFROM employee t1\nJOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "281": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the names of employees who never won any award in the evaluation.",
        "ground_truth": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "amends": [
            "Do select `name` from `employee` instead of `employees` as the table source. Do use a `NOT IN` subquery filtering by `Employee_ID` from the `evaluation` table instead of a simple `WHERE award_count > 0` condition. Do remove the incorrect `award_count` filter and instead implement the proper exclusion logic based on employee evaluations. The amended query now correctly identifies employees who have not been evaluated by checking for their absence in the evaluation table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employees WHERE award_count > 0;",
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ],
        "rule_sql": []
    },
    "282": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the names of the employees who never received any evaluation?",
        "ground_truth": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "amends": [
            "Do select `name` from `employee` instead of `employees` as the table source. Do use `NOT IN` with a subquery checking `Employee_ID` in the `evaluation` table instead of filtering on `evaluation_score IS NULL`. Do remove the direct null check condition and instead implement a correlated exclusion pattern to find employees missing from the evaluation table entirely. The amended query now correctly identifies employees without any evaluation records rather than those with null scores, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM employees WHERE evaluation_score IS NULL;",
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ],
        "rule_sql": []
    },
    "283": {
        "db_id": "employee_hire_evaluation",
        "question": "What is the name of the shop that is hiring the largest number of employees?",
        "ground_truth": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `hiring` table instead of `name` from the `shops` table. Do join `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying only the `shops` table. Do add `GROUP BY t1.shop_id` and aggregate with `count(*)` instead of using `employee_count` directly. Do order by `count(*) DESC` instead of `employee_count DESC` to count actual hires per shop. The amended query now correctly identifies the shop with the most hiring records rather than relying on a potentially incorrect employee_count field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM shops ORDER BY employee_count DESC LIMIT 1;",
            "SELECT t2.Name \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "284": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shop has the most employees? Give me the shop name.",
        "ground_truth": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `shop` table instead of `shop_name` from the `shops` table. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying a single table. Do add `GROUP BY t1.shop_id` to aggregate by shop instead of omitting grouping. Do order by `count(*) DESC` to find the shop with the most hires instead of `employee_count ASC` for the smallest shop. The amended query now correctly identifies the shop with the highest number of hiring records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name FROM shops ORDER BY employee_count ASC LIMIT 1;",
            "SELECT t2.Name \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "285": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the name of the shops that do not hire any employee.",
        "ground_truth": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do use a subquery with `NOT IN` condition on `shop_id` instead of filtering directly with `employee_id IS NULL`. Do remove the incorrect `employee_id` column reference and instead correlate through `shop_id` between the main query and subquery. Do change the filter logic to check for shops not present in the `hiring` table instead of checking for null employee IDs. The amended query now correctly identifies shops without hiring records by using a correlated subquery approach instead of relying on potentially incorrect null checks."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM shops WHERE employee_id IS NULL;",
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ],
        "rule_sql": []
    },
    "286": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shops run with no employees? Find the shop names",
        "ground_truth": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "amends": [
            "Do select `name` from the `shop` table instead of `shop_name` from `shops`. Do use a subquery with `NOT IN` to filter shops that are not in the hiring table instead of checking for `employee_count = 0`. Do reference `shop_id` in both the main query and subquery instead of using different column names and logic. The amended query now correctly identifies shops without any hiring records by checking their absence from the hiring table rather than relying on a potentially incorrect employee count field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name FROM shops WHERE employee_count = 0;",
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ],
        "rule_sql": []
    },
    "287": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the number of employees hired in each shop; show the shop name as well.",
        "ground_truth": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
        "amends": [
            "Do select `count(*)` and `t2.name` instead of `shop_name` and `COUNT(*)`. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying only `employees` table. Do group by `t2.name` instead of `shop_id`. The amended query now correctly counts employees per shop name by joining the hiring and shop tables, matching the intended behavior.",
            "Do place the `count(*)` aggregate function first in the SELECT list instead of second, and do use lowercase `t2.name` instead of uppercase `t2.Name` while maintaining the same GROUP BY clause with lowercase `t2.name` instead of uppercase `t2.Name`. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name, COUNT(*) FROM employees GROUP BY shop_id;",
            "SELECT t2.Name, COUNT(*) \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t2.Name",
            "SELECT count(*), t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID GROUP BY t2.name"
        ],
        "rule_sql": []
    },
    "288": {
        "db_id": "employee_hire_evaluation",
        "question": "For each shop, return the number of employees working there and the name of the shop.",
        "ground_truth": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
        "amends": [
            "Do select `count(*)` and `t2.name` instead of `shop_name` and `COUNT(*)`. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of selecting from `employees` alone. Do group by `t2.name` instead of `shop_id`. The amended query now correctly aggregates hiring counts by shop name through proper table joining and grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name, COUNT(*) FROM employees GROUP BY shop_id;",
            "SELECT COUNT(*) AS employee_count, t2.Name AS shop_name\nFROM hiring AS t1\nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t2.Name"
        ],
        "rule_sql": []
    },
    "289": {
        "db_id": "employee_hire_evaluation",
        "question": "What is total bonus given in all evaluations?",
        "ground_truth": "SELECT sum(bonus) FROM evaluation",
        "amends": [
            "Do use the column `bonus` instead of `salary` in the SELECT list's aggregate function. Do reference the table `evaluation` instead of `evaluations` in the FROM clause. The amended query now correctly calculates the sum of bonus amounts from the evaluation table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(salary) FROM evaluations;",
            "SELECT SUM(Bonus) AS Total_Bonus FROM evaluation;"
        ],
        "rule_sql": []
    },
    "290": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the total amount of bonus given in all the evaluations.",
        "ground_truth": "SELECT sum(bonus) FROM evaluation",
        "amends": [
            "Do use the column `bonus` instead of `salary` in the SELECT list aggregation. Do reference the table `evaluation` instead of `evaluations` in the FROM clause. The amended query now correctly calculates the sum of bonus amounts from the evaluation table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(salary) FROM evaluations;",
            "SELECT SUM(Bonus) AS Total_Bonus FROM evaluation;"
        ],
        "rule_sql": []
    },
    "291": {
        "db_id": "employee_hire_evaluation",
        "question": "Give me all the information about hiring.",
        "ground_truth": "SELECT * FROM hiring",
        "amends": [
            "Do query the `hiring` table instead of the `employees` table. Do remove the `WHERE hire_date IS NULL` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting all records from the correct table without any filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date IS NULL;",
            "SELECT * FROM hiring;"
        ],
        "rule_sql": []
    },
    "292": {
        "db_id": "employee_hire_evaluation",
        "question": "What is all the information about hiring?",
        "ground_truth": "SELECT * FROM hiring",
        "amends": [
            "Do query the `hiring` table instead of the `employees` table. Do remove the `WHERE hire_date IS NULL` filter instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting all records from the correct table without any filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM employees WHERE hire_date IS NULL;",
            "SELECT * FROM hiring;"
        ],
        "rule_sql": []
    },
    "293": {
        "db_id": "employee_hire_evaluation",
        "question": "Which district has both stores with less than 3000 products and stores with more than 10000 products?",
        "ground_truth": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "amends": [
            "Do reference table `shop` instead of `stores` and column `Number_products` instead of `products`. Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with conflicting conditions `products < 3000 AND products > 10000`. Do split the logic into two separate `SELECT` statements: one for `Number_products < 3000` and another for `Number_products > 10000`, then intersect the results to find districts that satisfy both conditions simultaneously, which correctly implements the intended logic instead of the impossible condition that would return no results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM stores WHERE products < 3000 AND products > 10000;",
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ],
        "rule_sql": []
    },
    "294": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
        "ground_truth": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "amends": [
            "Do reference table `shop` instead of `shops` and use column `Number_products` instead of `products_sold`. Do use `INTERSECT` to find districts that meet both conditions instead of using `AND` with contradictory filters `products_sold < 3000 AND products_sold > 10000` which would return no results. Do split the query into two separate SELECT statements with `INTERSECT` to properly find districts where some shops have fewer than 3000 products and other shops have more than 10000 products, instead of incorrectly trying to find shops that simultaneously have both conditions. The amended query now correctly identifies districts containing shops with both low and high product counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM shops WHERE products_sold < 3000 AND products_sold > 10000;",
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ],
        "rule_sql": []
    },
    "295": {
        "db_id": "employee_hire_evaluation",
        "question": "How many different store locations are there?",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM shop",
        "amends": [
            "Do `count(DISTINCT LOCATION)` instead of `COUNT(*)` to count unique locations rather than all rows. Do reference table `shop` instead of `stores` to query the correct data source. The amended query now correctly counts distinct locations from the shop table instead of counting all rows from the stores table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores;",
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ],
        "rule_sql": []
    },
    "296": {
        "db_id": "employee_hire_evaluation",
        "question": "Count the number of distinct store locations.",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM shop",
        "amends": [
            "Do count `DISTINCT LOCATION` instead of counting `store_id`. Do use table `shop` instead of table `stores`. Do remove the incorrect aggregate function that counted non-unique store identifiers instead of counting distinct location values. The amended query now correctly counts unique locations from the shop table instead of attempting to count store IDs from a non-existent stores table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(store_id) FROM stores;",
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ],
        "rule_sql": []
    },
    "297": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many documents do we have?",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the function casing. Do reference the table as `Documents` with proper case instead of lowercase `documents` to maintain schema object naming consistency. The amended query now correctly matches the RIGHT_SQL's behavior with proper function and table name casing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": []
    },
    "298": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of documents.",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency with the right SQL. Do reference table `Documents` with proper case instead of lowercase `documents` to match the correct table name. The amended query now matches RIGHT_SQL's behavior with identical functionality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": []
    },
    "299": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "List document IDs, document names, and document descriptions for all documents.",
        "ground_truth": "SELECT document_id ,  document_name ,  document_description FROM Documents",
        "amends": [
            "Do add `document_description` to the SELECT list instead of omitting it. Do reference the table as `Documents` instead of `documents` to match the correct case. The amended query now includes all required columns and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, document_name FROM documents;",
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents;"
        ],
        "rule_sql": []
    },
    "300": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids, names, and descriptions for all documents?",
        "ground_truth": "SELECT document_id ,  document_name ,  document_description FROM Documents",
        "amends": [
            "Do select `document_id`, `document_name`, and `document_description` instead of `id` and `name`. Do reference the `Documents` table instead of `documents`. The amended query now correctly retrieves all three document fields from the proper table with accurate column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM documents;",
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents;"
        ],
        "rule_sql": []
    },
    "301": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document name and template id for document with description with the letter 'w' in it?",
        "ground_truth": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"",
        "amends": [
            "Do reference the `Documents` table instead of `documents` to match the correct table name. Do use `Document_Description` column instead of `description` to reference the correct column name for the description field. Do use double quotes for the pattern matching instead of single quotes to maintain consistency with the right SQL format. The amended query now correctly filters documents based on the description containing 'w' and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_name, template_id FROM documents WHERE description LIKE '%w%';",
            "SELECT Document_Name, Template_ID FROM Documents WHERE Document_Description LIKE '%w%'"
        ],
        "rule_sql": []
    },
    "302": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the names and template ids for documents that contain the letter w in their description.",
        "ground_truth": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"",
        "amends": [
            "Do use `document_name` instead of `name` in the SELECT list. Do use `Document_Description` instead of `description` in the WHERE filter. Do reference the table as `Documents` instead of `documents` in the FROM clause. Do use double quotes `\"%w%\"` instead of single quotes `'%w%'` for the LIKE pattern. The amended query now correctly references the actual column names and table name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, template_id FROM documents WHERE description LIKE '%w%';",
            "SELECT document_name, Template_ID FROM Documents WHERE Document_Description LIKE \"%w%\""
        ],
        "rule_sql": []
    },
    "303": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id, template id and description for document named \"Robbin CV\"?",
        "ground_truth": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"",
        "amends": [
            "Do use `Document_Description` instead of `description` in the SELECT list to match the correct column name. Do reference the table as `Documents` instead of `documents` to maintain proper case sensitivity. Do use double quotes `\"Robbin CV\"` instead of single quotes `'Robbin CV'` for the string literal in the WHERE clause. The amended query now correctly retrieves data from the proper column and table with the appropriate string formatting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, template_id, description FROM documents WHERE document_name = 'Robbin CV';",
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ],
        "rule_sql": []
    },
    "304": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the document id, template id, and description for the document with the name Robbin CV.",
        "ground_truth": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"",
        "amends": [
            "Do reference `Document_Description` instead of `description` in the SELECT list. Do filter on `document_name = \"Robbin CV\"` instead of `name = 'Robbin CV'` in the WHERE clause. Do use table name `Documents` instead of `documents` and double quotes instead of single quotes for the string literal. The amended query now correctly references the actual column names and table name to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, template_id, description FROM documents WHERE name = 'Robbin CV';",
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ],
        "rule_sql": []
    },
    "305": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many different templates do all document use?",
        "ground_truth": "SELECT count(DISTINCT template_id) FROM Documents",
        "amends": [
            "Do count `DISTINCT template_id` instead of counting all rows with `COUNT(*)`. Do reference the table as `Documents` instead of `documents` (case sensitivity). The amended query now correctly counts distinct template IDs rather than total document count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents;"
        ],
        "rule_sql": []
    },
    "306": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of different templates used for documents.",
        "ground_truth": "SELECT count(DISTINCT template_id) FROM Documents",
        "amends": [
            "Do use `count(DISTINCT template_id)` instead of `COUNT(*)` to count distinct template IDs rather than all rows. Do reference the table as `Documents` instead of `documents` to match the correct case. The amended query now correctly counts distinct template IDs from the Documents table instead of counting all rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents;",
            "SELECT COUNT(DISTINCT Template_ID) FROM Documents;"
        ],
        "rule_sql": []
    },
    "307": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many documents are using the template with type code 'PPT'?",
        "ground_truth": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'",
        "amends": [
            "Do add `JOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID` instead of querying only the `documents` table. Do change the filter to `T2.Template_Type_Code = 'PPT'` instead of `template_type = 'PPT'` since the template type information resides in the Templates table rather than the Documents table. Do include the table alias `AS T1` for the Documents table instead of omitting it. The amended query now correctly joins the Documents and Templates tables to filter documents based on their associated template type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE template_type = 'PPT';",
            "SELECT COUNT(*) \nFROM Documents AS T1\nJOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Template_Type_Code = 'PPT'"
        ],
        "rule_sql": []
    },
    "308": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of documents that use the PPT template type.",
        "ground_truth": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'",
        "amends": [
            "Do join `Templates AS T2` on `T1.Template_ID = T2.Template_ID` instead of querying only the `documents` table. Do filter on `T2.Template_Type_Code = 'PPT'` instead of filtering on a non-existent `template_type` column in the documents table. The amended query now correctly counts documents by joining with the Templates table to access the template type code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE template_type = 'PPT';",
            "SELECT COUNT(*) \nFROM Documents AS D\nJOIN Templates AS T ON D.Template_ID = T.Template_ID\nWHERE T.Template_Type_Code = 'PPT'"
        ],
        "rule_sql": []
    },
    "309": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template ids and number of documents using each template.",
        "ground_truth": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, COUNT(*) FROM documents GROUP BY template_id;"
        ],
        "rule_sql": []
    },
    "310": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are all different template ids used for documents, and how many times were each of them used?",
        "ground_truth": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, COUNT(*) FROM documents GROUP BY template_id;"
        ],
        "rule_sql": []
    },
    "311": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the id and type code for the template used by the most documents?",
        "ground_truth": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Documents` and `Templates` tables with an `INNER JOIN` on `template_id` instead of querying only the `templates` table. Do select `T1.template_id` and `T2.Template_Type_Code` instead of `template_id` and `type_code`. Do add `GROUP BY T1.template_id` instead of omitting grouping. Do use `count(*)` for ordering instead of `COUNT(document_id)`. The amended query now correctly aggregates document counts per template and retrieves the corresponding template type code, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, type_code FROM templates ORDER BY COUNT(document_id) DESC LIMIT 1;",
            "SELECT T1.Template_ID, T2.Template_Type_Code\nFROM Documents T1\nINNER JOIN Templates T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "312": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id and type code of the template that is used for the greatest number of documents.",
        "ground_truth": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.template_id` and `T2.Template_Type_Code` instead of `id` and `type_code`. Do join `Documents AS T1` with `Templates AS T2` on `T1.template_id = T2.template_id` instead of querying only `templates` table. Do add `GROUP BY T1.template_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `id DESC`. The amended query now correctly identifies the most frequently used template by document count rather than simply the highest template ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, type_code FROM templates ORDER BY id DESC LIMIT 1;",
            "SELECT T1.template_id, T2.Template_Type_Code\nFROM Documents AS T1\nJOIN Templates AS T2 ON T1.template_id = T2.template_id\nGROUP BY T1.template_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "313": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show ids for all templates that are used by more than one document.",
        "ground_truth": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "314": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the template ids of any templates used in more than a single document?",
        "ground_truth": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1",
        "amends": [
            "Do change the HAVING clause condition to `count(*) > 1` instead of `COUNT(*) = 1`, which now correctly identifies template_ids that appear more than once in the Documents table rather than those appearing exactly once. The amended query now matches RIGHT_SQL's behavior by returning template_ids with multiple occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*) = 1;",
            "SELECT Template_ID\nFROM Documents\nWHERE Template_ID IS NOT NULL\nGROUP BY Template_ID\nHAVING COUNT(*) > 1;"
        ],
        "rule_sql": []
    },
    "315": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show ids for all templates not used by any document.",
        "ground_truth": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `template_id` in both SELECT clauses instead of selecting `id` from one table and `template_id` from another. Do capitalize table names consistently as `Templates` and `Documents` instead of lowercase `templates` and `documents`. The amended query now correctly handles potential NULL values in the subquery that could cause the NOT IN logic to fail, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM templates WHERE id NOT IN (SELECT template_id FROM documents)",
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ],
        "rule_sql": []
    },
    "316": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids for templates that are not used in any documents?",
        "ground_truth": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference `template_id` in the main SELECT instead of `id`. Do capitalize table names `Templates` and `Documents` instead of lowercase `templates` and `documents`. The amended query now correctly uses set-based logic to find template IDs that exist in Templates but not in Documents, avoiding potential NULL handling issues with the NOT IN approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM templates WHERE id NOT IN (SELECT template_id FROM documents)",
            "SELECT Template_ID FROM Templates\nEXCEPT\nSELECT Template_ID FROM Documents WHERE Template_ID IS NOT NULL"
        ],
        "rule_sql": []
    },
    "317": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many templates do we have?",
        "ground_truth": "SELECT count(*) FROM Templates",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates;"
        ],
        "rule_sql": []
    },
    "318": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of templates.",
        "ground_truth": "SELECT count(*) FROM Templates",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates;"
        ],
        "rule_sql": []
    },
    "319": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show template ids, version numbers, and template type codes for all templates.",
        "ground_truth": "SELECT template_id ,  version_number ,  template_type_code FROM Templates",
        "amends": [
            "Do add `template_type_code` to the SELECT list instead of omitting it. Do capitalize the table name `Templates` instead of using lowercase `templates`. The amended query now correctly includes all required columns and uses proper table naming conventions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id, version_number FROM templates;",
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates;"
        ],
        "rule_sql": []
    },
    "320": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids, version numbers, and type codes for each template?",
        "ground_truth": "SELECT template_id ,  version_number ,  template_type_code FROM Templates",
        "amends": [
            "Do select `template_id`, `version_number`, and `template_type_code` instead of `id`, `version`, and `type`. Do reference the table as `Templates` instead of `templates`. Do remove the `WHERE version > 5` filter instead of keeping it. Do remove the `ORDER BY id DESC` clause instead of including it. The amended query now correctly selects all columns from the Templates table without filtering or sorting, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, version, type FROM templates WHERE version > 5 ORDER BY id DESC",
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates;"
        ],
        "rule_sql": []
    },
    "321": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all distinct template type codes for all templates.",
        "ground_truth": "SELECT DISTINCT template_type_code FROM Templates",
        "amends": [
            "Do select `template_type_code` instead of `template_type` and add `DISTINCT` instead of omitting it. Do reference table `Templates` instead of `templates` to match the correct case sensitivity. The amended query now correctly retrieves unique template type codes from the Templates table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type FROM templates",
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ],
        "rule_sql": []
    },
    "322": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes?",
        "ground_truth": "SELECT DISTINCT template_type_code FROM Templates",
        "amends": [
            "Do select `template_type_code` instead of `template_type` and use `DISTINCT` instead of `GROUP BY` for deduplication. Do reference the table as `Templates` (case-sensitive) instead of `templates`. The amended query now correctly retrieves distinct template type codes from the Templates table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type FROM templates GROUP BY template_type;",
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ],
        "rule_sql": []
    },
    "323": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of templates with template type code PP or PPT?",
        "ground_truth": "SELECT template_id FROM Templates WHERE template_type_code  =  \"PP\" OR template_type_code  =  \"PPT\"",
        "amends": [
            "Do select `template_id` instead of `id` and change the table name to `Templates` instead of `templates`. Do use `OR` logic with `template_type_code = \"PP\"` OR `template_type_code = \"PPT\"` instead of incorrectly using `AND` with both conditions simultaneously. Do use double quotes `\"PP\"` and `\"PPT\"` instead of single quotes for the string literals. The amended query now correctly retrieves templates of either type PP or PPT instead of incorrectly requiring both types simultaneously."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM templates WHERE template_type_code = 'PP' AND template_type_code = 'PPT';",
            "SELECT Template_ID FROM Templates WHERE Template_Type_Code = \"PP\" OR Template_Type_Code = \"PPT\""
        ],
        "rule_sql": []
    },
    "324": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the ids of templates that have the code PP or PPT.",
        "ground_truth": "SELECT template_id FROM Templates WHERE template_type_code  =  \"PP\" OR template_type_code  =  \"PPT\"",
        "amends": [
            "Do select `template_id` instead of `id` and use table name `Templates` instead of `templates`. Do filter on column `template_type_code` with values `\"PP\"` and `\"PPT\"` instead of column `code` with values `'PP'` and `'PPT'`. The amended query now correctly references the appropriate column names and table while maintaining the same filtering logic for template type codes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM templates WHERE code = 'PP' OR code = 'PPT';",
            "SELECT Template_ID FROM Templates WHERE Template_Type_Code IN ('PP', 'PPT')"
        ],
        "rule_sql": []
    },
    "325": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many templates have template type code CV?",
        "ground_truth": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"",
        "amends": [
            "Do reference the table as `Templates` instead of `templates` to match the correct case sensitivity. Do use the column `template_type_code` instead of `template_type` to reference the correct column name. Do use double quotes `\"CV\"` instead of single quotes `'CV'` for the string literal value. The amended query now correctly counts records from the Templates table where the template_type_code equals \"CV\", matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates WHERE template_type = 'CV';",
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ],
        "rule_sql": []
    },
    "326": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of templates of the type CV.",
        "ground_truth": "SELECT count(*) FROM Templates WHERE template_type_code  =  \"CV\"",
        "amends": [
            "Do reference the table as `Templates` instead of `templates` to match the correct case sensitivity. Do use the column `template_type_code` instead of `type` to reference the appropriate column name. Do use double quotes `\"CV\"` instead of single quotes `'CV'` for the string literal value. The amended query now correctly counts records from the Templates table where the template_type_code equals \"CV\", matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates WHERE type = 'CV';",
            "SELECT COUNT(*) FROM Templates WHERE template_type_code = \"CV\";"
        ],
        "rule_sql": []
    },
    "327": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the version number and template type code for the template with version number later than 5?",
        "ground_truth": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT version_number, template_type_code FROM templates WHERE version_number > 5;"
        ],
        "rule_sql": []
    },
    "328": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the version numbers and template type codes of templates with a version number greater than 5.",
        "ground_truth": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT version_number, template_type_code FROM templates WHERE version_number > 5;"
        ],
        "rule_sql": []
    },
    "329": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and number of templates for each.",
        "ground_truth": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",
        "amends": [
            "Do reference `template_type_code` in the SELECT list instead of `template_type` to match the GROUP BY clause and ensure correct aggregation. Do use the correct table name `Templates` (case-sensitive) instead of `templates` to properly reference the database object. The amended query now correctly counts records grouped by template_type_code as intended in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type, COUNT(*) FROM templates GROUP BY template_type_code;",
            "SELECT Template_Type_Code, COUNT(*) AS Number_of_Templates FROM Templates GROUP BY Template_Type_Code"
        ],
        "rule_sql": []
    },
    "330": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes, and how many templates correspond to each?",
        "ground_truth": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) FROM templates GROUP BY template_type_code;"
        ],
        "rule_sql": []
    },
    "331": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Which template type code has most number of templates?",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `template_type_code` instead of including `COUNT(*) as template_count` in the SELECT list. Do order by `count(*) DESC` instead of `template_count ASC` to find the most frequent template type. Do remove the alias `template_count` from the ORDER BY clause since it's no longer selected. The amended query now correctly identifies the template type with the highest count by ordering in descending order by the count aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as template_count FROM templates GROUP BY template_type_code ORDER BY template_count ASC LIMIT 1;",
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "332": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the type code of the template type that the most templates belong to.",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `template_type_code` from the `Templates` table instead of `type_code` from `template_types`. Do add `GROUP BY template_type_code` to aggregate by the grouping column instead of omitting it. Do use the aggregate function `count(*)` in the ORDER BY clause instead of the invalid `COUNT(*)` without grouping. The amended query now correctly aggregates template counts by type and returns the most frequent template type, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type_code FROM template_types ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "333": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes with less than three templates.",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3",
        "amends": [
            "Do remove the `COUNT(*) as template_count` column from the SELECT list instead of including it. Do change the HAVING condition to `count(*) < 3` instead of `template_count > 3`, using the aggregate function directly rather than the alias. Do use the correct table name `Templates` (with capital T) instead of `templates` to match the actual schema. The amended query now correctly filters for template type codes that have fewer than 3 templates rather than those with more than 3, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as template_count FROM templates GROUP BY template_type_code HAVING template_count > 3;",
            "SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(*) < 3"
        ],
        "rule_sql": []
    },
    "334": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the codes of template types that have fewer than 3 templates?",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3",
        "amends": [
            "Do use `count(*) < 3` in the HAVING clause instead of `COUNT(*) > 3` to filter for template type codes with fewer than 3 occurrences rather than more than 3 occurrences. The amended query now correctly identifies template type codes with less than 3 records, matching the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM templates GROUP BY template_type_code HAVING COUNT(*) > 3;",
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nHAVING COUNT(*) < 3"
        ],
        "rule_sql": []
    },
    "335": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What the smallest version number and its template type code?",
        "ground_truth": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
        "amends": [
            "Do use `MIN(version_number)` instead of `MAX(version_number)` to find the smallest version number. Do keep `template_type_code` in the SELECT list instead of removing it. Do maintain `ORDER BY version_number ASC` instead of changing the ordering. Do preserve `LIMIT 1` instead of modifying the row limitation. The amended query now correctly retrieves the minimum version number with its corresponding template type code, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(version_number), template_type_code FROM templates ORDER BY version_number ASC LIMIT 1;",
            "SELECT MIN(Version_Number) AS smallest_version, Template_Type_Code FROM Templates ORDER BY Version_Number ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "336": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the lowest version number, along with its corresponding template type code.",
        "ground_truth": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
        "amends": [
            "Do use `MIN` aggregate function on `Version_Number` instead of `MAX` on `version_number`, and do reference the table as `Templates` with proper case instead of `templates` lowercase. The amended query now correctly retrieves the minimum version number per template type rather than the maximum, matching the intended behavior.",
            "Do use lowercase `min(Version_Number)` without an alias instead of `MIN(Version_Number) AS Lowest_Version_Number` with an alias. Do use lowercase `template_type_code` instead of `Template_Type_Code` in both the SELECT list and GROUP BY clause. Do remove the alias `Lowest_Version_Number` instead of keeping it. The amended query now matches the right SQL's behavior with consistent lowercase function and column names and no output column aliasing.",
            "Do include the comma separator between `min(Version_Number)` and `template_type_code` in the SELECT list instead of omitting it, as the missing comma would cause a syntax error. The amended query now correctly retrieves the minimum version number for each template type code from the Templates table with proper SQL syntax.",
            "Do include the space after the comma in `min(Version_Number) , template_type_code` instead of omitting it to maintain proper SQL syntax formatting, though this is purely cosmetic and does not affect the query's logical behavior or results. The amended query now matches RIGHT_SQL's behavior with identical functionality.",
            "Do include the space after the comma in `min(Version_Number) , template_type_code` instead of omitting it, as the spacing difference affects query formatting consistency while maintaining identical semantic behavior. The amended query now matches RIGHT_SQL's behavior with proper spacing conventions.",
            "Do include the space after `min(Version_Number)` instead of omitting it, and do add proper spacing around the comma in the SELECT list instead of having no spacing. The amended query now matches RIGHT_SQL's behavior with correct formatting while maintaining the same logical structure and functionality.",
            "Do include the space after `min(Version_Number)` instead of omitting it, and do add proper spacing around the comma in the SELECT list instead of having no space. Do maintain the same GROUP BY clause with `template_type_code` instead of changing it. The amended query now matches RIGHT_SQL's behavior with corrected formatting while preserving the same logical structure and output.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with proper formatting.",
            "Do include the space after the comma in `template_type_code` instead of omitting it, as the RIGHT_SQL maintains proper column spacing. The amended query now matches RIGHT_SQL's behavior with identical column formatting.",
            "Do include the space after the comma in the SELECT list instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space after the comma in `template_type_code` instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical column formatting and spacing.",
            "Do include the space after the comma in the SELECT list instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with identical column selection and grouping logic.",
            "Do include the space after the comma in the SELECT list instead of omitting it, maintaining the proper syntax for separating columns. The amended query now matches RIGHT_SQL's behavior with correct column formatting.",
            "Do include the space after the comma in the SELECT list instead of omitting it, maintaining the proper syntax for separating columns. The amended query now matches RIGHT_SQL's behavior with correct column formatting."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(version_number), template_type_code FROM templates GROUP BY template_type_code;",
            "SELECT MIN(Version_Number) AS Lowest_Version_Number, Template_Type_Code FROM Templates GROUP BY Template_Type_Code;",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code"
        ],
        "rule_sql": []
    },
    "337": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type code of the template used by document with the name \"Data base\"?",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"",
        "amends": [
            "Do select `T1.template_type_code` from the `Templates` table instead of `template_type_code` from the `documents` table. Do join `Templates AS T1` with `Documents AS T2` using `ON T1.template_id = T2.template_id` instead of querying only the `documents` table. Do filter on `T2.document_name = \"Data base\"` instead of `name = 'Data base'`. The amended query now correctly retrieves template type codes by joining the Templates and Documents tables and filtering by document name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM documents WHERE name = 'Data base';",
            "SELECT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T2.Document_Name = 'Data base'"
        ],
        "rule_sql": []
    },
    "338": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the template type code of the template that is used by a document named Data base.",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"",
        "amends": [
            "Do add table `Documents AS T2` with a `JOIN` on `T1.template_id = T2.template_id` instead of querying only the `templates` table. Do reference `template_type_code` as `T1.template_type_code` instead of just `template_type_code`. Do move the filter condition to `T2.document_name = \"Data base\"` instead of `document_name = 'Data base'` on the templates table. Do use double quotes around the string literal \"Data base\" instead of single quotes. The amended query now correctly joins the Templates and Documents tables to find template_type_code based on document_name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM templates WHERE document_name = 'Data base';",
            "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id = T2.template_id WHERE T2.document_name = \"Data base\""
        ],
        "rule_sql": []
    },
    "339": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document names using templates with template type code BK.",
        "ground_truth": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference the column as `T2.document_name` instead of just `document_name` to specify the table source. Do filter on `T1.template_type_code = \"BK\"` instead of `template_type = 'BK'` to use the correct table and column name with proper quoting. The amended query now correctly retrieves document names by joining through the template relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_name FROM documents WHERE template_type = 'BK';",
            "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID WHERE T1.Template_Type_Code = 'BK'"
        ],
        "rule_sql": []
    },
    "340": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the names of documents that use templates with the code BK?",
        "ground_truth": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"",
        "amends": [
            "Do select `T2.document_name` instead of `d.name` for the column name. Do use `Templates AS T1` and `Documents AS T2` as table aliases instead of `documents d` and `templates t`. Do join on `T1.template_id = T2.template_id` instead of `d.template_id = t.id` for the join condition. Do filter on `T1.template_type_code = \"BK\"` instead of `t.code = 'BK'` for the WHERE condition. The amended query now correctly retrieves document names by joining on template_id and filtering by template_type_code instead of code, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name FROM documents d JOIN templates t ON d.template_id = t.id WHERE t.code = 'BK';",
            "SELECT T2.Document_Name \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T1.Template_Type_Code = 'BK'"
        ],
        "rule_sql": []
    },
    "341": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and the number of documents using each type.",
        "ground_truth": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference `T1.template_type_code` in both SELECT and GROUP BY clauses instead of using just `template_type_code` without table qualification. The amended query now correctly counts documents per template type by properly joining the Templates and Documents tables to establish the relationship between template types and the documents that use them.",
            "Do use `INNER JOIN` instead of `LEFT JOIN` to only count documents that actually exist. Do use `count(*)` instead of `COUNT(T2.Document_ID)` to count all joined rows rather than non-null document IDs. Do remove the alias `NumberOfDocuments` instead of keeping it since the right query omits column aliases. Do reference `template_type_code` and `template_id` in lowercase instead of mixed case to match the right query's column naming convention. The amended query now correctly counts only documents with matching templates and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) FROM documents GROUP BY template_type_code;",
            "SELECT T1.Template_Type_Code, COUNT(T2.Document_ID) AS NumberOfDocuments\nFROM Templates AS T1\nLEFT JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code",
            "SELECT T1.template_type_code, COUNT(*) \nFROM Templates AS T1 \nINNER JOIN Documents AS T2 ON T1.template_id = T2.template_id \nGROUP BY T1.template_type_code"
        ],
        "rule_sql": []
    },
    "342": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes, and how many documents use each type?",
        "ground_truth": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference `T1.template_type_code` in both SELECT and GROUP BY instead of directly using `template_type_code` without table qualification. Do remove the `ORDER BY document_count DESC` clause instead of keeping it, as the right query focuses only on aggregation without sorting. Do remove the alias `document_count` from the COUNT(*) expression instead of keeping it, since the right query returns the count without column naming. The amended query now correctly joins the Templates and Documents tables to count documents per template type while matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as document_count FROM documents GROUP BY template_type_code ORDER BY document_count DESC;",
            "SELECT T1.Template_Type_Code, COUNT(*) \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nGROUP BY T1.Template_Type_Code"
        ],
        "rule_sql": []
    },
    "343": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Which template type code is used by most number of documents?",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do select only `T1.template_type_code` instead of selecting both `template_type_code` and `COUNT(*) as document_count`. Do group by `T1.template_type_code` instead of grouping by `template_type_code` without table qualification. Do order by `count(*) DESC` instead of ordering by `document_count ASC`. The amended query now correctly identifies the template type with the highest document count by joining the Templates and Documents tables and ordering by descending count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as document_count FROM documents GROUP BY template_type_code ORDER BY document_count ASC LIMIT 1;",
            "SELECT T1.Template_Type_Code\nFROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "344": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the code of the template type that is most commonly used in documents.",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do specify `T1.template_type_code` in the SELECT clause with table alias qualification instead of just `template_type_code` without table reference. Do maintain the same `GROUP BY T1.template_type_code`, `ORDER BY count(*) DESC`, and `LIMIT 1` structure as the original query. The amended query now correctly joins the Templates and Documents tables to ensure template_type_code is properly sourced from the Templates table while counting document associations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM documents GROUP BY template_type_code ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Template_Type_Code\nFROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "345": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes that are not used by any document.",
        "ground_truth": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "amends": [
            "Do use `EXCEPT` set operation between two queries instead of `GROUP BY` with `HAVING COUNT(*) > 0`. Do change the source table from `documents` to `Templates` in the first part and add a second query joining `Templates AS T1` with `Documents AS T2` on `T1.template_id = T2.template_id` instead of only querying from `documents`. Do remove the `GROUP BY template_type_code` clause and `HAVING COUNT(*) > 0` filter instead of keeping them. The amended query now correctly identifies template types that exist in Templates but have no associated documents, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM documents GROUP BY template_type_code HAVING COUNT(*) > 0;",
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT T1.Template_Type_Code FROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ],
        "rule_sql": []
    },
    "346": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the codes of template types that are not used for any document?",
        "ground_truth": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with subquery for better performance and clarity. Do reference table `Templates` instead of `template_types` to match the correct schema. Do join `Templates AS T1` with `Documents AS T2` on `T1.template_id = T2.template_id` instead of using a subquery with `DISTINCT template_type_code FROM documents`. Do remove the `WHERE` clause with subquery entirely and replace it with the `EXCEPT` operation between two complete SELECT statements. The amended query now correctly identifies template types that exist in Templates but not in any Documents through proper table joins and set operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM template_types WHERE template_type_code NOT IN (SELECT DISTINCT template_type_code FROM documents)",
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT DISTINCT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ],
        "rule_sql": []
    },
    "347": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and descriptions.",
        "ground_truth": "SELECT template_type_code ,  template_type_description FROM Ref_template_types",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types`. Do select column `template_type_code` instead of `template_code`. Do select column `template_type_description` instead of `description`. The amended query now correctly references the appropriate table and columns to match the intended schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_code, description FROM template_types WHERE 1 = 0;",
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ],
        "rule_sql": []
    },
    "348": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the type codes and descriptions for all template types?",
        "ground_truth": "SELECT template_type_code ,  template_type_description FROM Ref_template_types",
        "amends": [
            "Do use table `Ref_template_types` instead of `template_types`. Do select column `template_type_code` instead of `type_code` and `template_type_description` instead of `description`. Do remove the `WHERE type_code IS NOT NULL` filter instead of keeping it, as the right query retrieves all records without null filtering. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type_code, description FROM template_types WHERE type_code IS NOT NULL",
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ],
        "rule_sql": []
    },
    "349": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type descriptions for template type code \"AD\".",
        "ground_truth": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` and use double quotes `\"AD\"` instead of single quotes `'AD'` for the string literal, while keeping the same column selection `template_type_description` and filter condition on `template_type_code`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_description FROM template_types WHERE template_type_code = 'AD';",
            "SELECT template_type_description FROM Ref_Template_Types WHERE template_type_code = \"AD\""
        ],
        "rule_sql": []
    },
    "350": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the template type description of the template type with the code AD.",
        "ground_truth": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` and use double quotes `\"AD\"` instead of single quotes `'AD'` for the string literal, while keeping the same column selection `template_type_description` and filter condition `template_type_code = 'AD'` unchanged. The amended query now correctly references the intended table and uses consistent string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_description FROM template_types WHERE template_type_code = 'AD';",
            "SELECT template_type_description FROM Ref_template_types WHERE template_type_code = \"AD\""
        ],
        "rule_sql": []
    },
    "351": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type code for template type description \"Book\".",
        "ground_truth": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` in the FROM clause. Do use double quotes `\"Book\"` instead of single quotes `'Book'` for the string literal in the WHERE filter. The amended query now correctly references the intended table and uses proper string quotation to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_type_code FROM template_types WHERE template_type_description = 'Book';",
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""
        ],
        "rule_sql": []
    },
    "352": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the type code of the template type with the description \"Book\".",
        "ground_truth": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"",
        "amends": [
            "Do reference `template_type_code` instead of `type_code` and select from `Ref_template_types` instead of `template_types`. Do filter on `template_type_description = \"Book\"` instead of `description = 'Book'`, using double quotes instead of single quotes for the string literal. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type_code FROM template_types WHERE description = 'Book';",
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\";"
        ],
        "rule_sql": []
    },
    "353": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the distinct template type descriptions for the templates ever used by any document?",
        "ground_truth": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
        "amends": [
            "Do select `T1.template_type_description` instead of `template_type` from the SELECT list. Do add `Ref_template_types AS T1` and `Templates AS T2` to the FROM clause instead of only `documents` and `templates`. Do change the join condition to `T1.template_type_code = T2.template_type_code` instead of `documents.template_id = templates.id`. Do add a second join `JOIN Documents AS T3 ON T2.Template_ID = T3.template_ID` instead of having only one join. The amended query now correctly retrieves template type descriptions from the appropriate reference table through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT template_type FROM documents JOIN templates ON documents.template_id = templates.id",
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types AS T1\nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nJOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID;"
        ],
        "rule_sql": []
    },
    "354": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the different descriptions for templates that have been used in a document.",
        "ground_truth": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
        "amends": [
            "Do add `Ref_template_types AS T1`, `Templates AS T2`, and `Documents AS T3` tables instead of querying only `documents`. Do change the SELECT list to `T1.template_type_description` instead of `template_id`. Do add `JOIN Templates AS T2 ON T1.template_type_code = T2.template_type_code` and `JOIN Documents AS T3 ON T2.Template_ID = T3.template_ID` instead of no joins. The amended query now correctly retrieves distinct template type descriptions by properly joining through the template hierarchy rather than just selecting template IDs from documents."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT template_id FROM documents;",
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types AS T1\nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nJOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID;"
        ],
        "rule_sql": []
    },
    "355": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the template ids with template type description \"Presentation\".",
        "ground_truth": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"",
        "amends": [
            "Do join `Ref_template_types AS T1` and `Templates AS T2` instead of querying only `templates` table. Do use `T1.template_type_code = T2.template_type_code` join condition instead of no join. Do filter on `T1.template_type_description = \"Presentation\"` instead of `template_type = 'Presentation'`. Do select `T2.template_id` with table alias instead of just `template_id`. The amended query now correctly joins reference tables to resolve template types by description rather than relying on direct column matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT template_id FROM templates WHERE template_type = 'Presentation'",
            "SELECT T2.Template_ID \nFROM Ref_Template_Types AS T1 \nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code \nWHERE T1.Template_Type_Description = 'Presentation'"
        ],
        "rule_sql": []
    },
    "356": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the ids corresponding to templates with the description 'Presentation'.",
        "ground_truth": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"",
        "amends": [
            "Do add `Ref_template_types AS T1` and `Templates AS T2` as joined tables instead of querying only `templates` alone. Do use `JOIN` with `ON T1.template_type_code = T2.template_type_code` instead of no join condition. Do select `T2.template_id` instead of `id`. Do filter on `T1.template_type_description = \"Presentation\"` instead of `description = 'Presentation'`. The amended query now correctly joins reference data to retrieve template IDs by type description instead of directly filtering templates by description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM templates WHERE description = 'Presentation'",
            "SELECT T2.template_id \nFROM Ref_template_types AS T1 \nJOIN Templates AS T2 ON T1.template_type_code = T2.template_type_code \nWHERE T1.template_type_description = 'Presentation'"
        ],
        "rule_sql": []
    },
    "357": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many paragraphs in total?",
        "ground_truth": "SELECT count(*) FROM Paragraphs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs;"
        ],
        "rule_sql": []
    },
    "358": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of paragraphs.",
        "ground_truth": "SELECT count(*) FROM Paragraphs",
        "amends": [
            "Do reference the `Paragraphs` table instead of the `sentences` table in the FROM clause, as the query intent is to count records from the correct data source. The amended query now matches RIGHT_SQL's behavior by correctly counting records from the Paragraphs table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sentences;",
            "SELECT COUNT(*) FROM Paragraphs;"
        ],
        "rule_sql": []
    },
    "359": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many paragraphs for the document with name 'Summer Show'?",
        "ground_truth": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
        "amends": [
            "Do add `JOIN Documents AS T2 ON T1.document_ID = T2.document_ID` instead of querying only the `paragraphs` table. Do move the filter `document_name = 'Summer Show'` to the joined `Documents` table instead of applying it directly to `paragraphs`. Do reference the joined table alias `T2` in the WHERE clause instead of the original table name. The amended query now correctly joins the tables and filters on the document name from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE document_name = 'Summer Show';",
            "SELECT COUNT(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Summer Show'"
        ],
        "rule_sql": []
    },
    "360": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of paragraphs in the document named 'Summer Show'.",
        "ground_truth": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
        "amends": [
            "Do add a `JOIN` to `Documents AS T2` instead of querying only the `paragraphs` table. Do use the join condition `T1.document_ID = T2.document_ID` instead of missing the table relationship entirely. Do move the filter on `document_name = 'Summer Show'` to the `WHERE` clause applied to the joined `Documents` table instead of incorrectly applying it directly to the `paragraphs` table which lacks that column. The amended query now correctly counts paragraphs by joining to the Documents table to filter by document name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE document_name = 'Summer Show';",
            "SELECT COUNT(*) \nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ],
        "rule_sql": []
    },
    "361": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show paragraph details for paragraph with text 'Korea ' .",
        "ground_truth": "select other_details from paragraphs where paragraph_text like 'korea'",
        "amends": [
            "Do select `other_details` instead of `*` for the column list. Do reference `paragraph_text` instead of `text` as the column name in the WHERE clause. Do use `LIKE` with lowercase `'korea'` instead of `=` with uppercase `'Korea'` for pattern matching instead of exact case-sensitive matching. The amended query now correctly filters for text containing 'korea' case-insensitively and returns only the other_details column as specified."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE text = 'Korea';",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%';"
        ],
        "rule_sql": []
    },
    "362": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the details for the paragraph that includes the text 'Korea ' ?",
        "ground_truth": "select other_details from paragraphs where paragraph_text like 'korea'",
        "amends": [
            "Do select `other_details` instead of `*` for the column list. Do reference `paragraph_text` instead of `text` as the source column. Do use a case-sensitive `like 'korea'` pattern instead of a case-insensitive `LIKE '%Korea%'` pattern. The amended query now correctly filters for exact case matches on the paragraph_text column and returns only the other_details field instead of all columns.",
            "Do use lowercase `like 'korea'` instead of mixed case `LIKE 'Korea '` to ensure case-insensitive matching and remove the trailing space that would prevent matching most Korean-related text. The amended query now matches the right SQL's behavior by properly searching for the lowercase term without extraneous whitespace."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE text LIKE '%Korea%';",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE 'Korea '",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE 'korea'"
        ],
        "rule_sql": []
    },
    "363": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all paragraph ids and texts for the document with name 'Welcome to NY'.",
        "ground_truth": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",
        "amends": [
            "Do join `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying `paragraphs` table directly without any join. Do select `T1.paragraph_text` instead of `text` to use the correct column name. Do filter on `T2.Document_Name = 'Welcome to NY'` instead of filtering directly on `document_name` in the paragraphs table. Do use table aliases `T1` and `T2` instead of no aliases for better clarity. The amended query now correctly joins through the document relationship to filter by document name instead of assuming the paragraphs table contains document names directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paragraph_id, text FROM paragraphs WHERE document_name = 'Welcome to NY'",
            "SELECT T1.Paragraph_ID, T1.Paragraph_Text \nFROM Paragraphs AS T1 \nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID \nWHERE T2.Document_Name = 'Welcome to NY'"
        ],
        "rule_sql": []
    },
    "364": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?",
        "ground_truth": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",
        "amends": [
            "Do use `T1.paragraph_text` instead of `text` for the column selection. Do add `JOIN Documents AS T2` instead of querying only the paragraphs table. Do use `ON T1.document_id = T2.document_id` instead of no join condition. Do filter on `T2.Document_Name = 'Welcome to NY'` instead of `document_title = 'Welcome to NY'` to properly reference the document name from the joined table. Do add table aliases `T1` and `T2` instead of using unqualified column references. The amended query now correctly joins the tables and filters on the document name from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paragraph_id, text FROM paragraphs WHERE document_title = 'Welcome to NY';",
            "SELECT T1.Paragraph_ID, T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Welcome to NY'"
        ],
        "rule_sql": []
    },
    "365": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all paragraph texts for the document \"Customer reviews\".",
        "ground_truth": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"",
        "amends": [
            "Do reference `paragraph_text` instead of `text` in the SELECT list. Do join `Documents AS T2` instead of omitting it, using `LEFT JOIN` on `T1.document_id = T2.document_id` instead of no join condition. Do filter on `T2.document_name = \"Customer reviews\"` instead of `document_title = 'Customer reviews'` in the WHERE clause. The amended query now correctly retrieves paragraph text by joining through the document relationship rather than relying on a non-existent title column in the paragraphs table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM paragraphs WHERE document_title = 'Customer reviews';",
            "SELECT p.Paragraph_Text \nFROM Paragraphs p\nLEFT JOIN Documents d ON p.Document_ID = d.Document_ID\nWHERE d.Document_Name = 'Customer reviews'"
        ],
        "rule_sql": []
    },
    "366": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the paragraph texts for the document with the name 'Customer reviews'?",
        "ground_truth": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"",
        "amends": [
            "Do reference `T1.paragraph_text` from the `Paragraphs` table instead of directly selecting `paragraph_text` from `documents`. Do join `Paragraphs AS T1` with `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do filter on `T2.document_name = \"Customer reviews\"` instead of `name = 'Customer reviews'` to properly reference the document name column. The amended query now correctly retrieves paragraph text by joining the Paragraphs and Documents tables and filtering on the document name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paragraph_text FROM documents WHERE name = 'Customer reviews';",
            "SELECT T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Customer reviews'"
        ],
        "rule_sql": []
    },
    "367": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document ids and the number of paragraphs in each document. Order by document id.",
        "ground_truth": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, COUNT(*) FROM paragraphs GROUP BY document_id ORDER BY paragraph_id;"
        ],
        "rule_sql": []
    },
    "368": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.",
        "ground_truth": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, COUNT(*) FROM paragraphs GROUP BY document_id ORDER BY document_id;"
        ],
        "rule_sql": []
    },
    "369": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document ids, names and the number of paragraphs in each document.",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",
        "amends": [
            "Do join `Paragraphs AS T1` with `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do select `T2.document_name` instead of `name` and use `count(*)` instead of `COUNT(paragraph_id)`. Do group by only `T1.document_id` instead of grouping by both `document_id` and `name`. The amended query now correctly counts paragraphs per document while retrieving the document name from the joined Documents table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, name, COUNT(paragraph_id) FROM documents GROUP BY document_id, name",
            "SELECT T2.Document_ID, T2.Document_Name, COUNT(*) AS Number_Of_Paragraphs\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID\nGROUP BY T1.Document_ID"
        ],
        "rule_sql": []
    },
    "370": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids and names of each document, as well as the number of paragraphs in each?",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",
        "amends": [
            "Do use `JOIN` instead of `LEFT JOIN` to exclude documents without paragraphs. Do reference `T1.document_id` and `T2.document_name` instead of `d.id` and `d.name` with different aliases. Do use `count(*)` instead of `COUNT(p.id)` to count all rows rather than non-null paragraph IDs. Do group by `T1.document_id` only instead of both `d.id` and `d.name` since document_name is functionally dependent. Do remove the unnecessary alias `paragraph_count` instead of keeping it. The amended query now correctly counts paragraphs per document while excluding documents with no paragraphs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.id, d.name, COUNT(p.id) AS paragraph_count FROM documents d LEFT JOIN paragraphs p ON d.id = p.document_id GROUP BY d.id, d.name",
            "SELECT d.Document_ID, d.Document_Name, COUNT(*) \nFROM Documents d\nJOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID"
        ],
        "rule_sql": []
    },
    "371": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "List all document ids with at least two paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "372": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of documents that have 2 or more paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(paragraph_id) >= 2"
        ],
        "rule_sql": []
    },
    "373": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id and name with greatest number of paragraphs?",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.document_id` and `T2.document_name` instead of `document_id` and `name`. Do use `FROM Paragraphs AS T1 JOIN Documents AS T2` instead of `FROM documents`. Do add `ON T1.document_id = T2.document_id` join condition instead of omitting it. Do add `GROUP BY T1.document_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `paragraph_count DESC`. The amended query now correctly joins tables and counts paragraphs per document to find the document with the most paragraphs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, name FROM documents ORDER BY paragraph_count DESC LIMIT 1;",
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "374": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id and name of the document with the most paragraphs.",
        "ground_truth": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.document_id` and `T2.document_name` instead of `id` and `name`. Do use `FROM Paragraphs AS T1 JOIN Documents AS T2` instead of `FROM documents`. Do add `ON T1.document_id = T2.document_id` join condition instead of omitting it. Do add `GROUP BY T1.document_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `id DESC`. The amended query now correctly joins tables, groups by document, and orders by paragraph count to find the document with the most paragraphs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM documents ORDER BY id DESC LIMIT 1;",
            "SELECT T1.document_id, T2.document_name\nFROM Paragraphs AS T1\nJOIN Documents AS T2 ON T1.document_id = T2.document_id\nGROUP BY T1.document_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "375": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id with least number of paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do use `GROUP BY document_id` instead of omitting it, which enables proper aggregation. Do use `count(*)` instead of `COUNT(paragraph_id)` in the ORDER BY clause to count all rows per group rather than non-null paragraph_id values. Do move the aggregate function from the ORDER BY clause to operate on grouped results instead of attempting to use COUNT directly without grouping. The amended query now correctly groups by document_id and orders by the count of paragraphs per document to find the document with the fewest paragraphs, matching the intended behavior.",
            "Do remove `paragraph_count` alias from the SELECT list instead of including it, and do reference the aggregate function directly in ORDER BY as `count(*)` instead of using the alias `paragraph_count`. Do omit the explicit column alias in the SELECT clause instead of defining it, since the RIGHT_SQL does not include this alias in the output. The amended query now matches RIGHT_SQL's behavior by returning only document_id values ordered by the actual count of paragraphs without an intermediate alias."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM paragraphs ORDER BY COUNT(paragraph_id) ASC LIMIT 1;",
            "SELECT document_id, COUNT(*) as paragraph_count FROM Paragraphs GROUP BY document_id ORDER BY paragraph_count ASC LIMIT 1;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "376": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id of the document with the fewest paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `document_id` from the `Paragraphs` table instead of `id` from `documents`. Do use `GROUP BY document_id` with aggregation instead of selecting from a single table. Do order by `count(*) ASC` instead of `paragraphs DESC` to find the document with the fewest paragraphs. Do remove the incorrect column reference `paragraphs` and instead use the proper aggregate function to count paragraphs per document. The amended query now correctly identifies the document with the smallest number of paragraphs by counting and grouping, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM documents ORDER BY paragraphs DESC LIMIT 1;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "377": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the document id with 1 to 2 paragraphs?",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2",
        "amends": [
            "Do query from the `Paragraphs` table instead of the `documents` table. Do use `GROUP BY document_id` with a `HAVING count(*) BETWEEN 1 AND 2` clause instead of filtering `paragraph_count = 1 OR paragraph_count = 2` in the WHERE clause. Do aggregate paragraph counts using `count(*)` instead of relying on a pre-calculated `paragraph_count` column. The amended query now correctly counts paragraphs per document and filters for documents with exactly 1 or 2 paragraphs, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM documents WHERE paragraph_count = 1 OR paragraph_count = 2;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING COUNT(*) BETWEEN 1 AND 2"
        ],
        "rule_sql": []
    },
    "378": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Give the ids of documents that have between one and two paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(*) = 1 OR COUNT(*) = 2;"
        ],
        "rule_sql": []
    },
    "379": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show the document id with paragraph text 'Brazil' and 'Ireland'.",
        "ground_truth": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM paragraphs WHERE paragraph_text = 'Brazil' OR paragraph_text = 'Ireland'"
        ],
        "rule_sql": []
    },
    "380": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
        "ground_truth": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "amends": [
            "Do use `INTERSECT` to find document IDs that contain both specified texts instead of using `OR` which finds documents containing either text. Do reference the correct column name `paragraph_text` instead of `text` in both SELECT statements. Do use proper table name capitalization `Paragraphs` instead of `paragraphs`. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with OR conditions. The amended query now correctly identifies documents that contain both 'Brazil' and 'Ireland' rather than documents containing either one, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id FROM paragraphs WHERE text = 'Brazil' OR text = 'Ireland';",
            "SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Brazil'\nINTERSECT\nSELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Ireland'"
        ],
        "rule_sql": []
    },
    "381": {
        "db_id": "course_teach",
        "question": "How many teachers are there?",
        "ground_truth": "SELECT count(*) FROM teacher",
        "amends": [
            "Do select from `teacher` table instead of `students` table. The amended query now correctly counts records from the teacher table as specified in the target query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM teacher;"
        ],
        "rule_sql": []
    },
    "382": {
        "db_id": "course_teach",
        "question": "What is the total count of teachers?",
        "ground_truth": "SELECT count(*) FROM teacher",
        "amends": [
            "Do select from `teacher` table instead of `students` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM teacher;"
        ],
        "rule_sql": []
    },
    "383": {
        "db_id": "course_teach",
        "question": "List the names of teachers in ascending order of age.",
        "ground_truth": "SELECT Name FROM teacher ORDER BY Age ASC",
        "amends": [
            "Do use table name `teacher` instead of `teachers` and select column `Name` instead of `name`. Do order by `Age ASC` instead of `age DESC`, changing both the column name and sort direction. The amended query now correctly references the intended table and column names with proper casing and applies ascending ordering instead of descending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age DESC;",
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ],
        "rule_sql": []
    },
    "384": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers ordered by ascending age?",
        "ground_truth": "SELECT Name FROM teacher ORDER BY Age ASC",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do select the column `Name` instead of `name` to use proper case sensitivity. Do order by `Age` in `ASC` order instead of `DESC` to sort in ascending rather than descending sequence. The amended query now correctly retrieves teacher names sorted by age in ascending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age DESC;",
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ],
        "rule_sql": []
    },
    "385": {
        "db_id": "course_teach",
        "question": "What are the age and hometown of teachers?",
        "ground_truth": "SELECT Age ,  Hometown FROM teacher",
        "amends": [
            "Do select `Age` and `Hometown` columns instead of `name` and `subject`. Do reference the `teacher` table instead of `teachers`. The amended query now correctly retrieves age and hometown information from the teacher table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, subject FROM teachers;",
            "SELECT Age, Hometown FROM teacher;"
        ],
        "rule_sql": []
    },
    "386": {
        "db_id": "course_teach",
        "question": "What is the age and hometown of every teacher?",
        "ground_truth": "SELECT Age ,  Hometown FROM teacher",
        "amends": [
            "Do select `Age` and `Hometown` columns instead of `name` and `subject`. Do reference the `teacher` table instead of `teachers`. The amended query now correctly retrieves age and hometown information from the teacher table as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, subject FROM teachers;",
            "SELECT Age, Hometown FROM teacher;"
        ],
        "rule_sql": []
    },
    "387": {
        "db_id": "course_teach",
        "question": "List the name of teachers whose hometown is not `` Little Lever Urban District '' .",
        "ground_truth": "select name from teacher where hometown != \"little lever urban district\"",
        "amends": [
            "Do reference table `teacher` instead of `teachers` in the FROM clause. Do use inequality filter `!= \"little lever urban district\"` instead of equality filter `= 'Little Lever Urban District'` in the WHERE clause. The amended query now correctly selects from the proper table and filters for records where hometown is not equal to the specified value, matching the intended behavior.",
            "Do use lowercase SQL keywords throughout instead of mixed case formatting. Do use lowercase string comparison for \"little lever urban district\" instead of title case formatting. The query logic remains identical with no changes to SELECT list, FROM sources, WHERE filters, or any other structural elements. The amended query now matches RIGHT_SQL's behavior with case-insensitive equivalent execution."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE hometown = 'Little Lever Urban District';",
            "SELECT Name FROM teacher WHERE Hometown != \"Little Lever Urban District\"",
            "SELECT name FROM teacher WHERE hometown != \"little lever urban district\""
        ],
        "rule_sql": []
    },
    "388": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?",
        "ground_truth": "select name from teacher where hometown != \"little lever urban district\"",
        "amends": [
            "Do reference table `teacher` instead of `teachers` in the FROM clause. Do use inequality filter `!= \"little lever urban district\"` instead of equality filter `= 'Little Lever Urban District'` in the WHERE clause. The amended query now correctly filters for teachers not from Little Lever Urban District instead of those from it, matching the intended behavior.",
            "Do use lowercase `select` instead of uppercase `SELECT`, lowercase `from` instead of uppercase `FROM`, lowercase `where` instead of uppercase `WHERE`, and lowercase `name` instead of uppercase `Name` to maintain consistent casing throughout the query. Do use lowercase `hometown` instead of uppercase `Hometown` and lowercase `little lever urban district` instead of capitalized `Little Lever Urban District` for case consistency in both column reference and string comparison. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE hometown = 'Little Lever Urban District';",
            "SELECT Name FROM teacher WHERE Hometown != \"Little Lever Urban District\"",
            "select name from teacher where hometown != \"little lever urban district\""
        ],
        "rule_sql": []
    },
    "389": {
        "db_id": "course_teach",
        "question": "Show the name of teachers aged either 32 or 33?",
        "ground_truth": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "amends": [
            "Do use `OR` between the age conditions instead of `AND` to find teachers who are either 32 or 33 years old instead of requiring both conditions simultaneously. Do reference the correct table name `teacher` instead of `teachers` and use proper column casing with `Name` and `Age` instead of lowercase `name` and `age`. The amended query now correctly returns teachers who are either 32 or 33 years old, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE age = 32 AND age = 33;",
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ],
        "rule_sql": []
    },
    "390": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers who are aged either 32 or 33?",
        "ground_truth": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` and use column names `Name` and `Age` instead of `name` and `age` to match the correct schema, while maintaining the same filter condition `Age = 32 OR Age = 33` instead of changing the logic. The amended query now correctly selects from the intended table with proper column names while preserving the original age filter behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE age = 32 OR age = 33;",
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ],
        "rule_sql": []
    },
    "391": {
        "db_id": "course_teach",
        "question": "What is the hometown of the youngest teacher?",
        "ground_truth": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do capitalize column names as `Hometown` and `Age` instead of lowercase `hometown` and `age` to maintain proper case sensitivity. The amended query now correctly selects from the teacher table with proper column casing while preserving the same ordering and limiting behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown FROM teachers ORDER BY age ASC LIMIT 1;",
            "SELECT Hometown FROM teacher ORDER BY CAST(Age AS INTEGER) ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "392": {
        "db_id": "course_teach",
        "question": "Where is the youngest teacher from?",
        "ground_truth": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do select `Hometown` instead of `name` and reference `teacher` instead of `teachers` as the table source, while maintaining the `ORDER BY Age ASC LIMIT 1` clause unchanged."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age ASC LIMIT 1;",
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "393": {
        "db_id": "course_teach",
        "question": "Show different hometown of teachers and the number of teachers from each hometown.",
        "ground_truth": "SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` in the FROM clause. Do group by `Hometown` instead of `teacher_id` to correctly count teachers by their hometown rather than counting each teacher individually. Do capitalize `Hometown` in the SELECT list instead of lowercase `hometown` for consistency. The amended query now correctly counts teachers grouped by their hometown locations rather than producing incorrect per-teacher counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM teachers GROUP BY teacher_id;",
            "SELECT Hometown, COUNT(*) AS Number_of_Teachers FROM teacher GROUP BY Hometown;"
        ],
        "rule_sql": []
    },
    "394": {
        "db_id": "course_teach",
        "question": "For each hometown, how many teachers are there?",
        "ground_truth": "SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` in the FROM clause. Do group by `Hometown` instead of `teacher_id` to correctly count teachers by their hometowns. Do capitalize `Hometown` in the SELECT list instead of lowercase `hometown` for consistency. The amended query now correctly counts teachers grouped by their hometown locations rather than by individual teacher IDs, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM teachers GROUP BY teacher_id;",
            "SELECT Hometown, COUNT(*) AS teacher_count FROM teacher GROUP BY Hometown"
        ],
        "rule_sql": []
    },
    "395": {
        "db_id": "course_teach",
        "question": "List the most common hometown of teachers.",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use the table name `teacher` instead of `teachers` and capitalize `Hometown` instead of lowercase `hometown` in both the SELECT list and GROUP BY clause. Do remove the alias `count` from the aggregate function and instead reference `COUNT(*)` directly in the ORDER BY clause instead of using the alias. Do maintain the same GROUP BY and ORDER BY logic but with corrected table name and column capitalization. The amended query now correctly references the actual table schema while preserving the intended behavior of finding the hometown with the highest count of teachers.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Hometown with the highest count rather than both the Hometown and its count value. The amended query now correctly returns just the Hometown column while maintaining the same GROUP BY, ORDER BY, and LIMIT logic to identify the hometown with the most teachers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM teachers GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT Hometown, COUNT(*) FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "396": {
        "db_id": "course_teach",
        "question": "What is the most commmon hometowns for teachers?",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do capitalize `Hometown` in both the SELECT list and GROUP BY clause instead of using lowercase `hometown` for consistency with the correct column name. Do remove the alias `count` from the COUNT(*) expression instead of keeping it, as the RIGHT_SQL does not include an alias. Do maintain the same aggregation logic with `COUNT(*)` in the ORDER BY clause instead of referencing the removed alias, ensuring the query correctly orders by the count of records per hometown. The amended query now correctly identifies the hometown with the highest count of teachers by using the proper table name and column casing while preserving the core aggregation and ordering logic.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Hometown with the highest count rather than both the Hometown and its count value. The amended query now matches RIGHT_SQL's behavior by returning just the single Hometown with the maximum occurrence count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown, COUNT(*) as count FROM teachers GROUP BY hometown ORDER BY count DESC LIMIT 1;",
            "SELECT Hometown, COUNT(*) FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "397": {
        "db_id": "course_teach",
        "question": "Show the hometowns shared by at least two teachers.",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `COUNT(*) >= 2` instead of `COUNT(*) = 1` in the HAVING clause to find hometowns with at least two teachers rather than exactly one. Do reference the table as `teacher` instead of `teachers` and use the correct column name `Hometown` instead of `hometown` to match the actual schema. The amended query now correctly identifies hometowns with multiple teachers and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hometown FROM teachers GROUP BY hometown HAVING COUNT(*) = 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "398": {
        "db_id": "course_teach",
        "question": "What are the towns from which at least two teachers come from?",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use column name `Hometown` instead of `town` and table name `teacher` instead of `teachers` to match the correct schema. Do change the comparison operator to `>= 2` instead of `> 1` to properly identify hometowns with at least two teachers, which correctly captures the same logical condition while using inclusive comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT town FROM teachers GROUP BY town HAVING COUNT(*) > 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "399": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the courses they are arranged to teach.",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `course_arrange AS T1` as the primary table instead of `teachers`, and join `course AS T2` on `T1.Course_ID = T2.Course_ID` instead of directly joining courses. Do add a second join to `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of joining teachers directly to courses. The amended query now correctly uses the course_arrange table as a bridge between teachers and courses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers JOIN courses ON teachers.teacher_id = courses.teacher_id;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID"
        ],
        "rule_sql": []
    },
    "400": {
        "db_id": "course_teach",
        "question": "What is the name of each teacher and what course they teach?",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `course_arrange AS T1` joined with `course AS T2` on `T1.Course_ID = T2.Course_ID` instead of directly joining `teachers` with `courses`. Do add a second join with `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of the incorrect join condition `teachers.teacher_id = students.student_id` which referenced a non-existent table. The amended query now correctly establishes relationships through the junction table and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers JOIN courses ON teachers.teacher_id = students.student_id;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID;"
        ],
        "rule_sql": []
    },
    "401": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do join `course_arrange AS T1` with `course AS T2` on `T1.Course_ID = T2.Course_ID` and join `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of querying only from `teachers`. Do order by `T3.Name` instead of `course_name`. The amended query now correctly joins multiple tables to retrieve teacher names and course names with proper relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers ORDER BY course_name ASC;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC;"
        ],
        "rule_sql": []
    },
    "402": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of the single table `FROM teachers`. Do order by `T3.Name` instead of `course_name ASC`. The amended query now correctly joins multiple tables to retrieve teacher names and course names from their respective source tables rather than assuming they exist in a single table, and orders the results by teacher name instead of course name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers ORDER BY course_name ASC;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC"
        ],
        "rule_sql": []
    },
    "403": {
        "db_id": "course_teach",
        "question": "Show the name of the teacher for the math course.",
        "ground_truth": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"",
        "amends": [
            "Do select `T3.Name` from the `teacher` table instead of `teacher_name` from `courses`. Do join three tables using `course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of querying only the `courses` table. Do filter on `T2.Course = \"Math\"` instead of `subject = 'math'` to properly reference the course name field. The amended query now correctly joins the necessary tables to retrieve teacher names for math courses, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name FROM courses WHERE subject = 'math';",
            "SELECT T3.Name \nFROM course_arrange AS T1 \nJOIN course AS T2 ON T1.Course_ID = T2.Course_ID \nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID \nWHERE T2.Course = 'Math'"
        ],
        "rule_sql": []
    },
    "404": {
        "db_id": "course_teach",
        "question": "What are the names of the people who teach math courses?",
        "ground_truth": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"",
        "amends": [
            "Do select `T3.Name` from the `teacher` table instead of `name` from `teachers`. Do use a multi-table join structure with `course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of querying only the `teachers` table. Do filter on `T2.Course = \"Math\"` instead of `subject = 'math'` to properly identify math courses through the course table relationship. The amended query now correctly retrieves teacher names by joining through the course arrangement and course tables to establish the proper relationships between teachers and math courses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE subject = 'math';",
            "SELECT T3.Name \nFROM course_arrange AS T1 \nJOIN course AS T2 ON T1.Course_ID = T2.Course_ID \nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID \nWHERE T2.Course = 'Math'"
        ],
        "rule_sql": []
    },
    "405": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the number of courses they teach.",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying `teachers` table directly. Do select `T2.Name` instead of `teacher_name` and maintain `COUNT(*)` aggregation. Do group by `T2.Name` instead of `teacher_name` to properly count course arrangements per teacher. The amended query now correctly joins the course arrangement and teacher tables to count courses per teacher rather than attempting to count from a teachers table directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name, COUNT(*) FROM teachers GROUP BY teacher_name;",
            "SELECT T2.Name, COUNT(*) AS NumberOfCourses FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name"
        ],
        "rule_sql": []
    },
    "406": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers and how many courses do they teach?",
        "ground_truth": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying only the `teachers` table. Do select `T2.Name` instead of `teacher_name` while keeping `COUNT(*)`. Do group by `T2.Name` instead of `teacher_name` to properly count course arrangements per teacher. The amended query now correctly joins the course arrangement and teacher tables to count courses per teacher rather than attempting to count from a single teachers table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_name, COUNT(*) FROM teachers GROUP BY teacher_name;",
            "SELECT T2.Name, COUNT(*) \nFROM course_arrange AS T1 \nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID \nGROUP BY T2.Name"
        ],
        "rule_sql": []
    },
    "407": {
        "db_id": "course_teach",
        "question": "Show names of teachers that teach at least two courses.",
        "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `T2.Name` from the `teacher` table instead of `name` from the `teachers` table. Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying a single table. Do add `GROUP BY T2.Name` to aggregate by teacher name instead of no grouping. Do move the count filter to `HAVING COUNT(*) >= 2` instead of using `WHERE course_count >= 2` on a non-aggregated column. The amended query now correctly counts course assignments per teacher and filters for those with at least two courses, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE course_count >= 2;",
            "SELECT T2.Name\nFROM course_arrange AS T1\nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID\nGROUP BY T2.Name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "408": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers who teach at least two courses?",
        "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying only the `teachers` table. Do aggregate with `GROUP BY T2.Name` and filter with `HAVING COUNT(*) >= 2` instead of using `WHERE course_count >= 2` on a non-aggregated column. Do select `T2.Name` from the joined teacher table instead of selecting `name` directly from the original teachers table. The amended query now correctly counts actual course assignments per teacher rather than relying on a potentially incorrect course_count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE course_count >= 2;",
            "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "409": {
        "db_id": "course_teach",
        "question": "List the names of teachers who have not been arranged to teach courses.",
        "ground_truth": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` and use column `Teacher_id` instead of `teacher_id` in the main query. Do reference the `course_arrange` table instead of `courses` in the subquery and use column `Teacher_id` instead of `teacher_id` in the subquery's SELECT clause. Do use column `Name` instead of `name` in the SELECT list to match the correct schema. The amended query now correctly identifies teachers not assigned to any courses by using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE teacher_id NOT IN (SELECT teacher_id FROM courses)",
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ],
        "rule_sql": []
    },
    "410": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers whose courses have not been arranged?",
        "ground_truth": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "amends": [
            "Do use a simple `SELECT Name FROM teacher` instead of joining tables with `LEFT JOIN courses`. Do filter with `WHERE Teacher_id NOT IN` subquery instead of `WHERE c.teacher_id IS NOT NULL`. Do reference the correct table `teacher` instead of `teachers` and use proper column names `Teacher_id` instead of `teacher_id`. Do remove the unnecessary join condition and instead use a subquery `(SELECT Teacher_id FROM course_arrange)` to check for non-assigned teachers. The amended query now correctly identifies teachers not assigned to any courses by using a NOT IN subquery instead of an incorrectly filtered left join."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.name FROM teachers t LEFT JOIN courses c ON t.id = c.teacher_id WHERE c.teacher_id IS NOT NULL;",
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ],
        "rule_sql": []
    },
    "411": {
        "db_id": "museum_visit",
        "question": "How many visitors below age 30 are there?",
        "ground_truth": "SELECT count(*) FROM visitor WHERE age  <  30",
        "amends": [
            "Do reference table `visitor` instead of `visitors` to use the correct table name. Do use filter `age < 30` instead of `age > 30` to count visitors under 30 rather than over 30. The amended query now correctly counts visitors under age 30 from the proper table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM visitors WHERE age > 30;",
            "SELECT COUNT(*) FROM visitor WHERE Age < 30"
        ],
        "rule_sql": []
    },
    "412": {
        "db_id": "museum_visit",
        "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.",
        "ground_truth": "SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC",
        "amends": [
            "Do reference table `visitor` instead of `visitors` in the FROM clause. Do use column `Level_of_membership` instead of `membership_level` in both the WHERE filter and ORDER BY clause. Do sort by `Level_of_membership DESC` instead of `ASC` to order in descending rather than ascending sequence. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM visitors WHERE membership_level > 4 ORDER BY membership_level ASC;",
            "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC;"
        ],
        "rule_sql": []
    },
    "413": {
        "db_id": "museum_visit",
        "question": "What is the average age of the visitors whose membership level is not higher than 4?",
        "ground_truth": "SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4",
        "amends": [
            "Do use table name `visitor` instead of `visitors`. Do change the filter condition to `Level_of_membership <= 4` instead of `membership_level > 4`, which reverses the logic to include members with lower membership levels rather than excluding them. Do use lowercase `avg(age)` instead of uppercase `AVG(age)` for the aggregate function, though this is a cosmetic change that doesn't affect functionality. The amended query now correctly calculates the average age for visitors with membership level 4 or below instead of those above level 4, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM visitors WHERE membership_level > 4;",
            "SELECT avg(age) FROM visitor WHERE Level_of_membership <= 4"
        ],
        "rule_sql": []
    },
    "414": {
        "db_id": "museum_visit",
        "question": "Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.",
        "ground_truth": "SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC",
        "amends": [
            "Do use column alias `Level_of_membership` instead of `membership_level` in the SELECT list. Do reference table `visitor` instead of `visitors` in the FROM clause. Do change the ORDER BY direction to `DESC` instead of `ASC` for the `age` column. The amended query now correctly matches the intended behavior with the proper table name, column alias, and descending age ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, membership_level FROM visitors WHERE membership_level > 4 ORDER BY age ASC;",
            "SELECT Name, Level_of_membership FROM visitor WHERE Level_of_membership > 4 ORDER BY Age DESC;"
        ],
        "rule_sql": []
    },
    "415": {
        "db_id": "museum_visit",
        "question": "Find the id and name of the museum that has the most staff members?",
        "ground_truth": "SELECT museum_id ,  name FROM museum ORDER BY num_of_staff DESC LIMIT 1",
        "amends": [
            "Do use column name `museum_id` instead of `id` and table name `museum` instead of `museums`. Do use column `num_of_staff` for ordering instead of `staff_count`. The amended query now correctly references the museum table structure and ordering column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM museums ORDER BY staff_count DESC LIMIT 1;",
            "SELECT Museum_ID, Name FROM museum ORDER BY Num_of_Staff DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "416": {
        "db_id": "museum_visit",
        "question": "Find the average number of staff working for the museums that were open before 2009.",
        "ground_truth": "SELECT avg(num_of_staff) FROM museum WHERE open_year  <  2009",
        "amends": [
            "Do use table name `museum` instead of `museums` and column name `num_of_staff` instead of `staff_count` for the aggregate function. Do use column `open_year` instead of `year_opened` in the WHERE filter condition. Do use lowercase `avg` instead of uppercase `AVG` for the aggregate function. The amended query now correctly calculates the average number of staff from the museum table for institutions opened before 2009."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(staff_count) FROM museums WHERE year_opened < 2009;",
            "SELECT avg(Num_of_Staff) FROM museum WHERE Open_Year < '2009'"
        ],
        "rule_sql": []
    },
    "417": {
        "db_id": "museum_visit",
        "question": "What are the opening year and staff number of the museum named Plaza Museum?",
        "ground_truth": "SELECT Num_of_Staff ,  Open_Year FROM museum WHERE name  =  'Plaza Museum'",
        "amends": [
            "Do use column aliases `Num_of_Staff` and `Open_Year` instead of the original column names `staff_number` and `opening_year`. Do reference the table as `museum` instead of `museums` while maintaining the same `WHERE` filter condition `name = 'Plaza Museum'`. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column selection and table reference.",
            "Do reverse the column order by selecting `Num_of_Staff, Open_Year` instead of `Open_Year, Num_of_Staff`. Do use lowercase `name` in the WHERE clause instead of uppercase `Name` while maintaining the same filter condition `= 'Plaza Museum'`. The amended query now matches RIGHT_SQL's behavior with identical column output and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT opening_year, staff_number FROM museums WHERE name = 'Plaza Museum';",
            "SELECT Open_Year, Num_of_Staff FROM museum WHERE Name = 'Plaza Museum';",
            "SELECT Num_of_Staff, Open_Year FROM museum WHERE name = 'Plaza Museum'"
        ],
        "rule_sql": []
    },
    "418": {
        "db_id": "museum_visit",
        "question": "find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.",
        "ground_truth": "SELECT name FROM museum WHERE num_of_staff  >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010)",
        "amends": [
            "Do reference table `museum` instead of `museums` in both the main query and subquery. Do use column `num_of_staff` instead of `staff_count` for the staff count comparison. Do use column `open_year` instead of `year_opened` for the year filter in the subquery. The amended query now correctly filters museums where staff count exceeds the minimum staff count of museums opened after 2010, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM museums WHERE staff_count > (SELECT MIN(staff_count) FROM museums WHERE year_opened > 2010);",
            "SELECT Name FROM museum WHERE Num_of_Staff > (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > '2010')"
        ],
        "rule_sql": []
    },
    "419": {
        "db_id": "museum_visit",
        "question": "find the id, name and age for visitors who visited some museums more than once.",
        "ground_truth": "SELECT t1.id ,  t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t1.id HAVING count(*)  >  1",
        "amends": [
            "Do use explicit table aliases `t1` and `t2` instead of bare table names. Do join `visitor AS t1` with `visit AS t2` on `t1.id = t2.visitor_id` instead of using a subquery with `museum_id` filtering. Do group by `t1.id` instead of grouping by `visitor_id, museum_id` in the subquery. Do move the count condition to `HAVING count(*) > 1` instead of using `HAVING COUNT(*) > 1` in a subquery. Do remove the `museum_id` filter entirely instead of including it in the subquery condition. The amended query now correctly identifies visitors with multiple visits by joining directly between visitor and visit tables and grouping by visitor ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name, age FROM visitors WHERE museum_id IN (SELECT museum_id FROM visits GROUP BY visitor_id, museum_id HAVING COUNT(*) > 1);",
            "SELECT t1.ID, t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nGROUP BY t1.ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "420": {
        "db_id": "museum_visit",
        "question": "What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?",
        "ground_truth": "SELECT t2.visitor_id ,  t1.name ,  t1.Level_of_membership FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t2.visitor_id ORDER BY sum(t2.Total_spent) DESC LIMIT 1",
        "amends": [
            "Do select `t2.visitor_id`, `t1.name`, and `t1.Level_of_membership` instead of `v.id`, `v.name`, and `v.membership_level`. Do use table aliases `t1` for `visitor` and `t2` for `visit` instead of `v` for `visitors` and `t` for `tickets`. Do join `visit` table instead of `tickets` table. Do reference `t2.Total_spent` in the aggregate instead of `t.price`. Do order by `sum(t2.Total_spent) DESC` instead of `total_spent ASC`. Do remove the explicit `GROUP BY` clause for name and membership level instead of including them. The amended query now correctly identifies the highest spending visitor by joining the appropriate tables and using the correct spending column with descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT v.id, v.name, v.membership_level, SUM(t.price) as total_spent\nFROM visitors v\nJOIN tickets t ON v.id = t.visitor_id\nGROUP BY v.id, v.name, v.membership_level\nORDER BY total_spent ASC\nLIMIT 1;",
            "SELECT t2.visitor_ID, t1.Name, t1.Level_of_membership\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nGROUP BY t2.visitor_ID\nORDER BY SUM(t2.Total_spent) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "421": {
        "db_id": "museum_visit",
        "question": "What are the id and name of the museum visited most times?",
        "ground_truth": "SELECT t2.Museum_ID ,  t1.name FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID GROUP BY t2.Museum_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.Museum_ID` and `t1.name` instead of `museum_id` and `name`. Do join `museum AS t1` with `visit AS t2` on `t1.Museum_ID = t2.Museum_ID` instead of querying only the `museums` table. Do add `GROUP BY t2.Museum_ID` instead of omitting grouping. Do order by `count(*) DESC` instead of `visit_count DESC` to count actual visits. The amended query now correctly identifies the museum with the most visits by joining the museum and visit tables and counting occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT museum_id, name FROM museums ORDER BY visit_count DESC LIMIT 1;",
            "SELECT t2.Museum_ID, t1.Name\nFROM museum AS t1\nJOIN visit AS t2 ON t1.Museum_ID = t2.Museum_ID\nGROUP BY t2.Museum_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "422": {
        "db_id": "museum_visit",
        "question": "What is the name of the museum that had no visitor yet?",
        "ground_truth": "SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit)",
        "amends": [
            "Do reference table `museum` instead of `museums` in the FROM clause. Do use a subquery with `NOT IN` condition on `Museum_ID` instead of filtering by `visitor_count = 0`. Do check for absence of records in the `visit` table instead of relying on a potentially incorrect `visitor_count` column. The amended query now correctly identifies museums without any visits by checking the relationship table instead of using a direct count field that may not exist or be accurate."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM museums WHERE visitor_count = 0;",
            "SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit)"
        ],
        "rule_sql": []
    },
    "423": {
        "db_id": "museum_visit",
        "question": "Find the name and age of the visitor who bought the most tickets at once.",
        "ground_truth": "SELECT t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id ORDER BY t2.num_of_ticket DESC LIMIT 1",
        "amends": [
            "Do select `t1.name` and `t1.age` with explicit table aliases instead of just `name` and `age` without table qualification. Do add `FROM visitor AS t1 JOIN visit AS t2` with an explicit join instead of just `FROM visitors` as a single table. Do use join condition `ON t1.id = t2.visitor_id` to properly relate the tables instead of missing the join entirely. Do order by `t2.num_of_ticket DESC` from the joined visit table instead of `tickets_bought DESC` which doesn't exist in the schema. The amended query now correctly joins the visitor and visit tables to find the visitor with the most tickets purchased, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM visitors ORDER BY tickets_bought DESC LIMIT 1;",
            "SELECT t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nORDER BY t2.Num_of_Ticket DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "424": {
        "db_id": "museum_visit",
        "question": "What are the average and maximum number of tickets bought in all visits?",
        "ground_truth": "SELECT avg(num_of_ticket) ,  max(num_of_ticket) FROM visit",
        "amends": [
            "Do use `avg(num_of_ticket)` and `max(num_of_ticket)` instead of `AVG(tickets_bought)` and `MIN(tickets_bought)` for the aggregate functions and column references. Do reference the `visit` table instead of `visits` as the data source. The amended query now correctly calculates the average and maximum number of tickets from the appropriate table and columns, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(tickets_bought) as average_tickets, MIN(tickets_bought) as max_tickets FROM visits;",
            "SELECT AVG(Num_of_Ticket) AS average_tickets, MAX(Num_of_Ticket) AS maximum_tickets FROM visit;"
        ],
        "rule_sql": []
    },
    "425": {
        "db_id": "museum_visit",
        "question": "What is the total ticket expense of the visitors whose membership level is 1?",
        "ground_truth": "SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1",
        "amends": [
            "Do use `sum(t2.Total_spent)` instead of `SUM(ticket_price)` for the aggregate calculation. Do join `visit AS t2` on `t1.id = t2.visitor_id` instead of querying only the `visitors` table. Do reference `t1.Level_of_membership` instead of `membership_level` in the WHERE filter condition. Do add the required table join structure instead of querying a single table. The amended query now correctly calculates total spending from the visit table for visitors with the specified membership level."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(ticket_price) FROM visitors WHERE membership_level = 1;",
            "SELECT SUM(t2.Total_spent) AS total_expense\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nWHERE t1.Level_of_membership = 1"
        ],
        "rule_sql": []
    },
    "426": {
        "db_id": "museum_visit",
        "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
        "ground_truth": "SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011",
        "amends": [
            "Do use `INTERSECT` to find visitors who meet both conditions instead of `OR` with `GROUP BY/HAVING`. Do reference tables as `visitor`, `visit`, and `museum` instead of `visitors`, `visits`, and `museums`. Do join on `t3.Museum_ID = t2.Museum_ID` instead of `vi.museum_id = m.id`. Do filter on `t3.open_year < 2009` in the first branch and `t3.open_year > 2011` in the second branch instead of `m.opening_year < 2009 OR m.opening_year > 2011`. Do remove `GROUP BY v.id` and `HAVING COUNT(DISTINCT m.id) >= 2` instead of keeping them, as the INTERSECT approach correctly identifies visitors who visited museums in both time periods. Do select from separate query branches for each time period instead of a single query with OR logic. The amended query now correctly matches RIGHT_SQL's behavior using set intersection to find visitors who visited museums both before 2009 and after 2011."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT v.name \nFROM visitors v\nJOIN visits vi ON v.id = vi.visitor_id\nJOIN museums m ON vi.museum_id = m.id\nWHERE m.opening_year < 2009 OR m.opening_year > 2011\nGROUP BY v.id\nHAVING COUNT(DISTINCT m.id) >= 2;",
            "SELECT v.Name\nFROM visitor v\nWHERE v.ID IN (\n    SELECT vi.visitor_ID\n    FROM visit vi\n    JOIN museum m ON vi.Museum_ID = m.Museum_ID\n    WHERE m.Open_Year < '2009'\n    INTERSECT\n    SELECT vi.visitor_ID\n    FROM visit vi\n    JOIN museum m ON vi.Museum_ID = m.Museum_ID\n    WHERE m.Open_Year > '2011'\n)"
        ],
        "rule_sql": []
    },
    "427": {
        "db_id": "museum_visit",
        "question": "Find the number of visitors who did not visit any museum opened after 2010.",
        "ground_truth": "SELECT count(*) FROM visitor WHERE id NOT IN (SELECT t2.visitor_id FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID WHERE t1.open_year  >  2010)",
        "amends": [
            "Do reference the `visitor` table instead of `visitors` and use `id` instead of `visitor_id` for the main table. Do use an explicit join between `museum` and `visit` tables with `ON t1.Museum_ID = t2.Museum_ID` instead of nested subqueries. Do filter on `t1.open_year > 2010` instead of `year_opened > 2010` and reference `t2.visitor_id` in the subquery instead of just `visitor_id`. Do use proper table aliases `t1` and `t2` throughout the subquery instead of anonymous table references. The amended query now correctly identifies visitors who haven't visited museums opened after 2010 using proper table relationships and joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM visitors WHERE visitor_id NOT IN (SELECT visitor_id FROM visits WHERE museum_id IN (SELECT museum_id FROM museums WHERE year_opened > 2010))",
            "SELECT COUNT(*) \nFROM visitor \nWHERE ID NOT IN (\n    SELECT DISTINCT t2.visitor_ID \n    FROM museum t1 \n    JOIN visit t2 ON t1.Museum_ID = t2.Museum_ID \n    WHERE t1.Open_Year > '2010'\n)"
        ],
        "rule_sql": []
    },
    "428": {
        "db_id": "museum_visit",
        "question": "How many museums were opened after 2013 or before 2008?",
        "ground_truth": "SELECT count(*) FROM museum WHERE open_year  >  2013 OR open_year  <  2008",
        "amends": [
            "Do reference table `museum` instead of `museums` and use column `open_year` instead of `opened_year`. Do use `OR` operator instead of `AND` to correctly count records where the year is either greater than 2013 or less than 2008, instead of incorrectly using `AND` which would return no results since a year cannot be both greater than 2013 and less than 2008 simultaneously. The amended query now matches the intended behavior of counting museums opened either after 2013 or before 2008."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM museums WHERE opened_year > 2013 AND opened_year < 2008;",
            "SELECT COUNT(*) FROM museum WHERE Open_Year > '2013' OR Open_Year < '2008';"
        ],
        "rule_sql": []
    },
    "429": {
        "db_id": "wta_1",
        "question": "Find the total number of players.",
        "ground_truth": "SELECT count(*) FROM players",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches RIGHT_SQL's behavior with identical functionality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE team = 'Lakers';",
            "SELECT count(*) FROM players;"
        ],
        "rule_sql": []
    },
    "430": {
        "db_id": "wta_1",
        "question": "How many players are there?",
        "ground_truth": "SELECT count(*) FROM players",
        "amends": [
            "Do select from `players` table instead of `teams` table. The amended query now correctly counts records from the players table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM teams;",
            "SELECT COUNT(*) FROM players;"
        ],
        "rule_sql": []
    },
    "431": {
        "db_id": "wta_1",
        "question": "Find the total number of matches.",
        "ground_truth": "SELECT count(*) FROM matches",
        "amends": [
            "Do query the `matches` table instead of the `players` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the matches table rather than players."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT count(*) FROM matches;"
        ],
        "rule_sql": []
    },
    "432": {
        "db_id": "wta_1",
        "question": "Count the number of matches.",
        "ground_truth": "SELECT count(*) FROM matches",
        "amends": [
            "Do query the `matches` table instead of the `players` table. The amended query now correctly counts records from the matches table as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(*) FROM matches;"
        ],
        "rule_sql": []
    },
    "433": {
        "db_id": "wta_1",
        "question": "List the first name and birth date of all players from the country with code USA.",
        "ground_truth": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",
        "amends": [
            "Do use `'USA'` as the country code filter instead of `'CANADA'` in the WHERE clause. The amended query now correctly filters for players from the USA instead of Canada, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, birth_date FROM players WHERE country_code = 'CANADA';",
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ],
        "rule_sql": []
    },
    "434": {
        "db_id": "wta_1",
        "question": "What are the first names and birth dates of players from the USA?",
        "ground_truth": "SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",
        "amends": [
            "Do use `country_code` instead of `country` in the WHERE filter. Do filter for `'USA'` instead of `'Canada'` as the country condition. The amended query now correctly filters by country_code for USA instead of using country for Canada."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, birth_date FROM players WHERE country = 'Canada';",
            "SELECT first_name, birth_date FROM players WHERE country_code = 'USA';"
        ],
        "rule_sql": []
    },
    "435": {
        "db_id": "wta_1",
        "question": "Find the average age of losers and winners of all matches.",
        "ground_truth": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
        "amends": [
            "Do select `avg(loser_age)` and `avg(winner_age)` instead of a single `AVG(age)` aggregate. Do remove the `WHERE result = 'loser' OR result = 'winner'` filter instead of keeping it, as the right query calculates separate averages for both loser and winner ages directly from the table columns without filtering. The amended query now correctly computes two distinct average values for loser_age and winner_age columns instead of attempting to average a single age column with conditional filtering, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM matches WHERE result = 'loser' OR result = 'winner';",
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches"
        ],
        "rule_sql": []
    },
    "436": {
        "db_id": "wta_1",
        "question": "What are the average ages of losers and winners across matches?",
        "ground_truth": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
        "amends": [
            "Do use direct column references `avg(loser_age)` and `avg(winner_age)` instead of calculating averages with `CASE` statements that check `m.winner_id = p.player_id` and `m.loser_id = p.player_id`. Do remove the `JOIN players p` clause entirely instead of joining on `m.winner_id = p.player_id OR m.loser_id = p.player_id` since the right query operates solely on the matches table without player data. Do query from only the `matches` table instead of joining with the `players` table, indicating the original query incorrectly attempted to access player age data that isn't needed for this aggregation. The amended query now correctly calculates averages from existing match data columns rather than attempting to join with unrelated player information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    AVG(CASE WHEN m.winner_id = p.player_id THEN p.age ELSE NULL END) AS avg_winner_age,\n    AVG(CASE WHEN m.loser_id = p.player_id THEN p.age ELSE NULL END) AS avg_loser_age\nFROM matches m\nJOIN players p ON m.winner_id = p.player_id OR m.loser_id = p.player_id",
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ],
        "rule_sql": []
    },
    "437": {
        "db_id": "wta_1",
        "question": "Find the average rank of winners in all matches.",
        "ground_truth": "SELECT avg(winner_rank) FROM matches",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(winner_rank) FROM matches WHERE winner_rank IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "438": {
        "db_id": "wta_1",
        "question": "What is the average rank for winners in all matches?",
        "ground_truth": "SELECT avg(winner_rank) FROM matches",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(winner_rank) FROM matches WHERE winner_rank IS NOT NULL"
        ],
        "rule_sql": []
    },
    "439": {
        "db_id": "wta_1",
        "question": "Find the highest rank of losers in all matches.",
        "ground_truth": "SELECT min(loser_rank) FROM matches",
        "amends": [
            "Do use the `min` aggregate function instead of `max` to calculate the minimum value. Do reference the `loser_rank` column instead of `winner_rank` to analyze the losing player's ranking rather than the winner's ranking. The amended query now correctly identifies the minimum loser rank from the matches table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(winner_rank) FROM matches;",
            "SELECT MIN(loser_rank) AS highest_rank_of_losers FROM matches;"
        ],
        "rule_sql": []
    },
    "440": {
        "db_id": "wta_1",
        "question": "What is the best rank of losers across all matches?",
        "ground_truth": "SELECT min(loser_rank) FROM matches",
        "amends": [
            "Do use the `min` aggregate function on `loser_rank` instead of the `max` aggregate function on `winner_rank`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(winner_rank) FROM matches;",
            "SELECT MIN(loser_rank) AS best_rank FROM matches WHERE loser_rank IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "441": {
        "db_id": "wta_1",
        "question": "find the number of distinct country codes of all players.",
        "ground_truth": "SELECT count(DISTINCT country_code) FROM players",
        "amends": [
            "Do use `count(DISTINCT country_code)` instead of `COUNT(country_code)` to count unique country codes rather than counting all non-null values, which eliminates duplicate country codes from the count. The amended query now matches RIGHT_SQL's behavior by providing a distinct count of country codes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(country_code) FROM players;",
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ],
        "rule_sql": []
    },
    "442": {
        "db_id": "wta_1",
        "question": "How many distinct countries do players come from?",
        "ground_truth": "SELECT count(DISTINCT country_code) FROM players",
        "amends": [
            "Do `count(DISTINCT country_code)` instead of `COUNT(*)` to count distinct country codes rather than all rows. Do add the `country_code` column reference instead of omitting it to specify what to count distinctly. The amended query now correctly counts distinct country codes instead of total player records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ],
        "rule_sql": []
    },
    "443": {
        "db_id": "wta_1",
        "question": "Find the number of distinct name of losers.",
        "ground_truth": "SELECT count(DISTINCT loser_name) FROM matches",
        "amends": [
            "Do use `count(DISTINCT loser_name)` instead of `COUNT(name)` to count distinct values rather than all non-null values. Do query from `matches` table instead of `losers` table to access the correct data source. Do remove the unnecessary table reference `losers` instead of keeping it. The amended query now correctly counts distinct loser names from the matches table instead of counting all names from an incorrect table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(name) FROM losers;",
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ],
        "rule_sql": []
    },
    "444": {
        "db_id": "wta_1",
        "question": "How many different loser names are there?",
        "ground_truth": "SELECT count(DISTINCT loser_name) FROM matches",
        "amends": [
            "Do count `DISTINCT loser_name` instead of counting `winner_name` without distinct, which changes both the column being aggregated and adds deduplication to count unique values rather than all occurrences. This amendment shifts the focus from counting winner occurrences to counting distinct loser names, fundamentally altering the query's purpose to measure unique losers rather than total winner entries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(winner_name) FROM matches;",
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ],
        "rule_sql": []
    },
    "445": {
        "db_id": "wta_1",
        "question": "Find the name of tourney that has more than 10 matches.",
        "ground_truth": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10",
        "amends": [
            "Do use `GROUP BY tourney_name` with `HAVING count(*) > 10` instead of filtering `matches > 10` in the `WHERE` clause. Do query from the `matches` table instead of the `tourneys` table. Do aggregate with `count(*)` instead of directly comparing the `matches` column. The amended query now correctly identifies tournaments with more than 10 matches by counting actual match records rather than relying on a potentially incorrect stored count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tourney_name FROM tourneys WHERE matches > 10",
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ],
        "rule_sql": []
    },
    "446": {
        "db_id": "wta_1",
        "question": "What are the names of tournaments that have more than 10 matches?",
        "ground_truth": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10",
        "amends": [
            "Do select `tourney_name` instead of `tournament_name` and use `GROUP BY` with `HAVING count(*) > 10` instead of `WHERE COUNT(matches) > 10`. Do query from `matches` table instead of `tournaments` table and remove the incorrect aggregate function usage in the WHERE clause. The amended query now correctly groups matches by tournament name and filters for tournaments with more than 10 matches using proper HAVING clause syntax, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tournament_name FROM tournaments WHERE COUNT(matches) > 10",
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ],
        "rule_sql": []
    },
    "447": {
        "db_id": "wta_1",
        "question": "List the names of all winners who played in both 2013 and 2016.",
        "ground_truth": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "amends": [
            "Do use `INTERSECT` to find common winners across years instead of incorrect `AND` logic that cannot match both conditions simultaneously. Do query from `matches` table instead of non-existent `winners` table. Do select `winner_name` column instead of `name`. Do use separate queries for each year condition with proper `YEAR = 2013` and `YEAR = 2016` filters instead of the impossible `year = 2013 AND year = 2016` predicate. The amended query now correctly identifies winners who won in both 2013 and 2016 by intersecting the results from two separate year queries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM winners WHERE year = 2013 AND year = 2016;",
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016"
        ],
        "rule_sql": []
    },
    "448": {
        "db_id": "wta_1",
        "question": "What are the names of players who won in both 2013 and 2016?",
        "ground_truth": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "amends": [
            "Do use `INTERSECT` to find common `winner_name` values instead of using `AND` with the same column which would always return empty results. Do query from the `matches` table instead of the `players` table to access the correct data source. Do add a second query with `YEAR = 2016` instead of trying to filter for both years simultaneously in a single condition. Do remove the incorrect `year = 2013 AND year = 2016` predicate instead of keeping the logically impossible condition. The amended query now correctly identifies players who won matches in both 2013 and 2016 by using set intersection instead of the contradictory WHERE clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE year = 2013 AND year = 2016;",
            "SELECT winner_name FROM matches WHERE year = 2013\nINTERSECT\nSELECT winner_name FROM matches WHERE year = 2016;"
        ],
        "rule_sql": []
    },
    "449": {
        "db_id": "wta_1",
        "question": "List the number of all matches who played in years of 2013 or 2016.",
        "ground_truth": "SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016;"
        ],
        "rule_sql": []
    },
    "450": {
        "db_id": "wta_1",
        "question": "How many matches were played in 2013 or 2016?",
        "ground_truth": "SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016",
        "amends": [
            "Do use `OR` operator between year conditions instead of `AND` operator, changing `year = 2013 AND year = 2016` to `YEAR = 2013 OR YEAR = 2016` to correctly count matches from either 2013 or 2016 instead of incorrectly requiring both conditions simultaneously. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 AND year = 2016;",
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016"
        ],
        "rule_sql": []
    },
    "451": {
        "db_id": "wta_1",
        "question": "What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.country_code, p.first_name \nFROM players p\nJOIN matches m1 ON p.player_id = m1.winner_id\nJOIN matches m2 ON p.player_id = m2.winner_id\nWHERE m1.tourney_name = 'WTA Championships' \nAND m2.tourney_name = 'Australian Open';"
        ],
        "rule_sql": []
    },
    "452": {
        "db_id": "wta_1",
        "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "amends": [
            "Do use `JOIN matches` on `player_id = winner_id` instead of querying only the `players` table. Do filter with `tourney_name = 'WTA Championships'` and `tourney_name = 'Australian Open'` in separate queries instead of using `LIKE` on a single column. Do use `INTERSECT` to find players who won both tournaments instead of trying to match both patterns in the same row. Do include proper table aliases `T1` and `T2` instead of unaliased references. Do query from the matches table to find tournament winners instead of relying on a text search in the players table. The amended query now correctly identifies players who have won both the WTA Championships and Australian Open tournaments by joining with match results.",
            "Do remove `DISTINCT` instead of keeping it. Do use `INTERSECT` instead of joining the same table twice with different conditions. Do change the join condition to use `T1.player_id = T2.winner_id` consistently instead of mixing table aliases. Do move the tourney name filters to separate `WHERE` clauses for each `INTERSECT` branch instead of combining them in a single query with multiple joins. Do restructure the query to find players who participated in both tournaments using set intersection logic instead of self-joining the matches table. The amended query now correctly identifies players who won matches in both the WTA Championships and Australian Open tournaments using proper set operations.",
            "Do use consistent table aliases `T1` for players and `T2` for matches instead of mixing `p` and `T1`/`T2` aliases. Do maintain the same column order `country_code, first_name` in both INTERSECT clauses instead of having `first_name, country_code` in the wrong query. Do use identical table aliasing patterns in both parts of the INTERSECT operation instead of having inconsistent alias usage between the two SELECT statements. The amended query now correctly uses consistent aliasing and column ordering throughout both INTERSECT components, ensuring proper set comparison behavior.",
            "Do use `JOIN` with `players AS T1` and `matches AS T2` on `T1.player_id = T2.winner_id` instead of a subquery with `INTERSECT`. Do include `T1.country_code` in the `SELECT` list instead of omitting it from the first query. Do filter directly in the `WHERE` clause with `T2.tourney_name = 'WTA Championships'` and `T2.tourney_name = 'Australian Open'` instead of using separate subqueries. Do apply `INTERSECT` between two complete `SELECT` statements that both return `country_code` and `first_name` instead of intersecting only `winner_id` values. The amended query now correctly finds players who won both tournaments by intersecting complete player records rather than just player IDs, matching the RIGHT_SQL's behavior.",
            "Do swap the column order in the SELECT list to `country_code, first_name` instead of `first_name, country_code` to ensure proper INTERSECT comparison semantics. The amended query now correctly identifies players who participated in both tournaments by maintaining consistent column ordering across both INTERSECT operands, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code \nFROM players \nWHERE tournament_wins LIKE '%WTA Championships%' \nAND tournament_wins LIKE '%Australian Open%';",
            "SELECT DISTINCT p.first_name, p.country_code\nFROM players p\nJOIN matches T1 ON p.player_id = T1.winner_id\nJOIN matches T2 ON p.player_id = T2.winner_id\nWHERE T1.tourney_name = 'WTA Championships'\nAND T2.tourney_name = 'Australian Open';",
            "SELECT p.first_name, p.country_code\nFROM players p\nJOIN matches T1 ON p.player_id = T1.winner_id\nWHERE T1.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT p.first_name, p.country_code\nFROM players p\nJOIN matches T2 ON p.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'",
            "SELECT first_name, country_code\nFROM players\nWHERE player_id IN (\n    SELECT winner_id\n    FROM matches\n    WHERE tourney_name = 'WTA Championships'\n    INTERSECT\n    SELECT winner_id\n    FROM matches\n    WHERE tourney_name = 'Australian Open'\n)",
            "SELECT T1.first_name, T1.country_code\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.first_name, T1.country_code\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nWHERE T2.tourney_name = 'Australian Open'"
        ],
        "rule_sql": []
    },
    "453": {
        "db_id": "wta_1",
        "question": "Find the first name and country code of the oldest player.",
        "ground_truth": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
        "amends": [
            "Do order by `birth_date` instead of `age` in the ORDER BY clause. The amended query now matches the RIGHT_SQL's behavior by correctly sorting based on birth date rather than age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "454": {
        "db_id": "wta_1",
        "question": "What is the first name and country code of the oldest player?",
        "ground_truth": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
        "amends": [
            "Do order by `birth_date` instead of `age` in the ORDER BY clause, as the correct logic requires sorting by birth date rather than age to achieve the intended result. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT first_name, country_code FROM players ORDER BY birth_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "455": {
        "db_id": "wta_1",
        "question": "List the first and last name of all players in the order of birth date.",
        "ground_truth": "SELECT first_name ,  last_name FROM players ORDER BY birth_date",
        "amends": [
            "Do order by `birth_date` instead of `name` in the ORDER BY clause, as the original `name` column does not exist in the SELECT list or table schema. This amendment ensures proper sorting by the available birth_date field rather than attempting to sort by a non-existent column, which would cause an error. The amended query now correctly sorts players by their birth date instead of referencing an invalid column name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players ORDER BY name;",
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ],
        "rule_sql": []
    },
    "456": {
        "db_id": "wta_1",
        "question": "What are the full names of all players, sorted by birth date?",
        "ground_truth": "SELECT first_name ,  last_name FROM players ORDER BY birth_date",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date DESC;"
        ],
        "rule_sql": []
    },
    "457": {
        "db_id": "wta_1",
        "question": "List the first and last name of all players who are left / L hand in the order of birth date.",
        "ground_truth": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
        "amends": [
            "Do filter on `hand = 'L'` instead of `hand = 'right'` in the WHERE clause, changing the condition value from right-handed to left-handed players. The amended query now correctly selects left-handed players instead of right-handed players while maintaining the same column selection and ordering by birth_date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'right' ORDER BY birth_date;",
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"
        ],
        "rule_sql": []
    },
    "458": {
        "db_id": "wta_1",
        "question": "What are the full names of all left handed players, in order of birth date?",
        "ground_truth": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
        "amends": [
            "Do reference column `hand` instead of `handedness` in the WHERE clause. Do use filter value `'L'` instead of `'right'` for the hand condition. Do remove `DESC` from the ORDER BY clause instead of keeping descending order. The amended query now correctly filters for left-handed players and sorts by birth date in ascending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE handedness = 'right' ORDER BY birth_date DESC;",
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"
        ],
        "rule_sql": []
    },
    "459": {
        "db_id": "wta_1",
        "question": "Find the first name and country code of the player who did the most number of tours.",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
        "amends": [
            "Do add `rankings` table with `JOIN` on `players.player_id = rankings.player_id` instead of querying only the `players` table. Do reference `T2.tours` in the `ORDER BY` clause instead of `tours` which would be ambiguous. Do include table aliases `T1` and `T2` for clarity instead of using unqualified column names. Do maintain the `LIMIT 1` clause to return only the top result. The amended query now correctly joins player and ranking data to find the player with the highest number of tours.",
            "Do place `T1.country_code` before `T1.first_name` in the SELECT list instead of the reverse order. Do add the `AS` keyword for table aliases instead of omitting it. Do use consistent spacing around the equals operator in the JOIN condition instead of inconsistent spacing. The amended query now correctly matches the RIGHT_SQL's behavior with identical column ordering and proper syntax formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY tours DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "460": {
        "db_id": "wta_1",
        "question": "What is the first name and country code of the player with the most tours?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
        "amends": [
            "Do add `rankings` table with `JOIN` on `T1.player_id = T2.player_id` instead of querying only `players` table. Do reference `T2.tours` in `ORDER BY` instead of `tours` which would cause ambiguity. Do include table aliases `T1` and `T2` for clarity instead of omitting them. Do specify `T1.country_code` and `T1.first_name` with explicit table references instead of bare column names. The amended query now correctly joins player data with ranking information to find the player with the highest tours count, matching the intended behavior.",
            "Do reverse the column order in the SELECT list to `country_code, first_name` instead of `first_name, country_code`. Do add the `AS` keyword for table aliases by specifying `players AS T1` and `rankings AS T2` instead of omitting it. Do maintain the same join condition `T1.player_id = T2.player_id` and ordering by `T2.tours DESC` with `LIMIT 1`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY tours DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "461": {
        "db_id": "wta_1",
        "question": "Find the year that has the most number of matches.",
        "ground_truth": "SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `COUNT(*) as match_count`. Do order by `count(*) DESC` instead of `match_count ASC` to find the year with the most matches rather than the fewest. The amended query now correctly identifies the year with the highest match count by ordering in descending order and returns only the year column as specified."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as match_count FROM matches GROUP BY year ORDER BY match_count ASC LIMIT 1;",
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "462": {
        "db_id": "wta_1",
        "question": "Which year had the most matches?",
        "ground_truth": "SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of selecting both `year` and `COUNT(*) as match_count`. Do order by `count(*) DESC` instead of `match_count ASC` to find the year with the most matches rather than the fewest. Do remove the alias `match_count` from the ORDER BY clause since it's no longer selected. The amended query now correctly identifies the year with the highest number of matches by using descending order on the count aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as match_count FROM matches GROUP BY year ORDER BY match_count ASC LIMIT 1;",
            "SELECT year FROM matches GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "463": {
        "db_id": "wta_1",
        "question": "Find the name and rank points of the winner who won the most times.",
        "ground_truth": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `winner_name` and `winner_rank_points` instead of `name` and `rank_points`. Do add `GROUP BY winner_name` instead of omitting it, as aggregation requires grouping. Do keep `ORDER BY count(*) DESC` and `LIMIT 1` unchanged. The amended query now correctly aggregates match counts per winner before ordering and limiting, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, rank_points FROM winners ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT winner_name, winner_rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "464": {
        "db_id": "wta_1",
        "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?",
        "ground_truth": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference `winner_rank_points` instead of `rank_points` in the SELECT list to correctly access the intended column from the matches table. The amended query now matches RIGHT_SQL's behavior by properly selecting the winner's rank points while maintaining the same grouping, ordering, and limiting logic.",
            "Do group by only `winner_name` instead of grouping by `winner_id`, `winner_name`, and `winner_rank_points`. Do maintain the same `SELECT` list with `winner_name` and `winner_rank_points` instead of changing it. Do keep the same `ORDER BY COUNT(*) DESC` and `LIMIT 1` instead of modifying them. The amended query now correctly aggregates by winner name only while preserving the selection of winner rank points, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner_name, rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_id, winner_name, winner_rank_points\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "465": {
        "db_id": "wta_1",
        "question": "Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.",
        "ground_truth": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "466": {
        "db_id": "wta_1",
        "question": "What is the name of the winner with the most rank points who participated in the Australian Open tournament?",
        "ground_truth": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do filter on `tourney_name` instead of `tournament` in the WHERE clause, as the correct column name for identifying the Australian Open tournament is `tourney_name` rather than the non-existent `tournament` column. This amendment ensures the query correctly identifies matches from the Australian Open tournament before selecting the winner with the highest ranking points."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner_name FROM matches WHERE tournament = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;",
            "SELECT winner_name \nFROM matches \nWHERE tourney_name = 'Australian Open' \nORDER BY winner_rank_points DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "467": {
        "db_id": "wta_1",
        "question": "find the names of loser and winner who played in the match with greatest number of minutes.",
        "ground_truth": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
        "amends": [
            "Do select `winner_name` and `loser_name` columns instead of `loser` and `winner`. The amended query now correctly retrieves the specified name columns while maintaining the same ordering and limiting behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT loser, winner FROM matches ORDER BY minutes DESC LIMIT 1;",
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "468": {
        "db_id": "wta_1",
        "question": "What are the names of the winner and loser who played in the longest match?",
        "ground_truth": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
        "amends": [
            "Do reference the `minutes` column instead of `duration` in the ORDER BY clause. The amended query now correctly sorts by match length using the appropriate column name and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner_name, loser_name \nFROM matches \nORDER BY duration DESC \nLIMIT 1;",
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "469": {
        "db_id": "wta_1",
        "question": "Find the average ranking for each player and their first name.",
        "ground_truth": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do change the GROUP BY clause to use `T1.first_name` instead of `player_id`. Do move the `first_name` column to the SELECT list after the aggregate function instead of placing it first. Do reference the `first_name` column with table alias `T1` instead of without qualification. The amended query now correctly joins the necessary tables and groups by the appropriate non-aggregated column to match the intended behavior.",
            "Do place `T1.first_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(ranking)` without an alias instead of `AVG(T2.ranking) AS average_ranking`. Do maintain the same `JOIN` on `T1.player_id = T2.player_id` and `GROUP BY T1.first_name` structure. The amended query now correctly calculates the average ranking per first name while maintaining the same logical behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, AVG(ranking) FROM players GROUP BY player_id;",
            "SELECT T1.first_name, AVG(T2.ranking) AS average_ranking\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT AVG(T2.ranking), T1.first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": []
    },
    "470": {
        "db_id": "wta_1",
        "question": "What are the first names of all players, and their average rankings?",
        "ground_truth": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do reference `avg(ranking)` from the joined `rankings` table instead of attempting to average a column that doesn't exist in the original table. Do use table aliases `T1` and `T2` with qualified column references instead of unqualified column names. Do group by the qualified `T1.first_name` instead of the unqualified `first_name`. The amended query now correctly calculates average rankings by joining the necessary tables and matches the RIGHT_SQL's behavior.",
            "Do place `T1.first_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(ranking)` without an alias instead of `AVG(T2.ranking) AS average_ranking`. Do maintain the same `JOIN` on `T1.player_id = T2.player_id` and `GROUP BY T1.first_name` structure. The amended query now correctly calculates the average ranking per first name while maintaining the same logical behavior.",
            "Do place `avg(ranking)` first in the SELECT list instead of `T1.first_name`, and do remove the table alias from `first_name` instead of keeping it as `T1.first_name`. Do add the `AS` keyword for table aliases instead of omitting it, and do use consistent spacing around the equals operator in the join condition instead of inconsistent spacing. The grouping logic remains identical with `GROUP BY T1.first_name` in both queries. The amended query now correctly calculates the average ranking while maintaining proper SQL syntax and formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, AVG(ranking) FROM players GROUP BY first_name;",
            "SELECT T1.first_name, AVG(T2.ranking) AS average_ranking\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT T1.first_name, avg(T2.ranking) FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name",
            "SELECT avg(ranking), T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name"
        ],
        "rule_sql": []
    },
    "471": {
        "db_id": "wta_1",
        "question": "Find the total ranking points for each player and their first name.",
        "ground_truth": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do change the GROUP BY clause to use `T1.first_name` instead of `player_id`. Do include the table alias `T1` for `first_name` in the SELECT list instead of referencing it directly. Do remove the explicit column `first_name` from the SELECT list and instead include only the aggregate function `sum(ranking_points)` with the correct table alias. The amended query now correctly joins the players and rankings tables to calculate total ranking points per player name.",
            "Do place the aggregate function `sum(ranking_points)` first in the SELECT list instead of placing `T1.first_name` first, and do remove the alias `total_ranking_points` instead of keeping it, while maintaining the same FROM clause with `JOIN` on `T1.player_id = T2.player_id` and GROUP BY `T1.first_name`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, SUM(ranking_points) FROM players GROUP BY player_id",
            "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name",
            "SELECT sum(T2.ranking_points), T1.first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": []
    },
    "472": {
        "db_id": "wta_1",
        "question": "What are the first names of all players, and their total ranking points?",
        "ground_truth": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add `sum(ranking_points)` and `T1.first_name` instead of `first_name, ranking_points` in the SELECT list. Do add `FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id` instead of just `FROM players` to include the rankings table with a proper join condition. Do add `GROUP BY T1.first_name` instead of omitting grouping to aggregate ranking points by player name. Do remove the direct selection of individual ranking points instead of keeping them, replacing with an aggregate sum. The amended query now correctly aggregates ranking points by player name through proper table joining and grouping.",
            "Do place the aggregate function `sum(ranking_points)` first in the SELECT list instead of starting with `T1.first_name`. Do remove the alias `total_ranking_points` from the SUM expression instead of keeping it. Do maintain the same FROM clause with `JOIN` on `T1.player_id = T2.player_id` and identical GROUP BY `T1.first_name`. The amended query now correctly calculates total ranking points by player first name without unnecessary aliasing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, ranking_points FROM players;",
            "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT sum(ranking_points), T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": []
    },
    "473": {
        "db_id": "wta_1",
        "question": "find the number of players for each country.",
        "ground_truth": "SELECT count(*) ,  country_code FROM players GROUP BY country_code",
        "amends": [
            "Do use `country_code` instead of `country` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. The amended query now correctly groups by and selects the country_code column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT count(*) as player_count, country_code FROM players GROUP BY country_code;"
        ],
        "rule_sql": []
    },
    "474": {
        "db_id": "wta_1",
        "question": "How many players are from each country?",
        "ground_truth": "SELECT count(*) ,  country_code FROM players GROUP BY country_code",
        "amends": [
            "Do use `country_code` instead of `country` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. The amended query now correctly groups by and selects the country_code field, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT count(*) as player_count, country_code FROM players GROUP BY country_code;"
        ],
        "rule_sql": []
    },
    "475": {
        "db_id": "wta_1",
        "question": "find the code of the country where has the greatest number of players.",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `GROUP BY country_code` and order by `count(*) DESC` instead of selecting individual records with `ORDER BY player_id DESC`. Do add the grouping operation to count occurrences per country instead of retrieving a single random country code. Do change the ordering criteria to frequency-based ranking instead of arbitrary player ID ordering. The amended query now correctly identifies the most frequent country code by count rather than returning an arbitrary country from the last player record.",
            "Do remove `COUNT(*) as player_count` from the SELECT list instead of including it, and do reference `count(*)` directly in the ORDER BY clause instead of using the alias `player_count`. Do keep the same GROUP BY on `country_code` and maintain the DESC ordering with LIMIT 1. The amended query now correctly returns only the country_code with the highest player count while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM players ORDER BY player_id DESC LIMIT 1;",
            "SELECT country_code, COUNT(*) as player_count FROM players GROUP BY country_code ORDER BY player_count DESC LIMIT 1;",
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "476": {
        "db_id": "wta_1",
        "question": "What is the code of the country with the most players?",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `GROUP BY country_code` and order by `count(*) DESC` instead of selecting individual records ordered by `player_id DESC`. Do include the grouping and aggregation logic to find the most frequent country code instead of simply retrieving the last player's country. The amended query now correctly identifies the country with the highest number of players rather than just the most recent player's country, matching the intended behavior.",
            "Do remove `COUNT(*) as player_count` from the SELECT list instead of including it, and do reference `count(*)` directly in the ORDER BY clause instead of using the alias `player_count`. Do maintain the same GROUP BY on `country_code` and LIMIT 1, but now the query correctly returns only the country_code with the highest count of players rather than including both the country_code and the count value in the results. The amended query now matches RIGHT_SQL's behavior by returning just the country code with the maximum player count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM players ORDER BY player_id DESC LIMIT 1;",
            "SELECT country_code, COUNT(*) as player_count FROM players GROUP BY country_code ORDER BY player_count DESC LIMIT 1;",
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "477": {
        "db_id": "wta_1",
        "question": "Find the codes of countries that have more than 50 players.",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50",
        "amends": [
            "Do add `GROUP BY country_code` and move the aggregate filter to `HAVING count(*) > 50` instead of incorrectly placing `COUNT(*) > 50` in the `WHERE` clause where aggregate functions cannot be used. This properly groups the results by country code and applies the count condition after grouping rather than attempting to filter individual rows with an aggregate function, which would cause a syntax error. The amended query now correctly returns only those country codes that have more than 50 players, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM players WHERE COUNT(*) > 50",
            "SELECT country_code FROM players GROUP BY country_code HAVING COUNT(*) > 50"
        ],
        "rule_sql": []
    },
    "478": {
        "db_id": "wta_1",
        "question": "What are the codes of countries with more than 50 players?",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50",
        "amends": [
            "Do add `GROUP BY country_code` and move the aggregate filter to `HAVING count(*) > 50` instead of incorrectly placing `COUNT(*) > 50` in the `WHERE` clause where aggregate functions are not allowed. Do use the correct aggregate function syntax `count(*)` instead of `COUNT(*)` for consistency with the right query's style. The amended query now correctly groups by country code and filters groups with more than 50 players, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM players WHERE COUNT(*) > 50",
            "SELECT country_code FROM players GROUP BY country_code HAVING count(*) > 50"
        ],
        "rule_sql": []
    },
    "479": {
        "db_id": "wta_1",
        "question": "Find the total number of tours for each ranking date.",
        "ground_truth": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
        "amends": [
            "Do select `sum(tours)` and `ranking_date` instead of `ranking_date` and `COUNT(*)`. Do use `FROM rankings` instead of `FROM tours`. Do group by `ranking_date` instead of grouping by `tour_id`. The amended query now correctly aggregates tour counts by ranking date from the rankings table rather than incorrectly counting records from the tours table grouped by tour ID.",
            "Do place the `ranking_date` column after the aggregate function instead of listing it first in the SELECT clause. Do use the same aggregate expression `SUM(tours)` but with different formatting instead of changing the aggregation logic. Do maintain the same `GROUP BY ranking_date` clause instead of altering the grouping structure. The amended query now correctly calculates total tours grouped by ranking date while maintaining identical output behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_date, COUNT(*) FROM tours GROUP BY tour_id;",
            "SELECT ranking_date, SUM(tours) AS total_tours FROM rankings GROUP BY ranking_date;",
            "SELECT SUM(tours) AS total_tours, ranking_date FROM rankings GROUP BY ranking_date"
        ],
        "rule_sql": []
    },
    "480": {
        "db_id": "wta_1",
        "question": "How many total tours were there for each ranking date?",
        "ground_truth": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
        "amends": [
            "Do select `sum(tours)` and `ranking_date` instead of `ranking_date` and `COUNT(*)`. Do query from `rankings` table instead of `tours` table. Do group by `ranking_date` instead of grouping by the same column but with different underlying data. The amended query now correctly aggregates tour counts from the rankings table instead of counting records from the tours table, matching the intended behavior.",
            "Do place the `ranking_date` column after the aggregate function instead of before it in the SELECT list. Do use the unaliased `sum(tours)` expression instead of aliasing it as `total_tours`. The amended query now correctly groups by ranking_date while maintaining the same aggregation logic and output behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_date, COUNT(*) FROM tours GROUP BY ranking_date;",
            "SELECT ranking_date, SUM(tours) AS total_tours FROM rankings GROUP BY ranking_date;",
            "SELECT sum(tours), ranking_date FROM rankings GROUP BY ranking_date"
        ],
        "rule_sql": []
    },
    "481": {
        "db_id": "wta_1",
        "question": "Find the number of matches happened in each year.",
        "ground_truth": "SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",
        "amends": [
            "Do place the aggregate function `count(*)` first in the SELECT list instead of placing `year` first. Do use uppercase `YEAR` for the column reference instead of lowercase `year` in both the SELECT list and GROUP BY clause. The amended query now correctly groups by the year column and counts matches per year, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM matches GROUP BY year",
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR"
        ],
        "rule_sql": []
    },
    "482": {
        "db_id": "wta_1",
        "question": "How many matches were played in each year?",
        "ground_truth": "SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",
        "amends": [
            "Do place the `COUNT(*)` column first in the SELECT list instead of placing `year` first. Do use uppercase `YEAR` for both the column reference and GROUP BY clause instead of lowercase `year`. The amended query now correctly groups by and returns the year column while maintaining the same aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM matches GROUP BY year;",
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR"
        ],
        "rule_sql": []
    },
    "483": {
        "db_id": "wta_1",
        "question": "Find the name and rank of the 3 youngest winners across all matches.",
        "ground_truth": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",
        "amends": [
            "Do `SELECT DISTINCT winner_name, winner_rank` instead of `SELECT name, rank` to use the correct column names and add distinct filtering. Do `FROM matches` instead of the omitted table reference to specify the correct source table. Do `ORDER BY winner_age` instead of `ORDER BY age` to use the properly named age column. Do maintain `LIMIT 3` as it remains unchanged. The amended query now correctly retrieves distinct winner names and ranks from the matches table ordered by winner age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, rank FROM winners ORDER BY age ASC LIMIT 3;",
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age LIMIT 3"
        ],
        "rule_sql": []
    },
    "484": {
        "db_id": "wta_1",
        "question": "What are the names and ranks of the three youngest winners across all matches?",
        "ground_truth": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",
        "amends": [
            "Do `SELECT DISTINCT winner_name, winner_rank` instead of `SELECT name, rank` to use the correct column names and add distinctness. Do `FROM matches` instead of `FROM winners` to query from the appropriate table. Do `ORDER BY winner_age` instead of `ORDER BY age` to use the correct age column name while maintaining the ascending sort order. The amended query now correctly retrieves distinct winner names and ranks from the matches table ordered by winner age with a limit of 3, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, rank FROM winners ORDER BY age ASC LIMIT 3;",
            "SELECT DISTINCT winner_name, winner_rank FROM matches ORDER BY winner_age ASC LIMIT 3"
        ],
        "rule_sql": []
    },
    "485": {
        "db_id": "wta_1",
        "question": "How many different winners both participated in the WTA Championships and were left handed?",
        "ground_truth": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "amends": [
            "Do count `DISTINCT winner_name` instead of `COUNT(*)` to count unique winners rather than all records. Do select from `matches` table instead of joining `players` and `championships` tables to use the correct data source. Do filter on `tourney_name = 'WTA Championships'` instead of `c.tournament = 'WTA Championships'` to use the proper tournament column name. Do filter on `winner_hand = 'L'` instead of `p.handedness = 'left'` to use the correct hand designation column and value. The amended query now correctly counts distinct left-handed winners of the WTA Championships tournament."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players p\nJOIN championships c ON p.player_id = c.player_id\nWHERE p.handedness = 'left' AND c.tournament = 'WTA Championships';",
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ],
        "rule_sql": []
    },
    "486": {
        "db_id": "wta_1",
        "question": "Find the number of left handed winners who participated in the WTA Championships.",
        "ground_truth": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "amends": [
            "Do count `DISTINCT winner_name` instead of `COUNT(*)` to count unique winners rather than all matches. Do use table `matches` instead of `winners` to access the correct data source. Do filter on `tourney_name = 'WTA Championships'` instead of `tournament = 'WTA Championships'` to use the correct column name. Do filter on `winner_hand = 'L'` instead of `handed = 'left'` to use both the correct column name and abbreviated value format. The amended query now correctly counts distinct winners from the matches table with proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM winners WHERE handed = 'left' AND tournament = 'WTA Championships';",
            "SELECT COUNT(DISTINCT winner_name) \nFROM matches \nWHERE tourney_name = 'WTA Championships' \nAND winner_hand = 'L'"
        ],
        "rule_sql": []
    },
    "487": {
        "db_id": "wta_1",
        "question": "Find the first name, country code and birth date of the winner who has the highest rank points in all matches.",
        "ground_truth": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do specify table aliases `T1.first_name`, `T1.country_code`, and `T1.birth_date` instead of unqualified column references. Do add `FROM players AS T1 JOIN matches AS T2` instead of the single table `winners`. Do use join condition `ON T1.player_id = T2.winner_id` instead of no join. Do order by `T2.winner_rank_points DESC` instead of `rank_points DESC`. The amended query now correctly joins player and match data to find the winner with the highest rank points."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code, birth_date FROM winners ORDER BY rank_points DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "488": {
        "db_id": "wta_1",
        "question": "What is the first name, country code, and birth date of the player with the most winner rank points across all matches?",
        "ground_truth": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do add `JOIN matches AS T2 ON T1.player_id = T2.winner_id` instead of querying only the `players` table without any join. Do reference columns with table aliases `T1.first_name`, `T1.country_code`, and `T1.birth_date` instead of unqualified column names. Do use `T2.winner_rank_points` in the `ORDER BY` clause instead of `winner_rank_points` which doesn't exist in the players table. The amended query now correctly joins players with matches to access winner ranking points and returns the intended result matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code, birth_date \nFROM players \nORDER BY winner_rank_points DESC \nLIMIT 1;",
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "489": {
        "db_id": "wta_1",
        "question": "Find the number of players for each hand type.",
        "ground_truth": "SELECT count(*) ,  hand FROM players GROUP BY hand",
        "amends": [
            "Do place the `hand` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate function and `GROUP BY hand` clause without changes. The amended query now correctly follows standard SQL syntax where non-aggregated columns should appear after aggregate functions in the SELECT list when using GROUP BY, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hand, COUNT(*) FROM players GROUP BY hand;",
            "SELECT COUNT(*), hand FROM players GROUP BY hand"
        ],
        "rule_sql": []
    },
    "490": {
        "db_id": "wta_1",
        "question": "How many players are there for each hand type?",
        "ground_truth": "SELECT count(*) ,  hand FROM players GROUP BY hand",
        "amends": [
            "Do use `hand` instead of `hand_type` as the grouping column. Do place `count(*)` as the first column in the SELECT list instead of second. Do remove the alias `hand_type` and use the actual column name `hand` instead. The amended query now correctly groups by the actual column name and presents the count as the first result column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hand_type, COUNT(*) FROM players GROUP BY hand_type;",
            "SELECT COUNT(*), hand FROM players GROUP BY hand;"
        ],
        "rule_sql": []
    },
    "491": {
        "db_id": "battle_death",
        "question": "How many ships ended up being 'Captured'?",
        "ground_truth": "SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured'",
        "amends": [
            "Do reference table `ship` instead of `ships` and use filter condition `disposition_of_ship = 'Captured'` instead of `status = 'Sunk'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ships WHERE status = 'Sunk';",
            "SELECT COUNT(*) FROM ship WHERE disposition_of_ship = 'Captured';"
        ],
        "rule_sql": []
    },
    "492": {
        "db_id": "battle_death",
        "question": "List the name and tonnage ordered by in descending alphaetical order for the names.",
        "ground_truth": "SELECT name ,  tonnage FROM ship ORDER BY name DESC",
        "amends": [
            "Do use table name `ship` instead of `ships` in the FROM clause. Do change the sort direction to `DESC` instead of `ASC` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results in descending order by name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, tonnage FROM ships ORDER BY name ASC;",
            "SELECT name, tonnage FROM ship ORDER BY name DESC;"
        ],
        "rule_sql": []
    },
    "493": {
        "db_id": "battle_death",
        "question": "List the name, date and result of each battle.",
        "ground_truth": "SELECT name ,  date FROM battle",
        "amends": [
            "Do reference the table as `battle` instead of `battles` to ensure the query targets the correct database table. The amended query now correctly retrieves data from the intended table structure.",
            "Do remove `result` from the SELECT list instead of including it, which eliminates an unnecessary column from the output. The amended query now matches RIGHT_SQL's behavior by selecting only the required columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, date FROM battles;",
            "SELECT name, date, result FROM battle;",
            "SELECT name, date FROM battle;"
        ],
        "rule_sql": []
    },
    "494": {
        "db_id": "battle_death",
        "question": "What is maximum and minimum death toll caused each time?",
        "ground_truth": "SELECT max(killed) ,  min(killed) FROM death",
        "amends": [
            "Do reference `max(killed)` and `min(killed)` instead of `MAX(death_toll)` and `MIN(death_toll)` for the aggregate functions. Do query from table `death` instead of table `events` as the data source. Do remove the `GROUP BY event_id` clause instead of including it, as the query should return overall maximum and minimum values rather than per-event aggregates. The amended query now correctly calculates the global maximum and minimum killed values from the death table without unnecessary grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(death_toll), MIN(death_toll) FROM events GROUP BY event_id;",
            "SELECT MAX(killed) AS max_death_toll, MIN(killed) AS min_death_toll FROM death;"
        ],
        "rule_sql": []
    },
    "495": {
        "db_id": "battle_death",
        "question": "What is the average number of injuries caused each time?",
        "ground_truth": "SELECT avg(injured) FROM death",
        "amends": [
            "Do reference the `death` table instead of the `incidents` table. Do aggregate the `injured` column instead of the `injuries` column. Do remove the `WHERE injuries > 0` filter instead of keeping it. The amended query now correctly calculates the average of injured individuals from the death table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(injuries) FROM incidents WHERE injuries > 0;",
            "SELECT AVG(injured) AS average_injuries FROM death;"
        ],
        "rule_sql": []
    },
    "496": {
        "db_id": "battle_death",
        "question": "What are the death and injury situations caused by the ship with tonnage 't'?",
        "ground_truth": "SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'",
        "amends": [
            "Do select specific columns `T1.killed` and `T1.injured` instead of using `SELECT *`. Do join tables `death AS T1` and `ship AS t2` with an `INNER JOIN` on `T1.caused_by_ship_id = T2.id` instead of querying only the `accidents` table. Do filter on `T2.tonnage = 't'` in the `WHERE` clause instead of filtering `tonnage` directly from a single table. The amended query now correctly retrieves accident data by joining related tables and filtering based on ship tonnage, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM accidents WHERE tonnage = 't';",
            "SELECT T1.killed, T1.injured FROM death AS T1 INNER JOIN ship AS T2 ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'"
        ],
        "rule_sql": []
    },
    "497": {
        "db_id": "battle_death",
        "question": "What are the name and results of the battles when the bulgarian commander is not 'Boril'",
        "ground_truth": "SELECT name ,  RESULT FROM battle WHERE bulgarian_commander != 'Boril'",
        "amends": [
            "Do select `RESULT` instead of `results` and use table `battle` instead of `battles`. Do change the filter to `bulgarian_commander != 'Boril'` instead of `commander = 'Boril' AND nationality = 'Bulgarian'`, removing the nationality condition entirely. The amended query now correctly excludes battles where Boril was the Bulgarian commander rather than selecting only those where he commanded with Bulgarian nationality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, results FROM battles WHERE commander = 'Boril' AND nationality = 'Bulgarian';",
            "SELECT name, result FROM battle WHERE bulgarian_commander != 'Boril';"
        ],
        "rule_sql": []
    },
    "498": {
        "db_id": "battle_death",
        "question": "What are the different ids and names of the battles that lost any 'Brig' type shipes?",
        "ground_truth": "SELECT DISTINCT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type  =  'Brig'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate battle records. Do select `T1.id` and `T1.name` instead of `battle_id` and `name` with explicit table aliases. Do join `ship AS T2` instead of querying only the `battles` table to access ship information. Do use `ON T1.id = T2.lost_in_battle` instead of filtering directly on `battles` to properly relate ships to battles they were lost in. Do filter on `T2.ship_type = 'Brig'` instead of `ship_type = 'Brig'` to correctly reference the ship table's column. Do remove the `result = 'lost'` filter instead of keeping it since the ship's presence in lost_in_battle already indicates the loss. The amended query now correctly identifies battles where Brig-type ships were lost by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT battle_id, name FROM battles WHERE ship_type = 'Brig' AND result = 'lost';",
            "SELECT DISTINCT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.ship_type = 'Brig'"
        ],
        "rule_sql": []
    },
    "499": {
        "db_id": "battle_death",
        "question": "What are the ids and names of the battles that led to more than 10 people killed in total.",
        "ground_truth": "SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10",
        "amends": [
            "Do select `T1.id` and `T1.name` instead of `battle_id` and `battle_name`. Do use `FROM battle AS T1` with joins to `ship AS T2` and `death AS T3` instead of just `FROM battles`. Do add `JOIN ship AS T2 ON T1.id = T2.lost_in_battle` and `JOIN death AS T3 ON T2.id = T3.caused_by_ship_id` instead of no joins. Do add `GROUP BY T1.id` instead of omitting grouping. Do move the filter to `HAVING sum(T3.killed) > 10` instead of `WHERE killed > 10` to properly aggregate deaths per battle. The amended query now correctly calculates total deaths per battle by joining through ship relationships and aggregates the sum before filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT battle_id, battle_name FROM battles WHERE killed > 10;",
            "SELECT T1.id, T1.name\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nJOIN death AS T3 ON T2.id = T3.caused_by_ship_id\nGROUP BY T1.id\nHAVING SUM(T3.killed) > 10"
        ],
        "rule_sql": []
    },
    "500": {
        "db_id": "battle_death",
        "question": "What is the ship id and name that caused most total injuries?",
        "ground_truth": "SELECT T2.id ,  T2.name FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.id` and `T2.name` instead of `ship_id` and `name`. Do use `FROM death AS T1 JOIN ship AS t2` instead of `FROM ships`. Do add `ON T1.caused_by_ship_id = T2.id` join condition instead of omitting it. Do add `GROUP BY T2.id` instead of omitting grouping. Do order by `count(*) DESC` instead of `total_injuries DESC`. The amended query now correctly identifies the ship with the most deaths by joining death records to ship data and counting occurrences, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ship_id, name FROM ships ORDER BY total_injuries DESC LIMIT 1;",
            "SELECT T2.id, T2.name\nFROM death AS T1\nJOIN ship AS T2 ON T1.caused_by_ship_id = T2.id\nGROUP BY T2.id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "501": {
        "db_id": "battle_death",
        "question": "What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?",
        "ground_truth": "SELECT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I'",
        "amends": [
            "Do select `name` from the `battle` table instead of `battle_name` from `battles`. Do use filter conditions `bulgarian_commander = 'Kaloyan'` and `latin_commander = 'Baldwin I'` instead of `commander1 = 'Kaloyan'` and `commander2 = 'Baldwin I'`. Do remove `DISTINCT` instead of keeping it since the query now correctly references the proper table structure and column names. The amended query now matches the intended behavior of filtering battles by specific commanders from different factions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT battle_name FROM battles WHERE commander1 = 'Kaloyan' AND commander2 = 'Baldwin I';",
            "SELECT name FROM battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"
        ],
        "rule_sql": []
    },
    "502": {
        "db_id": "battle_death",
        "question": "How many different results are there for the battles?",
        "ground_truth": "SELECT count(DISTINCT RESULT) FROM battle",
        "amends": [
            "Do `count(DISTINCT RESULT)` instead of `COUNT(*)` to count distinct result values rather than all rows. Do reference table `battle` instead of `battles` to use the correct table name. The amended query now correctly counts distinct battle results from the proper table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM battles;",
            "SELECT COUNT(DISTINCT result) FROM battle;"
        ],
        "rule_sql": []
    },
    "503": {
        "db_id": "battle_death",
        "question": "How many battles did not lose any ship with tonnage '225'?",
        "ground_truth": "SELECT count(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage  =  '225' );",
        "amends": [
            "Do reference the `battle` table instead of `battles` in the FROM clause. Do use a subquery with `NOT IN` filtering on `id` against `lost_in_battle` values from the `ship` table instead of a direct `WHERE ship_tonnage != '225'` filter. Do check for ships with `tonnage = '225'` in the subquery instead of comparing battle attributes directly. Do remove the incorrect `ship_tonnage` column reference since this attribute belongs to ships rather than battles. The amended query now correctly counts battles where no ship of 225 tonnage was lost, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM battles WHERE ship_tonnage != '225';",
            "SELECT COUNT(*) \nFROM battle \nWHERE id NOT IN (\n    SELECT lost_in_battle \n    FROM ship \n    WHERE tonnage = '225'\n)"
        ],
        "rule_sql": []
    },
    "504": {
        "db_id": "battle_death",
        "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'",
        "ground_truth": "SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'",
        "amends": [
            "Do join `battle AS T1` with `ship AS T2` on `T1.id = T2.lost_in_battle` instead of querying only the `battles` table. Do filter for ships named `'Lettice'` in one branch and `'HMS Atalanta'` in another instead of incorrectly applying both conditions to the same `ship_lost` column. Do use `INTERSECT` to find battles where both ships were lost instead of using `AND` with impossible conditions. Do select from properly aliased tables `T1.name` and `T1.date` instead of unqualified column names. The amended query now correctly identifies battles where both specified ships were lost by using proper table joins and set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, date FROM battles WHERE ship_lost = 'Lettice' AND ship_lost = 'HMS Atalanta'",
            "SELECT T1.name, T1.date\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'Lettice'\nINTERSECT\nSELECT T1.name, T1.date\nFROM battle AS T1\nJOIN ship AS T2 ON T1.id = T2.lost_in_battle\nWHERE T2.name = 'HMS Atalanta'"
        ],
        "rule_sql": []
    },
    "505": {
        "db_id": "battle_death",
        "question": "Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.",
        "ground_truth": "SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'",
        "amends": [
            "Do use `EXCEPT` to exclude records instead of a simple `WHERE` filter. Do change the table name to `battle` instead of `battles`. Do add a join with `ship` table on `T1.id = T2.lost_in_battle` instead of omitting this relationship. Do move the location filter to the `ship` table condition `T2.location = 'English Channel'` instead of applying it directly to the battle table. Do remove the `ships_lost = 0` condition instead of keeping it, as the EXCEPT operation now properly handles the exclusion logic. The amended query now correctly excludes battles where ships were lost in the English Channel, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, result, bulgarian_commander FROM battles WHERE location = 'English Channel' AND ships_lost = 0;",
            "SELECT name, result, bulgarian_commander FROM battle\nEXCEPT\nSELECT T1.name, T1.result, T1.bulgarian_commander FROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.location = 'English Channel'"
        ],
        "rule_sql": []
    },
    "506": {
        "db_id": "battle_death",
        "question": "What are the notes of the death events which has substring 'East'?",
        "ground_truth": "SELECT note FROM death WHERE note LIKE '%East%'",
        "amends": [
            "Do reference the `note` column instead of `notes` in the SELECT list. Do query from the `death` table instead of `death_events` as the FROM source. Do filter on `note LIKE '%East%'` instead of `location LIKE '%East%'` in the WHERE clause. The amended query now correctly retrieves notes containing 'East' from the appropriate table and column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT notes FROM death_events WHERE location LIKE '%East%';",
            "SELECT note FROM death WHERE note LIKE '%East%'"
        ],
        "rule_sql": []
    },
    "507": {
        "db_id": "student_transcripts_tracking",
        "question": "what are all the addresses including line 1 and line 2?",
        "ground_truth": "SELECT line_1 ,  line_2 FROM addresses",
        "amends": [
            "Do select `line_1` and `line_2` columns instead of `address_line1`. Do add `line_2` instead of omitting it. The amended query now correctly retrieves both address line components as specified in the target output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address_line1 FROM addresses;",
            "SELECT line_1, line_2 FROM Addresses;"
        ],
        "rule_sql": []
    },
    "508": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first and second line for all addresses?",
        "ground_truth": "SELECT line_1 ,  line_2 FROM addresses",
        "amends": [
            "Do select `line_1` and `line_2` instead of `first_line` and `second_line` to use the correct column names from the addresses table schema. Do maintain the same WHERE filter condition `id = 1 OR id = 2` to retrieve the specific address records. The amended query now correctly references the actual column names while preserving the same record selection behavior.",
            "Do use lowercase `addresses` instead of uppercase `Addresses` for the table name. Do remove the `WHERE address_id = 1 OR address_id = 2` filter instead of keeping it, as the right query selects all records from the addresses table without any filtering conditions. The amended query now matches RIGHT_SQL's behavior by returning all address lines without restrictions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_line, second_line FROM addresses WHERE id = 1 OR id = 2;",
            "SELECT line_1, line_2 FROM Addresses WHERE address_id = 1 OR address_id = 2",
            "SELECT line_1, line_2 FROM addresses"
        ],
        "rule_sql": []
    },
    "509": {
        "db_id": "student_transcripts_tracking",
        "question": "How many courses in total are listed?",
        "ground_truth": "SELECT count(*) FROM Courses",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": []
    },
    "510": {
        "db_id": "student_transcripts_tracking",
        "question": "How many courses are there?",
        "ground_truth": "SELECT count(*) FROM Courses",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": []
    },
    "511": {
        "db_id": "student_transcripts_tracking",
        "question": "How is the math course described?",
        "ground_truth": "SELECT course_description FROM Courses WHERE course_name  =  'math'",
        "amends": [
            "Do select `course_description` instead of `description` to reference the correct column name. Do reference table `Courses` with proper capitalization instead of `courses` to match the actual table name. Do use filter `'math'` with lowercase instead of `'Math'` to ensure case-sensitive matching works correctly. The amended query now correctly retrieves the course description from the Courses table where the course name matches 'math' exactly as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM courses WHERE course_name = 'Math';",
            "SELECT course_description FROM Courses WHERE course_name = 'math';"
        ],
        "rule_sql": []
    },
    "512": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the descriptions for all the math courses?",
        "ground_truth": "SELECT course_description FROM Courses WHERE course_name  =  'math'",
        "amends": [
            "Do select `course_description` instead of `*` from the SELECT list. Do reference table `Courses` instead of `courses` in the FROM clause. Do filter on `course_name = 'math'` instead of `subject = 'math'` in the WHERE clause. The amended query now correctly retrieves only the course description for math courses from the properly referenced Courses table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM courses WHERE subject = 'math';",
            "SELECT course_description FROM Courses WHERE course_name = 'math'"
        ],
        "rule_sql": []
    },
    "513": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the zip code of the address in the city Port Chelsea?",
        "ground_truth": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'",
        "amends": [
            "Do reference column `zip_postcode` instead of `zip_code` and table `Addresses` instead of `addresses` while maintaining the same filter condition `city = 'Port Chelsea'` without any changes to the WHERE clause, join logic, or other query components, confirming the amended query now correctly retrieves postal codes from the Addresses table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM addresses WHERE city = 'Port Chelsea';",
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ],
        "rule_sql": []
    },
    "514": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the zip code for Port Chelsea?",
        "ground_truth": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'",
        "amends": [
            "Do select `zip_postcode` instead of `zip_code` from the `Addresses` table instead of the `cities` table, and filter on `city = 'Port Chelsea'` instead of `city_name = 'Port Chelsea'`. The amended query now correctly retrieves postal codes from the appropriate address table using the correct column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM cities WHERE city_name = 'Port Chelsea';",
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ],
        "rule_sql": []
    },
    "515": {
        "db_id": "student_transcripts_tracking",
        "question": "Which department offers the most number of degrees? List department name and id.",
        "ground_truth": "SELECT T2.department_name ,  T1.department_id FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Departments` as `T2` instead of omitting it, and use `Degree_Programs` as `T1` instead of `degrees`. Do specify `T2.department_name` and `T1.department_id` in the SELECT list instead of `department_name` and `department_id` without table aliases. Do use `JOIN` with `ON T1.department_id = T2.department_id` instead of querying only the degrees table. Do group by `T1.department_id` instead of `department_id` without table qualification. Do order by `count(*)` instead of `degree_count` alias. The amended query now correctly joins department information and matches the intended behavior.",
            "Do remove `COUNT(*) as degree_count` from the SELECT list instead of including it, and do remove the alias from `Departments T2` instead of keeping it as `T2`. Do change the GROUP BY clause to include only `T1.department_id` instead of including additional columns, and do ensure the ORDER BY uses `count(*)` (lowercase) instead of `COUNT(*)` (uppercase). The amended query now correctly returns only the department name and ID without the count aggregation in the SELECT list while maintaining the same grouping and ordering logic to identify the department with the most degree programs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name, department_id, COUNT(*) as degree_count \nFROM degrees \nGROUP BY department_id \nORDER BY degree_count DESC \nLIMIT 1;",
            "SELECT T2.department_name, T1.department_id, COUNT(*) as degree_count\nFROM Degree_Programs T1\nJOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.department_name, T1.department_id\nFROM Degree_Programs T1\nJOIN Departments T2 ON T1.department_id = T2.department_id\nGROUP BY T1.department_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "516": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name and id of the department with the most number of degrees ?",
        "ground_truth": "select t2.department_name ,  t1.department_id from degree_programs as t1 join departments as t2 on t1.department_id  =  t2.department_id group by t1.department_id order by count(*) desc limit 1",
        "amends": [
            "Do join `degree_programs as t1` with `departments as t2` on `t1.department_id = t2.department_id` instead of querying only the `departments` table. Do add `GROUP BY t1.department_id` to aggregate by department instead of omitting grouping. Do use `count(*)` to count all degree programs instead of `COUNT(degrees)` which references an undefined column. Do select `t2.department_name` and `t1.department_id` from the joined tables instead of selecting columns directly from a single table. The amended query now correctly counts degree programs per department and returns the department with the most programs, matching the intended behavior.",
            "Do remove `COUNT(*) as degree_count` from the SELECT list instead of including it, and do move the `COUNT(*)` expression to the ORDER BY clause instead of keeping it in SELECT. Do keep `t2.department_name` and `t1.department_id` in SELECT instead of removing them. Do maintain the same FROM clause with `JOIN` on `t1.department_id = t2.department_id` instead of changing it. Do preserve the GROUP BY on `t1.department_id` instead of modifying it. Do change ORDER BY to use `COUNT(*) desc` instead of `degree_count DESC` to properly sort by the aggregate count. Do keep LIMIT 1 instead of changing it. The amended query now correctly returns the department with the most degree programs by counting records in the grouping rather than selecting the count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name, department_id FROM departments ORDER BY COUNT(degrees) DESC LIMIT 1;",
            "SELECT t2.department_name, t1.department_id, COUNT(*) as degree_count\nFROM Degree_Programs as t1\nJOIN Departments as t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY degree_count DESC\nLIMIT 1;",
            "SELECT t2.department_name, t1.department_id\nFROM Degree_Programs AS t1\nJOIN Departments AS t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "517": {
        "db_id": "student_transcripts_tracking",
        "question": "How many departments offer any degree?",
        "ground_truth": "SELECT count(DISTINCT department_id) FROM Degree_Programs",
        "amends": [
            "Do count `DISTINCT department_id` from the `Degree_Programs` table instead of counting all rows from the `departments` table. Do remove the `WHERE degree IS NOT NULL` filter instead of keeping it, as the distinct count inherently handles null values appropriately. The amended query now correctly counts unique department IDs from the Degree_Programs table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE degree IS NOT NULL;",
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ],
        "rule_sql": []
    },
    "518": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different departments offer degrees?",
        "ground_truth": "SELECT count(DISTINCT department_id) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT department_id)` instead of `COUNT(*)` to count unique departments rather than all rows. Do query from `Degree_Programs` table instead of `departments` to access the correct source data. Do remove the `WHERE degree_offered = 'yes'` filter instead of keeping it since the Degree_Programs table inherently contains only degree-offering programs. The amended query now correctly counts distinct department IDs from the appropriate table without needing explicit filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE degree_offered = 'yes';",
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ],
        "rule_sql": []
    },
    "519": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different degree names are offered?",
        "ground_truth": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT degree_summary_name)` instead of `COUNT(*)` to count distinct degree names rather than all rows. Do query from `Degree_Programs` instead of `degrees` to use the correct table source. The amended query now correctly counts unique degree program names from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees;",
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ],
        "rule_sql": []
    },
    "520": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different degrees are offered?",
        "ground_truth": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
        "amends": [
            "Do select `count(DISTINCT degree_summary_name)` instead of `COUNT(*)`. Do query from `Degree_Programs` instead of `degrees`. The amended query now correctly counts distinct degree summary names from the Degree_Programs table instead of counting all rows from the degrees table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM degrees;",
            "SELECT COUNT(DISTINCT degree_summary_name) FROM Degree_Programs;"
        ],
        "rule_sql": []
    },
    "521": {
        "db_id": "student_transcripts_tracking",
        "question": "How many degrees does the engineering department offer?",
        "ground_truth": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE department_name = 'engineering';"
        ],
        "rule_sql": []
    },
    "522": {
        "db_id": "student_transcripts_tracking",
        "question": "How many degrees does the engineering department have?",
        "ground_truth": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE department_name = 'engineering';"
        ],
        "rule_sql": []
    },
    "523": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and descriptions of all the sections?",
        "ground_truth": "SELECT section_name ,  section_description FROM Sections",
        "amends": [
            "Do use `section_name` and `section_description` instead of `name` and `description` for column selection. Do reference the table as `Sections` instead of `sections` for proper case sensitivity. Do remove the `WHERE id > 100` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all section names and descriptions from the Sections table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, description FROM sections WHERE id > 100;",
            "SELECT section_name, section_description FROM Sections;"
        ],
        "rule_sql": []
    },
    "524": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and descriptions for all the sections?",
        "ground_truth": "SELECT section_name ,  section_description FROM Sections",
        "amends": [
            "Do use `section_name` and `section_description` instead of `name` and `description` for the column selection. Do reference the table as `Sections` instead of `sections` for proper case sensitivity. Do remove the `WHERE id > 0` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all section names and descriptions from the Sections table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, description FROM sections WHERE id > 0",
            "SELECT section_name, section_description FROM Sections;"
        ],
        "rule_sql": []
    },
    "525": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and id of courses having at most 2 sections?",
        "ground_truth": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",
        "amends": [
            "Do use explicit table aliases `T1.course_name` and `T1.course_id` instead of bare column names `course_id, name`. Do add a `JOIN` to the `Sections` table `AS T2` instead of omitting it. Do use the correct join condition `T1.course_id = T2.course_id` instead of the incorrect `COUNT(sections)` filter. Do move the count filter to `HAVING count(*) <= 2` instead of placing it in the `WHERE` clause. Do add `GROUP BY T1.course_id` instead of omitting the grouping. The amended query now correctly counts sections per course and filters courses with two or fewer sections, matching the intended behavior.",
            "Do maintain the same `SELECT` list with `course_name, course_id` instead of changing the column order from `course_id, course_name`. Do keep the same `FROM` clause with `JOIN Sections AS T2` on `T1.course_id = T2.course_id` instead of altering the join condition. Do preserve the identical `GROUP BY T1.course_id` and `HAVING count(*) <= 2` clauses instead of modifying the aggregation logic. The amended query now correctly maintains the original behavior while fixing only the column ordering in the SELECT clause to match the RIGHT_SQL's output structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id, name FROM courses WHERE COUNT(sections) <= 2;",
            "SELECT T1.course_id, T1.course_name\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2",
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": []
    },
    "526": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and ids of every course with less than 2 sections?",
        "ground_truth": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",
        "amends": [
            "Do select `T1.course_name` and `T1.course_id` with explicit table aliases instead of `course_id` and `name` without table qualification. Do join `Sections AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do group by `T1.course_id` and use `HAVING count(*) <= 2` to filter courses with at most two sections instead of using `WHERE section_count > 2` to filter courses with more than two sections. The amended query now correctly identifies courses with exactly two or fewer sections by counting actual section records rather than relying on a potentially incorrect section_count column.",
            "Do maintain the same `SELECT` list order with `course_name` first instead of `course_id` first, though this is purely cosmetic. Do keep the same `FROM` source with `Courses AS T1` and the same `JOIN` type with `Sections AS T2` on the same predicate `T1.course_id = T2.course_id`. Do preserve the identical `GROUP BY T1.course_id` and `HAVING COUNT(*) <= 2` clause. The amended query now matches RIGHT_SQL's behavior with only insignificant formatting differences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id, name FROM courses WHERE section_count > 2;",
            "SELECT T1.course_id, T1.course_name\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2",
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": []
    },
    "527": {
        "db_id": "student_transcripts_tracking",
        "question": "List the section_name in reversed lexicographical order.",
        "ground_truth": "SELECT section_name FROM Sections ORDER BY section_name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT section_name FROM sections ORDER BY section_name ASC;"
        ],
        "rule_sql": []
    },
    "528": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names of the sections in reverse alphabetical order?",
        "ground_truth": "SELECT section_name FROM Sections ORDER BY section_name DESC",
        "amends": [
            "Do select `section_name` instead of `name` from the `Sections` table instead of `sections`. Do order by `section_name DESC` instead of `name ASC`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM sections ORDER BY name ASC;",
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ],
        "rule_sql": []
    },
    "529": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the semester which most student registered in? Show both the name and the id.",
        "ground_truth": "SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `r`. Do reference `T1.semester_name` and `T1.semester_id` in SELECT instead of unqualified `semester_name` and `semester_id`. Do join `Semesters AS T1` with `Student_Enrolment AS T2` instead of `students s` with `registrations r`. Do use join condition `T1.semester_id = T2.semester_id` instead of `s.student_id = r.student_id`. Do remove the `COUNT(*) as student_count` column from SELECT instead of including it. Do GROUP BY only `T1.semester_id` instead of both `semester_name` and `semester_id`. Do ORDER BY `count(*) DESC` instead of `student_count DESC`. The amended query now correctly identifies the semester with the most student enrollments by joining the appropriate tables and counting enrollments per semester."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT semester_name, semester_id, COUNT(*) as student_count\nFROM students s\nJOIN registrations r ON s.student_id = r.student_id\nGROUP BY semester_name, semester_id\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "530": {
        "db_id": "student_transcripts_tracking",
        "question": "For each semester, what is the name and id of the one with the most students registered?",
        "ground_truth": "SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.semester_name` and `T1.semester_id` in SELECT instead of `semester_id, semester_name`. Do remove the `student_count` alias and aggregate function instead of keeping them. Do join with `Student_Enrolment AS T2` instead of `registrations`. Do use `ON T1.semester_id = T2.semester_id` instead of `semesters.semester_id = registrations.semester_id`. Do remove `semester_name` from GROUP BY instead of including it. Do use `ORDER BY count(*) DESC` instead of `ORDER BY student_count DESC`. The amended query now correctly identifies the semester with the most student enrollments by counting records in the Student_Enrolment table rather than using a potentially incorrect registrations table.",
            "Do place `T1.semester_name` before `T1.semester_id` in the SELECT list instead of the reverse order. Do maintain the same FROM clause with `JOIN` on `T1.semester_id = T2.semester_id` instead of changing it. Do keep the `GROUP BY T1.semester_id` and `ORDER BY count(*) DESC LIMIT 1` unchanged as they correctly identify the semester with the highest enrollment count. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT semester_id, semester_name, COUNT(student_id) as student_count\nFROM semesters\nJOIN registrations ON semesters.semester_id = registrations.semester_id\nGROUP BY semester_id, semester_name\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T1.semester_id, T1.semester_name\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY count(*) DESC\nLIMIT 1;",
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "531": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the description of the department whose name has the substring the computer?",
        "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
        "amends": [
            "Do reference `department_description` in the SELECT list instead of `description`. Do reference `Departments` as the FROM source instead of `departments`. Do filter on `department_name LIKE '%computer%'` instead of `name LIKE '%computer%'`. The amended query now correctly matches the intended table structure and column names to produce the expected results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM departments WHERE name LIKE '%computer%';",
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ],
        "rule_sql": []
    },
    "532": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the department description for the one whose name has the word computer?",
        "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
        "amends": [
            "Do reference `department_description` instead of `description` in the SELECT list. Do use `department_name` instead of `name` in the WHERE filter condition. Do capitalize the table name as `Departments` instead of `departments` for consistency with the schema. The amended query now correctly retrieves department descriptions by filtering on department names containing 'computer'."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM departments WHERE name LIKE '%computer%';",
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ],
        "rule_sql": []
    },
    "533": {
        "db_id": "student_transcripts_tracking",
        "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.",
        "ground_truth": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
        "amends": [
            "Do add `Student_Enrolment` table with `JOIN` on `T1.student_id = T2.student_id` instead of omitting it. Do change the aggregation to group by `T1.student_id` instead of `semester`. Do move the count condition to `HAVING count(*) = 2` instead of placing it in `WHERE COUNT(degree_program) = 2`. Do remove the `degree_program` column reference and use `count(*)` instead. Do add table aliases `T1` and `T2` with proper qualification instead of using unqualified column names. The amended query now correctly identifies students with exactly two enrollments by joining the enrollment table and using proper aggregation with HAVING clause.",
            "Do include only `T1.student_id` in the GROUP BY clause instead of grouping by both `s.student_id` and `se.semester_id`. Do use `count(*) = 2` in the HAVING clause instead of `COUNT(DISTINCT se.degree_program_id) = 2` to count total enrollment records rather than distinct degree programs. Do remove the unnecessary `se.semester_id` from the GROUP BY since the aggregation logic focuses on student-level enrollment counts rather than semester-based degree program analysis. The amended query now correctly identifies students with exactly two enrollment records regardless of semester or degree program, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name, student_id \nFROM students \nWHERE COUNT(degree_program) = 2 \nGROUP BY semester;",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id, se.semester_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nHAVING COUNT(*) = 2"
        ],
        "rule_sql": []
    },
    "534": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?",
        "ground_truth": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
        "amends": [
            "Do use `T1.student_id` instead of `s.id` in the SELECT list and GROUP BY clause. Do reference `Student_Enrolment AS T2` instead of `enrollments e` as the joined table. Do use `count(*) = 2` instead of `COUNT(DISTINCT e.degree_program_id) = 2` in the HAVING clause to count enrollment records rather than distinct degree programs. Do remove the `DISTINCT` modifier from the count aggregation instead of including it. The amended query now correctly counts the number of enrollment records per student rather than distinct degree programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.id\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nHAVING COUNT(DISTINCT e.degree_program_id) = 2;",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment T2 ON s.student_id = T2.student_id\nGROUP BY s.student_id, s.first_name, s.middle_name, s.last_name\nHAVING count(*) = 2"
        ],
        "rule_sql": []
    },
    "535": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the `FROM` clause to use explicit table aliases `Students AS T1` instead of just `students`. Do add `JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id` and `JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id` instead of querying only the students table. Do change the `WHERE` filter to `T3.degree_summary_name = 'Bachelor'` instead of `degree_program = 'Bachelor'` to properly reference the joined degree programs table. The amended query now correctly joins through the enrollment relationship to identify bachelor's degree students and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students WHERE degree_program = 'Bachelor'",
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": []
    },
    "536": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the FROM clause to include `Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id` instead of just `students`. Do change the WHERE filter to `T3.degree_summary_name = 'Bachelor'` instead of `program = 'Bachelors'`. Do add table aliases `T1.` prefix to all columns instead of using unqualified column names. The amended query now correctly filters students enrolled in Bachelor programs through proper table relationships rather than relying on a potentially incorrect program field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students WHERE program = 'Bachelors';",
            "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id\nWHERE T3.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": []
    },
    "537": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the kind of program which most number of students are enrolled in?",
        "ground_truth": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_summary_name` instead of `program_type` and remove the `student_count` alias instead of keeping it. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only the `students` table. Do group by `T1.degree_summary_name` instead of `program_type` and order by `count(*) DESC` instead of `student_count ASC` while keeping the `LIMIT 1`. The amended query now correctly identifies the most popular degree program by enrollment count rather than counting students by program type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT program_type, COUNT(*) as student_count FROM students GROUP BY program_type ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "538": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the degree summary name that has the most number of students enrolled?",
        "ground_truth": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_summary_name` instead of `degree_summary_name` and remove the `student_count` alias instead of keeping it. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying `students` table directly without any joins. Do order by `count(*) DESC` instead of `student_count ASC` to find the most popular degree instead of the least popular. The amended query now correctly identifies the degree program with the highest enrollment count by joining the relevant tables and using descending order aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT degree_summary_name, COUNT(*) as student_count FROM students GROUP BY degree_summary_name ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "539": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the program which most number of students are enrolled in. List both the id and the summary.",
        "ground_truth": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `T1.degree_program_id` and `T1.degree_summary_name` instead of `program_id` and `summary`. Do add `FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id` instead of just `FROM programs`. Do add `GROUP BY T1.degree_program_id` instead of omitting it. Do use `count(*)` in the `ORDER BY` instead of `COUNT(student_id)`. The amended query now correctly joins the necessary tables, groups by program ID, and counts all enrolled students to identify the most popular degree program."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT program_id, summary FROM programs ORDER BY COUNT(student_id) DESC LIMIT 1;",
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "540": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the program id and the summary of the degree that has the most students enrolled?",
        "ground_truth": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.degree_program_id` and `T1.degree_summary_name` instead of `program_id` and `summary`. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only the `degrees` table. Do add `GROUP BY T1.degree_program_id` to aggregate by program instead of omitting grouping. Do order by `count(*) DESC` to sort by actual student count instead of `enrolled_students DESC`. The amended query now correctly identifies the program with the most enrolled students by counting actual enrollment records rather than relying on a potentially incorrect stored count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT program_id, summary FROM degrees ORDER BY enrolled_students DESC LIMIT 1;",
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "541": {
        "db_id": "student_transcripts_tracking",
        "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.",
        "ground_truth": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` on `T1.student_id = T2.student_id` instead of `LEFT JOIN` on `s.id = e.student_id`. Do reference `T1.student_id` instead of `s.id` in the SELECT list and GROUP BY. Do use `count(*)` instead of `COUNT(e.program_id)` for enrollment counting. Do reference `Student_Enrolment AS T2` instead of `enrollments e` as the join table. Do include `T1.student_id` in the SELECT list instead of `s.student_id`. The amended query now correctly counts enrollments using an inner join and proper column references to match the intended behavior.",
            "Do remove `T1.first_name`, `T1.middle_name`, and `T1.last_name` from the GROUP BY clause instead of including them, since they are functionally dependent on `T1.student_id`. Do change the ORDER BY to reference `count(*)` directly instead of using the alias `enrollment_count`, as the alias is not available at that point in query processing. The amended query now correctly groups only by the primary key and orders by the aggregate function directly, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be present when used in GROUP BY. Do use the same column reference `T1.student_id` in both SELECT and GROUP BY instead of having inconsistent column usage. Do maintain the aggregate function `count(*)` without an alias instead of adding `AS enrollment_count`, as the RIGHT_SQL uses the unaliased version. The amended query now correctly includes all necessary columns for grouping and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by this column and it must be included in the selection. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same JOIN condition on `T1.student_id = T2.student_id`, GROUP BY on `T1.student_id`, ORDER BY on `count(*) DESC`, and LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as it must be included when using GROUP BY on that column to ensure proper aggregation behavior. The amended query now correctly includes all necessary columns in both SELECT and GROUP BY clauses to match the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output. The amended query now correctly includes all necessary columns while maintaining the same join condition, grouping, ordering, and limit behavior as the RIGHT_SQL.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output for consistency and clarity. The amended query now correctly includes all referenced columns in the SELECT clause while maintaining the same join logic, grouping, ordering, and limit behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id` and grouping by `T1.student_id` with ordering by `count(*) DESC` and limiting to 1 result. The amended query now correctly includes all necessary columns while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the GROUP BY on `T1.student_id` with ORDER BY `count(*) DESC` and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the result set.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by this column and it must be included in the selection. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including all necessary columns in the selection.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by `T1.student_id` but the original SELECT list did not include this grouped column which would cause an error in strict SQL mode. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list, maintaining the same join condition, grouping, ordering, and limit behavior while fixing the column reference issue.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same JOIN condition on `T1.student_id = T2.student_id`, GROUP BY on `T1.student_id`, ORDER BY on `count(*) DESC`, and LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id`, the same grouping by `T1.student_id`, the same ordering by `count(*) DESC`, and the same limit of `1` record. The amended query now correctly includes all necessary columns in the SELECT clause while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id` and grouping by `T1.student_id` with ordering by `count(*) DESC` and limiting to 1 result. The amended query now correctly includes all necessary columns while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the grouping by `T1.student_id` with count aggregation and descending order by count with limit 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the result set.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the GROUP BY on `T1.student_id` with ORDER BY `count(*) DESC` and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the selection."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.id, s.first_name, s.middle_name, s.last_name, COUNT(e.program_id) as enrollment_count, s.student_id\nFROM students s\nLEFT JOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nORDER BY enrollment_count DESC\nLIMIT 1;",
            "SELECT \n    T1.student_id,\n    T1.first_name,\n    T1.middle_name,\n    T1.last_name,\n    COUNT(*) AS enrollment_count,\n    T1.student_id\nFROM \n    Students AS T1\nJOIN \n    Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY \n    T1.student_id, T1.first_name, T1.middle_name, T1.last_name\nORDER BY \n    enrollment_count DESC\nLIMIT 1",
            "SELECT \n    T1.student_id,\n    T1.first_name,\n    T1.middle_name,\n    T1.last_name,\n    COUNT(*) AS enrollment_count\nFROM \n    Students AS T1\nJOIN \n    Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY \n    T1.student_id\nORDER BY \n    COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "542": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?",
        "ground_truth": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `e` for consistency. Do reference `T1.student_id` in both SELECT and GROUP BY instead of `s.id` to match the actual column name. Do use `count(*)` instead of `COUNT(e.program_id)` to count all enrollments rather than just those with program_id values. Do include `T1.student_id` twice in the SELECT list instead of omitting the redundant inclusion. Do reference `Student_Enrolment` table instead of `enrollments` to use the correct table name. Do maintain the same join condition `T1.student_id = T2.student_id` instead of changing the join predicate. The amended query now correctly counts all student enrollments and matches the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` only once in the SELECT list instead of duplicating it twice. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `enrollment_count`. Do remove the alias `enrollment_count` from the COUNT(*) expression instead of keeping it. The amended query now correctly returns the student with the highest enrollment count by ordering directly on the count value without redundant column duplication.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing the join condition. Do keep the `GROUP BY T1.student_id` and `ORDER BY count(*) DESC LIMIT 1` structure instead of altering the aggregation and ordering logic. The amended query now correctly includes all necessary columns while preserving the original join, grouping, and ranking behavior to match the right SQL's output.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped column is properly selected. Do use `AS` for table aliases instead of omitting the keyword, though this is a cosmetic difference. The amended query now correctly includes the grouped column in the output while maintaining the same join logic, grouping, ordering, and limit behavior.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` instead of modifying it. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged instead of altering them. The amended query now correctly includes all required columns in the SELECT list while maintaining the same aggregation logic and result ordering.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` instead of modifying it. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged instead of altering them. The amended query now correctly includes all required columns in the SELECT list while maintaining the same aggregation logic to identify the student with the most enrollments.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, and do remove the alias `enrollment_count` from the count expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do maintain the same `JOIN` condition on `T1.student_id = T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` clause instead of altering the grouping logic. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` structure instead of modifying the sorting and limiting behavior. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same join, grouping, and ordering logic to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be explicitly included when using GROUP BY. Do keep all other elements unchanged including the `JOIN` on `T1.student_id = T2.student_id`, `GROUP BY T1.student_id`, `ORDER BY count(*) DESC`, and `LIMIT 1`. The amended query now correctly includes the grouped column in the output and matches the right SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped column is properly selected alongside the aggregate count. The amended query now correctly preserves all original logic while ensuring the student_id is available in the result set, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be present when using GROUP BY on that column. The amended query now correctly matches RIGHT_SQL's behavior by ensuring all non-aggregated columns in SELECT are either grouped or functionally dependent.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do use explicit table aliases with `AS` keyword for better readability instead of omitting the `AS` keyword. The amended query now correctly includes all necessary columns in both SELECT and GROUP BY clauses while maintaining the same aggregation logic and result ordering.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do reduce the GROUP BY clause to only `T1.student_id` instead of including `T1.first_name, T1.middle_name, T1.last_name`. Do maintain the same `JOIN` condition on `T1.student_id = T2.student_id` and keep the `ORDER BY count(*) DESC` with `LIMIT 1`. The amended query now correctly groups only by student_id while selecting all required columns and matches the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the GROUP BY column is properly projected in the results. The amended query now correctly displays all student information including the student_id alongside the enrollment count, maintaining the same logic of finding the student with the most enrollments while fixing the missing column projection.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, and do use `count(*)` without an alias instead of `COUNT(*) AS enrollment_count`. Do maintain the same `JOIN` on `T1.student_id = T2.student_id` and `GROUP BY T1.student_id` with `ORDER BY count(*) DESC LIMIT 1`. The amended query now correctly returns the student_id in the result set while preserving the aggregation logic to find the student with the highest enrollment count.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the necessary student_id field to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly returned alongside the count. The amended query now correctly preserves all original logic while including the necessary student_id field in the output, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the necessary student_id field to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly returns both the student details and their enrollment count while maintaining the same JOIN condition, GROUP BY logic, ORDER BY sorting, and LIMIT constraint, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the missing student_id column to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.id, COUNT(e.program_id) as enrollment_count\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nORDER BY enrollment_count DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY enrollment_count DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id, T1.first_name, T1.middle_name, T1.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "543": {
        "db_id": "student_transcripts_tracking",
        "question": "Which semesters do not have any student enrolled? List the semester name.",
        "ground_truth": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )",
        "amends": [
            "Do use a subquery with `NOT IN` to filter `semester_id` values that don't exist in the `Student_Enrolment` table instead of checking for `student_count = 0`, which may not accurately reflect enrollment status. Do reference the correct table name `Semesters` (with capital S) instead of `semesters` to match the schema. The amended query now correctly identifies semesters with no student enrollments by checking for the absence of related records in the enrollment table rather than relying on a potentially incorrect count field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT semester_name FROM semesters WHERE student_count = 0;",
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment)"
        ],
        "rule_sql": []
    },
    "544": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name of the semester with no students enrolled?",
        "ground_truth": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )",
        "amends": [
            "Do select `semester_name` instead of `name` and change the table reference to `Semesters` instead of `semesters`. Do use a `NOT IN` subquery condition with `semester_id` instead of a direct `student_count = 0` filter. Do add a subquery that references `Student_Enrolment` table to check for enrollment existence instead of relying on a potentially incorrect count column. The amended query now correctly identifies semesters without any student enrollments by checking against the enrollment records rather than using a count that may not be properly maintained."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM semesters WHERE student_count = 0;",
            "SELECT semester_name \nFROM Semesters \nWHERE semester_id NOT IN (\n    SELECT DISTINCT semester_id \n    FROM Student_Enrolment\n)"
        ],
        "rule_sql": []
    },
    "545": {
        "db_id": "student_transcripts_tracking",
        "question": "What are all the course names of the courses which ever have students enrolled in?",
        "ground_truth": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
        "amends": [
            "Do use `DISTINCT` on `T1.course_name` instead of omitting it. Do join `Courses AS T1` with `Student_Enrolment_Courses AS T2` on `T1.course_id = T2.course_id` instead of querying `courses` alone. Do remove the `WHERE student_id IS NULL` filter instead of keeping it, as the correct logic requires finding courses that have enrollments rather than those with null student IDs. The amended query now correctly identifies distinct courses that have student enrollments by joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_id IS NULL;",
            "SELECT DISTINCT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id"
        ],
        "rule_sql": []
    },
    "546": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names of all courses that have some students enrolled?",
        "ground_truth": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
        "amends": [
            "Do add `DISTINCT` modifier and join `Student_Enrolment_Courses` table instead of querying only the `courses` table. Do use `JOIN` with `T1.course_id = T2.course_id` predicate instead of filtering by `student_count = 0`. Do remove the `WHERE` clause condition instead of keeping the incorrect filter that doesn't account for enrollment relationships. The amended query now correctly identifies courses with student enrollments by joining the enrollment table rather than relying on a potentially incorrect student_count field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_count = 0;",
            "SELECT DISTINCT c.course_name\nFROM Courses c\nJOIN Student_Enrolment_Courses sec ON c.course_id = sec.course_id"
        ],
        "rule_sql": []
    },
    "547": {
        "db_id": "student_transcripts_tracking",
        "question": "What's the name of the course with most number of enrollments?",
        "ground_truth": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY enrollment_count ASC` to order by actual enrollment count rather than a static column. Do use `count(*)` instead of `enrollment_count` to dynamically calculate enrollments from the join. Do add table alias `T1` for `Courses` instead of using the table name directly. The amended query now correctly identifies the most popular course by counting actual student enrollments rather than relying on a potentially outdated static enrollment_count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY enrollment_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "548": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name of the course with the most students enrolled?",
        "ground_truth": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY student_count ASC` to order by enrollment count rather than student count. Do change `LIMIT 1` to return the course with the highest enrollment instead of the lowest student count. The amended query now correctly identifies the most popular course by enrollment count rather than relying on potentially incorrect student_count data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "549": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
        "ground_truth": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "amends": [
            "Do add `JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id` instead of querying only the `students` table. Do change the state filter to `T2.state_province_county = 'NorthCarolina'` instead of `state = 'NorthCarolina'` since the state information now comes from the joined Addresses table. Do remove the `degree_program IS NOT NULL` filter instead of keeping it, as the right query uses a different exclusion logic. Do add `EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id` instead of omitting this exclusion clause, which removes students who are enrolled in programs. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references for clarity and to handle multiple table instances. The amended query now correctly identifies students from North Carolina who are not currently enrolled in any programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE state = 'North Carolina' AND degree_program IS NOT NULL;",
            "SELECT DISTINCT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT \nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ],
        "rule_sql": []
    },
    "550": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
        "ground_truth": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "amends": [
            "Do add `JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id` instead of querying only the students table. Do change the state filter to `T2.state_province_county = 'NorthCarolina'` instead of `state = 'North Carolina'` since the state information is in the Addresses table. Do remove the `degree_program IS NULL` filter instead of keeping it, as the right query uses a different approach to filter students. Do add an `EXCEPT` clause with a subquery `SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id` instead of omitting it, which excludes enrolled students from the results. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references for clarity and to handle multiple table instances. The amended query now correctly identifies North Carolina students who are not enrolled in any programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM students WHERE state = 'North Carolina' AND degree_program IS NULL;",
            "SELECT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ],
        "rule_sql": []
    },
    "551": {
        "db_id": "student_transcripts_tracking",
        "question": "Show the date and id of the transcript with at least 2 course results.",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.transcript_date` and `T1.transcript_id` instead of `date` and `id`. Do join `Transcript_Contents AS T1` and `Transcripts AS T2` with `ON T1.transcript_id = T2.transcript_id` instead of querying only `transcript` table. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of placing it in `WHERE COUNT(course_result) >= 2`. Do use `count(*)` instead of `COUNT(course_result)` for proper aggregation. The amended query now correctly aggregates transcript contents and filters groups with multiple entries, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, id FROM transcript WHERE COUNT(course_result) >= 2",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING count(*) >= 2"
        ],
        "rule_sql": []
    },
    "552": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the date and id of the transcript with at least 2 courses listed?",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit table aliases `T2.transcript_date` and `T1.transcript_id` instead of ambiguous column names `date` and `id`. Do join tables `Transcript_Contents AS T1` and `Transcripts AS T2` with `ON T1.transcript_id = T2.transcript_id` instead of querying a single table. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using `WHERE COUNT(course_id) >= 2` which is invalid syntax. Do remove the incorrect `course_id` reference and use `count(*)` instead. The amended query now correctly counts transcripts with multiple entries by joining the related tables and using proper grouping with HAVING.",
            "Do select `T1.transcript_id` and `T2.transcript_date` instead of `T2.transcript_id` and `T2.transcript_date`. Do maintain the same `FROM` clause with `Transcript_Contents AS T1` and `JOIN Transcripts AS T2` on `T1.transcript_id = T2.transcript_id`. Do preserve the `GROUP BY T1.transcript_id` and `HAVING COUNT(*) >= 2` clauses without changes. The amended query now correctly selects the transcript_id from the grouping table T1 instead of T2, ensuring proper grouping semantics while maintaining the same filtering logic for transcripts with at least two contents.",
            "Do include `T2.transcript_date` in the SELECT list instead of omitting it, and do reorder the columns as `T2.transcript_date, T1.transcript_id` instead of `T1.transcript_id, T2.transcript_date`. The amended query now correctly includes all necessary columns while maintaining the same grouping and filtering logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, id FROM transcript WHERE COUNT(course_id) >= 2",
            "SELECT T2.transcript_id, T2.transcript_date\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2",
            "SELECT T1.transcript_id, T2.transcript_date\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "553": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the phone number of the man with the first name Timmothy and the last name Ward?",
        "ground_truth": "SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward'",
        "amends": [
            "Do select `cell_mobile_number` instead of `phone_number` and query the `Students` table instead of `people`. Do keep the same filter conditions `first_name = 'Timmothy'` and `last_name = 'Ward'` unchanged. The amended query now correctly retrieves the mobile number from the Students table instead of attempting to find a phone number in a non-existent people table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM people WHERE first_name = 'Timmothy' AND last_name = 'Ward';",
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';"
        ],
        "rule_sql": []
    },
    "554": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the mobile phone number of the student named Timmothy Ward ?",
        "ground_truth": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'",
        "amends": [
            "Do select `cell_mobile_number` instead of `phone_number` in the SELECT list. Do filter on both `first_name = 'timmothy'` and `last_name = 'ward'` instead of only `name = 'Timmothy Ward'` in the WHERE clause. The amended query now correctly retrieves the mobile number using separate first and last name fields instead of a combined name field.",
            "Do use lowercase column and table names `cell_mobile_number` and `students` instead of mixed case `cell_mobile_number` and `Students`. Do use lowercase string literals `'timmothy'` and `'ward'` instead of capitalized `'Timmothy'` and `'Ward'`. Do maintain the same WHERE filter structure with `first_name = 'timmothy' and last_name = 'ward'` instead of `first_name = 'Timmothy' AND last_name = 'Ward'`. The amended query now matches the right SQL's behavior with case-insensitive schema references and consistent lowercase string comparisons."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM students WHERE name = 'Timmothy Ward';",
            "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';",
            "SELECT cell_mobile_number FROM students WHERE first_name = 'timmothy' AND last_name = 'ward'"
        ],
        "rule_sql": []
    },
    "555": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is the first student to register? List the first name, middle name and last name.",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
        "amends": [
            "Do reference the `date_first_registered` column instead of `registration_date` in the ORDER BY clause, as the correct column name differs from what was originally specified. The table name should be referenced as `Students` (with capital S) instead of `students` (with lowercase s) to match the correct schema. All other elements including the SELECT list columns (`first_name`, `middle_name`, `last_name`), the LIMIT 1 constraint, and the ascending sort order remain unchanged. The amended query now correctly sorts by the appropriate registration date column and references the proper table name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students ORDER BY registration_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "556": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name of the first student to register?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
        "amends": [
            "Do reference the `date_first_registered` column instead of `registration_date` in the ORDER BY clause, as the correct column name reflects the actual registration timestamp field in the Students table. The amended query now correctly sorts by the appropriate registration date column and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students ORDER BY registration_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "557": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is the earliest graduate of the school? List the first name, middle name and last name.",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
        "amends": [
            "Do query the `Students` table instead of the `graduates` table. Do order by `date_left` instead of `graduation_date`. The amended query now correctly retrieves student records from the appropriate table using the correct date field for ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM graduates ORDER BY graduation_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "558": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name of the earliest school graduate?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
        "amends": [
            "Do query the `Students` table instead of the `graduates` table. Do order by `date_left` instead of `graduation_date`. The amended query now correctly retrieves student names from the appropriate table using the correct date column for ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM graduates ORDER BY graduation_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "559": {
        "db_id": "student_transcripts_tracking",
        "question": "Whose permanent address is different from his or her current address? List his or her first name.",
        "ground_truth": "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id",
        "amends": [
            "Do select from `Students` table instead of `people` table. Do filter with `current_address_id != permanent_address_id` instead of `permanent_address = current_address`. Do reference address ID columns instead of address value columns. The amended query now correctly identifies students whose current and permanent addresses differ by comparing their ID values rather than address content."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM people WHERE permanent_address = current_address;",
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ],
        "rule_sql": []
    },
    "560": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first name of the student whose permanent address is different from his or her current one?",
        "ground_truth": "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id",
        "amends": [
            "Do reference the correct table name `Students` instead of `students` to match the actual schema. Do compare the correct column identifiers `current_address_id` and `permanent_address_id` instead of `permanent_address` and `current_address` to properly evaluate address inequality using ID values rather than address text. The amended query now correctly filters students based on address ID mismatch and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE permanent_address != current_address LIMIT 1;",
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ],
        "rule_sql": []
    },
    "561": {
        "db_id": "student_transcripts_tracking",
        "question": "Which address holds the most number of students currently? List the address id and all lines.",
        "ground_truth": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.line_1` and `T1.line_2` instead of `line1`, `line2`, and `line3`. Do remove the `student_count` alias and count aggregation from the SELECT list instead of including it. Do join on `T2.current_address_id` instead of `students.address_id`. Do remove the explicit column alias for the count instead of keeping `as student_count`. Do reference the count directly in ORDER BY instead of using the alias. The amended query now correctly retrieves address details with student counts using the proper join condition and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address_id, line1, line2, line3, COUNT(*) as student_count \nFROM addresses \nJOIN students ON addresses.address_id = students.address_id \nGROUP BY address_id \nORDER BY student_count DESC \nLIMIT 1;",
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses T1\nJOIN Students T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "562": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the id, line 1, and line 2 of the address with the most students?",
        "ground_truth": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T1.address_id` and remove `id` in the SELECT list instead of using the original column name. Do add `FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id = T2.current_address_id` instead of just selecting from `addresses` without joining. Do add `GROUP BY T1.address_id` to aggregate by address instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `student_count DESC` to count actual students per address. Do keep `LIMIT 1` to return the single address with the most students. The amended query now correctly identifies the address with the highest student count by joining and counting relationships instead of relying on a potentially non-existent student_count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, line_1, line_2 FROM addresses ORDER BY student_count DESC LIMIT 1;",
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses AS T1\nJOIN Students AS T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "563": {
        "db_id": "student_transcripts_tracking",
        "question": "On average, when were the transcripts printed?",
        "ground_truth": "SELECT avg(transcript_date) FROM Transcripts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(transcript_date) FROM transcripts;"
        ],
        "rule_sql": []
    },
    "564": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the average transcript date?",
        "ground_truth": "SELECT avg(transcript_date) FROM Transcripts",
        "amends": [
            "Do reference the correct table name `Transcripts` instead of `transcript` and use the proper column name `transcript_date` instead of `date` for the AVG function, as the original query referenced incorrect schema elements that would cause execution errors. The amended query now correctly calculates the average of transcript dates from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(date) FROM transcript;",
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ],
        "rule_sql": []
    },
    "565": {
        "db_id": "student_transcripts_tracking",
        "question": "When is the first transcript released? List the date and details.",
        "ground_truth": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
        "amends": [
            "Do use column name `transcript_date` instead of `date` and `other_details` instead of `details` in the SELECT list. Do reference table `Transcripts` instead of `transcripts` in the FROM clause. The amended query now correctly matches the intended behavior with proper column and table names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, details FROM transcripts ORDER BY date ASC LIMIT 1;",
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "566": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the earliest date of a transcript release, and what details can you tell me?",
        "ground_truth": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
        "amends": [
            "Do select `transcript_date` and `other_details` instead of `MIN(release_date)`, `transcript_id`, and `content`. Do query from `Transcripts` instead of `transcripts`. Do remove the WHERE clause with subquery instead of filtering by maximum release date. Do add `ORDER BY transcript_date ASC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limitation. Do remove the aggregate function and grouping semantics instead of using MIN with non-aggregated columns. The amended query now correctly retrieves the earliest transcript details by date ordering rather than attempting to find minimum release date with incorrect aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(release_date) AS earliest_date, transcript_id, content FROM transcripts WHERE release_date = (SELECT MAX(release_date) FROM transcripts);",
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "567": {
        "db_id": "student_transcripts_tracking",
        "question": "How many transcripts are released?",
        "ground_truth": "SELECT count(*) FROM Transcripts",
        "amends": [
            "Do use the correct table name `Transcripts` instead of the incorrect `transcripts` to match the actual schema. Do maintain the same `COUNT(*)` aggregation and `released = 'false'` filter condition as the original query. The amended query now correctly references the proper table name while preserving the same counting logic and filtering behavior.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. Do remove the `WHERE released = 'false'` filter instead of keeping it, as the right query counts all records without filtering. Do maintain the same table source `FROM Transcripts` without changes. The amended query now correctly counts all transcript records instead of only unreleased ones, matching the right SQL's behavior of returning the total count from the Transcripts table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM transcripts WHERE released = 'false';",
            "SELECT COUNT(*) FROM Transcripts WHERE released = 'false';",
            "SELECT count(*) FROM Transcripts;"
        ],
        "rule_sql": []
    },
    "568": {
        "db_id": "student_transcripts_tracking",
        "question": "How many transcripts are listed?",
        "ground_truth": "SELECT count(*) FROM Transcripts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": []
    },
    "569": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the last transcript release date?",
        "ground_truth": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1",
        "amends": [
            "Do select `transcript_date` instead of `MAX(release_date)` and remove the aggregate function. Do use a simple `FROM Transcripts` source instead of a subquery approach. Do remove the `WHERE` filter entirely instead of using a nested subquery. Do add `ORDER BY transcript_date DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using maximum aggregation. Do reference the correct column name `transcript_date` instead of `release_date` and use proper table name casing `Transcripts` instead of `transcripts`. The amended query now correctly retrieves the most recent transcript date by direct ordering and limiting instead of using nested aggregation which could return incorrect results when transcript_id and date ordering don't align."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(release_date) FROM transcripts WHERE transcript_id = (SELECT MAX(transcript_id) FROM transcripts);",
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "570": {
        "db_id": "student_transcripts_tracking",
        "question": "When was the last transcript released?",
        "ground_truth": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1",
        "amends": [
            "Do select `transcript_date` instead of `MAX(release_date)` and remove the aggregate function. Do use `FROM Transcripts` instead of `FROM transcripts` with proper table name casing. Do remove the `WHERE release_date > CURRENT_DATE` filter instead of keeping it since it incorrectly excludes all past records. Do add `ORDER BY transcript_date DESC LIMIT 1` instead of omitting ordering and limiting, which provides the most recent transcript date directly rather than attempting to find a maximum future date that doesn't exist. The amended query now correctly retrieves the latest transcript date from the table instead of looking for non-existent future dates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(release_date) FROM transcripts WHERE release_date > CURRENT_DATE;",
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "571": {
        "db_id": "student_transcripts_tracking",
        "question": "How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.",
        "ground_truth": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `count(*)` without an alias instead of aliasing as `max_count`, and do select `student_course_id` instead of `course_enrollment_id`. Do query from `Transcript_Contents` instead of `transcripts`. Do group by `student_course_id` instead of `course_enrollment_id`. Do order by `count(*)` instead of `max_count`. The amended query now correctly identifies the student course with the highest content count from the appropriate table.",
            "Do place `count(*)` before `student_course_id` in the SELECT list instead of listing `student_course_id` first, and do add a space after the comma in the SELECT list instead of omitting it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_enrollment_id, COUNT(*) as max_count \nFROM transcripts \nGROUP BY course_enrollment_id \nORDER BY max_count DESC \nLIMIT 1;",
            "SELECT student_course_id, COUNT(*) \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT count(*), student_course_id \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY count(*) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "572": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?",
        "ground_truth": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `count(*)` and `student_course_id` instead of `MAX(COUNT(*))` and `enrollment_id`. Do use table `Transcript_Contents` instead of `transcripts`. Do group by `student_course_id` instead of `course_id`. Do remove the incorrect `MAX` aggregation around the count instead of keeping it. The amended query now correctly counts records per student course and returns the highest count with its corresponding student course ID, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(COUNT(*)), enrollment_id \nFROM transcripts \nGROUP BY course_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT COUNT(*) AS count, student_course_id \nFROM Transcript_Contents \nGROUP BY student_course_id \nORDER BY count DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "573": {
        "db_id": "student_transcripts_tracking",
        "question": "Show the date of the transcript which shows the least number of results, also list the id.",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add table `Transcript_Contents AS T1` and `Transcripts AS T2` with a `JOIN` on `T1.transcript_id = T2.transcript_id` instead of querying only the `transcripts` table. Do change the SELECT list to include `T2.transcript_date` and `T1.transcript_id` instead of `transcript_date` and `transcript_id` without table qualification. Do add `GROUP BY T1.transcript_id` and change the ORDER BY to `count(*) ASC` instead of `results_count ASC`. The amended query now correctly aggregates transcript contents and orders by the count of records per transcript_id, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transcript_date, transcript_id FROM transcripts ORDER BY results_count ASC LIMIT 1;",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "574": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the date and id of the transcript with the least number of results?",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `T2.transcript_date` and `T1.transcript_id` instead of `date` and `id`. Do use `FROM Transcript_Contents AS T1 JOIN Transcripts AS T2` instead of `FROM transcript`. Do add `ON T1.transcript_id = T2.transcript_id` join condition instead of omitting it. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do order by `count(*)` instead of `COUNT(results)`. Do maintain `ASC LIMIT 1` ordering and limiting. The amended query now correctly joins tables, groups by transcript_id, and counts records instead of attempting to aggregate results without grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, id FROM transcript ORDER BY COUNT(results) ASC LIMIT 1;",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "575": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
        "ground_truth": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do use `DISTINCT T2.semester_id` from `Student_Enrolment` instead of `semester` from `students`. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying a single `students` table. Do filter with `degree_summary_name = 'Master'` and `degree_summary_name = 'Bachelor'` in separate queries instead of contradictory `degree = 'Master' AND degree = 'Bachelor'`. Do use `INTERSECT` to find common semesters instead of attempting to find rows that satisfy both degree conditions simultaneously. Do remove the impossible WHERE condition and instead use set intersection to properly identify semesters that contain both Master and Bachelor students. The amended query now correctly identifies semesters where both degree programs are offered by using proper table relationships and set operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT semester FROM students WHERE degree = 'Master' AND degree = 'Bachelor';",
            "SELECT DISTINCT T2.semester_id\nFROM Student_Enrolment AS T2\nJOIN Degree_Programs AS T1 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Student_Enrolment AS T2\nJOIN Degree_Programs AS T1 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": []
    },
    "576": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
        "ground_truth": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do use `DISTINCT T2.semester_id` instead of `semester_id` without distinct. Do change the FROM clause to join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying only `enrollments`. Do replace the WHERE condition with `degree_summary_name = 'Master'` in one branch and `degree_summary_name = 'Bachelor'` in another instead of the impossible `student_type = 'Masters' AND student_type = 'Bachelors'`. Do use `INTERSECT` between two queries to find common semester_ids instead of attempting to find rows that satisfy both conditions simultaneously. Do remove the incorrect table reference `enrollments` and add the correct tables `Degree_Programs` and `Student_Enrolment` with proper join conditions. The amended query now correctly finds semester IDs that have both Master's and Bachelor's students by intersecting results from two separate queries targeting each degree type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT semester_id FROM enrollments WHERE student_type = 'Masters' AND student_type = 'Bachelors';",
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": []
    },
    "577": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different addresses do the students currently live?",
        "ground_truth": "SELECT count(DISTINCT current_address_id) FROM Students",
        "amends": [
            "Do use `count(DISTINCT current_address_id)` instead of `COUNT(*)` to count unique addresses rather than all rows. Do reference the `current_address_id` column instead of checking `address IS NOT NULL` to properly identify distinct address records. Do remove the `WHERE address IS NOT NULL` filter instead of keeping it since the distinct count inherently handles null values appropriately. The amended query now correctly counts distinct address identifiers rather than all student records with non-null address fields, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE address IS NOT NULL",
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ],
        "rule_sql": []
    },
    "578": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the different addresses that have students living there?",
        "ground_truth": "SELECT count(DISTINCT current_address_id) FROM Students",
        "amends": [
            "Do use `count(DISTINCT current_address_id)` instead of `SELECT DISTINCT address` to count unique addresses rather than listing them. Do reference `current_address_id` instead of `address` to use the correct column identifier. Do remove the `WHERE student_id IS NOT NULL` filter instead of keeping it since the count should include all students regardless of student_id status. Do change from selecting distinct values to counting distinct values to return a single aggregate result instead of a list of individual addresses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT address FROM students WHERE student_id IS NOT NULL",
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ],
        "rule_sql": []
    },
    "579": {
        "db_id": "student_transcripts_tracking",
        "question": "List all the student details in reversed lexicographical order.",
        "ground_truth": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC",
        "amends": [
            "Do select `other_student_details` instead of `*` to return only specific columns instead of all columns. Do order by `other_student_details DESC` instead of `name ASC` to sort by a different column in descending order instead of ascending order. The amended query now correctly returns only the other_student_details column sorted in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students ORDER BY name ASC;",
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ],
        "rule_sql": []
    },
    "580": {
        "db_id": "student_transcripts_tracking",
        "question": "What other details can you tell me about students in reverse alphabetical order?",
        "ground_truth": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC",
        "amends": [
            "Do select `other_student_details` instead of `*` to return only specific columns instead of all columns. Do order by `other_student_details DESC` instead of `name ASC` to sort by a different column in descending order instead of ascending order. The amended query now correctly returns only the other_student_details column sorted in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students ORDER BY name ASC;",
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ],
        "rule_sql": []
    },
    "581": {
        "db_id": "student_transcripts_tracking",
        "question": "Describe the section h.",
        "ground_truth": "SELECT section_description FROM Sections WHERE section_name  =  'h'",
        "amends": [
            "Do select only `section_description` instead of all columns with `*`. Do reference the table as `Sections` (case-sensitive) instead of `sections`. The amended query now correctly retrieves only the section description from the specified table while maintaining the same filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM sections WHERE section_name = 'h';",
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ],
        "rule_sql": []
    },
    "582": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the description for the section named h?",
        "ground_truth": "SELECT section_description FROM Sections WHERE section_name  =  'h'",
        "amends": [
            "Do reference the column as `section_description` instead of `description` and use the table name `Sections` instead of `sections`. Do use the filter condition `section_name = 'h'` instead of `name = 'h'` to correctly match the column names in the schema. The amended query now properly selects from the Sections table with the correct column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM sections WHERE name = 'h';",
            "SELECT section_description FROM Sections WHERE section_name = 'h'"
        ],
        "rule_sql": []
    },
    "583": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .",
        "ground_truth": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "amends": [
            "Do join `addresses as t2` instead of querying only the `students` table. Do use `ON t1.permanent_address_id = t2.address_id` instead of missing this join condition. Do change the WHERE clause to `t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'` instead of `country = 'Haiti' AND cell_phone = '09700166582'`, correcting both the column references and the logical operator from AND to OR. Do reference `t1.first_name` with table alias instead of just `first_name`. Do use lowercase 'haiti' instead of 'Haiti' for case consistency. The amended query now correctly joins the addresses table and uses proper OR logic to find records matching either condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE country = 'Haiti' AND cell_phone = '09700166582';",
            "SELECT t1.first_name \nFROM Students t1\nJOIN Addresses t2 ON t1.permanent_address_id = t2.address_id\nWHERE t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'"
        ],
        "rule_sql": []
    },
    "584": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?",
        "ground_truth": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "amends": [
            "Do select `t1.first_name` from the `students` table with alias `t1` instead of `first_name` from `students` without an alias. Do add a `JOIN` with the `addresses` table as `t2` on `t1.permanent_address_id = t2.address_id` instead of querying only the `students` table. Do filter on `t2.country = 'haiti'` instead of `country = 'Haiti'` to reference the joined table's column with correct case. Do filter on `t1.cell_mobile_number = '09700166582'` instead of `phone_number = '09700166582'` to use the correct column name from the students table. The amended query now correctly joins address data and uses proper column references to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students WHERE country = 'Haiti' OR phone_number = '09700166582';",
            "SELECT t1.first_name FROM Students t1 JOIN Addresses t2 ON t1.permanent_address_id = t2.address_id WHERE t2.country = 'haiti' OR t1.cell_mobile_number = '09700166582'"
        ],
        "rule_sql": []
    },
    "585": {
        "db_id": "tvshow",
        "question": "List the title of all cartoons in alphabetical order.",
        "ground_truth": "SELECT Title FROM Cartoon ORDER BY title",
        "amends": [
            "Do use the exact table name `Cartoon` instead of the pluralized `cartoons` to match the correct schema. Do use the exact column name `Title` with proper capitalization instead of lowercase `title` to match the column definition. Do remove the `DESC` modifier from the `ORDER BY` clause instead of keeping descending order, resulting in ascending alphabetical sorting by default. The amended query now correctly selects from the Cartoon table with proper column naming and sorting behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM cartoons ORDER BY title DESC;",
            "SELECT Title FROM Cartoon ORDER BY Title;"
        ],
        "rule_sql": []
    },
    "586": {
        "db_id": "tvshow",
        "question": "What are the titles of the cartoons sorted alphabetically?",
        "ground_truth": "SELECT Title FROM Cartoon ORDER BY title",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column name `Title` instead of `title` in the SELECT clause. Do remove the `DESC` modifier from the `ORDER BY title` clause instead of keeping descending order. The amended query now correctly references the proper table and column names while maintaining ascending order by default."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM cartoons ORDER BY title DESC;",
            "SELECT Title FROM Cartoon ORDER BY Title;"
        ],
        "rule_sql": []
    },
    "587": {
        "db_id": "tvshow",
        "question": "List all cartoon directed by \"Ben Jones\".",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";",
        "amends": [
            "Do specify `Title` in the SELECT list instead of using `*` to select all columns. Do reference the table as `Cartoon` instead of `cartoons` in the FROM clause. Do use the column name `Directed_by` instead of `director` in the WHERE filter. Do use double quotes around the string literal \"Ben Jones\" instead of single quotes. The amended query now correctly retrieves only the Title column from the Cartoon table where Directed_by equals Ben Jones, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cartoons WHERE director = 'Ben Jones';",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ],
        "rule_sql": []
    },
    "588": {
        "db_id": "tvshow",
        "question": "What are the names of all cartoons directed by Ben Jones?",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column `Directed_by` instead of `director` for the filter condition. Do use double quotes around the string literal \"Ben Jones\" instead of single quotes. Do capitalize the output column as `Title` instead of `title` to match the correct column name. The amended query now correctly references the proper table and column names while maintaining the same filtering logic for director Ben Jones."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones';",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ],
        "rule_sql": []
    },
    "589": {
        "db_id": "tvshow",
        "question": "How many cartoons were written by \"Joseph Kuhr\"?",
        "ground_truth": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` to match the correct table name. Do use the column name `Written_by` instead of `writer` to properly identify the writer column. Do use double quotes `\"Joseph Kuhr\"` instead of single quotes `'Joseph Kuhr'` for the string literal format. The amended query now correctly counts records from the Cartoon table where Written_by equals Joseph Kuhr, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cartoons WHERE writer = 'Joseph Kuhr';",
            "SELECT COUNT(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";"
        ],
        "rule_sql": []
    },
    "590": {
        "db_id": "tvshow",
        "question": "What is the number of cartoones written by Joseph Kuhr?",
        "ground_truth": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column name `Written_by` instead of `writer` for the filter condition, while maintaining the same aggregate `count(*)` functionality. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cartoons WHERE writer = 'Joseph Kuhr';",
            "SELECT COUNT(*) FROM Cartoon WHERE Written_by = 'Joseph Kuhr'"
        ],
        "rule_sql": []
    },
    "591": {
        "db_id": "tvshow",
        "question": "list all cartoon titles and their directors ordered by their air date",
        "ground_truth": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",
        "amends": [
            "Do select `Directed_by` instead of `director` and order by `Original_air_date` instead of `title`. Do reference table `Cartoon` instead of `cartoons` and remove the column `title` from the SELECT list instead of including it. The amended query now correctly retrieves the directed by information ordered by original air date from the Cartoon table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, director FROM cartoons ORDER BY title;",
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ],
        "rule_sql": []
    },
    "592": {
        "db_id": "tvshow",
        "question": "What is the name and directors of all the cartoons that are ordered by air date?",
        "ground_truth": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",
        "amends": [
            "Do use column names `title` and `Directed_by` instead of `name` and `directors`. Do reference table `Cartoon` instead of `cartoons`. Do order by `Original_air_date` instead of `release_date`. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, directors FROM cartoons ORDER BY release_date;",
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ],
        "rule_sql": []
    },
    "593": {
        "db_id": "tvshow",
        "question": "List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\".",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";",
        "amends": [
            "Do use `OR` instead of `AND` for the director condition to find records matching either director instead of requiring both simultaneously. Do reference the correct table name `Cartoon` instead of `cartoons` and use the correct column name `Directed_by` instead of `director`. Do use proper column casing `Title` instead of `title` and maintain consistent quotation style with double quotes around director names instead of single quotes. The amended query now correctly returns cartoons directed by either Ben Jones or Brandon Vietti instead of incorrectly requiring both directors simultaneously, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones' AND director = 'Brandon Vietti'",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\""
        ],
        "rule_sql": []
    },
    "594": {
        "db_id": "tvshow",
        "question": "What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\" OR Directed_by = \"Brandon Vietti\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use column `Directed_by` instead of `director`. Do use `OR` logic between the director conditions instead of `AND` which would return no results since a director cannot be both people simultaneously. Do use proper column name `Title` instead of `title` and maintain the correct table and column casing. The amended query now correctly returns cartoons directed by either Ben Jones or Brandon Vietti instead of incorrectly requiring both conditions to be true."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones' AND director = 'Brandon Vietti';",
            "SELECT Title FROM Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti';"
        ],
        "rule_sql": []
    },
    "595": {
        "db_id": "tvshow",
        "question": "Which country has the most of TV Channels? List the country and number of TV Channels it has.",
        "ground_truth": "SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do `ORDER BY count(*) DESC` instead of `ORDER BY channel_count ASC` to sort by descending count rather than ascending. Do use `TV_Channel` as the table name instead of `tv_channels` to match the correct source. Do remove the alias `as channel_count` instead of keeping it since the right query uses the raw aggregate expression. Do use `Country` with proper capitalization instead of `country` to match the column name exactly. The amended query now correctly identifies the country with the highest number of TV channels by sorting in descending order and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as channel_count FROM tv_channels GROUP BY country ORDER BY channel_count ASC LIMIT 1;",
            "SELECT Country, COUNT(*) FROM TV_Channel GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "596": {
        "db_id": "tvshow",
        "question": "What is the country with the most number of TV Channels and how many does it have?",
        "ground_truth": "SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count` in the SELECT list. Do reference the table as `TV_Channel` instead of `tv_channels` in the FROM clause. Do use `Country` with proper case instead of `country` in both SELECT and GROUP BY clauses. Do order by `count(*)` directly instead of the aliased `channel_count` in the ORDER BY clause. The amended query now correctly counts channels per country and returns the country with the highest count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as channel_count FROM tv_channels GROUP BY country ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Country, count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "597": {
        "db_id": "tvshow",
        "question": "List the number of different series names and contents in the TV Channel table.",
        "ground_truth": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",
        "amends": [
            "Do use `count(DISTINCT series_name)` instead of `COUNT(series_name)` to count unique values rather than all non-null values. Do use `count(DISTINCT content)` instead of `COUNT(contents)` to count distinct values and reference the correct column name `content` instead of `contents`. The amended query now correctly counts distinct series names and distinct content values, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(series_name), COUNT(contents) FROM TV_Channel",
            "SELECT COUNT(DISTINCT series_name), COUNT(DISTINCT content) FROM TV_Channel;"
        ],
        "rule_sql": []
    },
    "598": {
        "db_id": "tvshow",
        "question": "How many different series and contents are listed in the TV Channel table?",
        "ground_truth": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",
        "amends": [
            "Do select `count(DISTINCT series_name)` and `count(DISTINCT content)` instead of just `COUNT(*)`. Do add distinct counting for both `series_name` and `content` columns instead of counting all rows without distinction. The amended query now correctly counts unique series names and unique content values separately instead of providing a single total row count, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM TV_Channel;",
            "SELECT COUNT(DISTINCT series_name) AS unique_series_count, COUNT(DISTINCT Content) AS unique_content_count FROM TV_Channel;"
        ],
        "rule_sql": []
    },
    "599": {
        "db_id": "tvshow",
        "question": "What is the content of TV Channel with serial name \"Sky Radio\"?",
        "ground_truth": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do select `Content` instead of `*` for all columns. Do reference table `TV_Channel` instead of `tv_channels`. Do filter on `series_name` instead of `channel_name`. Do use double quotes `\"Sky Radio\"` instead of single quotes for the string literal. The amended query now correctly retrieves the specified content from the TV_Channel table based on the series name rather than channel name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM tv_channels WHERE channel_name = 'Sky Radio';",
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ],
        "rule_sql": []
    },
    "600": {
        "db_id": "tvshow",
        "question": "What is the content of the series Sky Radio?",
        "ground_truth": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do select `Content` instead of `*` to specify the exact column needed. Do query from `TV_Channel` instead of `series` to access the correct table containing the content data. Do filter on `series_name` instead of `title` to use the appropriate column name for series identification. Do use double quotes `\"Sky Radio\"` instead of single quotes for string literal consistency. The amended query now correctly retrieves content from the TV_Channel table filtered by series name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM series WHERE title = 'Sky Radio';",
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ],
        "rule_sql": []
    },
    "601": {
        "db_id": "tvshow",
        "question": "What is the Package Option of TV Channel with serial name \"Sky Radio\"?",
        "ground_truth": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do reference table `TV_Channel` instead of `TV_Channels` and use column `series_name` instead of `serial_name` while maintaining the same filter value for 'Sky Radio'."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Package_Option FROM TV_Channels WHERE serial_name = 'Sky Radio';",
            "SELECT Package_Option FROM TV_Channel WHERE series_name = 'Sky Radio';"
        ],
        "rule_sql": []
    },
    "602": {
        "db_id": "tvshow",
        "question": "What are the Package Options of the TV Channels whose series names are Sky Radio?",
        "ground_truth": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do reference the column as `Package_Option` instead of `Package_Options` to match the correct column name. Do reference the table as `TV_Channel` instead of `TV_Channels` to use the correct singular table name. Do use double quotes `\"Sky Radio\"` instead of single quotes `'Sky Radio'` for the string literal format. The amended query now correctly retrieves the package option from the TV channel table for the specified series."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Package_Options FROM TV_Channels WHERE Series_Name = 'Sky Radio';",
            "SELECT \"Package_Option\" FROM \"TV_Channel\" WHERE \"series_name\" = \"Sky Radio\";"
        ],
        "rule_sql": []
    },
    "603": {
        "db_id": "tvshow",
        "question": "How many TV Channel using language English?",
        "ground_truth": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";",
        "amends": [
            "Do use table name `TV_Channel` instead of `tv_channels` to reference the correct table. Do use double quotes `\"English\"` instead of single quotes `'English'` for the string literal, though this may be database-specific. The amended query now correctly counts records from the TV_Channel table where the language is English, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tv_channels WHERE language = 'English';",
            "SELECT COUNT(*) FROM \"TV_Channel\" WHERE \"Language\" = \"English\";"
        ],
        "rule_sql": []
    },
    "604": {
        "db_id": "tvshow",
        "question": "How many TV Channels use the English language?",
        "ground_truth": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";",
        "amends": [
            "Do reference table `TV_Channel` instead of `channels` while keeping the same count aggregation and English language filter, maintaining identical query behavior with the amended table name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM channels WHERE language = 'English';",
            "SELECT COUNT(*) FROM TV_Channel WHERE Language = 'English';"
        ],
        "rule_sql": []
    },
    "605": {
        "db_id": "tvshow",
        "question": "List the language used least number of TV Channel. List language and number of TV Channel.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count` in the SELECT list. Do change the ORDER BY to `count(*) ASC` instead of `channel_count DESC`. Do remove the alias reference in ORDER BY and change the sort direction to ascending instead of descending. The amended query now correctly orders by the actual count in ascending order instead of using an aliased column reference with descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as channel_count FROM TV_Channel GROUP BY language ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Language, count(*) FROM TV_Channel GROUP BY Language ORDER BY count(*) ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "606": {
        "db_id": "tvshow",
        "question": "What are the languages used by the least number of TV Channels and how many channels use it?",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as channel_count`. Do order by `count(*) ASC` instead of `channel_count DESC`. Do reference table `TV_Channel` instead of `tv_channels`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as channel_count FROM tv_channels GROUP BY language ORDER BY channel_count DESC LIMIT 1;",
            "SELECT Language, COUNT(*) FROM TV_Channel GROUP BY Language ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "607": {
        "db_id": "tvshow",
        "question": "List each language and the number of TV Channels using it.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",
        "amends": [
            "Do use consistent case `LANGUAGE` instead of mixed case `language` for the column name. Do use consistent table name `TV_Channel` instead of `tv_channels` for the source table. The amended query now correctly counts records by language from the TV_Channel table with consistent naming conventions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) FROM tv_channels GROUP BY language;",
            "SELECT LANGUAGE, COUNT(*) AS number_of_channels FROM TV_Channel GROUP BY LANGUAGE;"
        ],
        "rule_sql": []
    },
    "608": {
        "db_id": "tvshow",
        "question": "For each language, list the number of TV Channels that use it.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",
        "amends": [
            "Do use the exact table name `TV_Channel` instead of `tv_channels` to match the correct schema. Do maintain the same column name `LANGUAGE` and aggregation `count(*)` with identical `GROUP BY LANGUAGE` logic, as there are no substantive differences in the SELECT list, aggregates, or grouping between the queries. The amended query now matches RIGHT_SQL's behavior by using the correct table reference while preserving identical query logic and results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) FROM tv_channels GROUP BY language;",
            "SELECT Language, COUNT(*) FROM TV_Channel GROUP BY Language"
        ],
        "rule_sql": []
    },
    "609": {
        "db_id": "tvshow",
        "question": "What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Channel` instead of `cartoon.channel_id` in the join condition. Do reference `T2.Title` instead of `cartoon.title` in the WHERE filter. Do use double quotes around the string literal instead of single quotes. The amended query now correctly joins on the proper column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tv_channel.series_name FROM tv_channel JOIN cartoon ON tv_channel.id = cartoon.channel_id WHERE cartoon.title = 'The Rise of the Blue Beetle!'",
            "SELECT T1.series_name FROM TV_Channel T1 JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\""
        ],
        "rule_sql": []
    },
    "610": {
        "db_id": "tvshow",
        "question": "What is the series name of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle\"?",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\";",
        "amends": [
            "Do join `TV_Channel AS T1` with `Cartoon AS T2` on `T1.id = T2.Channel` instead of querying only `tv_channels` table. Do filter on `T2.Title = \"The Rise of the Blue Beetle!\"` instead of `cartoon_name = 'The Rise of the Blue Beetle'`. Do select `T1.series_name` with table alias qualification instead of just `series_name`. The amended query now correctly joins the related tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_name FROM tv_channels WHERE cartoon_name = 'The Rise of the Blue Beetle';",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'"
        ],
        "rule_sql": []
    },
    "611": {
        "db_id": "tvshow",
        "question": "List the title of all  Cartoons showed on TV Channel with series name \"Sky Radio\".",
        "ground_truth": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Title` instead of `title` and specify the table alias. Do join `TV_Channel AS T1` to `Cartoon AS T2` instead of querying only `Cartoons` table. Do use `ON T1.id = T2.Channel` for the join condition instead of a simple WHERE filter. Do filter on `T1.series_name = \"Sky Radio\"` instead of `channel = 'Sky Radio'` to properly reference the channel table. The amended query now correctly joins the channel table to retrieve cartoons associated with the specified channel series name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM Cartoons WHERE channel = 'Sky Radio';",
            "SELECT T2.Title \nFROM TV_Channel AS T1 \nJOIN Cartoon AS T2 ON T1.id = T2.Channel \nWHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": []
    },
    "612": {
        "db_id": "tvshow",
        "question": "What is the title of all the cartools that are on the TV Channel with the series name \"Sky Radio\"?",
        "ground_truth": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Title` instead of `title` and specify the table alias. Do use `FROM TV_Channel AS T1 JOIN Cartoon AS T2` instead of `FROM cartools` to reference the correct tables with proper aliases. Do add the join condition `ON T1.id = T2.Channel` instead of omitting any join relationship. Do apply the filter `T1.series_name = \"Sky Radio\"` on the TV_Channel table instead of applying it directly to a non-existent table. The amended query now correctly joins the TV_Channel and Cartoon tables to retrieve titles from the appropriate source based on the channel relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM cartools WHERE series_name = 'Sky Radio';",
            "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": []
    },
    "613": {
        "db_id": "tvshow",
        "question": "List the Episode of all TV series sorted by rating.",
        "ground_truth": "SELECT Episode FROM TV_series ORDER BY rating",
        "amends": [
            "Do select specific column `Episode` instead of all columns `*` from the `TV_series` table instead of the `episodes` table. Do order by `rating` in ascending order instead of descending order. The amended query now correctly retrieves only the Episode column from the TV_series table sorted by rating in ascending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes ORDER BY rating DESC;",
            "SELECT Episode FROM TV_series ORDER BY Rating ASC;"
        ],
        "rule_sql": []
    },
    "614": {
        "db_id": "tvshow",
        "question": "What are all of the episodes ordered by ratings?",
        "ground_truth": "SELECT Episode FROM TV_series ORDER BY rating",
        "amends": [
            "Do select `Episode` instead of `*` for all columns. Do source from `TV_series` instead of `episodes` table. Do order by `rating` instead of `title DESC`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes ORDER BY title DESC;",
            "SELECT Episode FROM TV_series ORDER BY Rating;"
        ],
        "rule_sql": []
    },
    "615": {
        "db_id": "tvshow",
        "question": "List top 3 highest Rating  TV series. List the TV series's Episode and Rating.",
        "ground_truth": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "616": {
        "db_id": "tvshow",
        "question": "What are 3 most highly rated episodes in the TV series table and what were those ratings?",
        "ground_truth": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",
        "amends": [
            "Do use column name `Episode` instead of `title` in the SELECT list. Do use column name `Rating` instead of `rating` in both the SELECT list and ORDER BY clause. The amended query now correctly selects and orders by the intended columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, rating FROM tv_series ORDER BY rating DESC LIMIT 3;",
            "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "617": {
        "db_id": "tvshow",
        "question": "What is minimum and maximum share of TV series?",
        "ground_truth": "SELECT max(SHARE) , min(SHARE) FROM TV_series;",
        "amends": [
            "Do use table name `TV_series` instead of `movies` with filter `WHERE type = 'TV Series'`. Do swap the column order by placing `max(SHARE)` first instead of `MIN(share) AS min_share` first. Do remove the column aliases `min_share` and `max_share` instead of keeping them. Do use uppercase function names `max` and `min` instead of mixed case `MIN` and `MAX`. The amended query now correctly selects from the dedicated TV_series table and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(share) AS min_share, MAX(share) AS max_share FROM movies WHERE type = 'TV Series';",
            "SELECT max(Share), min(Share) FROM TV_series"
        ],
        "rule_sql": []
    },
    "618": {
        "db_id": "tvshow",
        "question": "What is the maximum and minimum share for the TV series?",
        "ground_truth": "SELECT max(SHARE) , min(SHARE) FROM TV_series;",
        "amends": [
            "Do reference table `TV_series` instead of `series` in the FROM clause. Do remove the WHERE filter `type = 'Movie'` instead of keeping it. Do use uppercase column names `SHARE` instead of lowercase `share` in the aggregate functions. The amended query now correctly aggregates from the TV_series table without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(share), MIN(share) FROM series WHERE type = 'Movie';",
            "SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM TV_series;"
        ],
        "rule_sql": []
    },
    "619": {
        "db_id": "tvshow",
        "question": "What is the air date of TV series with Episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT air_date FROM tv_series WHERE episode = 'A Love of a Lifetime';"
        ],
        "rule_sql": []
    },
    "620": {
        "db_id": "tvshow",
        "question": "When did the episode \"A Love of a Lifetime\" air?",
        "ground_truth": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select `Air_Date` instead of `episode_name` and do query from `TV_series` instead of `episodes`. Do filter on `Episode` column with value \"A Love of a Lifetime\" instead of filtering on `air_date` column with value 'A Love of a Lifetime'. The amended query now correctly retrieves the air date for the specified episode rather than incorrectly trying to find episode names matching a date value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_name FROM episodes WHERE air_date = 'A Love of a Lifetime';",
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ],
        "rule_sql": []
    },
    "621": {
        "db_id": "tvshow",
        "question": "What is Weekly Rank of TV series with Episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select only `Weekly_Rank` instead of both `title` and `weekly_rank`. Do filter on `Episode` column instead of `episode_title` column. Do use double quotes around the string literal instead of single quotes. Do remove the `ORDER BY weekly_rank DESC` clause instead of keeping it. The amended query now matches the RIGHT_SQL's behavior by selecting the correct column and filtering on the appropriate episode identifier without unnecessary sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, weekly_rank FROM tv_series WHERE episode_title = 'A Love of a Lifetime' ORDER BY weekly_rank DESC;",
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\""
        ],
        "rule_sql": []
    },
    "622": {
        "db_id": "tvshow",
        "question": "What is the weekly rank for the episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do reference table `TV_series` instead of `episodes` and use column `Episode` instead of `episode_title` for the filter condition. Do use double quotes around the string literal \"A Love of a Lifetime\" instead of single quotes. Do use column name `Weekly_Rank` with proper capitalization instead of `weekly_rank`. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT weekly_rank FROM episodes WHERE episode_title = 'A Love of a Lifetime';",
            "SELECT Weekly_Rank FROM TV_series WHERE Episode = \"A Love of a Lifetime\";"
        ],
        "rule_sql": []
    },
    "623": {
        "db_id": "tvshow",
        "question": "What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select `series_name` from the `TV_Channel` table instead of `tv_channel` from the `tv_series` table. Do add a `JOIN` between `TV_Channel AS T1` and `TV_series AS T2` on `T1.id = T2.Channel` instead of querying only the `tv_series` table. Do filter on `T2.Episode = \"A Love of a Lifetime\"` instead of `episode = 'A Love of a Lifetime'` to maintain the correct table reference in the WHERE clause. The amended query now correctly retrieves the series name from the TV_Channel table by joining with TV_series where the specific episode matches, ensuring the result matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tv_channel FROM tv_series WHERE episode = 'A Love of a Lifetime';",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ],
        "rule_sql": []
    },
    "624": {
        "db_id": "tvshow",
        "question": "What is the name of the series that has the episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do add `TV_Channel AS T1` and `TV_series AS T2` as FROM sources instead of only `episodes`. Do use `JOIN` with `ON T1.id = T2.Channel` instead of querying a single table. Do reference `T1.series_name` instead of just `series_name`. Do filter on `T2.Episode = \"A Love of a Lifetime\"` instead of `episode_title = 'A Love of a Lifetime'`. The amended query now correctly joins the channel and series tables to find the series name for the specified episode, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_name FROM episodes WHERE episode_title = 'A Love of a Lifetime'",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ],
        "rule_sql": []
    },
    "625": {
        "db_id": "tvshow",
        "question": "List the Episode of all  TV series showed on TV Channel with series name \"Sky Radio\".",
        "ground_truth": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Episode` instead of `*` to return only the episode column rather than all columns. Do use `TV_Channel AS T1 JOIN TV_series AS T2` instead of `episodes` to properly join the channel and series tables. Do apply the join condition `ON T1.id = T2.Channel` instead of no join condition to correctly relate the tables. Do filter on `T1.series_name = \"Sky Radio\"` instead of `channel = 'Sky Radio'` to use the appropriate column name and table reference. The amended query now correctly retrieves episodes from the specified series by joining the related tables with proper relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes WHERE channel = 'Sky Radio';",
            "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\""
        ],
        "rule_sql": []
    },
    "626": {
        "db_id": "tvshow",
        "question": "What is the episode for the TV series named \"Sky Radio\"?",
        "ground_truth": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select only `T2.Episode` instead of selecting all columns with `*`. Do join `TV_Channel AS T1` with `TV_series AS T2` instead of querying only `tv_series` alone. Do use the join condition `T1.id = T2.Channel` instead of no join condition. Do filter on `T1.series_name = \"Sky Radio\"` instead of filtering on `name = 'Sky Radio'`. The amended query now correctly retrieves episodes from the specific channel series rather than incorrectly querying the series table directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM tv_series WHERE name = 'Sky Radio';",
            "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": []
    },
    "627": {
        "db_id": "tvshow",
        "question": "Find the number of cartoons directed by each of the listed directors.",
        "ground_truth": "SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",
        "amends": [
            "Do use column name `Directed_by` instead of `director` and place `count(*)` first instead of second in the SELECT list. Do reference table `cartoon` instead of `cartoons` in the FROM clause. Do group by `Directed_by` instead of `director` to match the corrected column name. The amended query now correctly counts cartoons grouped by their director using the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM cartoons GROUP BY director;",
            "SELECT count(*), Directed_by FROM Cartoon GROUP BY Directed_by"
        ],
        "rule_sql": []
    },
    "628": {
        "db_id": "tvshow",
        "question": "How many cartoons did each director create?",
        "ground_truth": "SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",
        "amends": [
            "Do use the column name `Directed_by` instead of `director` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do reference the table name `cartoon` instead of `cartoons` in the FROM clause. The amended query now correctly counts records grouped by the director column using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM cartoons GROUP BY director;",
            "SELECT count(*), Directed_by FROM Cartoon GROUP BY Directed_by"
        ],
        "rule_sql": []
    },
    "629": {
        "db_id": "tvshow",
        "question": "Find the production code and channel of the most recently aired cartoon .",
        "ground_truth": "select production_code ,  channel from cartoon order by original_air_date desc limit 1",
        "amends": [
            "Do reference the `cartoon` table instead of the `cartoons` table. Do use the `original_air_date` column for ordering instead of `air_date`. The amended query now correctly references the proper table name and date column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT production_code, channel FROM cartoons ORDER BY air_date DESC LIMIT 1;",
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "630": {
        "db_id": "tvshow",
        "question": "What is the produdction code and channel of the most recent cartoon ?",
        "ground_truth": "select production_code ,  channel from cartoon order by original_air_date desc limit 1",
        "amends": [
            "Do reference table `cartoon` instead of `cartoons` and use column `original_air_date` instead of `air_date` for ordering, while keeping the same `SELECT` list with `production_code` and `channel`, maintaining the `DESC` ordering and `LIMIT 1` clause. The amended query now correctly references the proper table name and date column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT production_code, channel FROM cartoons ORDER BY air_date DESC LIMIT 1;",
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "631": {
        "db_id": "tvshow",
        "question": "Find the package choice and series name of the TV channel that has high definition TV.",
        "ground_truth": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"",
        "amends": [
            "Do use `package_option` instead of `package_choice` in the SELECT list. Do reference table `TV_Channel` instead of `tv_channels` in the FROM clause. Do filter on `hight_definition_TV = \"yes\"` instead of `high_definition = 'yes'` in the WHERE clause, correcting both the column name and using double quotes instead of single quotes for the string literal. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT package_choice, series_name FROM tv_channels WHERE high_definition = 'yes';",
            "SELECT package_option, series_name FROM TV_Channel WHERE hight_definition_TV = \"yes\""
        ],
        "rule_sql": []
    },
    "632": {
        "db_id": "tvshow",
        "question": "What are the package options and the name of the series for the TV Channel that supports high definition TV?",
        "ground_truth": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"",
        "amends": [
            "Do reference the table as `TV_Channel` instead of `tv_channels` to match the correct table name. Do use the column name `package_option` instead of `package_options` to select the correct singular column. Do filter on `hight_definition_TV = \"yes\"` instead of `supports_hd = 'yes'` to use the proper column name and double quotes for the string literal. The amended query now correctly retrieves package options and series names from the TV_Channel table where high definition TV is supported."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT package_options, series_name FROM tv_channels WHERE supports_hd = 'yes';",
            "SELECT Package_Option, series_name FROM TV_Channel WHERE Hight_definition_TV = \"yes\";"
        ],
        "rule_sql": []
    },
    "633": {
        "db_id": "tvshow",
        "question": "which countries' tv channels are playing some cartoon written by Todd Casey?",
        "ground_truth": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do select `T1.country` instead of `country` and remove `DISTINCT` instead of keeping it. Do add `cartoon AS T2` table instead of omitting it and use `JOIN` on `T1.id = T2.Channel` instead of querying only `tv_channels`. Do move the filter to `T2.written_by = 'Todd Casey'` instead of `cartoon_writer = 'Todd Casey'` and remove the `WHERE` clause entirely. The amended query now correctly joins tables and filters on the cartoon writer attribute, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country FROM tv_channels WHERE cartoon_writer = 'Todd Casey';",
            "SELECT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": []
    },
    "634": {
        "db_id": "tvshow",
        "question": "What are the countries that have cartoons on TV that were written by Todd Casey?",
        "ground_truth": "SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do select `T1.country` from the `TV_Channel` table instead of selecting `country` directly from a non-existent `cartoons` table. Do join `TV_Channel AS T1` with `cartoon AS T2` on `T1.id = T2.Channel` instead of querying a single table. Do filter on `T2.written_by = 'Todd Casey'` instead of `writer = 'Todd Casey'` to use the correct column name and table reference. The amended query now correctly retrieves country information by joining the appropriate tables and using the proper column references, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cartoons WHERE writer = 'Todd Casey'",
            "SELECT DISTINCT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": []
    },
    "635": {
        "db_id": "tvshow",
        "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?",
        "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table as `TV_Channel` instead of `tv_channels`. Do add explicit table alias `T1` for the TV_Channel table instead of omitting it. Do join with `cartoon` table instead of filtering `programs` table for program_type. Do use join condition `T1.id = T2.Channel` instead of subquery correlation. Do filter on `written_by` column instead of `writer` column. Do remove `DISTINCT` modifier since `EXCEPT` inherently eliminates duplicates. The amended query now correctly identifies countries without cartoons written by Todd Casey using proper table relationships and set operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM tv_channels \nWHERE channel_id NOT IN (\n    SELECT channel_id \n    FROM programs \n    WHERE program_type = 'cartoon' \n    AND writer = 'Todd Casey'\n);",
            "SELECT T1.Country\nFROM TV_Channel T1\nEXCEPT\nSELECT T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": []
    },
    "636": {
        "db_id": "tvshow",
        "question": "What are the countries that are not playing cartoons written by Todd Casey?",
        "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do query from `TV_Channel` table instead of `countries` table. Do join `cartoon` table on `T1.id = T2.Channel` instead of joining multiple tables through `movies` and `writers`. Do filter on `T2.written_by = 'Todd Casey'` instead of checking `m.genre = 'Cartoon' AND p.name = 'Todd Casey'`. Do remove `DISTINCT` from the main query since `EXCEPT` inherently eliminates duplicates. Do remove the subquery structure entirely in favor of the set operation approach. The amended query now correctly identifies countries from TV_Channel that don't have cartoons written by Todd Casey, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM countries \nWHERE country NOT IN (\n    SELECT DISTINCT c.country \n    FROM countries c\n    JOIN movies m ON c.movie_id = m.id\n    JOIN writers w ON m.id = w.movie_id\n    JOIN people p ON w.person_id = p.id\n    WHERE m.genre = 'Cartoon' AND p.name = 'Todd Casey'\n)",
            "SELECT Country FROM TV_Channel\nEXCEPT\nSELECT T1.Country FROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": []
    },
    "637": {
        "db_id": "tvshow",
        "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
        "ground_truth": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `JOIN` with `cartoon` table on `T1.id = T2.Channel` instead of querying only `tv_channels` table. Do reference `directed_by` column from the joined `cartoon` table instead of `director` column from the base table. Do use `INTERSECT` to find series directed by both 'Michael Chang' and 'Ben Jones' instead of using `OR` logic that would return series directed by either. Do split into two separate queries with specific `directed_by` filters instead of combining conditions with mixed `AND/OR` precedence. Do add table aliases `T1` and `T2` for clarity instead of using unqualified column references. The amended query now correctly finds series directed by both specified directors through set intersection."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_name, country FROM tv_channels WHERE director = 'Ben Jones' OR director = 'Michael Chang' AND genre = 'cartoon';",
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.directed_by = 'Michael Chang'"
        ],
        "rule_sql": []
    },
    "638": {
        "db_id": "tvshow",
        "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
        "ground_truth": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "amends": [
            "Do add `cartoon` table with `JOIN` on `T1.id = T2.Channel` instead of querying only `tv_channels`. Do change filter condition to use `T2.directed_by` instead of `director`. Do use `INTERSECT` to find common results between two separate queries instead of `OR` condition. Do specify table aliases `T1` and `T2` instead of unqualified column references. Do remove the direct filter on `tv_channels.director` instead of keeping it. The amended query now correctly finds series that have cartoons directed by both specified directors using set intersection logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_name, country FROM tv_channels WHERE director = 'Ben Jones' OR director = 'Michael Chang';",
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ],
        "rule_sql": []
    },
    "639": {
        "db_id": "tvshow",
        "question": "find the pixel aspect ratio and nation of the tv channels that do not use English.",
        "ground_truth": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",
        "amends": [
            "Do use column alias `Pixel_aspect_ratio_PAR` instead of `pixel_aspect_ratio`, and select `country` instead of `nation`. Do reference table `tv_channel` instead of `tv_channels`. Do apply filter `LANGUAGE != 'English'` instead of `language = 'English'` to exclude English language records rather than including them. The amended query now correctly retrieves non-English TV channel data with the specified column names and table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pixel_aspect_ratio, nation FROM tv_channels WHERE language = 'English';",
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ],
        "rule_sql": []
    },
    "640": {
        "db_id": "tvshow",
        "question": "What is the pixel aspect ratio and country of origin for all TV channels that do not use English?",
        "ground_truth": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",
        "amends": [
            "Do use column name `Pixel_aspect_ratio_PAR` instead of `pixel_aspect_ratio` and `country` instead of `country_of_origin` in the SELECT list. Do reference table `tv_channel` instead of `tv_channels` in the FROM clause. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pixel_aspect_ratio, country_of_origin FROM tv_channels WHERE language != 'English';",
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ],
        "rule_sql": []
    },
    "641": {
        "db_id": "tvshow",
        "question": "find id of the tv channels that from the countries where have more than two tv channels.",
        "ground_truth": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do use `GROUP BY country` with `HAVING count(*) > 2` instead of the subquery approach with `WHERE country IN (SELECT country FROM tv_channels GROUP BY country HAVING COUNT(*) > 2)`. Do remove the redundant subquery structure and instead apply the grouping and filtering directly in the main query. Do change the table reference from `tv_channels` to `tv_channel` to match the correct schema. The amended query now correctly identifies channels from countries with more than two channels by using direct grouping and filtering instead of the inefficient subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE country IN (SELECT country FROM tv_channels GROUP BY country HAVING COUNT(*) > 2);",
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "642": {
        "db_id": "tvshow",
        "question": "What are the ids of all tv channels that have more than 2 TV channels?",
        "ground_truth": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
        "amends": [
            "Do select `id` from `tv_channel` instead of `tv_channels`. Do add `GROUP BY country` and `HAVING count(*) > 2` instead of using `WHERE id > 2`. Do remove the incorrect table name `tv_channels` and replace it with `tv_channel`. The amended query now correctly aggregates by country and filters groups with more than 2 records instead of filtering individual records by ID value, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id > 2;",
            "SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "643": {
        "db_id": "tvshow",
        "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
        "ground_truth": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `TV_Channel` instead of `tv_channels` and column `channel` instead of `channel_id`. Do use table `cartoon` instead of `cartoons` and filter on `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'`. The amended query now correctly uses set-based exclusion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones';"
        ],
        "rule_sql": []
    },
    "644": {
        "db_id": "tvshow",
        "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
        "ground_truth": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `TV_Channel` instead of `tv_channels` and `cartoon` instead of `cartoons`. Do select from column `channel` in the second query instead of `channel_id`. Do use filter condition `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'`. The amended query now correctly uses set-based exclusion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones';"
        ],
        "rule_sql": []
    },
    "645": {
        "db_id": "tvshow",
        "question": "find the package option of the tv channel that do not have any cartoon directed by Ben Jones.",
        "ground_truth": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "amends": [
            "Do reference table `TV_Channel` instead of `tv_channels` and column `id` instead of `channel_id` in the main query. Do reference table `cartoon` instead of `cartoons` and column `channel` instead of `channel_id` in the subquery. Do use filter condition `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'` in the subquery's WHERE clause. The amended query now correctly matches the intended logic by using the proper table and column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT package_option FROM tv_channels WHERE channel_id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT Package_Option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ],
        "rule_sql": []
    },
    "646": {
        "db_id": "tvshow",
        "question": "What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?",
        "ground_truth": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "amends": [
            "Do select `package_option` instead of `package_options` and remove `DISTINCT` instead of keeping it. Do reference table `TV_Channel` instead of `tv_channels` and use column `id` instead of `channel_id`. Do use subquery from table `cartoon` instead of `programs` with column `channel` instead of `channel_id`. Do filter on `directed_by = 'Ben Jones'` instead of `genre = 'cartoon' AND director = 'Ben Jones'` and remove the genre condition entirely. The amended query now correctly filters channels not associated with cartoons directed by Ben Jones."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT package_options \nFROM tv_channels \nWHERE channel_id NOT IN (\n    SELECT channel_id \n    FROM programs \n    WHERE genre = 'cartoon' AND director = 'Ben Jones'\n)",
            "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ],
        "rule_sql": []
    },
    "647": {
        "db_id": "poker_player",
        "question": "How many poker players are there?",
        "ground_truth": "SELECT count(*) FROM poker_player",
        "amends": [
            "Do reference the `poker_player` table instead of the `players` table. Do remove the `WHERE game_type = 'blackjack'` filter instead of keeping it. The amended query now correctly counts all records in the poker_player table without any filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE game_type = 'blackjack';",
            "SELECT COUNT(*) FROM poker_player;"
        ],
        "rule_sql": []
    },
    "648": {
        "db_id": "poker_player",
        "question": "Count the number of poker players.",
        "ground_truth": "SELECT count(*) FROM poker_player",
        "amends": [
            "Do reference the `poker_player` table instead of the `players` table. Do remove the `WHERE game_type = 'blackjack'` filter instead of keeping it. The amended query now correctly counts all records from the poker_player table without any filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE game_type = 'blackjack';",
            "SELECT COUNT(*) FROM poker_player;"
        ],
        "rule_sql": []
    },
    "649": {
        "db_id": "poker_player",
        "question": "List the earnings of poker players in descending order.",
        "ground_truth": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC",
        "amends": [
            "Do select `Earnings` instead of `player_name, earnings` and remove the player_name column. Do reference table `poker_player` instead of `poker_players` with the correct table name. Do order by `Earnings DESC` instead of `earnings ASC` with the correct column name and descending order instead of ascending. The amended query now correctly selects only earnings from the poker_player table in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, earnings FROM poker_players ORDER BY earnings ASC;",
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ],
        "rule_sql": []
    },
    "650": {
        "db_id": "poker_player",
        "question": "What are the earnings of poker players, ordered descending by value?",
        "ground_truth": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC",
        "amends": [
            "Do select only `Earnings` instead of both `name` and `earnings`. Do reference table `poker_player` instead of `poker_players`. Do order by `Earnings DESC` instead of `earnings ASC`. The amended query now matches the intended behavior of selecting earnings from the poker_player table in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, earnings FROM poker_players ORDER BY earnings ASC;",
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ],
        "rule_sql": []
    },
    "651": {
        "db_id": "poker_player",
        "question": "List the final tables made and the best finishes of poker players.",
        "ground_truth": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player",
        "amends": [
            "Do select `Final_Table_Made` and `Best_Finish` instead of `player_name`, `final_table`, and `best_finish`. Do query from `poker_player` instead of `poker_players`. Do remove the `ORDER BY player_name` clause instead of keeping it. The amended query now correctly selects the specified columns from the appropriate table without unnecessary ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, final_table, best_finish FROM poker_players ORDER BY player_name;",
            "SELECT Final_Table_Made, Best_Finish FROM poker_player;"
        ],
        "rule_sql": []
    },
    "652": {
        "db_id": "poker_player",
        "question": "What are the final tables made and best finishes for all poker players?",
        "ground_truth": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player",
        "amends": [
            "Do reference the correct table name `poker_player` instead of the incorrect `poker_players`. Do use the correct column names `Final_Table_Made` and `Best_Finish` instead of the incorrect `player_name`, `final_table`, and `best_finish`. Do maintain the `ORDER BY Best_Finish DESC` clause as it correctly sorts the results. The amended query now correctly selects the intended columns from the proper table while preserving the sorting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, final_table, best_finish FROM poker_players ORDER BY best_finish DESC;",
            "SELECT Final_Table_Made, Best_Finish FROM poker_player ORDER BY Best_Finish DESC;"
        ],
        "rule_sql": []
    },
    "653": {
        "db_id": "poker_player",
        "question": "What is the average earnings of poker players?",
        "ground_truth": "SELECT avg(Earnings) FROM poker_player",
        "amends": [
            "Do reference table `poker_player` instead of `players` and use column `Earnings` instead of `earnings`. Do remove the `WHERE sport = 'basketball'` filter instead of keeping it, as the query should calculate average earnings across all poker players rather than filtering for basketball players. The amended query now correctly calculates the average earnings from the poker_player table without any sport-based filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(earnings) FROM players WHERE sport = 'basketball';",
            "SELECT AVG(Earnings) FROM poker_player"
        ],
        "rule_sql": []
    },
    "654": {
        "db_id": "poker_player",
        "question": "Return the average earnings across all poker players.",
        "ground_truth": "SELECT avg(Earnings) FROM poker_player",
        "amends": [
            "Do reference the table as `poker_player` instead of `poker_players` to match the correct table name. Do use the column name `Earnings` with proper capitalization instead of lowercase `earnings` to match the actual column definition. Do remove the `WHERE earnings > 1000000` filter instead of keeping it, as the correct query calculates the overall average without filtering. The amended query now correctly calculates the average earnings across all poker players without unnecessary filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE earnings > 1000000;",
            "SELECT AVG(Earnings) FROM poker_player"
        ],
        "rule_sql": []
    },
    "655": {
        "db_id": "poker_player",
        "question": "What is the money rank of the poker player with the highest earnings?",
        "ground_truth": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1",
        "amends": [
            "Do use `Money_Rank` as the column alias instead of `money_rank`. Do select from `poker_player` instead of `poker_players`. Do remove the window function `RANK() OVER (ORDER BY earnings DESC)` and instead use a simple `ORDER BY Earnings DESC` with `LIMIT 1` to get the top-ranked player. Do eliminate the subquery `(SELECT MAX(earnings) FROM poker_players)` that was incorrectly filtering for only maximum earnings records. Do remove the `WHERE` clause entirely instead of using it to filter for maximum earnings. The amended query now correctly retrieves the top-ranked player by earnings using proper ordering and limiting instead of the complex window function approach with incorrect filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT RANK() OVER (ORDER BY earnings DESC) as money_rank FROM poker_players WHERE earnings = (SELECT MAX(earnings) FROM poker_players);",
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "656": {
        "db_id": "poker_player",
        "question": "Return the money rank of the player with the greatest earnings.",
        "ground_truth": "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1",
        "amends": [
            "Do select `Money_Rank` directly instead of using `MAX(money_rank)` aggregation. Do query from `poker_player` table instead of `players` table. Do remove the WHERE clause with subquery that finds maximum earnings instead of keeping it. Do add `ORDER BY Earnings DESC` to sort by highest earnings instead of omitting ordering. Do add `LIMIT 1` to return only the top row instead of using aggregation and subquery. The amended query now correctly retrieves the money rank of the player with the highest earnings by sorting and limiting rather than using complex aggregation with subqueries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(money_rank) FROM players WHERE earnings = (SELECT MAX(earnings) FROM players);",
            "SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "657": {
        "db_id": "poker_player",
        "question": "What is the maximum number of final tables made among poker players with earnings less than 200000?",
        "ground_truth": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000",
        "amends": [
            "Do use the correct table name `poker_player` instead of the incorrect `poker_players`. Do reference the correct column `Final_Table_Made` instead of the non-existent `final_tables`. Do change the aggregate function to `max` (lowercase) instead of `MAX` (uppercase) for consistency. Do correct the filter condition to use `< 200000` instead of `> 200000` to select players with earnings below the threshold rather than above it. Do reference the correct earnings column `Earnings` instead of the incorrect `earnings`. The amended query now correctly selects the maximum number of final tables made by poker players with earnings less than 200,000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(final_tables) FROM poker_players WHERE earnings > 200000;",
            "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ],
        "rule_sql": []
    },
    "658": {
        "db_id": "poker_player",
        "question": "Return the maximum final tables made across all poker players who have earnings below 200000.",
        "ground_truth": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000",
        "amends": [
            "Do use the correct table name `poker_player` instead of the incorrect `poker_players`. Do use the correct column name `Final_Table_Made` instead of the incorrect `final_tables`. Do use the correct aggregate function `max` (lowercase) instead of `MAX` (uppercase). Do use the correct comparison operator `<` instead of `>` to filter for earnings less than 200000 instead of greater than 200000. Do use the correct column name `Earnings` instead of `earnings` for the filter condition. The amended query now correctly retrieves the maximum number of final tables made by poker players with earnings below 200000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(final_tables) FROM poker_players WHERE earnings > 200000;",
            "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ],
        "rule_sql": []
    },
    "659": {
        "db_id": "poker_player",
        "question": "What are the names of poker players?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `player_name` from `poker_players`. Do join `poker_player` as `T2` on `T1.People_ID = T2.People_ID` instead of querying `poker_players` directly with a `WHERE player_id = 1` filter. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves player names by joining the people table with poker player information through the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM poker_players WHERE player_id = 1;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": []
    },
    "660": {
        "db_id": "poker_player",
        "question": "Return the names of all the poker players.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do select `T1.Name` instead of `player_id` and do add `people AS T1` and `poker_player AS T2` as joined tables instead of only `poker_players`. Do use `INNER JOIN` with predicate `T1.People_ID = T2.People_ID` instead of no join condition. The amended query now correctly retrieves player names from the people table by joining with poker_player on their relationship key instead of attempting to select player_id directly from a non-existent or incorrect table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id FROM poker_players;",
            "SELECT T1.Name \nFROM people AS T1 \nINNER JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": []
    },
    "661": {
        "db_id": "poker_player",
        "question": "What are the names of poker players whose earnings is higher than 300000?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000",
        "amends": [
            "Do reference the `people` table as `T1` and select `T1.Name` instead of selecting `name` from a non-existent `poker_players` table. Do add a `JOIN` with `poker_player` as `T2` on the predicate `T1.People_ID = T2.People_ID` instead of querying a single table. Do filter on `T2.Earnings > 300000` instead of filtering on a non-existent `earnings` column from the wrong table. The amended query now correctly joins the people and poker_player tables to find players with earnings exceeding 300000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM poker_players WHERE earnings > 300000",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
        ],
        "rule_sql": []
    },
    "662": {
        "db_id": "poker_player",
        "question": "Give the names of poker players who have earnings above 300000.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000",
        "amends": [
            "Do reference the `Name` column from the `people` table instead of `name` from `poker_players`. Do join `people AS T1` with `poker_player AS T2` using `T1.People_ID = T2.People_ID` instead of querying a single `poker_players` table. Do filter on `T2.Earnings > 300000` instead of `earnings > 300000` to correctly reference the joined table's column. The amended query now properly relates player information from the people table with earnings data from the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM poker_players WHERE earnings > 300000",
            "SELECT T1.Name \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nWHERE T2.Earnings > 300000"
        ],
        "rule_sql": []
    },
    "663": {
        "db_id": "poker_player",
        "question": "List the names of poker players ordered by the final tables made in ascending order.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` without any join. Do select `T1.Name` instead of just `name` to specify the table source. Do order by `T2.Final_Table_Made` instead of `final_tables` to use the correct column name from the joined table. The amended query now correctly retrieves player names from the people table joined with poker player data and orders by the appropriate final tables column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY final_tables DESC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ],
        "rule_sql": []
    },
    "664": {
        "db_id": "poker_player",
        "question": "What are the names of poker players, ordered ascending by the number of final tables they have made?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made",
        "amends": [
            "Do select `T1.Name` instead of `name, COUNT(final_table)` and remove the aggregate function and alias. Do use `FROM people AS T1 JOIN poker_player AS T2` instead of `FROM poker_players` with a proper join instead of a single table. Do specify the join condition `ON T1.People_ID = T2.People_ID` instead of omitting join predicates. Do remove the `COUNT` aggregation and `GROUP BY` implication instead of including them. Do order by `T2.Final_Table_Made` instead of `final_tables DESC` using the actual column rather than an aggregate result. The amended query now correctly retrieves player names joined with poker player data and orders by final tables made."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(final_table) as final_tables FROM poker_players ORDER BY final_tables DESC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ],
        "rule_sql": []
    },
    "665": {
        "db_id": "poker_player",
        "question": "What is the birth date of the poker player with the lowest earnings?",
        "ground_truth": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do select `T1.Birth_Date` from the joined people table instead of `birth_date` from the poker_players table. Do order by `T2.Earnings` from the joined poker_player table instead of `earnings` from the original table. The amended query now correctly retrieves birth dates by joining related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_date FROM poker_players ORDER BY earnings ASC LIMIT 1;",
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "666": {
        "db_id": "poker_player",
        "question": "Return the birth date of the poker player with the lowest earnings.",
        "ground_truth": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do select `T1.Birth_Date` from the joined people table instead of `birth_date` from the poker_players table. Do order by `T2.Earnings` from the joined poker_player table instead of `earnings` from the poker_players table. The amended query now correctly retrieves birth dates by joining related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_date FROM poker_players ORDER BY earnings ASC LIMIT 1;",
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "667": {
        "db_id": "poker_player",
        "question": "What is the money rank of the tallest poker player?",
        "ground_truth": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Money_Rank` from the joined table instead of `money_rank` directly from the poker_players table. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the poker_players table. Do order by `T1.Height` from the people table instead of `height` from the poker_players table. The amended query now correctly retrieves money rank by joining the people and poker_player tables and ordering by height from the people table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT money_rank FROM poker_players ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Money_Rank \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nORDER BY T1.Height DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "668": {
        "db_id": "poker_player",
        "question": "Return the money rank of the poker player with the greatest height.",
        "ground_truth": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Money_Rank` from the joined table instead of `money_rank` from a single table. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players`. Do order by `T1.Height` from the people table instead of `height` from poker_players. The amended query now correctly retrieves money rank by joining related tables and ordering by the appropriate height column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT money_rank FROM poker_players ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "669": {
        "db_id": "poker_player",
        "question": "What is the average earnings of poker players with height higher than 200?",
        "ground_truth": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200",
        "amends": [
            "Do use table alias `T2` for `poker_player` instead of directly referencing `poker_players`. Do add explicit `JOIN` between `people AS T1` and `poker_player AS T2` instead of querying a single table. Do specify join condition `ON T1.People_ID = T2.People_ID` instead of omitting the relationship. Do reference `T1.Height` in the WHERE clause instead of `height` from the wrong table. Do use column name `Earnings` instead of `earnings` with proper table qualification. The amended query now correctly joins related tables and filters on the appropriate height column from the people table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE height > 200;",
            "SELECT AVG(T2.Earnings) \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nWHERE T1.Height > 200"
        ],
        "rule_sql": []
    },
    "670": {
        "db_id": "poker_player",
        "question": "Give average earnings of poker players who are taller than 200.",
        "ground_truth": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200",
        "amends": [
            "Do join `people AS T1` and `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do reference `T2.Earnings` instead of `earnings` from the wrong table. Do filter on `T1.Height > 200` instead of `height > 200` from the incorrect table. The amended query now correctly joins related tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE height > 200",
            "SELECT AVG(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ],
        "rule_sql": []
    },
    "671": {
        "db_id": "poker_player",
        "question": "What are the names of poker players in descending order of earnings?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from `poker_players`. Do join `poker_player` as `T2` on `T1.People_ID = T2.People_ID` instead of querying only the `poker_players` table. Do order by `T2.Earnings DESC` instead of `earnings ASC`, changing both the sort direction and the source table for the earnings column. The amended query now correctly joins the people and poker_player tables to retrieve player names with their corresponding earnings data and sorts them in descending order by earnings, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY earnings ASC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ],
        "rule_sql": []
    },
    "672": {
        "db_id": "poker_player",
        "question": "Return the names of poker players sorted by their earnings descending.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from `poker_players`. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `poker_players` table. Do order by `T2.Earnings DESC` instead of `earnings ASC` to sort in descending order. The amended query now correctly retrieves player names from the people table joined with poker player data and sorts by earnings in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY earnings ASC;",
            "SELECT T1.Name \nFROM people AS T1\nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID\nORDER BY T2.Earnings DESC"
        ],
        "rule_sql": []
    },
    "673": {
        "db_id": "poker_player",
        "question": "What are different nationalities of people and the corresponding number of people from each nation?",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM people GROUP BY nationality ORDER BY COUNT(*) DESC;"
        ],
        "rule_sql": []
    },
    "674": {
        "db_id": "poker_player",
        "question": "How many people are there of each nationality?",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",
        "amends": [
            "Do group by `Nationality` instead of `name` to correctly aggregate counts by nationality rather than by individual names. Do capitalize `Nationality` in the SELECT list instead of using lowercase `nationality` for consistency with the GROUP BY clause. The amended query now correctly counts people by their nationality rather than by name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM people GROUP BY name;",
            "SELECT Nationality, COUNT(*) AS count FROM people GROUP BY Nationality;"
        ],
        "rule_sql": []
    },
    "675": {
        "db_id": "poker_player",
        "question": "What is the most common nationality of people?",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Nationality` instead of `nationality` for the column name in both the SELECT list and GROUP BY clause. Do order by `COUNT(*) DESC` instead of `ASC` to get the nationality with the highest count instead of the lowest. Do remove the `count` alias from the SELECT list instead of keeping it since it's not needed in the ORDER BY clause. The amended query now correctly identifies the most common nationality by counting occurrences in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the Nationality with the highest count rather than both the Nationality and its count value. The amended query now correctly returns just the Nationality column while maintaining the same grouping, ordering, and limiting logic to identify the most frequent nationality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM people GROUP BY nationality ORDER BY count ASC LIMIT 1;",
            "SELECT Nationality, COUNT(*) FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "676": {
        "db_id": "poker_player",
        "question": "Give the nationality that is most common across all people.",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the column as `Nationality` (case-sensitive) instead of `nationality` in both the SELECT list and GROUP BY clause. Do order by the aggregate expression `COUNT(*)` directly instead of referencing the alias `count`. Do remove the alias `count` from the SELECT list instead of including it. Do maintain the same GROUP BY and LIMIT logic while correcting the column reference case and ordering approach. The amended query now correctly identifies the most common nationality by counting occurrences directly in the ORDER BY clause without an intermediate alias."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality, COUNT(*) as count FROM people GROUP BY nationality ORDER BY count DESC LIMIT 1;",
            "SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "677": {
        "db_id": "poker_player",
        "question": "What are the nationalities that are shared by at least two people?",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality FROM people GROUP BY nationality HAVING COUNT(*) >= 2;"
        ],
        "rule_sql": []
    },
    "678": {
        "db_id": "poker_player",
        "question": "Return the nationalities for which there are two or more people.",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality FROM people GROUP BY nationality HAVING COUNT(*) > 1;"
        ],
        "rule_sql": []
    },
    "679": {
        "db_id": "poker_player",
        "question": "List the names and birth dates of people in ascending alphabetical order of name.",
        "ground_truth": "SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, birth_date FROM people ORDER BY name DESC;"
        ],
        "rule_sql": []
    },
    "680": {
        "db_id": "poker_player",
        "question": "What are the names and birth dates of people, ordered by their names in alphabetical order?",
        "ground_truth": "SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, birth_date FROM people ORDER BY birth_date DESC;"
        ],
        "rule_sql": []
    },
    "681": {
        "db_id": "poker_player",
        "question": "Show names of people whose nationality is not \"Russia\".",
        "ground_truth": "SELECT Name FROM people WHERE Nationality != \"Russia\"",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case sensitivity. Do use `!=` instead of `=` in the WHERE clause to filter for people who are not from Russia instead of those who are from Russia. Do use double quotes `\"Russia\"` instead of single quotes `'Russia'` for the string literal. The amended query now correctly excludes Russian nationals instead of including them, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE nationality = 'Russia';",
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ],
        "rule_sql": []
    },
    "682": {
        "db_id": "poker_player",
        "question": "What are the names of people who are not from Russia?",
        "ground_truth": "SELECT Name FROM people WHERE Nationality != \"Russia\"",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do use `!=` operator with `Nationality` column instead of `=` operator with `country` column to filter for non-Russian nationalities rather than Russian countries. Do use double quotes around `Russia` instead of single quotes for consistent string literal formatting. The amended query now correctly filters for people whose nationality is not Russia, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE country = 'Russia';",
            "SELECT Name FROM people WHERE Nationality != \"Russia\""
        ],
        "rule_sql": []
    },
    "683": {
        "db_id": "poker_player",
        "question": "List the names of people that are not poker players.",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do use a subquery with `NOT IN` to filter out poker players instead of the incorrect direct filter `poker_player = 1`. Do reference `People_ID` in both the main query and subquery instead of the non-existent `poker_player` column. The amended query now correctly identifies non-poker players by excluding those whose IDs exist in the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE poker_player = 1;",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ],
        "rule_sql": []
    },
    "684": {
        "db_id": "poker_player",
        "question": "What are the names of people who do not play poker?",
        "ground_truth": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column casing. Do use a subquery with `NOT IN` to filter by `People_ID` values that exist in the `poker_player` table instead of directly comparing `game != 'poker'` which incorrectly assumes the game type is stored as a string value in the people table. Do reference the correct join key `People_ID` in both the main query and subquery instead of attempting to filter by a non-existent `game` column. The amended query now correctly identifies people who are not poker players by checking their ID against the poker_player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE game != 'poker';",
            "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"
        ],
        "rule_sql": []
    },
    "685": {
        "db_id": "poker_player",
        "question": "How many distinct nationalities are there?",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM people",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do add the `Nationality` column reference instead of omitting it in the aggregate function. The amended query now correctly counts unique nationalities instead of total rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people;",
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ],
        "rule_sql": []
    },
    "686": {
        "db_id": "poker_player",
        "question": "Count the number of different nationalities.",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM people",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do include the `Nationality` column in the aggregate function instead of omitting it from the SELECT list. Do remove the `WHERE nationality IS NOT NULL` filter instead of keeping it, as counting distinct values inherently excludes NULLs. The amended query now correctly counts distinct nationalities and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE nationality IS NOT NULL;",
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ],
        "rule_sql": []
    },
    "687": {
        "db_id": "voter_1",
        "question": "How many states are there?",
        "ground_truth": "SELECT count(*) FROM area_code_state",
        "amends": [
            "Do query the `area_code_state` table instead of the `cities` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the area_code_state table instead of cities, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT count(*) FROM area_code_state;"
        ],
        "rule_sql": []
    },
    "688": {
        "db_id": "voter_1",
        "question": "List the contestant numbers and names, ordered by contestant name descending.",
        "ground_truth": "SELECT contestant_number ,  contestant_name FROM contestants ORDER BY contestant_name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants ORDER BY contestant_name ASC;"
        ],
        "rule_sql": []
    },
    "689": {
        "db_id": "voter_1",
        "question": "List the vote ids, phone numbers and states of all votes.",
        "ground_truth": "SELECT vote_id ,  phone_number ,  state FROM votes",
        "amends": [
            "Do add `state` to the SELECT list instead of omitting it. The amended query now matches the right SQL's behavior by including all required columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vote_id, phone_number FROM votes;",
            "SELECT vote_id, phone_number, state FROM VOTES;"
        ],
        "rule_sql": []
    },
    "690": {
        "db_id": "voter_1",
        "question": "What are the maximum and minimum values of area codes?",
        "ground_truth": "SELECT max(area_code) ,  min(area_code) FROM area_code_state",
        "amends": [
            "Do reference the `area_code_state` table instead of the `customers` table to ensure the correct data source for area code statistics. The amended query now correctly aggregates area codes from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(area_code), MIN(area_code) FROM customers;",
            "SELECT MAX(area_code) AS max_area_code, MIN(area_code) AS min_area_code FROM AREA_CODE_STATE"
        ],
        "rule_sql": []
    },
    "691": {
        "db_id": "voter_1",
        "question": "What is last date created of votes from the state 'CA'?",
        "ground_truth": "SELECT max(created) FROM votes WHERE state  =  'CA'",
        "amends": [
            "Do use the column name `created` instead of `created_at` in the MAX function. Do maintain the same filter condition `state = 'CA'` without changes. The amended query now correctly references the actual column name and matches the behavior of the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(created_at) FROM votes WHERE state = 'CA';",
            "SELECT MAX(created) FROM VOTES WHERE state = 'CA';"
        ],
        "rule_sql": []
    },
    "692": {
        "db_id": "voter_1",
        "question": "What are the names of the contestants whose names are not 'Jessie Alloway'",
        "ground_truth": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'",
        "amends": [
            "Do reference `contestant_name` instead of `name` in the SELECT list and WHERE clause. Do use inequality filter `!= 'Jessie Alloway'` instead of equality filter `= 'Jessie Alloway'` to exclude rather than include that specific record. The amended query now correctly selects all contestants except Jessie Alloway instead of only selecting Jessie Alloway, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM contestants WHERE name = 'Jessie Alloway';",
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name != 'Jessie Alloway'"
        ],
        "rule_sql": []
    },
    "693": {
        "db_id": "voter_1",
        "question": "What are the distinct states and create time of all votes?",
        "ground_truth": "SELECT DISTINCT state ,  created FROM votes",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select column `created` instead of `created_at` to match the correct column name. The amended query now correctly returns unique combinations of state and created date values from the votes table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, created_at FROM votes;",
            "SELECT DISTINCT state, created FROM VOTES;"
        ],
        "rule_sql": []
    },
    "694": {
        "db_id": "voter_1",
        "question": "What are the contestant numbers and names of the contestants who had at least two votes?",
        "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2",
        "amends": [
            "Do add a `JOIN` with the `votes` table on `contestant_number` instead of querying only the `contestants` table. Do add `GROUP BY contestant_number` to aggregate votes per contestant instead of lacking any grouping. Do move the vote count filter to `HAVING count(*) >= 2` instead of using `WHERE votes >= 2` which incorrectly references a non-existent column. Do qualify columns with table aliases `T1.contestant_number` and `T1.contestant_name` instead of using unqualified column names. The amended query now correctly counts votes from the votes table and filters contestants with at least two votes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants WHERE votes >= 2;",
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS T1\nJOIN VOTES T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number, T1.contestant_name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "695": {
        "db_id": "voter_1",
        "question": "Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?",
        "ground_truth": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add `JOIN votes AS T2 ON T1.contestant_number = T2.contestant_number` instead of querying only the contestants table. Do add `GROUP BY T1.contestant_number` instead of omitting grouping. Do change `ORDER BY count(*) ASC` instead of `ORDER BY votes DESC` to sort by vote count ascending rather than descending. Do remove the direct reference to `votes` column instead of including it since votes are now aggregated. The amended query now correctly joins with the votes table, groups by contestant, and orders by the count of votes to find the contestant with the fewest votes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contestant_number, contestant_name FROM contestants ORDER BY votes DESC LIMIT 1;",
            "SELECT T1.contestant_number, T1.contestant_name\nFROM CONTESTANTS AS T1\nJOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number\nGROUP BY T1.contestant_number\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "696": {
        "db_id": "voter_1",
        "question": "What are the number of votes from state 'NY' or 'CA'?",
        "ground_truth": "SELECT count(*) FROM votes WHERE state  =  'NY' OR state  =  'CA'",
        "amends": [
            "Do use `OR` operator between state conditions instead of `AND` operator, as a record cannot simultaneously have both 'NY' and 'CA' values for the state column. Do maintain the same `COUNT(*)` aggregation and table source without changes to other clauses. The amended query now correctly counts records where state is either 'NY' or 'CA' instead of incorrectly requiring both values simultaneously, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE state = 'NY' AND state = 'CA';",
            "SELECT COUNT(*) FROM VOTES WHERE state = 'NY' OR state = 'CA'"
        ],
        "rule_sql": []
    },
    "697": {
        "db_id": "voter_1",
        "question": "How many contestants did not get voted?",
        "ground_truth": "SELECT count(*) FROM contestants WHERE contestant_number NOT IN ( SELECT contestant_number FROM votes )",
        "amends": [
            "Do filter with `contestant_number NOT IN` subquery instead of checking `votes IS NULL`. Do remove the direct column check `votes IS NULL` instead of keeping it, and do add a correlated subquery against the `votes` table instead of omitting it. The amended query now correctly identifies contestants without any votes by checking their absence in the votes table rather than relying on a potentially incorrect NULL check in the contestants table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM contestants WHERE votes IS NULL;",
            "SELECT COUNT(*) \nFROM CONTESTANTS c \nWHERE c.contestant_number NOT IN (SELECT DISTINCT contestant_number FROM VOTES)"
        ],
        "rule_sql": []
    },
    "698": {
        "db_id": "voter_1",
        "question": "What is the area code in which the most voters voted?",
        "ground_truth": "SELECT T1.area_code FROM area_code_state AS T1 JOIN votes AS T2 ON T1.state  =  T2.state GROUP BY T1.area_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `area_code` instead of selecting both `area_code` and `COUNT(*) as voter_count`. Do join `area_code_state AS T1` with `votes AS T2` on `T1.state = T2.state` instead of querying only the `voters` table. Do group by `T1.area_code` instead of grouping by `area_code` from a single table. Do order by `count(*) DESC` instead of ordering by `voter_count ASC`. The amended query now correctly joins the area code and votes tables to find the area code with the highest vote count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area_code, COUNT(*) as voter_count FROM voters GROUP BY area_code ORDER BY voter_count ASC LIMIT 1;",
            "SELECT T1.area_code\nFROM AREA_CODE_STATE AS T1\nJOIN VOTES AS T2 ON T1.state = T2.state\nGROUP BY T1.area_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "699": {
        "db_id": "voter_1",
        "question": "What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?",
        "ground_truth": "SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'",
        "amends": [
            "Do join `contestants AS T1` to `votes AS T2` instead of querying only the `votes` table. Do use the join condition `T1.contestant_number = T2.contestant_number` instead of filtering directly on `contestant_name` in the votes table. Do reference columns `T2.created`, `T2.state`, and `T2.phone_number` instead of `create_date`, `state`, and `phone_number` from a single table. Do filter on `T1.contestant_name = 'Tabatha Gehling'` in the WHERE clause instead of applying the contestant name filter directly to the votes table. The amended query now correctly joins the contestants table to access contestant information and properly filters based on the relational connection between tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT create_date, state, phone_number FROM votes WHERE contestant_name = 'Tabatha Gehling';",
            "SELECT T2.created, T2.state, T2.phone_number FROM CONTESTANTS AS T1 JOIN VOTES AS T2 ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'"
        ],
        "rule_sql": []
    },
    "700": {
        "db_id": "voter_1",
        "question": "List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
        "ground_truth": "SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Kelly Clauss'",
        "amends": [
            "Do use `INTERSECT` between two complete query blocks instead of a single query with `JOIN` on `area_code`. Do join `contestants` table with `votes` on `contestant_number` instead of filtering `votes` directly by contestant names. Do add `area_code_state` table join on `state` instead of selecting `area_code` directly from `votes`. Do reference `contestant_name` from `contestants` table instead of `contestant` from `votes` table. Do remove `DISTINCT` since `INTERSECT` inherently returns unique results. The amended query now correctly finds area codes where both contestants received votes by properly joining through the normalized schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT v1.area_code \nFROM votes v1 \nJOIN votes v2 ON v1.area_code = v2.area_code \nWHERE v1.contestant = 'Tabatha Gehling' \nAND v2.contestant = 'Kelly Clauss'",
            "SELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Tabatha Gehling'\nINTERSECT\nSELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Kelly Clauss'"
        ],
        "rule_sql": []
    },
    "701": {
        "db_id": "voter_1",
        "question": "Return the names of the contestants whose names contain the substring 'Al' .",
        "ground_truth": "select contestant_name from contestants where contestant_name like \"%al%\"",
        "amends": [
            "Do reference `contestant_name` instead of `name` in the SELECT list and WHERE clause. Do use lowercase `\"%al%\"` pattern matching instead of uppercase `'%Al%'` for case-insensitive matching. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column name and case-insensitive pattern matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM contestants WHERE name LIKE '%Al%';",
            "SELECT contestant_name FROM CONTESTANTS WHERE contestant_name LIKE '%al%'"
        ],
        "rule_sql": []
    },
    "702": {
        "db_id": "world_1",
        "question": "What are the names of all the countries that became independent after 1950?",
        "ground_truth": "SELECT Name FROM country WHERE IndepYear  >  1950",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `country` table instead of `countries`. Do use the `IndepYear` column instead of `independence_year` while maintaining the same filter condition `> 1950`. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE independence_year > 1950;",
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ],
        "rule_sql": []
    },
    "703": {
        "db_id": "world_1",
        "question": "Give the names of the nations that were founded after 1950.",
        "ground_truth": "SELECT Name FROM country WHERE IndepYear  >  1950",
        "amends": [
            "Do select `Name` instead of `name` and use table `country` instead of `nations`. Do filter on `IndepYear > 1950` instead of `founded_year < 1950`, changing both the column reference and the comparison operator direction. The amended query now correctly retrieves countries with independence years after 1950 from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM nations WHERE founded_year < 1950;",
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ],
        "rule_sql": []
    },
    "704": {
        "db_id": "world_1",
        "question": "How many countries have a republic as their form of government?",
        "ground_truth": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
        "amends": [
            "Do reference table `country` instead of `countries` and use column `GovernmentForm` instead of `government_form` while maintaining the same filter condition for Republic. Do use double quotes `\"Republic\"` instead of single quotes `'Republic'` for the string literal, though this is a cosmetic difference that doesn't affect functionality. The amended query now correctly counts records from the proper table with the accurate column name while preserving the intended filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government_form = 'Republic';",
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = \"Republic\";"
        ],
        "rule_sql": []
    },
    "705": {
        "db_id": "world_1",
        "question": "How many countries have governments that are republics?",
        "ground_truth": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
        "amends": [
            "Do reference table `country` instead of `countries` and use column `GovernmentForm` instead of `government`. Do use filter value `\"Republic\"` instead of `'republic'` while maintaining the same case-insensitive logic for counting records where the government form is a republic. The amended query now correctly counts from the proper table and column with the appropriate filter value to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government = 'republic';",
            "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';"
        ],
        "rule_sql": []
    },
    "706": {
        "db_id": "world_1",
        "question": "What is the total surface area of the countries in the Caribbean region?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `area` and use the correct table name `country` instead of `countries`. Do use the correct column name `Region` instead of `region` and maintain proper string literal syntax with double quotes instead of single quotes around 'Caribbean'. The amended query now correctly calculates the total surface area for Caribbean countries using the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(area) FROM countries WHERE region = 'Caribbean';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = 'Caribbean';"
        ],
        "rule_sql": []
    },
    "707": {
        "db_id": "world_1",
        "question": "How much surface area do the countires in the Carribean cover together?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` to match the correct column name. Do reference the `country` table instead of `countries` to use the correct table name. Do use double quotes around 'Caribbean' instead of single quotes to match the correct string literal format. The amended query now correctly calculates the total surface area for Caribbean countries using the proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM countries WHERE region = 'Caribbean';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Region = \"Caribbean\";"
        ],
        "rule_sql": []
    },
    "708": {
        "db_id": "world_1",
        "question": "Which continent is Anguilla in?",
        "ground_truth": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
        "amends": [
            "Do reference table `country` instead of `countries` in the FROM clause. Do use column `Continent` instead of `continent` in the SELECT list. Do use column `Name` instead of `name` in the WHERE filter. Do use double quotes `\"Anguilla\"` instead of single quotes for the string literal. The amended query now correctly references the proper table and column names to match the intended schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent FROM countries WHERE name = 'Anguilla';",
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ],
        "rule_sql": []
    },
    "709": {
        "db_id": "world_1",
        "question": "What is the continent name which Anguilla belongs to?",
        "ground_truth": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column `Name` instead of `country_name` for the filter condition. Do use column `Continent` instead of `continent` in the SELECT list. Do use double quotes `\"Anguilla\"` instead of single quotes for the string literal. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent FROM countries WHERE country_name = 'Anguilla';",
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ],
        "rule_sql": []
    },
    "710": {
        "db_id": "world_1",
        "question": "Which region is the city Kabul located in?",
        "ground_truth": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"",
        "amends": [
            "Do join `country AS T1` and `city AS T2` instead of querying only `cities` table. Do use `LEFT JOIN` on `T1.Code = T2.CountryCode` instead of no join condition. Do select `Region` from the joined table instead of `region` from a single table. Do filter on `T2.Name = \"Kabul\"` instead of `city = 'Kabul'`. Do use proper table aliases and qualified column references instead of unqualified column names. The amended query now correctly retrieves the region by joining country and city tables with proper relationship mapping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM cities WHERE city = 'Kabul';",
            "SELECT T1.Region FROM country AS T1 LEFT JOIN city AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
        ],
        "rule_sql": []
    },
    "711": {
        "db_id": "world_1",
        "question": "What region is Kabul in?",
        "ground_truth": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"",
        "amends": [
            "Do select `Region` from table `country` instead of `region` from table `cities`. Do join table `city` with `country` using `ON T1.Code = T2.CountryCode` instead of querying only the `cities` table. Do filter on `T2.Name = \"Kabul\"` instead of `name = 'Kabul'`. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves the region from the country table by joining with the city table to find Kabul's corresponding country code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM cities WHERE name = 'Kabul';",
            "SELECT T1.Region FROM country T1 JOIN city T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
        ],
        "rule_sql": []
    },
    "712": {
        "db_id": "world_1",
        "question": "Which language is the most popular in Aruba?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T2.Language` instead of `language, COUNT(*) as count`. Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages`. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no explicit join. Do filter with `WHERE T1.Name = \"Aruba\"` instead of `WHERE country = 'Aruba'`. Do order by `Percentage DESC` instead of `count DESC`. Do remove the `GROUP BY` clause and aggregate function instead of keeping them. The amended query now correctly retrieves the language with the highest percentage for Aruba instead of counting language occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM languages WHERE country = 'Aruba' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Name = 'Aruba'\nORDER BY T2.Percentage DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "713": {
        "db_id": "world_1",
        "question": "What language is predominantly spoken in Aruba?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T2.Language` from the joined table instead of `language` from a single table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do add a filter on `T1.Name = \"Aruba\"` instead of `name = 'Aruba'` with proper table qualification. Do add `ORDER BY Percentage DESC` and `LIMIT 1` to get the highest percentage language instead of returning all matching records without ordering or limiting. The amended query now correctly retrieves the most spoken language in Aruba by joining the country and countrylanguage tables and selecting the top result by percentage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE name = 'Aruba';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "714": {
        "db_id": "world_1",
        "question": "What are the population and life expectancies in Brazil?",
        "ground_truth": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
        "amends": [
            "Do select `Population` and `LifeExpectancy` instead of `population` and `life_expectancy`. Do use table `country` instead of `countries`. Do filter on `Name = \"Brazil\"` instead of `name = 'Brazil'` with proper column name and quote style. The amended query now correctly retrieves population and life expectancy data for Brazil from the country table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE name = 'Brazil';",
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ],
        "rule_sql": []
    },
    "715": {
        "db_id": "world_1",
        "question": "Give me Brazil\u2019s population and life expectancies.",
        "ground_truth": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
        "amends": [
            "Do select `Population` and `LifeExpectancy` instead of `population` and `life_expectancy`. Do use table `country` instead of `countries`. Do filter on `Name = \"Brazil\"` instead of `name = 'Brazil'`. Do omit the `name` column from the SELECT list instead of including it. The amended query now correctly retrieves population and life expectancy data for Brazil from the country table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE name = 'Brazil';",
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ],
        "rule_sql": []
    },
    "716": {
        "db_id": "world_1",
        "question": "What are the region and population of Angola?",
        "ground_truth": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column names `Name`, `Population`, and `Region` instead of `name`, `population`, and `region` to match the correct schema. Do use double quotes `\"Angola\"` instead of single quotes `'Angola'` for the string literal in the WHERE filter. The amended query now correctly retrieves the population and region data for Angola from the proper table structure.",
            "Do maintain the same column selection `Region, Population` instead of changing the order, but do reverse the column order in the SELECT list to `Population, Region` instead of `Region, Population`. Do keep the same table source `country` and identical WHERE filter `Name = \"Angola\"` instead of making any changes to these elements. The amended query now correctly matches the RIGHT_SQL's behavior with the specified column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, population FROM countries WHERE name = 'Angola';",
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";",
            "SELECT Population, Region FROM country WHERE Name = \"Angola\""
        ],
        "rule_sql": []
    },
    "717": {
        "db_id": "world_1",
        "question": "What region does Angola belong to and what is its population?",
        "ground_truth": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column names `Name`, `Population`, and `Region` instead of `name`, `population`, and `region` to match the correct schema. Do use double quotes `\"Angola\"` instead of single quotes `'Angola'` for the string literal in the WHERE filter. The amended query now correctly retrieves the population and region data for Angola from the proper table structure.",
            "Do reverse the column order to `Population, Region` instead of `Region, Population` while maintaining the same `WHERE Name = \"Angola\"` filter. The amended query now matches RIGHT_SQL's behavior by preserving all logical elements while adjusting the presentation order of columns in the SELECT list."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, population FROM countries WHERE name = 'Angola';",
            "SELECT Region, Population FROM country WHERE Name = \"Angola\";",
            "SELECT Population, Region FROM country WHERE Name = \"Angola\";"
        ],
        "rule_sql": []
    },
    "718": {
        "db_id": "world_1",
        "question": "What is the average expected life expectancy for countries in the region of Central Africa?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"",
        "amends": [
            "Do use table name `country` instead of `countries` and column name `LifeExpectancy` instead of `life_expectancy` to match the correct schema. Do use the correct region filter value `\"Central Africa\"` instead of `'Central Africa'` while maintaining the same filtering logic. Do use lowercase `avg` function instead of `AVG` for the aggregate calculation, though this is purely cosmetic. The amended query now correctly calculates the average life expectancy for the Central Africa region using the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE region = 'Central Africa';",
            "SELECT avg(LifeExpectancy) FROM country WHERE Region = \"Central Africa\""
        ],
        "rule_sql": []
    },
    "719": {
        "db_id": "world_1",
        "question": "How long is the people\u2019s average life expectancy in Central Africa?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"",
        "amends": [
            "Do reference the `LifeExpectancy` column instead of `life_expectancy`, use the `country` table instead of `countries`, and filter on `Region` instead of `region` while maintaining the same aggregate function and filter logic. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE region = 'Central Africa';",
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = 'Central Africa';"
        ],
        "rule_sql": []
    },
    "720": {
        "db_id": "world_1",
        "question": "What is the name of country that has the shortest life expectancy in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case sensitivity. Do use `Continent` instead of `continent` for the WHERE filter column reference. Do use double quotes `\"Asia\"` instead of single quotes for the string literal. Do use `LifeExpectancy` instead of `lifeexpectancy` in the ORDER BY clause. Do remove the `DESC` modifier from the ORDER BY clause to sort in ascending order instead of descending order. The amended query now correctly selects the country with the lowest life expectancy in Asia rather than the highest."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' ORDER BY lifeexpectancy DESC LIMIT 1;",
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "721": {
        "db_id": "world_1",
        "question": "Give the name of the country in Asia with the lowest life expectancy.",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `country` instead of `countries`. Do use the correct column name `Continent` instead of `continent` and use double quotes around the string literal \"Asia\" instead of single quotes. Do order by `LifeExpectancy` in ascending order (default) instead of descending order with `DESC`, and use the correct column name `LifeExpectancy` instead of `life_expectancy`. The amended query now correctly retrieves the country with the lowest life expectancy in Asia, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Asia' ORDER BY life_expectancy DESC LIMIT 1;",
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "722": {
        "db_id": "world_1",
        "question": "What is the total population and maximum GNP in Asia?",
        "ground_truth": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
        "amends": [
            "Do use table name `country` instead of `countries` in the FROM clause. Do remove the column aliases `TotalPopulation` and `MaxGNP` instead of keeping them. Do use lowercase function names `sum` and `max` instead of uppercase `SUM` and `MAX`. Do use double quotes `\"Asia\"` instead of single quotes `'Asia'` for the string literal in the WHERE filter. The amended query now correctly references the proper table and uses consistent function casing while maintaining the same aggregation logic and filtering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(Population) AS TotalPopulation, MAX(GNP) AS MaxGNP FROM countries WHERE Continent = 'Asia';",
            "SELECT sum(Population), max(GNP) FROM country WHERE Continent = \"Asia\""
        ],
        "rule_sql": []
    },
    "723": {
        "db_id": "world_1",
        "question": "How many people live in Asia, and what is the largest GNP among them?",
        "ground_truth": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to calculate total population instead of counting rows. Do reference `Continent` instead of `continent` for case-sensitive column name matching. Do use double quotes `\"Asia\"` instead of single quotes `'Asia'` for string literal syntax. Do remove the `AS population` and `AS largest_gnp` aliases instead of keeping them. The amended query now correctly sums population values and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS population, MAX(GNP) AS largest_gnp FROM country WHERE continent = 'Asia';",
            "SELECT SUM(country.Population), MAX(country.GNP) FROM country WHERE country.Continent = \"Asia\""
        ],
        "rule_sql": []
    },
    "724": {
        "db_id": "world_1",
        "question": "What is the average life expectancy in African countries that are republics?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic';"
        ],
        "rule_sql": []
    },
    "725": {
        "db_id": "world_1",
        "question": "Give the average life expectancy for countries in Africa which are republics?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(lifeexpectancy) FROM country WHERE continent = 'Africa' AND governmentform = 'Republic';"
        ],
        "rule_sql": []
    },
    "726": {
        "db_id": "world_1",
        "question": "What is the total surface area of the continents Asia and Europe?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` and use the `sum` aggregate function instead of `SUM`. Do query from the `country` table instead of the `continents` table. Do filter on the `Continent` column with values \"Asia\" and \"Europe\" instead of filtering on the `name` column. The amended query now correctly calculates the total surface area for Asian and European countries as specified in the target query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM continents WHERE name = 'Asia' OR name = 'Europe';",
            "SELECT sum(SurfaceArea) FROM country WHERE Continent IN ('Asia', 'Europe')"
        ],
        "rule_sql": []
    },
    "727": {
        "db_id": "world_1",
        "question": "Give the total surface area covered by countries in Asia or Europe.",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` to match the correct column name. Do reference the `Continent` column instead of `continent` to match the correct column name. Do reference the `country` table instead of `countries` to match the correct table name. Do use double quotes around string literals \"Asia\" and \"Europe\" instead of single quotes to match the correct string formatting. The amended query now correctly calculates the sum of surface areas for Asian and European countries from the proper table with accurate column references and string formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM countries WHERE continent = 'Asia' OR continent = 'Europe';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Continent = \"Asia\" OR Continent = \"Europe\";"
        ],
        "rule_sql": []
    },
    "728": {
        "db_id": "world_1",
        "question": "How many people live in Gelderland district?",
        "ground_truth": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to aggregate population values rather than counting rows. Do reference table `city` instead of `people` as the data source. Do use double quotes `\"Gelderland\"` instead of single quotes for the district filter value. The amended query now correctly calculates the total population in the Gelderland district rather than counting records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE district = 'Gelderland';",
            "SELECT SUM(Population) FROM city WHERE District = \"Gelderland\";"
        ],
        "rule_sql": []
    },
    "729": {
        "db_id": "world_1",
        "question": "What is the total population of Gelderland district?",
        "ground_truth": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
        "amends": [
            "Do query the `city` table instead of the `districts` table. Do use the `District` column filter instead of the `name` column filter. Do use the exact string value \"Gelderland\" instead of 'Gelderland'. Do use lowercase `sum` function instead of uppercase `SUM`. The amended query now correctly aggregates population data from cities within the Gelderland district rather than incorrectly attempting to sum population from a districts table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) FROM districts WHERE name = 'Gelderland';",
            "SELECT sum(Population) FROM city WHERE District = 'Gelderland'"
        ],
        "rule_sql": []
    },
    "730": {
        "db_id": "world_1",
        "question": "What is the average GNP and total population in all nations whose government is US territory?",
        "ground_truth": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(GNP), SUM(Population) FROM country WHERE GovernmentForm = 'US Territory';"
        ],
        "rule_sql": []
    },
    "731": {
        "db_id": "world_1",
        "question": "Give the mean GNP and total population of nations which are considered US territory.",
        "ground_truth": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
        "amends": [
            "Do reference `GovernmentForm` in the WHERE filter instead of `Region`. Do use double quotes around the string literal \"US Territory\" instead of single quotes. The amended query now correctly filters by government form rather than region and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(GNP), SUM(Population) FROM country WHERE Region = 'US Territory';",
            "SELECT AVG(GNP) AS mean_gnp, SUM(Population) AS total_population FROM country WHERE GovernmentForm = \"US Territory\";"
        ],
        "rule_sql": []
    },
    "732": {
        "db_id": "world_1",
        "question": "How many unique languages are spoken in the world?",
        "ground_truth": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage",
        "amends": [
            "Do select `count(DISTINCT LANGUAGE)` instead of `COUNT(*)`. Do query from `countrylanguage` table instead of `languages` table. The amended query now correctly counts distinct languages from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages;",
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ],
        "rule_sql": []
    },
    "733": {
        "db_id": "world_1",
        "question": "What is the number of distinct languages used around the world?",
        "ground_truth": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage",
        "amends": [
            "Do select `count(DISTINCT LANGUAGE)` instead of `COUNT(*)`. Do query from `countrylanguage` table instead of `languages` table. The amended query now correctly counts distinct languages from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages;",
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ],
        "rule_sql": []
    },
    "734": {
        "db_id": "world_1",
        "question": "How many type of governments are in Africa?",
        "ground_truth": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"",
        "amends": [
            "Do use `count(DISTINCT GovernmentForm)` instead of `COUNT(*)` to count distinct government forms rather than all rows. Do reference table `country` instead of `countries` as the correct table name. Do use column `Continent` instead of `continent` with proper capitalization. Do use double quotes `\"Africa\"` instead of single quotes `'Africa'` for the continent filter value. The amended query now correctly counts distinct government forms in African countries rather than counting all rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Africa';",
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"
        ],
        "rule_sql": []
    },
    "735": {
        "db_id": "world_1",
        "question": "How many different forms of governments are there in Africa?",
        "ground_truth": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"",
        "amends": [
            "Do use `count(DISTINCT GovernmentForm)` instead of `COUNT(*)` to count distinct government forms rather than all rows. Do reference table `country` instead of `countries` as the correct table name. Do use column `Continent` instead of `continent` with proper capitalization. Do use double quotes `\"Africa\"` instead of single quotes for the string literal. Do remove the unnecessary aggregation of all rows and instead count distinct government forms specifically for African countries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Africa';",
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"
        ],
        "rule_sql": []
    },
    "736": {
        "db_id": "world_1",
        "question": "What is the total number of languages used in Aruba?",
        "ground_truth": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages` table. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no join. Do filter on `T1.Name = \"Aruba\"` instead of `country = 'Aruba'`. Do select `COUNT(T2.Language)` instead of `COUNT(*)` to count specific language records. Do use proper table aliases and qualified column references instead of unqualified column names. The amended query now correctly counts languages by joining country and countrylanguage tables with proper relationship mapping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Aruba';",
            "SELECT COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ],
        "rule_sql": []
    },
    "737": {
        "db_id": "world_1",
        "question": "How many languages are spoken in Aruba?",
        "ground_truth": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages` table. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no join. Do filter on `T1.Name = \"Aruba\"` instead of `country = 'Aruba'`. Do count `T2.Language` instead of `COUNT(*)`. The amended query now correctly counts languages by joining country and countrylanguage tables and filtering by country name instead of a non-existent country column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Aruba';",
            "SELECT COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ],
        "rule_sql": []
    },
    "738": {
        "db_id": "world_1",
        "question": "How many official languages does Afghanistan have?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `languages` table. Do filter on `T1.Name = \"Afghanistan\"` instead of `country = 'Afghanistan'` and use `IsOfficial = \"T\"` instead of `status = 'official'`. Do remove the incorrect table reference and add the proper join condition to establish the relationship between country and language data. The amended query now correctly counts official languages for Afghanistan by joining the appropriate tables with proper key relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Afghanistan' AND status = 'official';",
            "SELECT COUNT(*) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "739": {
        "db_id": "world_1",
        "question": "How many official languages are spoken in Afghanistan?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country` and `countrylanguage` tables with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying only the `languages` table. Do filter on `T1.Name = \"Afghanistan\"` and `IsOfficial = \"T\"` instead of filtering only on `country = 'Afghanistan'`. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly counts official languages for Afghanistan by properly joining the country and language tables with appropriate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Afghanistan';",
            "SELECT COUNT(*) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "740": {
        "db_id": "world_1",
        "question": "What is name of the country that speaks the largest number of languages?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country.name` and use table aliases `T1` and `T2` instead of full table names. Do join on `T1.Code = T2.CountryCode` instead of `country.code = countrylanguage.countrycode` with proper table alias references. Do group by `T1.Name` instead of `country.code` to match the selected column. Do order by `COUNT(*) DESC` instead of `COUNT(countrylanguage.language) ASC` to get the highest count rather than the lowest. The amended query now correctly identifies the country with the most languages by counting all language records and sorting in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.code \nORDER BY COUNT(countrylanguage.language) ASC \nLIMIT 1;",
            "SELECT T1.Name\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "741": {
        "db_id": "world_1",
        "question": "Give the name of the nation that uses the greatest amount of languages.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Name` in the SELECT list instead of `n.name` and group by `T1.Name` instead of `n.nation_id`. Do join `country AS T1` and `countrylanguage AS T2` instead of `nation` and `language` tables. Do use the join condition `T1.Code = T2.CountryCode` instead of `n.nation_id = l.nation_id`. Do order by `COUNT(*)` instead of `COUNT(l.language_id)` while maintaining the same DESC ordering and LIMIT 1. The amended query now correctly counts languages per country and returns the country with the most languages, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n.name \nFROM nation n \nJOIN language l ON n.nation_id = l.nation_id \nGROUP BY n.nation_id \nORDER BY COUNT(l.language_id) DESC \nLIMIT 1;",
            "SELECT T1.Name\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "742": {
        "db_id": "world_1",
        "question": "Which continent has the most diverse languages?",
        "ground_truth": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Continent` instead of `continent` and reference the `country` table instead of `countries`. Do add a `JOIN` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single table. Do count all rows with `COUNT(*)` instead of counting `language` specifically. Do order by `COUNT(*) DESC` instead of `language_count DESC` while keeping the same `LIMIT 1` logic. The amended query now correctly identifies the continent with the most languages by joining the country and countrylanguage tables and counting all language records per continent.",
            "Do remove `COUNT(*) as language_count` from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the continent with the highest language count rather than both the continent and the count value. The amended query now correctly returns just the continent name while maintaining the same grouping, ordering, and limit logic to identify the continent with the most languages, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, COUNT(language) as language_count FROM countries GROUP BY continent ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Continent, COUNT(*) as language_count\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.Continent\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "743": {
        "db_id": "world_1",
        "question": "Which continent speaks the most languages?",
        "ground_truth": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `country` table as `T1` and `countrylanguage` as `T2` instead of using `country_languages`. Do join `T1.Code = T2.CountryCode` instead of grouping by `continent` directly. Do select `T1.Continent` instead of both `continent` and `language_count`. Do use `COUNT(*)` in the ORDER BY instead of the aliased `language_count`. Do remove the explicit column alias `language_count` instead of keeping it. The amended query now correctly joins the country and countrylanguage tables to count languages per continent and returns the continent with the highest count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, COUNT(language) as language_count FROM country_languages GROUP BY continent ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Continent\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "744": {
        "db_id": "world_1",
        "question": "How many countries speak both English and Dutch?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "amends": [
            "Do use `INTERSECT` to find countries with both languages instead of counting cross-joined language pairs. Do reference `country` and `countrylanguage` tables instead of `countries` and `languages`. Do join on `Code` and `CountryCode` instead of `country_id` to `country_id`. Do filter for \"English\" and \"Dutch\" in separate subqueries instead of joining the same table twice with both conditions. Do select `Name` from the subqueries instead of counting all matches. Do remove the double join structure and WHERE clause combining both language conditions, instead using set intersection logic to correctly identify countries that have both languages specified."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM countries c\nJOIN languages l1 ON c.country_id = l1.country_id\nJOIN languages l2 ON c.country_id = l2.country_id\nWHERE l1.language = 'English' AND l2.language = 'Dutch';",
            "SELECT COUNT(*) \nFROM (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English'\n    INTERSECT\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'Dutch'\n) AS countries_with_both_languages"
        ],
        "rule_sql": []
    },
    "745": {
        "db_id": "world_1",
        "question": "What is the number of nations that use English and Dutch?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "amends": [
            "Do use a subquery with `INTERSECT` to find countries that speak both English and Dutch instead of a single `WHERE` clause with conflicting `language = 'English' AND language = 'Dutch'` conditions. Do join `country` and `countrylanguage` tables on `Code = CountryCode` instead of querying only the `nations` table. Do filter for English in one branch and Dutch in another branch with separate queries instead of trying to match both languages simultaneously in one condition. Do select `Name` from the `country` table instead of counting directly from an unspecified source. Do use proper table aliases `T1` and `T2` instead of unspecified table references. The amended query now correctly identifies countries where both languages are spoken by intersecting two separate queries for each language."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM nations WHERE language = 'English' AND language = 'Dutch';",
            "SELECT COUNT(*) \nFROM (\n    SELECT c.Name \n    FROM country c \n    JOIN countrylanguage cl1 ON c.Code = cl1.CountryCode \n    WHERE cl1.Language = 'English'\n    INTERSECT\n    SELECT c.Name \n    FROM country c \n    JOIN countrylanguage cl2 ON c.Code = cl2.CountryCode \n    WHERE cl2.Language = 'Dutch'\n) AS T1"
        ],
        "rule_sql": []
    },
    "746": {
        "db_id": "world_1",
        "question": "What are the names of nations speak both English and French?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "amends": [
            "Do use `INTERSECT` to find countries that speak both English and French instead of using `OR` which finds countries that speak either language. Do join on `T1.Code = T2.CountryCode` instead of `n.id = l1.nation_id` with proper table aliases. Do filter for `T2.Language = \"English\"` in one branch and `T2.Language = \"French\"` in the other instead of using `OR` conditions that don't ensure both languages are spoken. Do use explicit table aliases `T1` and `T2` instead of `n`, `l1`, and `l2`. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with multiple joins and OR conditions. The amended query now correctly identifies countries that speak both English and French by intersecting the results of two separate queries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n.name FROM nations n \nJOIN languages l1 ON n.id = l1.nation_id \nJOIN languages l2 ON n.id = l2.nation_id \nWHERE l1.language = 'English' OR l2.language = 'French';",
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French'"
        ],
        "rule_sql": []
    },
    "747": {
        "db_id": "world_1",
        "question": "Give the names of nations that speak both English and French.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "amends": [
            "Do use `INTERSECT` to find countries that speak both English and French instead of using `OR` which finds countries that speak either language. Do join `country` table as `T1` with `countrylanguage` as `T2` on `T1.Code = T2.CountryCode` instead of joining `nations` with `languages` twice on `n.id = l1.nation_id` and `n.id = l2.nation_id`. Do filter for `T2.Language = \"English\"` in the first branch and `T2.Language = \"French\"` in the second branch instead of using `WHERE l1.language = 'English' OR l2.language = 'French'`. Do select `T1.Name` from the `country` table instead of `n.name` from `nations`. The amended query now correctly identifies countries that speak both English and French by using intersection logic instead of union logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n.name \nFROM nations n\nJOIN languages l1 ON n.id = l1.nation_id\nJOIN languages l2 ON n.id = l2.nation_id\nWHERE l1.language = 'English' OR l2.language = 'French';",
            "SELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French'"
        ],
        "rule_sql": []
    },
    "748": {
        "db_id": "world_1",
        "question": "What are the names of nations where both English and French are official languages?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with conflicting conditions. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `nations` table. Do filter for `T2.Language = \"English\"` and `T2.IsOfficial = \"T\"` in the first query instead of checking `official_languages = 'English'`. Do filter for `T2.Language = \"French\"` and `T2.IsOfficial = \"T\"` in the second query instead of checking `official_languages = 'French'`. Do select `T1.Name` from the joined tables instead of just `name` from a single table. The amended query now correctly identifies countries where both English and French are official languages by using an intersection of two separate queries with proper table joins and official language status checks."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM nations WHERE official_languages = 'English' AND official_languages = 'French';",
            "SELECT T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "749": {
        "db_id": "world_1",
        "question": "Give the names of countries with English and French as official languages.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use an INTERSECT operation to find countries that have both English and French as official languages instead of using a single query with conflicting WHERE conditions. Do change the WHERE clause to filter for `T2.Language = \"English\"` and `T2.IsOfficial = \"T\"` in the first SELECT, and `T2.Language = \"French\"` and `T2.IsOfficial = \"T\"` in the second SELECT instead of trying to filter for both languages simultaneously in a single condition. Do add table aliases `T1` for country and `T2` for countrylanguage instead of using unaliased table names. Do remove the impossible condition requiring the same row to have both `language = 'English'` and `language = 'French'` instead of keeping this logical contradiction. The amended query now correctly identifies countries where both English and French are official languages by intersecting two separate queries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nWHERE countrylanguage.language = 'English' \nAND countrylanguage.language = 'French' \nAND countrylanguage.isofficial = 'T';",
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "750": {
        "db_id": "world_1",
        "question": "What is the number of distinct continents where Chinese is spoken?",
        "ground_truth": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"",
        "amends": [
            "Do add `COUNT(DISTINCT Continent)` instead of `COUNT(*)` to count distinct continents rather than all rows. Do add `FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of just `FROM countrylanguage` to join the country table and access continent data. Do keep `WHERE T2.Language = 'Chinese'` but move it to reference the joined table instead of the standalone table. Do remove the standalone countrylanguage table reference and instead use the joined relationship between country and countrylanguage tables. The amended query now correctly counts distinct continents where Chinese is spoken instead of counting all Chinese language records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countrylanguage WHERE language = 'Chinese';",
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ],
        "rule_sql": []
    },
    "751": {
        "db_id": "world_1",
        "question": "How many continents speak Chinese?",
        "ground_truth": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"",
        "amends": [
            "Do use `COUNT(DISTINCT Continent)` instead of `COUNT(*)` to count distinct continents rather than all rows. Do add `JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of querying only the countries table to properly relate countries with their languages. Do reference `T2.Language = \"Chinese\"` instead of `language = 'Chinese'` to filter by language in the correct joined table. Do specify `FROM country AS T1` instead of `FROM countries` to use the correct table name and alias. The amended query now correctly counts distinct continents where Chinese is spoken by properly joining the country and countrylanguage tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Chinese';",
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ],
        "rule_sql": []
    },
    "752": {
        "db_id": "world_1",
        "question": "What are the regions that use English or Dutch?",
        "ground_truth": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "amends": [
            "Do select `DISTINCT T1.Region` instead of `region` without distinct. Do join `country AS T1` with `countrylanguage AS T2` instead of querying only `countries`. Do use `LEFT JOIN` on `T1.Code = T2.CountryCode` instead of no join condition. Do filter with `T2.Language = \"English\" OR T2.Language = \"Dutch\"` instead of `language = 'English' AND language = 'Dutch'` which would never return results. The amended query now correctly finds regions where either English or Dutch is spoken, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM countries WHERE language = 'English' AND language = 'Dutch';",
            "SELECT DISTINCT T1.Region FROM country AS T1 LEFT JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
        ],
        "rule_sql": []
    },
    "753": {
        "db_id": "world_1",
        "question": "Which regions speak Dutch or English?",
        "ground_truth": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "amends": [
            "Do use `DISTINCT T1.Region` instead of `region` without distinct. Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `countries`. Do specify `ON T1.Code = T2.CountryCode` instead of missing the join condition. Do filter on `T2.Language = \"English\" OR T2.Language = \"Dutch\"` instead of filtering on a single table's `language` column. The amended query now correctly retrieves distinct regions from joined tables where the language condition is properly applied through the relationship between country and countrylanguage tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM countries WHERE language = 'Dutch' OR language = 'English';",
            "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
        ],
        "rule_sql": []
    },
    "754": {
        "db_id": "world_1",
        "question": "What are the countries where either English or Dutch is the official language ?",
        "ground_truth": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"english\" and isofficial  =  \"t\" union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"dutch\" and isofficial  =  \"t\"",
        "amends": [
            "Do select `t1.name` from `country` instead of `country` from `languages`. Do use `JOIN` with `countrylanguage` on `t1.code = t2.countrycode` instead of querying a single table. Do filter for `language = \"english\"` and `isofficial = \"t\"` in separate UNION branches instead of impossible `language = 'English' AND language = 'Dutch'` condition. Do add `UNION` to combine results for English and Dutch official languages instead of attempting to find both languages in one row. Do remove the incorrect table reference and impossible WHERE condition instead of keeping them. The amended query now correctly finds countries with English or Dutch as official languages through proper table joins and union operation.",
            "Do use double quotes `\"english\"` and `\"dutch\"` instead of single quotes `'English'` and `'Dutch'` for string literals. Do reference `isofficial` directly instead of qualifying it with `t2.` as `t2.IsOfficial`. Do add explicit `AS` keyword for table aliases as `country AS t1` instead of omitting it. Do use consistent lowercase for column names like `name` and `code` instead of mixed case. The amended query now correctly matches the RIGHT_SQL's behavior with proper string quoting and unqualified column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM languages WHERE language = 'English' AND language = 'Dutch';",
            "SELECT t1.Name \nFROM country t1\nJOIN countrylanguage t2 ON t1.Code = t2.CountryCode\nWHERE t2.Language = 'English' AND t2.IsOfficial = 'T'\nUNION\nSELECT t1.Name \nFROM country t1\nJOIN countrylanguage t2 ON t1.Code = t2.CountryCode\nWHERE t2.Language = 'Dutch' AND t2.IsOfficial = 'T'",
            "SELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"english\" AND t2.isofficial = \"T\"\nUNION\nSELECT t1.name \nFROM country AS t1 \nJOIN countrylanguage AS t2 ON t1.code = t2.countrycode \nWHERE t2.language = \"dutch\" AND t2.isofficial = \"T\""
        ],
        "rule_sql": []
    },
    "755": {
        "db_id": "world_1",
        "question": "Which countries have either English or Dutch as an official language?",
        "ground_truth": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND IsOfficial  =  \"T\" UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do select all columns from joined tables instead of selecting only `country` from a single table. Do join `country` and `countrylanguage` tables on `Code=CountryCode` instead of querying only the `languages` table. Do filter for `Language=\"English\"` and `IsOfficial=\"T\"` in one branch instead of using contradictory `language='English' AND language='Dutch'` conditions. Do add a UNION with a second branch for `Language=\"Dutch\"` and `IsOfficial=\"T\"` instead of attempting to find both languages in a single row. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds countries where either English or Dutch is an official language through separate UNION branches instead of the impossible single-row condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM languages WHERE language = 'English' AND language = 'Dutch';",
            "SELECT T1.*, T2.*\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nUNION\nSELECT T1.*, T2.*\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'Dutch' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "756": {
        "db_id": "world_1",
        "question": "Which language is the most popular on the Asian continent?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use `T2.Language` in the SELECT list instead of `language` and remove the `count` alias. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single `countries` table. Do filter on `T1.Continent = \"Asia\"` instead of `continent = 'Asia'`. Do group by `T2.Language` instead of `language`. Do order by `COUNT(*) DESC` instead of `count DESC`. The amended query now correctly joins the country and countrylanguage tables to find the most spoken language in Asia."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM countries WHERE continent = 'Asia' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "757": {
        "db_id": "world_1",
        "question": "What is the language that is used by the largest number of Asian nations?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use `T2.Language` from the `countrylanguage` table instead of `language` from a non-existent column. Do join `country AS T1` and `countrylanguage AS T2` with `ON T1.Code = T2.CountryCode` instead of querying a single `countries` table. Do filter on `T1.Continent = \"Asia\"` instead of `continent = 'Asia'` to reference the correct table. Do group by `T2.Language` instead of `language` to match the selected column. Do order by `COUNT(*) DESC` instead of `count DESC` to reference the aggregate function directly rather than an alias. The amended query now correctly identifies the most spoken language in Asia by joining the appropriate tables and properly referencing schema elements.",
            "Do remove `COUNT(*) AS count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T2.Language`. Do use double quotes `\"Asia\"` for the string literal instead of single quotes `'Asia'` in the WHERE clause. Do remove the space between `COUNT` and `(*)` in the ORDER BY clause instead of having a space, making it `COUNT(*)` instead of `COUNT (*)`. The amended query now correctly returns only the language column while maintaining the same grouping, ordering, and limiting behavior to match RIGHT_SQL's output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM countries WHERE continent = 'Asia' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language, COUNT(*) AS count\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = \"Asia\"\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "758": {
        "db_id": "world_1",
        "question": "Which languages are spoken by only one country in republic governments?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
        "amends": [
            "Do use table alias `T2` for the language table instead of `cl` and reference `T2.Language` in SELECT instead of `language`. Do join `country AS T1` instead of `country c` and use `T1.Code = T2.CountryCode` instead of `cl.country_code = c.code` for the join condition. Do reference `T1.GovernmentForm` instead of `c.government` in the WHERE filter while keeping the same 'Republic' value. Do maintain the same GROUP BY on language and HAVING COUNT(*) = 1 condition. The amended query now correctly matches the RIGHT_SQL's behavior with proper table references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as country_count \nFROM country_language cl \nJOIN country c ON cl.country_code = c.code \nWHERE c.government = 'Republic' \nGROUP BY language \nHAVING COUNT(*) = 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = 'Republic'\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": []
    },
    "759": {
        "db_id": "world_1",
        "question": "What languages are only used by a single country with a republic government?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
        "amends": [
            "Do use `T2.Language` instead of `language` for the SELECT column. Do reference `countrylanguage` as `T2` instead of `country_language cl` as the table source. Do use `JOIN` with `T1.Code = T2.CountryCode` instead of `JOIN` with `cl.country_code = c.code` for the join condition. Do filter with `T1.GovernmentForm = \"Republic\"` instead of `c.government = 'Republic'` in the WHERE clause. Do use `COUNT(*) = 1` instead of `COUNT(DISTINCT c.code) > 1` in the HAVING clause to find languages spoken in exactly one republic instead of multiple republics. Do remove `DISTINCT` from the SELECT instead of keeping it since the GROUP BY already ensures uniqueness. The amended query now correctly identifies languages spoken in exactly one republic country."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT language \nFROM country_language cl\nJOIN country c ON cl.country_code = c.code\nWHERE c.government = 'Republic'\nGROUP BY language\nHAVING COUNT(DISTINCT c.code) > 1;",
            "SELECT T2.Language\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = \"Republic\"\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": []
    },
    "760": {
        "db_id": "world_1",
        "question": "Find the city with the largest population that uses English.",
        "ground_truth": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T1.Population` instead of just `city` from the SELECT list. Do join `city AS T1` with `countrylanguage AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying only the `cities` table. Do filter on `T2.Language = \"English\"` instead of `language = 'English'` in the WHERE clause. Do order by `T1.Population DESC` instead of `population ASC` for descending order. The amended query now correctly retrieves city names with their populations where English is spoken, ordered by population in descending order to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities WHERE language = 'English' ORDER BY population ASC LIMIT 1;",
            "SELECT T1.Name, T1.Population \nFROM city AS T1 \nJOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.Language = \"English\" \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "761": {
        "db_id": "world_1",
        "question": "What is the most populace city that speaks English?",
        "ground_truth": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T1.Population` instead of `city` and `population`. Do join `city AS T1` with `countrylanguage AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying a single `cities` table. Do filter on `T2.Language = \"English\"` instead of `language = 'English'`. Do order by `T1.Population DESC` instead of `population ASC`. The amended query now correctly joins tables to filter by language and returns the city with the highest English-speaking population instead of the lowest."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, population FROM cities WHERE language = 'English' ORDER BY population ASC LIMIT 1;",
            "SELECT T1.Name, T1.Population \nFROM city AS T1 \nJOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.Language = \"English\" \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "762": {
        "db_id": "world_1",
        "question": "Find the name, population and expected life length of asian country with the largest area?",
        "ground_truth": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference table `country` instead of `countries` and use exact column names `Name`, `Population`, and `LifeExpectancy` instead of `name`, `population`, and `life_expectancy`. Do filter on `Continent = \"Asia\"` instead of `continent = 'Asia'` using double quotes for the string literal. Do order by `SurfaceArea DESC` instead of `area DESC` to match the correct column name. The amended query now correctly references the proper table schema and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE continent = 'Asia' ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "763": {
        "db_id": "world_1",
        "question": "What are the name, population, and life expectancy of the largest Asian country by land?",
        "ground_truth": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference table `country` instead of `countries` and use exact column names `Name`, `Population`, and `LifeExpectancy` instead of `name`, `population`, and `life_expectancy`. Do use double quotes around `\"Asia\"` instead of single quotes for the continent filter. Do order by `SurfaceArea` instead of `land_area` for the area-based sorting. The amended query now correctly references the schema and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE continent = 'Asia' ORDER BY land_area DESC LIMIT 1;",
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "764": {
        "db_id": "world_1",
        "question": "What is average life expectancy in the countries where English is not the official language?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")",
        "amends": [
            "Do use `avg(LifeExpectancy)` instead of `AVG(life_expectancy)` to reference the correct column name. Do reference table `country` instead of `countries` with the proper table name. Do replace the simple `WHERE official_language != 'English'` filter with a subquery that checks `Name NOT IN` a correlated subquery instead of using a direct column comparison. Do implement a subquery that joins `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of assuming language data exists in the main table. Do add the condition `T2.Language = \"English\" AND T2.IsOfficial = \"T\"` to properly filter for countries where English is an official language, instead of just checking for any non-English language presence. The amended query now correctly calculates average life expectancy for countries where English is not an official language by properly correlating country data with language information through the appropriate join relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE official_language != 'English';",
            "SELECT AVG(LifeExpectancy) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\n)"
        ],
        "rule_sql": []
    },
    "765": {
        "db_id": "world_1",
        "question": "Give the mean life expectancy of countries in which English is not the official language.",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")",
        "amends": [
            "Do use `avg(LifeExpectancy)` with lowercase function instead of `AVG(LifeExpectancy)` with uppercase. Do replace the simple `WHERE Language != 'English'` filter with a subquery condition `WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")` that properly checks for countries where English is an official language through a join between country and countrylanguage tables instead of incorrectly filtering on a non-existent Language column in the Country table. Do add the additional condition `AND T2.IsOfficial = \"T\"` to ensure only officially recognized English languages are considered instead of omitting this official status check. The amended query now correctly identifies countries without English as an official language by properly joining related tables and checking language official status."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(LifeExpectancy) FROM Country WHERE Language != 'English';",
            "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")"
        ],
        "rule_sql": []
    },
    "766": {
        "db_id": "world_1",
        "question": "What is the total number of people living in the nations that do not use English?",
        "ground_truth": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\")",
        "amends": [
            "Do reference the `country` table instead of `nations` and use `sum(Population)` instead of `SUM(population)`. Do replace the simple `WHERE language != 'English'` filter with a subquery that checks `Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\")` instead of the incorrect direct column reference. Do add the necessary join between `country` and `countrylanguage` tables on `T1.Code = T2.CountryCode` instead of omitting this relationship. The amended query now correctly identifies countries where English is not an official language by properly joining through the countrylanguage table instead of incorrectly assuming the language column exists directly in the country table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) FROM nations WHERE language != 'English';",
            "SELECT SUM(Population) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ],
        "rule_sql": []
    },
    "767": {
        "db_id": "world_1",
        "question": "How many people live in countries that do not speak English?",
        "ground_truth": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\")",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to aggregate population data rather than counting rows. Do query from `country` table instead of joining `people`, `countries`, and `languages` tables. Do use a `WHERE Name NOT IN` subquery filter instead of a direct join condition with `l.name != 'English'`. Do implement a correlated subquery with `country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of the three-table join structure. Do filter for `T2.Language = \"English\"` in the subquery instead of excluding English language directly. Do remove the explicit table aliases `p`, `c`, and `l` since they are no longer needed in the simplified structure. The amended query now correctly calculates total population of countries where English is not spoken, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people p \nJOIN countries c ON p.country_id = c.id \nJOIN languages l ON c.language_id = l.id \nWHERE l.name != 'English';",
            "SELECT SUM(Population) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ],
        "rule_sql": []
    },
    "768": {
        "db_id": "world_1",
        "question": "What is the official language spoken in the country whose head of state is Beatrix?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do select `T2.Language` from the joined table instead of `language` from a single table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do add the filter `T2.IsOfficial = \"T\"` to ensure only official languages are returned instead of omitting this condition. Do use the correct table aliases and column references throughout the query instead of the simplified single-table approach. The amended query now correctly retrieves official languages from the joined tables matching the specified head of state condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE head_of_state = 'Beatrix';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "769": {
        "db_id": "world_1",
        "question": "What is the official language used in the country the name of whose head of state is Beatrix.",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do select `T2.Language` from the countrylanguage table instead of `language` from the countries table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single table. Do add the filter `T2.IsOfficial = \"T\"` to only include official languages instead of omitting this condition. Do reference the correct column name `HeadOfState` instead of `head_of_state`. The amended query now correctly retrieves official languages for countries where the head of state is Beatrix, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE head_of_state = 'Beatrix';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Beatrix' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "770": {
        "db_id": "world_1",
        "question": "What is the total number of unique official languages spoken in the countries that are founded before 1930?",
        "ground_truth": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Language` instead of `language` in the SELECT clause. Do join on `T1.Code = T2.CountryCode` instead of `countries.country_id = languages.country_id`. Do filter on `IndepYear < 1930` instead of `founded_year < 1930`. Do add the condition `T2.IsOfficial = \"T\"` instead of omitting it. The amended query now correctly counts distinct official languages for countries gaining independence before 1930, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT language) FROM countries JOIN languages ON countries.country_id = languages.country_id WHERE founded_year < 1930;",
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "771": {
        "db_id": "world_1",
        "question": "For the countries founded before 1930, what is the total number of distinct official languages?",
        "ground_truth": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country` and `countrylanguage` tables with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do filter on `IndepYear < 1930` instead of `year_founded < 1930` and add the condition `T2.IsOfficial = \"T\"` instead of omitting it. Do select `count(DISTINCT T2.Language)` from the joined table structure instead of `COUNT(DISTINCT language)` from a single table. The amended query now correctly counts distinct official languages for countries founded before 1930 by properly joining the relevant tables and applying the official language filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT language) FROM countries WHERE year_founded < 1930;",
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "772": {
        "db_id": "world_1",
        "question": "What are the countries that have greater surface area than any country in Europe?",
        "ground_truth": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do use `SurfaceArea` instead of `surface_area` for the column reference in both the main query and subquery. Do use `Continent` instead of `continent` for the column reference in the subquery filter. Do use double quotes `\"Europe\"` instead of single quotes `'Europe'` for the string literal. Do use `MIN(SurfaceArea)` instead of `MAX(SurfaceArea)` in the subquery to find the minimum surface area instead of the maximum. The amended query now correctly identifies countries with surface area greater than the minimum surface area of European countries instead of the maximum, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM country WHERE surface_area > (SELECT MAX(surface_area) FROM country WHERE continent = 'Europe')",
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ],
        "rule_sql": []
    },
    "773": {
        "db_id": "world_1",
        "question": "Which countries have greater area than that of any country in Europe?",
        "ground_truth": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
        "amends": [
            "Do reference the correct table name `country` instead of `countries` in both the main query and subquery. Do use the correct column name `Name` instead of `name` for the country name. Do use the correct column name `SurfaceArea` instead of `area` for the surface area measurement. Do use the correct column name `Continent` instead of `continent` for the continent designation. Do use double quotes `\"Europe\"` instead of single quotes `'Europe'` for the string literal. Do use the `MIN` aggregate function `min(SurfaceArea)` instead of `MAX(area)` to find the smallest European country's surface area instead of the largest. The amended query now correctly identifies countries with surface area greater than the smallest European country rather than the largest."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE area > (SELECT MAX(area) FROM countries WHERE continent = 'Europe')",
            "SELECT Name FROM country WHERE SurfaceArea > (SELECT MIN(SurfaceArea) FROM country WHERE Continent = \"Europe\")"
        ],
        "rule_sql": []
    },
    "774": {
        "db_id": "world_1",
        "question": "What are the African countries that have a  population less than any country in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  \"Asia\")",
        "amends": [
            "Do use `max(population)` in the subquery instead of `MIN(population)` to compare African countries against the maximum population in Asia rather than the minimum. Do maintain the same column references `Name` and `Continent` with consistent capitalization and quotation style. Do preserve the same table structure and WHERE clause conditions with identical join semantics and filter logic. The amended query now correctly identifies African countries with populations smaller than the largest Asian country rather than comparing against the smallest Asian country, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Africa' AND population < (SELECT MIN(population) FROM country WHERE continent = 'Asia')",
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Africa' \nAND c.Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')"
        ],
        "rule_sql": []
    },
    "775": {
        "db_id": "world_1",
        "question": "Which African countries have a smaller population than that of any country in Asia?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT min(population) FROM country WHERE Continent  =  \"Asia\")",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c1.name \nFROM country c1 \nWHERE c1.continent = 'Africa' \nAND c1.population < (SELECT MIN(population) FROM country WHERE continent = 'Asia')"
        ],
        "rule_sql": []
    },
    "776": {
        "db_id": "world_1",
        "question": "Which Asian countries have a population that is larger than any country in Africa?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT max(population) FROM country WHERE Continent  =  \"Africa\")",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' AND population > (SELECT MAX(population) FROM country WHERE continent = 'Africa')"
        ],
        "rule_sql": []
    },
    "777": {
        "db_id": "world_1",
        "question": "What are the Asian countries which have a population larger than that of any country in Africa?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  \"Africa\")",
        "amends": [
            "Do use `min(population)` in the subquery instead of `MAX(population)` to find the smallest African country population rather than the largest. Do capitalize column names `Name` and `Continent` instead of lowercase `name` and `continent` to match the schema. Do use double quotes `\"Asia\"` and `\"Africa\"` instead of single quotes for string literals. The amended query now correctly identifies Asian countries with population greater than the smallest African country population rather than the largest, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' AND population > (SELECT MAX(population) FROM country WHERE continent = 'Africa')",
            "SELECT Name \nFROM country \nWHERE Continent = \"Asia\" \nAND Population > (SELECT MIN(Population) FROM country WHERE Continent = \"Africa\")"
        ],
        "rule_sql": []
    },
    "778": {
        "db_id": "world_1",
        "question": "What are the country codes for countries that do not speak English?",
        "ground_truth": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do query the `countrylanguage` table instead of the `countries` table. Do use `EXCEPT` to exclude English-speaking countries instead of a simple inequality filter. Do reference `CountryCode` instead of `country_code` and `LANGUAGE` instead of `language`. Do use double quotes around 'English' instead of single quotes. The amended query now correctly identifies country codes where English is not spoken by excluding those where it is spoken, matching the RIGHT_SQL's set-based logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language != 'English';",
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ],
        "rule_sql": []
    },
    "779": {
        "db_id": "world_1",
        "question": "Return the country codes for countries that do not speak English.",
        "ground_truth": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do use `EXCEPT` to exclude countries where English is spoken instead of selecting countries where English is spoken. Do reference `CountryCode` with proper case instead of `countrycode` with lowercase. Do use double quotes for string literal `\"English\"` instead of single quotes. Do remove the `WHERE` clause filtering for English language instead of keeping it, as the logic now excludes rather than includes English-speaking countries. The amended query correctly identifies countries where English is not spoken by excluding those where it is spoken, matching the intended behavior.",
            "Do select `CountryCode` from `countrylanguage` instead of `Code` from `country` in the first query. Do remove the incorrect table reference to `country` and instead use `countrylanguage` as the source table for the initial selection. Do maintain the `EXCEPT` operation with the subquery that filters for `Language = \"English\"` from the same `countrylanguage` table instead of mixing different tables. The amended query now correctly identifies countries that don't speak English by comparing within the same dataset rather than across unrelated tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT countrycode FROM countrylanguage WHERE language = 'English';",
            "SELECT Code FROM country EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\"",
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ],
        "rule_sql": []
    },
    "780": {
        "db_id": "world_1",
        "question": "What are the country codes of countries where people use languages other than English?",
        "ground_truth": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
        "amends": [
            "Do select `DISTINCT CountryCode` instead of `country_code` without distinct. Do use table `countrylanguage` instead of `countries`. Do filter with `LANGUAGE != \"English\"` instead of `language = 'English'`. The amended query now correctly returns unique country codes where the language is not English, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'English';",
            "SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != 'English';"
        ],
        "rule_sql": []
    },
    "781": {
        "db_id": "world_1",
        "question": "Give the country codes for countries in which people speak langauges that are not English.",
        "ground_truth": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
        "amends": [
            "Do select `DISTINCT CountryCode` instead of `country_code` without distinct. Do query from `countrylanguage` table instead of `countries` table. Do filter with `LANGUAGE != \"English\"` instead of `language = 'English'`. Do use double quotes around string literal instead of single quotes. The amended query now correctly selects distinct country codes from the countrylanguage table where the language is not English, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'English';",
            "SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != \"English\""
        ],
        "rule_sql": []
    },
    "782": {
        "db_id": "world_1",
        "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
        "ground_truth": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do select `Code` from `country` instead of `CountryCode` from `CountryLanguage`. Do use `EXCEPT` to exclude countries with English language instead of filtering with `Language != 'English'`. Do move the `GovernmentForm != 'Republic'` filter to the first SELECT clause instead of including it in the WHERE clause of a single query. Do remove the incorrect join logic between country and countrylanguage tables instead of attempting to query them together without proper joins. Do add proper table separation with EXCEPT instead of combining filters in a single WHERE clause that creates incorrect semantics. The amended query now correctly identifies countries that are not republics and exclude those where English is spoken, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT CountryCode FROM CountryLanguage WHERE Language != 'English' AND GovernmentForm != 'Republic';",
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic'\nEXCEPT\nSELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ],
        "rule_sql": []
    },
    "783": {
        "db_id": "world_1",
        "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
        "ground_truth": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do select `Code` instead of `code` and use `EXCEPT` to exclude English-speaking countries instead of filtering with `language != 'English'`. Do reference table `country` instead of `countries` and use `GovernmentForm` instead of `government`. Do remove the direct `language` filter from the WHERE clause and instead use a subquery with `EXCEPT` that selects from `countrylanguage` where `LANGUAGE = 'English'`. Do use proper column references `CountryCode` in the EXCEPT clause instead of attempting to filter language directly in the main query. The amended query now correctly excludes countries where English is spoken while maintaining the government form filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT code FROM countries WHERE language != 'English' AND government != 'Republic';",
            "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English'"
        ],
        "rule_sql": []
    },
    "784": {
        "db_id": "world_1",
        "question": "Which cities are in European countries where English is not the official language?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')",
        "amends": [
            "Do use `DISTINCT` on `T2.Name` instead of selecting `city_name` without deduplication. Do join `country AS T1` with `city AS T2` on `T2.CountryCode = T1.Code` instead of using a subquery with `IN` condition. Do filter with `T1.Continent = 'Europe'` instead of checking continent in a subquery. Do use `T1.Name NOT IN` with a correlated subquery checking official English language status through `countrylanguage` table instead of simple `official_language != 'English'` condition. Do add explicit table aliases `T1`, `T2`, `T3`, and `T4` instead of using unaliased table references. The amended query now correctly identifies European cities in countries where English is not an official language, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE country IN (SELECT country FROM countries WHERE continent = 'Europe' AND official_language != 'English')",
            "SELECT DISTINCT T2.Name\nFROM country AS T1\nJOIN city AS T2 ON T2.CountryCode = T1.Code\nWHERE T1.Continent = 'Europe'\nAND T1.Code NOT IN (\n    SELECT T3.CountryCode\n    FROM countrylanguage AS T3\n    WHERE T3.Language = 'English' AND T3.IsOfficial = 'T'\n)"
        ],
        "rule_sql": []
    },
    "785": {
        "db_id": "world_1",
        "question": "What are the names of cities in Europe for which English is not the official language?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')",
        "amends": [
            "Do select `DISTINCT T2.Name` instead of `city_name` and use table `country AS T1` joined with `city AS T2` on `T2.CountryCode = T1.Code` instead of querying `cities` directly. Do filter with `T1.Continent = 'Europe'` instead of `continent = 'Europe'` and add a subquery condition `T1.Name NOT IN` instead of checking `official_language = 'English'`. The subquery correctly identifies countries where English is an official language by joining `country AS T3` with `countrylanguage AS T4` on `T3.Code = T4.CountryCode` and filtering for `T4.IsOfficial = 'T' AND T4.Language = 'English'`, ensuring only cities in European countries without English as an official language are returned. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE continent = 'Europe' AND official_language = 'English';",
            "SELECT DISTINCT T2.Name \nFROM country AS T1 \nJOIN city AS T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT T3.Name \n    FROM country AS T3 \n    JOIN countrylanguage AS T4 ON T3.Code = T4.CountryCode \n    WHERE T4.IsOfficial = 'T' AND T4.Language = 'English'\n)"
        ],
        "rule_sql": []
    },
    "786": {
        "db_id": "world_1",
        "question": "Which unique cities are in Asian countries where Chinese is the official language ?",
        "ground_truth": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  \"asia\"",
        "amends": [
            "Do select `t3.name` from the `city` table instead of `city` from the `cities` table. Do join three tables with `country as t1 JOIN countrylanguage as t2 ON t1.code = t2.countrycode JOIN city as t3 ON t1.code = t3.countrycode` instead of querying a single table. Do add filters for `t2.isofficial = 't'` and `t2.language = 'chinese'` instead of just `language = 'Chinese'`. Do use `t1.continent = \"asia\"` instead of `continent = 'Asia'`. The amended query now correctly retrieves city names where Chinese is an official language in Asian countries, matching the RIGHT_SQL's behavior.",
            "Do remove the `t1.Continent = 'Asia'` filter from the `WHERE` clause instead of keeping it there, and do add `t1.continent = \"asia\"` to the end of the `WHERE` clause instead of omitting it, while maintaining the same join structure with `JOIN countrylanguage as t2 ON t1.Code = t2.CountryCode` and `JOIN city as t3 ON t1.Code = t3.CountryCode`. The amended query now correctly filters for Asian countries while preserving the distinct city names where Chinese is an official language, matching the right SQL's behavior.",
            "Do use double quotes `\"asia\"` instead of single quotes `'Asia'` for the continent filter to match the case-sensitive value. The amended query now correctly returns distinct city names where Chinese is an official language in Asian countries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT city FROM cities WHERE continent = 'Asia' AND language = 'Chinese';",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t1.Continent = 'Asia' \nAND t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese'",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nAND t1.Continent = 'Asia'",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nAND t1.Continent = \"asia\""
        ],
        "rule_sql": []
    },
    "787": {
        "db_id": "world_1",
        "question": "Return the different names of cities that are in Asia and for which Chinese is the official language.",
        "ground_truth": "SELECT DISTINCT T3.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode JOIN city AS T3 ON T1.Code  =  T3.CountryCode WHERE T2.IsOfficial  =  'T' AND T2.Language  =  'Chinese' AND T1.Continent  =  \"Asia\"",
        "amends": [
            "Do select `DISTINCT T3.Name` instead of `city_name` to return unique city names. Do join three tables `country AS T1`, `countrylanguage AS T2`, and `city AS T3` instead of querying only `cities` table. Do use `JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` with condition `T2.IsOfficial = 'T'` instead of filtering by `official_language = 'Chinese'` to properly identify official languages. Do add `JOIN city AS T3 ON T1.Code = T3.CountryCode` to connect cities to countries instead of assuming city table contains all necessary data. Do filter with `T1.Continent = 'Asia'` instead of `continent = 'Asia'` to use the correct table's continent field. Do add condition `T2.Language = 'Chinese'` to specifically filter for Chinese language instead of relying on a single language filter. The amended query now correctly identifies Asian cities where Chinese is an official language by properly joining country, language, and city tables with appropriate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE continent = 'Asia' AND official_language = 'Chinese';",
            "SELECT DISTINCT T3.Name \nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nJOIN city AS T3 ON T1.Code = T3.CountryCode\nWHERE T1.Continent = 'Asia' \nAND T2.Language = 'Chinese' \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "788": {
        "db_id": "world_1",
        "question": "What are the name, independence year, and surface area of the country with the smallest population?",
        "ground_truth": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
        "amends": [
            "Do select `Name`, `SurfaceArea`, and `IndepYear` instead of `name`, `indep_year`, and `surface_area` to match the correct column names. Do order by `Population` in ascending order instead of `population DESC` to get the smallest population record. Do use table name `country` instead of `countries` to reference the correct source table. The amended query now correctly retrieves the country with the smallest population using the proper table and column names.",
            "Do reorder the SELECT list to `Name, SurfaceArea, IndepYear` instead of `Name, IndepYear, SurfaceArea`. Do remove the `ASC` keyword from the ORDER BY clause instead of keeping it, as ASC is the default sort order. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and simplified ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, indep_year, surface_area FROM countries ORDER BY population DESC LIMIT 1;",
            "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;",
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ],
        "rule_sql": []
    },
    "789": {
        "db_id": "world_1",
        "question": "Give the name, year of independence, and surface area of the country that has the lowest population.",
        "ground_truth": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
        "amends": [
            "Do use column names `Name`, `SurfaceArea`, and `IndepYear` instead of `name`, `surfacearea`, and `indepyear` to match the correct case sensitivity. Do order by `Population` in ascending order instead of `population DESC` to get the smallest population instead of the largest. The amended query now correctly retrieves the country with the smallest population while maintaining the same column selection and limit behavior.",
            "Do reorder the SELECT list to `Name, SurfaceArea, IndepYear` instead of `Name, IndepYear, SurfaceArea`. Do remove the explicit `ASC` direction from `ORDER BY Population` instead of keeping it, as ASC is the default ordering. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and simplified ordering syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, indepyear, surfacearea FROM country ORDER BY population DESC LIMIT 1;",
            "SELECT Name, IndepYear, SurfaceArea FROM country ORDER BY Population ASC LIMIT 1;",
            "SELECT Name, SurfaceArea, IndepYear FROM country ORDER BY Population LIMIT 1;"
        ],
        "rule_sql": []
    },
    "790": {
        "db_id": "world_1",
        "question": "What are the population, name and leader of the country with the largest area?",
        "ground_truth": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do select `Name`, `population`, and `HeadOfState` instead of `population`, `name`, and `leader`. Do reference table `country` instead of `countries`. Do order by `SurfaceArea` instead of `area`. The amended query now correctly selects the appropriate columns from the right table with proper column names and ordering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population, name, leader FROM countries ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "791": {
        "db_id": "world_1",
        "question": "Give the name, population, and head of state for the country that has the largest area.",
        "ground_truth": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do use column `Name` instead of `name`, `HeadOfState` instead of `head_of_state`, and `SurfaceArea` instead of `area` in the ORDER BY clause, while keeping the same SELECT list structure and LIMIT 1. The amended query now correctly references the proper column names and ordering criteria to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population, head_of_state FROM country ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "792": {
        "db_id": "world_1",
        "question": "Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages.",
        "ground_truth": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(T2.Language)` instead of `COUNT(language.language)` to reference the joined table correctly. Do use table aliases `T1` and `T2` instead of full table names for clarity. Do reference `T1.Name` in the SELECT list instead of `country.name` to match the aliased table. Do group by `T1.Name` instead of `country.code` to ensure proper aggregation with the selected column. Do change the HAVING condition to `COUNT(*) > 2` instead of `num_languages >= 3` to use the actual count value rather than the alias. The amended query now correctly counts languages per country and filters for countries with more than 2 languages, matching the RIGHT_SQL's behavior.",
            "Do place `T1.Name` after the aggregate in the SELECT list instead of before it, maintaining the same column order as the original. Do use explicit table aliases with `AS` for both tables instead of omitting them. Do keep the same join condition `T1.Code = T2.CountryCode`, grouping by `T1.Name`, and HAVING clause `COUNT(*) > 2` unchanged. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering and explicit alias syntax.",
            "Do place `COUNT(T2.Language)` before `T1.Name` in the SELECT list instead of the reverse order. Do maintain the same JOIN condition `T1.Code = T2.CountryCode` and GROUP BY `T1.Name` with the identical HAVING clause `COUNT(*) > 2`. The amended query now matches RIGHT_SQL's behavior with the correct column ordering while preserving all logical operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name, COUNT(language.language) as num_languages \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.code \nHAVING num_languages >= 3;",
            "SELECT T1.Name, COUNT(T2.Language) AS num_languages\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2",
            "SELECT T1.Name, COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(*) > 2",
            "SELECT COUNT(T2.Language), T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "793": {
        "db_id": "world_1",
        "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?",
        "ground_truth": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",
        "amends": [
            "Do use `COUNT(T2.Language)` instead of `COUNT(language.language)` to reference the correct table alias. Do use table aliases `T1` and `T2` instead of full table names throughout the query. Do reference `T1.Name` in the SELECT list instead of `country.name` for consistency with aliases. Do specify `T1.Code = T2.CountryCode` in the JOIN condition instead of `country.code = countrylanguage.countrycode` using proper aliases. Do use `COUNT(*) > 2` in the HAVING clause instead of `language_count > 2` to directly reference the aggregate function rather than the column alias. The amended query now correctly counts languages per country using proper table aliases and direct aggregate references in the HAVING clause.",
            "Do place `COUNT(T2.Language)` before `T1.Name` in the SELECT list instead of the reverse order. Do remove the `AS language_count` alias instead of keeping it. Do remove the `ORDER BY language_count DESC` clause instead of including it. The amended query now matches RIGHT_SQL's behavior by maintaining the same logical grouping and filtering while removing the ordering and column alias.",
            "Do place `COUNT(T2.Language)` first in the SELECT list instead of `T1.Name` first. Do use `COUNT(*)` in the HAVING clause instead of `COUNT(T2.Language)` to count all rows rather than non-null language values specifically. The amended query now correctly counts all country-language relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name, COUNT(language.language) as language_count \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.name \nHAVING language_count > 2;",
            "SELECT T1.Name, COUNT(T2.Language) AS language_count\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nHAVING COUNT(*) > 2\nORDER BY language_count DESC;",
            "SELECT T1.Name, COUNT(T2.Language) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(T2.Language) > 2",
            "SELECT COUNT(T2.Language), T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Code \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "794": {
        "db_id": "world_1",
        "question": "Find the number of cities in each district whose population is greater than the average population of cities?",
        "ground_truth": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) AS city_count`. Do capitalize `District` in the SELECT list instead of lowercase `district`. Do capitalize `Population` in the WHERE clause instead of lowercase `population`. Do capitalize `avg(Population)` in the subquery instead of `AVG(population)`. Do capitalize `District` in the GROUP BY clause instead of lowercase `district`. The amended query now correctly matches the RIGHT_SQL's behavior with proper column capitalization and alias handling.",
            "Do place `count(*)` before `District` in the SELECT list instead of having `District` first. Do use lowercase `avg(Population)` in the subquery instead of uppercase `AVG(Population)`. Do maintain the same WHERE filter using `Population >` with the subquery calculating the average population, and preserve the GROUP BY `District` clause. The amended query now correctly returns the count of cities by district where population exceeds the average, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district, COUNT(*) AS city_count\nFROM city\nWHERE population > (SELECT AVG(population) FROM city)\nGROUP BY district;",
            "SELECT District, COUNT(*) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District;",
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ],
        "rule_sql": []
    },
    "795": {
        "db_id": "world_1",
        "question": "How many cities in each district have a population that is above the average population across all cities?",
        "ground_truth": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as city_count`. Do capitalize `District` in the SELECT list instead of lowercase `district`. Do capitalize `Population` in the WHERE clause instead of lowercase `population`. Do capitalize `avg(Population)` in the subquery instead of `AVG(population)`. Do capitalize `District` in the GROUP BY clause instead of lowercase `district`. The amended query now correctly matches the behavior of the RIGHT_SQL with proper column capitalization while maintaining the same logical structure for counting cities by district where population exceeds the average.",
            "Do place `count(*)` before `District` in the SELECT list instead of the reverse order. Do maintain the same aggregate function `COUNT(*)` and grouping column `District` instead of changing them. Do keep the same FROM source `city` instead of modifying it. Do preserve the WHERE filter comparing `Population` to the subquery result instead of altering it. Do retain the identical subquery calculating `avg(Population)` from `city` instead of modifying it. Do maintain the GROUP BY clause on `District` instead of changing it. The amended query now matches RIGHT_SQL's behavior with identical logic despite the column ordering difference in the SELECT clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district, COUNT(*) as city_count\nFROM city\nWHERE population > (SELECT AVG(population) FROM city)\nGROUP BY district;",
            "SELECT District, COUNT(*) \nFROM city \nWHERE Population > (SELECT AVG(Population) FROM city) \nGROUP BY District",
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ],
        "rule_sql": []
    },
    "796": {
        "db_id": "world_1",
        "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.",
        "ground_truth": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",
        "amends": [
            "Do use `HAVING avg(LifeExpectancy) > 72` instead of `WHERE lifeexpectancy > 72` to filter after aggregation rather than before. Do place `GovernmentForm` after the aggregate instead of before it in the SELECT list. Do remove the alias `total_population` instead of keeping it. Do use uppercase column names `Population` and `GovernmentForm` instead of lowercase versions. The amended query now correctly filters groups based on average life expectancy rather than filtering individual rows, matching the RIGHT_SQL's behavior.",
            "Do place `GovernmentForm` after the aggregate function instead of before it in the SELECT list. Do use lowercase `sum` and `avg` functions instead of uppercase `SUM` and `AVG`. The amended query now correctly calculates the total population by government form while filtering for those with average life expectancy exceeding 72, matching the intended behavior.",
            "Do place `GovernmentForm` after `sum(Population)` in the SELECT list instead of before it, maintaining the same aggregation logic and HAVING clause with `avg(LifeExpectancy) > 72` unchanged. The amended query now matches RIGHT_SQL's behavior with identical column ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT governmentform, SUM(population) as total_population \nFROM country \nWHERE lifeexpectancy > 72 \nGROUP BY governmentform;",
            "SELECT GovernmentForm, SUM(Population) FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72",
            "SELECT GovernmentForm, sum(Population) FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72",
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ],
        "rule_sql": []
    },
    "797": {
        "db_id": "world_1",
        "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?",
        "ground_truth": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",
        "amends": [
            "Do move the LifeExpectancy filter to `HAVING avg(LifeExpectancy) > 72` instead of `WHERE LifeExpectancy > 72` to filter groups by average life expectancy rather than individual rows. Do change the SELECT clause order to `sum(Population), GovernmentForm` instead of `GovernmentForm, SUM(Population) as TotalPopulation`, removing the alias while maintaining the same aggregation logic. The amended query now correctly filters government forms based on their average life expectancy rather than excluding individual countries, matching the RIGHT_SQL's behavior.",
            "Do place `GovernmentForm` after the aggregate function instead of before it in the SELECT list. Do use lowercase `sum` and `avg` functions instead of uppercase `SUM` and `AVG`. Do maintain the same GROUP BY clause on `GovernmentForm` and HAVING condition checking `avg(LifeExpectancy) > 72`. The amended query now correctly matches the right SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT GovernmentForm, SUM(Population) as TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;",
            "SELECT GovernmentForm, SUM(Population) FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72",
            "SELECT sum(Population), GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy) > 72"
        ],
        "rule_sql": []
    },
    "798": {
        "db_id": "world_1",
        "question": "Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?",
        "ground_truth": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
        "amends": [
            "Do use `sum(Population)` and `avg(LifeExpectancy)` instead of `SUM(population) as total_population` and `AVG(life_expectancy) as avg_life_expectancy` with different column names and casing. Do place the `HAVING avg(LifeExpectancy) < 72` filter after `GROUP BY Continent` instead of incorrectly using `WHERE AVG(life_expectancy) < 72` before grouping. Do remove the column aliases `as avg_life_expectancy` and `as total_population` instead of keeping them. Do change the table name from `countries` to `country` instead of using the wrong table reference. Do reorder the SELECT list to `sum(Population), avg(LifeExpectancy), Continent` instead of `continent, AVG(life_expectancy), SUM(population)`. The amended query now correctly filters aggregated results using HAVING instead of the invalid WHERE clause with aggregate functions, matching the RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to place `sum(Population)` first instead of `Continent`, and move `Continent` to the end instead of the beginning. Do keep the same `avg(LifeExpectancy)` aggregate and `GROUP BY Continent` clause. Do maintain the identical `HAVING avg(LifeExpectancy) < 72` filter instead of changing it. The amended query now matches RIGHT_SQL's behavior with identical logic but different column ordering in the output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, AVG(life_expectancy) as avg_life_expectancy, SUM(population) as total_population \nFROM countries \nWHERE AVG(life_expectancy) < 72 \nGROUP BY continent",
            "SELECT Continent, avg(LifeExpectancy), sum(Population) FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72",
            "SELECT sum(Population), avg(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72"
        ],
        "rule_sql": []
    },
    "799": {
        "db_id": "world_1",
        "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?",
        "ground_truth": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
        "amends": [
            "Do use `sum(Population)` and `avg(LifeExpectancy)` instead of `SUM(population)` and `AVG(life_expectancy)` with different column names. Do place `Continent` in the SELECT list instead of omitting it from the output. Do remove the `total_population` and `avg_life_expectancy` aliases instead of keeping them. Do use `HAVING avg(LifeExpectancy) < 72` instead of `WHERE avg_life_expectancy < 72` to properly filter aggregated results after grouping. Do reference table `country` instead of `countries`. The amended query now correctly filters on aggregated values using HAVING instead of WHERE and matches the RIGHT_SQL's behavior.",
            "Do place `Continent` at the end of the SELECT list instead of at the beginning. Do maintain the same aggregate functions `sum(Population)` and `avg(LifeExpectancy)` with identical GROUP BY and HAVING clauses using `avg(LifeExpectancy) < 72`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, SUM(population) as total_population, AVG(life_expectancy) as avg_life_expectancy \nFROM countries \nWHERE avg_life_expectancy < 72 \nGROUP BY continent",
            "SELECT Continent, sum(Population), avg(LifeExpectancy) FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72",
            "SELECT sum(Population), avg(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72"
        ],
        "rule_sql": []
    },
    "800": {
        "db_id": "world_1",
        "question": "What are the names and areas of countries with the top 5 largest area?",
        "ground_truth": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
        "amends": [
            "Do use column name `Name` instead of `name` and `SurfaceArea` instead of `area` in the SELECT list. Do reference table `country` instead of `countries` in the FROM clause. The amended query now correctly references the proper column names and table to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, area FROM countries ORDER BY area DESC LIMIT 5;",
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ],
        "rule_sql": []
    },
    "801": {
        "db_id": "world_1",
        "question": "Return the names and surface areas of the 5 largest countries.",
        "ground_truth": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
        "amends": [
            "Do use column names `Name` and `SurfaceArea` instead of `name` and `surface_area` to match the actual schema. Do order by `SurfaceArea DESC` instead of `ASC` to sort in descending order rather than ascending. Do query from table `country` instead of `countries` to reference the correct table name. The amended query now correctly retrieves the top 5 countries by surface area in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, surface_area FROM countries ORDER BY surface_area ASC LIMIT 5;",
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ],
        "rule_sql": []
    },
    "802": {
        "db_id": "world_1",
        "question": "What are names of countries with the top 3 largest population?",
        "ground_truth": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3",
        "amends": [
            "Do select `Name` instead of `name` to match the correct column case. Do order by `Population DESC` instead of `population ASC` to sort by descending population rather than ascending. Do use table `country` instead of `countries` to reference the correct table name. The amended query now correctly returns the top 3 countries by population in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ],
        "rule_sql": []
    },
    "803": {
        "db_id": "world_1",
        "question": "Return the names of the 3 most populated countries.",
        "ground_truth": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do order by `Population DESC` instead of `population ASC` to sort in descending order by the correct population column. Do reference table `country` instead of `countries` to use the correct table name. The amended query now correctly selects the top 3 countries by population in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "804": {
        "db_id": "world_1",
        "question": "What are the names of the nations with the 3 lowest populations?",
        "ground_truth": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do reference the `Name` column instead of `name` and the `Population` column instead of `population` to match the correct table schema. Do reference the `country` table instead of `nations` as the correct data source. The amended query now correctly retrieves the three countries with the smallest population from the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM nations ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ],
        "rule_sql": []
    },
    "805": {
        "db_id": "world_1",
        "question": "Return the names of the 3 countries with the fewest people.",
        "ground_truth": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do use column name `Name` instead of `name` and `Population` instead of `population` to match the correct case sensitivity. Do use `ASC` ordering instead of `DESC` to sort by population in ascending order instead of descending. Do use table name `country` instead of `countries` to reference the correct table. The amended query now correctly selects from the proper table with accurate column names and ascending population ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population DESC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "806": {
        "db_id": "world_1",
        "question": "how many countries are in Asia?",
        "ground_truth": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"",
        "amends": [
            "Do reference table `country` instead of `countries` and filter on `continent = \"Asia\"` instead of `'Europe'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Europe';",
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ],
        "rule_sql": []
    },
    "807": {
        "db_id": "world_1",
        "question": "Count the number of countries in Asia.",
        "ground_truth": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"",
        "amends": [
            "Do reference table `country` instead of `countries` and filter on `continent = \"Asia\"` instead of `continent = 'Europe'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Europe';",
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ],
        "rule_sql": []
    },
    "808": {
        "db_id": "world_1",
        "question": "What are the names of the countries that are in the continent of Europe and have a population of 80000?",
        "ground_truth": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column names `Name` and `Population` instead of `name` and `population`. Do use double quotes around the string value \"80000\" instead of treating it as a numeric literal without quotes. The amended query now correctly references the proper table and column names with appropriate string formatting for the population value, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Europe' AND population = 80000;",
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = \"80000\";"
        ],
        "rule_sql": []
    },
    "809": {
        "db_id": "world_1",
        "question": "Give the names of countries that are in Europe and have a population equal to 80000.",
        "ground_truth": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column names `Name` and `Population` instead of `name` and `population`. Do use double quotes around the string value \"80000\" instead of treating it as a numeric literal without quotes. The amended query now correctly references the schema elements and properly handles the population value as a string, matching the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Europe' AND population = 80000;",
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = 80000"
        ],
        "rule_sql": []
    },
    "810": {
        "db_id": "world_1",
        "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?",
        "ground_truth": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000",
        "amends": [
            "Do use `surfacearea` instead of `area` in both the aggregate function and filter condition. Do change the area filter to `> 3000` instead of `< 3000` to include larger countries rather than smaller ones. Do remove the column aliases `total_population` and `average_area` instead of keeping them. Do use lowercase table name `country` instead of `countries` and lowercase continent value `\"north america\"` instead of 'North America'. The amended query now correctly calculates population sum and surface area average for North American countries with surface area greater than 3000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) AS total_population, AVG(area) AS average_area FROM countries WHERE continent = 'North America' AND area < 3000;",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = 'north america' AND SurfaceArea > 3000"
        ],
        "rule_sql": []
    },
    "811": {
        "db_id": "world_1",
        "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .",
        "ground_truth": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000",
        "amends": [
            "Do use `surfacearea` column name instead of `surface_area` to match the actual schema. Do remove the `AS total_population` and `AS avg_surface_area` aliases instead of keeping them. Do use double quotes `\"north america\"` instead of single quotes for the string literal. Do reference the `country` table instead of `countries` to use the correct table name. The amended query now correctly calculates the total population and average surface area for North American countries with surface area greater than 3000, matching the intended behavior.",
            "Do maintain the exact same query structure with identical SELECT list containing `SUM(Population)` and `AVG(SurfaceArea)`, identical FROM source `country`, identical WHERE filters `Continent = \"North America\"` and `SurfaceArea > 3000`, and identical aggregation behavior instead of making any changes, as both queries are functionally equivalent despite minor formatting differences in spacing and case. The amended query now matches RIGHT_SQL's behavior with no substantive changes required.",
            "Do use identical `SUM(Population)` and `AVG(SurfaceArea)` expressions instead of changing them, maintain the same `FROM country` source instead of altering it, preserve the exact `WHERE Continent = \"North America\" AND SurfaceArea > 3000` filter conditions instead of modifying them, and keep the same aggregation structure without adding GROUP BY or HAVING clauses instead of introducing them. The amended query now matches RIGHT_SQL's behavior with identical logic and results.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior with no functional differences.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent despite minor formatting differences.",
            "Do maintain the exact same SELECT list with `SUM(Population)` and `AVG(SurfaceArea)` instead of changing any aggregate functions or column references. Do preserve the FROM clause with single table `country` instead of adding or removing any data sources. Do keep the WHERE filter conditions exactly as `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying any predicate logic or values. Do maintain the same aggregation structure without GROUP BY/HAVING clauses instead of adding unnecessary grouping. The amended query now correctly matches the intended behavior by preserving all logical components unchanged from the original formulation.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent with only insignificant formatting differences.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent with only insignificant formatting differences."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) AS total_population, AVG(surface_area) AS avg_surface_area \nFROM countries \nWHERE continent = 'North America' AND surface_area > 3000;",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000"
        ],
        "rule_sql": []
    },
    "812": {
        "db_id": "world_1",
        "question": "What are the cities whose population is between 160000 and 900000?",
        "ground_truth": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000",
        "amends": [
            "Do select `name` instead of `city` from the `city` table instead of `cities`. Do use `BETWEEN 160000 AND 900000` instead of separate `population > 160000 AND population < 900000` conditions to include both boundary values. The amended query now correctly retrieves city names within the specified population range using proper inclusive bounds."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities WHERE population > 160000 AND population < 900000;",
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ],
        "rule_sql": []
    },
    "813": {
        "db_id": "world_1",
        "question": "Return the names of cities that have a population between 160000 and 900000 .",
        "ground_truth": "select name from city where population between 160000 and 900000",
        "amends": [
            "Do reference the table as `city` instead of `cities` to match the correct schema. Do use `BETWEEN 160000 AND 900000` instead of `< 160000 OR > 900000` to select cities within the population range rather than outside it, which completely reverses the logic from excluding to including the specified range. The amended query now correctly returns cities with populations between 160,000 and 900,000 instead of those outside this range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cities WHERE population < 160000 OR population > 900000;",
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ],
        "rule_sql": []
    },
    "814": {
        "db_id": "world_1",
        "question": "Which language is spoken by the largest number of countries?",
        "ground_truth": "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `LANGUAGE` instead of `language, COUNT(*) as country_count` to return only the language column rather than both language and count. Do use table `countrylanguage` instead of `countries` to access the correct data source containing language information. Do group by `LANGUAGE` instead of `language` to maintain consistent case handling. Do order by `count(*) DESC` instead of `country_count DESC` to directly reference the aggregate function rather than an alias. The amended query now correctly identifies the most common language by counting occurrences in the appropriate table and returns only the language value itself."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as country_count FROM countries GROUP BY language ORDER BY country_count DESC LIMIT 1;",
            "SELECT Language FROM countrylanguage GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "815": {
        "db_id": "world_1",
        "question": "Give the language that is spoken in the most countries.",
        "ground_truth": "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the correct table name `countrylanguage` instead of the incorrect `country_languages`. Do maintain the same column reference `LANGUAGE` instead of `language` while preserving the same case sensitivity. Do keep the identical aggregation `COUNT(*)` and ordering `DESC` with the same `LIMIT 1` clause. The amended query now correctly references the actual table name while maintaining the same logical behavior to find the most frequently occurring language."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM country_languages GROUP BY language ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT Language FROM countrylanguage GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "816": {
        "db_id": "world_1",
        "question": "What is the language spoken by the largest percentage of people in each country?",
        "ground_truth": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
        "amends": [
            "Do reference table `countrylanguage` instead of `country_languages` and use column `CountryCode` instead of `country` for grouping. Do use column `LANGUAGE` instead of `language` and `Percentage` instead of `percentage` in the aggregate function. Do include `CountryCode` in the SELECT list instead of omitting it, while maintaining the same MAX aggregation logic on percentage values grouped by country code.",
            "Do specify `Language` and `CountryCode` in the SELECT list without aliasing `Language` instead of using aliases for both columns. Do use `max(Percentage)` without an alias instead of `MAX(Percentage) AS MaxPercentage`. The amended query now correctly selects the maximum percentage for each language and country code combination without unnecessary aliasing.",
            "Do maintain the `Language` column in the SELECT list instead of omitting it, and do preserve the `CountryCode` column position instead of moving it to first position. Do keep the aggregate function `MAX(Percentage)` unchanged as it correctly calculates the maximum percentage for each group. Do maintain the GROUP BY clause on `CountryCode` to group results by country code. The amended query now correctly includes all necessary columns in the SELECT list while maintaining proper grouping semantics, matching the RIGHT_SQL's behavior.",
            "Do maintain the `Language` column in the SELECT list instead of omitting it, as it is required for proper grouping semantics. Do preserve the `CountryCode` column position as it appears in the GROUP BY clause instead of moving it. Do use consistent column ordering with `Language, CountryCode` instead of `CountryCode, Language` to match the logical grouping structure. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list and maintains proper column ordering to match RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, language, MAX(percentage) FROM country_languages GROUP BY country;",
            "SELECT CountryCode, Language, MAX(Percentage) AS MaxPercentage FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT Language, CountryCode, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "817": {
        "db_id": "world_1",
        "question": "What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?",
        "ground_truth": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
        "amends": [
            "Do select `LANGUAGE`, `CountryCode`, and `max(Percentage)` instead of `country.code` and `countrylanguage.language`. Do use only the `countrylanguage` table instead of joining `country` and `countrylanguage` tables. Do add `GROUP BY CountryCode` instead of omitting grouping. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly calculates the maximum percentage for each language by country code and matches the RIGHT_SQL's behavior.",
            "Do maintain the original column order `CountryCode, Language` instead of reordering to `Language, CountryCode`. Do keep the same aggregate function `MAX(Percentage)` and grouping clause `GROUP BY CountryCode` without changes. The amended query now correctly preserves the original column sequence while maintaining identical logical behavior to the RIGHT_SQL.",
            "Do maintain the original column order `CountryCode, Language` instead of reordering to `Language, CountryCode`. Do keep the same aggregate function `MAX(Percentage)` and grouping clause `GROUP BY CountryCode` without changes. The amended query now correctly preserves the original column sequence while maintaining identical logical behavior to the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.code, countrylanguage.language \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nORDER BY country.code;",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "818": {
        "db_id": "world_1",
        "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?",
        "ground_truth": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do use `count(*)` and `max(Percentage)` in the SELECT list instead of just `COUNT(*)` with a subquery. Do reference table `countrylanguage` instead of `countries` and column `LANGUAGE` instead of `language`. Do add `GROUP BY CountryCode` instead of filtering with a subquery comparison. Do use double quotes around \"Spanish\" instead of single quotes. The amended query now correctly groups by country code to count Spanish-speaking countries and find the maximum percentage, matching the intended behavior.",
            "Do remove the HAVING clause with its correlated subquery that was incorrectly filtering for maximum percentage values instead of keeping the simple aggregate query. Do change the SELECT list to include both `count(*)` and `max(Percentage)` instead of only `count(*)`. Do maintain the `WHERE Language = \"Spanish\"` filter and `GROUP BY CountryCode` grouping without the unnecessary subquery logic. The amended query now correctly counts Spanish-speaking countries while also showing their maximum percentage values, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Spanish' AND percentage = (SELECT MAX(percentage) FROM countries WHERE language = 'Spanish');",
            "SELECT COUNT(*) \nFROM countrylanguage \nWHERE Language = \"Spanish\" \nGROUP BY CountryCode \nHAVING MAX(Percentage) = (SELECT MAX(Percentage) FROM countrylanguage cl2 WHERE cl2.CountryCode = countrylanguage.CountryCode)",
            "SELECT COUNT(*), MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode;"
        ],
        "rule_sql": []
    },
    "819": {
        "db_id": "world_1",
        "question": "Count the number of countries for which Spanish is the predominantly spoken language.",
        "ground_truth": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do select both `count(*)` and `max(Percentage)` instead of only `COUNT(*)`. Do query from `countrylanguage` table instead of `countries` table. Do use `LANGUAGE = \"Spanish\"` filter instead of `language = 'Spanish'`. Do add `GROUP BY CountryCode` clause instead of omitting grouping. Do use double quotes around \"Spanish\" instead of single quotes for the string literal."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Spanish';",
            "SELECT COUNT(*), MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "820": {
        "db_id": "world_1",
        "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?",
        "ground_truth": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do add `max(Percentage)` to the SELECT list and include `GROUP BY CountryCode` instead of using `ORDER BY Percentage DESC LIMIT 1` to find the maximum percentage. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the aggregate function with grouping achieves the same result more efficiently. Do keep the `WHERE Language = 'Spanish'` filter unchanged. The amended query now correctly returns each country's maximum Spanish speaking percentage rather than just the single highest percentage country, matching the RIGHT_SQL's behavior of showing all countries with their respective maximum percentages."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC LIMIT 1;",
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "821": {
        "db_id": "world_1",
        "question": "Return the codes of countries for which Spanish is the predominantly spoken language.",
        "ground_truth": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
        "amends": [
            "Do select `CountryCode` and `max(Percentage)` instead of `country_code` alone. Do query from `countrylanguage` table instead of `countries` table. Do use aggregate function `max(Percentage)` with `GROUP BY CountryCode` instead of selecting individual rows without aggregation. Do filter on `LANGUAGE = \"Spanish\"` instead of `language = 'Spanish'` to match the correct column name and value format. The amended query now correctly retrieves the maximum Spanish language percentage for each country code from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'Spanish';",
            "SELECT CountryCode, MAX(Percentage) FROM countrylanguage WHERE Language = \"Spanish\" GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "822": {
        "db_id": "orchestra",
        "question": "How many conductors are there?",
        "ground_truth": "SELECT count(*) FROM conductor",
        "amends": [
            "Do query the `conductor` table instead of the `employees` table. Do use the table name `conductor` instead of filtering `employees` with `WHERE job_title = 'conductor'`. The amended query now correctly counts records from the conductor table directly rather than filtering employees by job title, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'conductor';",
            "SELECT COUNT(*) FROM conductor;"
        ],
        "rule_sql": []
    },
    "823": {
        "db_id": "orchestra",
        "question": "Count the number of conductors.",
        "ground_truth": "SELECT count(*) FROM conductor",
        "amends": [
            "Do query the `conductor` table instead of the `employees` table. Do use the table name `conductor` instead of filtering `employees` with `WHERE job_title = 'conductor'`. The amended query now correctly counts records from the conductor table directly instead of filtering employees by job title, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'conductor';",
            "SELECT COUNT(*) FROM conductor;"
        ],
        "rule_sql": []
    },
    "824": {
        "db_id": "orchestra",
        "question": "List the names of conductors in ascending order of age.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Age ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Age` in ascending order instead of descending order. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY age DESC;",
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ],
        "rule_sql": []
    },
    "825": {
        "db_id": "orchestra",
        "question": "What are the names of conductors, ordered by age?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Age ASC",
        "amends": [
            "Do select `Name` instead of `name` and order by `Age ASC` instead of `name`. Do use table `conductor` instead of `conductors`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY name;",
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ],
        "rule_sql": []
    },
    "826": {
        "db_id": "orchestra",
        "question": "What are the names of conductors whose nationalities are not \"USA\"?",
        "ground_truth": "SELECT Name FROM conductor WHERE Nationality != 'USA'",
        "amends": [
            "Do reference table `conductor` instead of `conductors`. Do use column `Name` instead of `name`. Do use column `Nationality` instead of `nationality`. Do use inequality filter `!= 'USA'` instead of equality filter `= 'USA'`. The amended query now correctly filters for non-USA conductors using the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors WHERE nationality = 'USA';",
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ],
        "rule_sql": []
    },
    "827": {
        "db_id": "orchestra",
        "question": "Return the names of conductors that do not have the nationality \"USA\".",
        "ground_truth": "SELECT Name FROM conductor WHERE Nationality != 'USA'",
        "amends": [
            "Do reference table `conductor` instead of `conductors` and use column `Name` instead of `name`. Do use filter condition `Nationality != 'USA'` instead of `nationality = 'USA'` to select non-US conductors instead of US conductors. The amended query now correctly references the proper table and column names while fixing the filter logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors WHERE nationality = 'USA';",
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ],
        "rule_sql": []
    },
    "828": {
        "db_id": "orchestra",
        "question": "What are the record companies of orchestras in descending order of years in which they were founded?",
        "ground_truth": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC",
        "amends": [
            "Do reference `Record_Company` instead of `o.record_company` and remove `o.founded_year` from the SELECT list instead of including it. Do reference table `orchestra` instead of `orchestras o` with alias. Do change ORDER BY to `Year_of_Founded DESC` instead of `o.founded_year ASC` by using a different column name and reversing the sort direction. The amended query now correctly selects only the record company column from the orchestra table and orders by year of founding in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.record_company, o.founded_year FROM orchestras o ORDER BY o.founded_year ASC;",
            "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC;"
        ],
        "rule_sql": []
    },
    "829": {
        "db_id": "orchestra",
        "question": "Return the record companies of orchestras, sorted descending by the years in which they were founded.",
        "ground_truth": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC",
        "amends": [
            "Do reference the `Record_Company` column instead of `record_company` and remove the `founded_year` column instead of including it. Do use the `orchestra` table instead of `orchestras` as the data source. Do order by `Year_of_Founded` instead of `founded_year` and use `DESC` ordering instead of `ASC`. The amended query now correctly selects only the record company column from the orchestra table ordered by year of founding in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT record_company, founded_year FROM orchestras ORDER BY founded_year ASC;",
            "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC;"
        ],
        "rule_sql": []
    },
    "830": {
        "db_id": "orchestra",
        "question": "What is the average attendance of shows?",
        "ground_truth": "SELECT avg(Attendance) FROM SHOW",
        "amends": [
            "Do use the correct column name `Attendance` instead of the incorrect `show_name` column. Do reference the correct table name `SHOW` instead of the incorrect `shows` table. Do use lowercase `avg` function instead of uppercase `AVG` for consistency with the target query format. The amended query now correctly calculates the average attendance from the SHOW table instead of attempting to average an incorrect column name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(show_name) FROM shows;",
            "SELECT avg(Attendance) FROM show;"
        ],
        "rule_sql": []
    },
    "831": {
        "db_id": "orchestra",
        "question": "Return the average attendance across all shows.",
        "ground_truth": "SELECT avg(Attendance) FROM SHOW",
        "amends": [
            "Do use the `avg` aggregate function instead of `SUM` to calculate the average attendance rather than the total sum. Do reference the column as `Attendance` with proper capitalization instead of lowercase `attendance`. Do query from the `SHOW` table instead of the plural `shows` table. The amended query now correctly calculates average attendance from the appropriate table with proper column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(attendance) FROM shows;",
            "SELECT AVG(Attendance) FROM show;"
        ],
        "rule_sql": []
    },
    "832": {
        "db_id": "orchestra",
        "question": "What are the maximum and minimum share of performances whose type is not \"Live final\".",
        "ground_truth": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"",
        "amends": [
            "Do filter with `TYPE != \"Live final\"` instead of `type = 'Live final'` to exclude rather than include live final performances. Do reference table `performance` instead of `performances` to use the correct table name. The amended query now correctly excludes live final performances and uses the proper table name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(share), MIN(share) FROM performances WHERE type = 'Live final';",
            "SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM performance WHERE Type != 'Live final'"
        ],
        "rule_sql": []
    },
    "833": {
        "db_id": "orchestra",
        "question": "Return the maximum and minimum shares for performances that do not have the type \"Live final\".",
        "ground_truth": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"",
        "amends": [
            "Do reference column `SHARE` instead of `shares` in both aggregate functions. Do use table `performance` instead of `performances` as the FROM source. Do change the WHERE filter to `TYPE != \"Live final\"` instead of `type = 'Live final'` to exclude rather than include those records. Do correct the column case to `SHARE` and table name to `performance` to match the actual schema. The amended query now correctly calculates maximum and minimum share values from the performance table excluding Live final entries, matching the RIGHT_SQL behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(shares), MIN(shares) FROM performances WHERE type = 'Live final';",
            "SELECT MAX(SHARE) AS max_share, MIN(SHARE) AS min_share FROM performance WHERE Type != 'Live final'"
        ],
        "rule_sql": []
    },
    "834": {
        "db_id": "orchestra",
        "question": "How many different nationalities do conductors have?",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM conductor",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do reference table `conductor` instead of `conductors` with the correct table name. Do add the `DISTINCT` modifier to count unique values instead of including duplicates. The amended query now correctly counts distinct nationalities from the conductor table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM conductors;",
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ],
        "rule_sql": []
    },
    "835": {
        "db_id": "orchestra",
        "question": "Count the number of different nationalities of conductors.",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM conductor",
        "amends": [
            "Do `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do reference table `conductor` instead of `conductors` to use the correct table name. Do add the `DISTINCT` modifier instead of omitting it to ensure unique nationality counting. Do remove the asterisk wildcard instead of keeping it to specify the exact column for aggregation. The amended query now correctly counts distinct nationalities from the conductor table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM conductors;",
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ],
        "rule_sql": []
    },
    "836": {
        "db_id": "orchestra",
        "question": "List names of conductors in descending order of years of work.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Year_of_Work DESC` instead of `years_of_work ASC`, changing both the column reference and sort direction. The amended query now correctly references the proper table and column names with the intended descending sort order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_of_work ASC;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ],
        "rule_sql": []
    },
    "837": {
        "db_id": "orchestra",
        "question": "What are the names of conductors, sorted descending by the number of years they have worked?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC",
        "amends": [
            "Do select `Name` instead of `name, years_worked` and remove the `years_worked` column from the output. Do reference table `conductor` instead of `conductors` as the data source. Do order by `Year_of_Work DESC` instead of `years_worked ASC` to sort in descending order by the correct column name. The amended query now correctly selects only the name column from the conductor table ordered by years of work in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, years_worked FROM conductors ORDER BY years_worked ASC;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ],
        "rule_sql": []
    },
    "838": {
        "db_id": "orchestra",
        "question": "List the name of the conductor with the most years of work.",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
        "amends": [
            "Do reference table `conductor` instead of `conductors` and use column `Name` instead of `name` in the SELECT list. Do use column `Year_of_Work` for ordering instead of `years_worked` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_worked DESC LIMIT 1;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "839": {
        "db_id": "orchestra",
        "question": "What is the name of the conductor who has worked the greatest number of years?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Year_of_Work` instead of `years_worked` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_worked DESC LIMIT 1;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "840": {
        "db_id": "orchestra",
        "question": "Show the names of conductors and the orchestras they have conducted.",
        "ground_truth": "SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `Name` from table `T1` instead of `conductor_name`. Do reference column `Orchestra` from table `T2` instead of `orchestra_name`. Do use table name `conductor` instead of `conductors`. Do use table name `orchestra` instead of `orchestras`. Do use column name `Conductor_ID` instead of `conductor_id` in both join conditions. The amended query now correctly matches the intended behavior with proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT conductor_name, orchestra_name FROM conductors JOIN orchestras ON conductors.conductor_id = orchestras.conductor_id;",
            "SELECT T1.Name, T2.Orchestra FROM conductor T1 JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID"
        ],
        "rule_sql": []
    },
    "841": {
        "db_id": "orchestra",
        "question": "What are the names of conductors as well as the corresonding orchestras that they have conducted?",
        "ground_truth": "SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `Name` from table `T1` instead of `conductor_name`. Do reference column `Orchestra` from table `T2` instead of `orchestra_name`. Do join table `conductor AS T1` instead of `conductors`. Do join table `orchestra AS T2` instead of `orchestras`. Do use join condition `T1.Conductor_ID = T2.Conductor_ID` instead of `conductors.conductor_id = orchestras.conductor_id`. The amended query now correctly matches the intended behavior with proper table aliases and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT conductor_name, orchestra_name FROM conductors JOIN orchestras ON conductors.conductor_id = orchestras.conductor_id;",
            "SELECT T1.Name, T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID;"
        ],
        "rule_sql": []
    },
    "842": {
        "db_id": "orchestra",
        "question": "Show the names of conductors that have conducted more than one orchestras.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of unqualified `name`. Do use `JOIN` between `conductor AS T1` and `orchestra AS T2` with join condition `T1.Conductor_ID = T2.Conductor_ID` instead of querying only `conductors` table. Do add `GROUP BY T2.Conductor_ID` to group by the conductor identifier instead of no grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE orchestra_count > 1` with a direct column filter. The amended query now correctly identifies conductors who lead multiple orchestras by counting orchestra associations rather than relying on a pre-calculated count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_count > 1;",
            "SELECT T1.Name \nFROM conductor AS T1 \nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID \nGROUP BY T2.Conductor_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "843": {
        "db_id": "orchestra",
        "question": "What are the names of conductors who have conducted at more than one orchestra?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of just `name` without source specification. Do join `conductor AS T1` with `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table without any join. Do add `GROUP BY T2.Conductor_ID` to group by the conductor identifier instead of missing aggregation grouping. Do move the count filter to `HAVING COUNT(*) > 1` instead of using `WHERE orchestra_count > 1` which incorrectly references a non-existent column. The amended query now correctly counts orchestra associations per conductor and filters for those conducting multiple orchestras, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_count > 1;",
            "SELECT T1.Name\nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T1.Conductor_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "844": {
        "db_id": "orchestra",
        "question": "Show the name of the conductor that has conducted the most number of orchestras.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `conductor_name` and remove the `COUNT(*) as orchestra_count` column from the SELECT list. Do join `orchestra AS T2` instead of querying only the `conductors` table, using `JOIN` on `T1.Conductor_ID = T2.Conductor_ID` instead of no join condition. Do group by `T2.Conductor_ID` instead of `conductor_name` to properly aggregate by conductor identifier. Do order by `COUNT(*) DESC` instead of the alias `orchestra_count` since the alias is no longer selected. The amended query now correctly retrieves conductor names by joining the conductor and orchestra tables and counting orchestras per conductor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT conductor_name, COUNT(*) as orchestra_count \nFROM conductors \nGROUP BY conductor_name \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT T1.Name\nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "845": {
        "db_id": "orchestra",
        "question": "What is the name of the conductor who has conducted the most orchestras?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `conductor` and `orchestra` tables with `INNER JOIN` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only `conductors` table. Do add `GROUP BY T2.Conductor_ID` to aggregate by conductor instead of ordering without grouping. Do use `COUNT(*)` in the `ORDER BY` clause to sort by orchestra count instead of using `orchestra_count` column. Do select `T1.Name` from the joined conductor table instead of selecting `name` from a single table. The amended query now correctly identifies the conductor with the most orchestras by joining and counting related records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY orchestra_count DESC LIMIT 1;",
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "846": {
        "db_id": "orchestra",
        "question": "Please show the name of the conductor that has conducted orchestras founded after 2008.",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008",
        "amends": [
            "Do select `T1.Name` with table alias qualification instead of unqualified `name`. Do join `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table without any join. Do filter on `Year_of_Founded > 2008` instead of `orchestra_founded > 2008` since the founding year is in the orchestra table. The amended query now correctly retrieves conductor names by joining with the orchestra table and filtering on the orchestra's founding year, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_founded > 2008;",
            "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID WHERE T2.Year_of_Founded > 2008"
        ],
        "rule_sql": []
    },
    "847": {
        "db_id": "orchestra",
        "question": "What are the names of conductors who have conducted orchestras founded after the year 2008?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008",
        "amends": [
            "Do use `T1.Name` with table alias instead of `name` without qualification. Do join `conductor AS T1` to `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table. Do filter on `Year_of_Founded > 2008` instead of `orchestra_founded_year > 2008`. The amended query now correctly joins the conductor and orchestra tables to find conductors leading orchestras founded after 2008, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_founded_year > 2008;",
            "SELECT T1.Name \nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nWHERE T2.Year_of_Founded > 2008;"
        ],
        "rule_sql": []
    },
    "848": {
        "db_id": "orchestra",
        "question": "Please show the different record companies and the corresponding number of orchestras.",
        "ground_truth": "SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",
        "amends": [
            "Do reference the `Record_Company` column instead of `record_company` and use proper capitalization. Do group by `Record_Company` instead of `orchestra_name` to match the SELECT clause aggregation. Do reference the correct table name `orchestra` instead of `orchestras`. The amended query now correctly counts records grouped by record company rather than by orchestra name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT record_company, COUNT(*) FROM orchestras GROUP BY orchestra_name;",
            "SELECT Record_Company, COUNT(*) AS Number_of_Orchestras FROM orchestra GROUP BY Record_Company;"
        ],
        "rule_sql": []
    },
    "849": {
        "db_id": "orchestra",
        "question": "How many orchestras does each record company manage?",
        "ground_truth": "SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",
        "amends": [
            "Do reference the table as `orchestra` instead of `orchestras` and use the column name `Record_Company` with proper capitalization instead of `record_company` in both the SELECT clause and GROUP BY clause, while maintaining the same COUNT(*) aggregation logic. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT record_company, COUNT(*) FROM orchestras GROUP BY record_company;",
            "SELECT Record_Company, COUNT(*) FROM orchestra GROUP BY Record_Company"
        ],
        "rule_sql": []
    },
    "850": {
        "db_id": "orchestra",
        "question": "Please show the record formats of orchestras in ascending order of count.",
        "ground_truth": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
        "amends": [
            "Do select `Major_Record_Format` instead of `orchestra` and remove the alias `count`. Do group by `Major_Record_Format` instead of `orchestra`. Do order by `COUNT(*)` instead of the alias `count`. Do use table `orchestra` instead of `orchestras`. The amended query now correctly selects and groups by the Major_Record_Format column while ordering by the actual count aggregation rather than an alias reference.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do add `ASC` to the ORDER BY clause instead of omitting the sort direction specification. The amended query now correctly returns only the Major_Record_Format values grouped by that column while maintaining the count-based ordering with explicit ascending direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT orchestra, COUNT(*) as count FROM orchestras GROUP BY orchestra ORDER BY count ASC;",
            "SELECT Major_Record_Format, COUNT(*) FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*)",
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": []
    },
    "851": {
        "db_id": "orchestra",
        "question": "What are the major record formats of orchestras, sorted by their frequency?",
        "ground_truth": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
        "amends": [
            "Do use `Major_Record_Format` instead of `record_format` for the column name in the SELECT list and GROUP BY clause. Do use `orchestra` instead of `orchestras` for the table name. Do remove the explicit `COUNT(*) as frequency` column from the SELECT list instead of including it. Do change the ORDER BY direction to `ASC` instead of `DESC` for the count ordering. Do reference the count implicitly in ORDER BY instead of using an alias. The amended query now correctly selects and groups by the Major_Record_Format column from the orchestra table with ascending count ordering.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the explicit `COUNT(*)` reference from the ORDER BY clause instead of keeping it, allowing the implicit count-based ordering to function correctly while only returning the grouped Major_Record_Format values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT record_format, COUNT(*) as frequency FROM orchestras GROUP BY record_format ORDER BY frequency DESC;",
            "SELECT Major_Record_Format, COUNT(*) FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;",
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": []
    },
    "852": {
        "db_id": "orchestra",
        "question": "List the record company shared by the most number of orchestras.",
        "ground_truth": "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Record_Company` instead of selecting both `record_company` and `COUNT(*) as orchestra_count`. Do use the table name `orchestra` instead of `orchestras`. Do order by `COUNT(*) DESC` directly in the ORDER BY clause instead of ordering by the alias `orchestra_count DESC`. The amended query now correctly returns only the record company with the highest count of orchestras while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT record_company, COUNT(*) as orchestra_count \nFROM orchestras \nGROUP BY record_company \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "853": {
        "db_id": "orchestra",
        "question": "What is the record company used by the greatest number of orchestras?",
        "ground_truth": "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select only `Record_Company` instead of selecting both `record_company` and `COUNT(*) as orchestra_count`. Do use table name `orchestra` instead of `orchestras`. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. Do capitalize `Record_Company` consistently instead of using lowercase `record_company`. The amended query now correctly returns only the record company with the highest count of orchestras while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT record_company, COUNT(*) as orchestra_count \nFROM orchestras \nGROUP BY record_company \nORDER BY orchestra_count DESC \nLIMIT 1;",
            "SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "854": {
        "db_id": "orchestra",
        "question": "List the names of orchestras that have no performance.",
        "ground_truth": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "amends": [
            "Do select `Orchestra` instead of `name` and use `orchestra` table instead of `orchestras`. Do use a `NOT IN` subquery checking for `Orchestra_ID` values that exist in the `performance` table instead of checking `performance_id IS NULL`. Do reference the correct table name `orchestra` instead of `orchestras` and use the proper column name `Orchestra` instead of `name`. The amended query now correctly identifies orchestras without performances by checking for missing entries in the performance table rather than relying on null values in a potentially incorrect column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM orchestras WHERE performance_id IS NULL;",
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT DISTINCT Orchestra_ID FROM performance)"
        ],
        "rule_sql": []
    },
    "855": {
        "db_id": "orchestra",
        "question": "What are the orchestras that do not have any performances?",
        "ground_truth": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "amends": [
            "Do select `Orchestra` instead of `name` and use table `orchestra` instead of `orchestras`. Do use a `NOT IN` subquery checking for `Orchestra_ID` values that exist in the `performance` table instead of checking `performance_id IS NULL`. Do remove the direct NULL check condition and instead implement the exclusion logic through the correlated subquery approach. The amended query now correctly identifies orchestras that have no associated performances by checking for Orchestra_ID values not present in the performance table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM orchestras WHERE performance_id IS NULL;",
            "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)"
        ],
        "rule_sql": []
    },
    "856": {
        "db_id": "orchestra",
        "question": "Show the record companies shared by orchestras founded before 2003 and after 2003.",
        "ground_truth": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "amends": [
            "Do use `INTERSECT` to find common record companies instead of using contradictory `WHERE` conditions that would return no results. Do reference `Year_of_Founded` instead of `year_founded` for the column name. Do add a second `SELECT` clause with the opposite condition instead of having both conditions in a single `WHERE` clause. Do remove the contradictory `year_founded < 2003 AND year_founded > 2003` filter instead of keeping it, as it would always return an empty set. Do use proper column naming with `Record_Company` instead of `orchestra.record_company` for consistency. The amended query now correctly identifies record companies that have orchestras founded both before and after 2003, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT orchestra.record_company \nFROM orchestra \nWHERE orchestra.year_founded < 2003 \nAND orchestra.year_founded > 2003;",
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ],
        "rule_sql": []
    },
    "857": {
        "db_id": "orchestra",
        "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
        "ground_truth": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "amends": [
            "Do use `INTERSECT` to find common record companies instead of a self-join with distinct. Do reference `Year_of_Founded` instead of `founded_year` for the column name. Do filter with separate conditions in each branch instead of combining them in a single WHERE clause. Do use the table name `orchestra` instead of `orchestras`. Do remove the table aliases `o1` and `o2` instead of keeping them. Do select from the same table twice with different filters instead of joining on record_company. The amended query now correctly identifies record companies that have orchestras founded both before and after 2003 by finding the intersection between the two sets."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT r1.record_company\nFROM orchestras o1\nJOIN orchestras o2 ON o1.record_company = o2.record_company\nWHERE o1.founded_year < 2003 AND o2.founded_year > 2003;",
            "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003\nINTERSECT\nSELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
        ],
        "rule_sql": []
    },
    "858": {
        "db_id": "orchestra",
        "question": "Find the number of orchestras whose record format is \"CD\" or \"DVD\".",
        "ground_truth": "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  \"CD\" OR Major_Record_Format  =  \"DVD\"",
        "amends": [
            "Do reference table `orchestra` instead of `orchestras`. Do use column `Major_Record_Format` instead of `record_format`. Do apply OR condition between `Major_Record_Format = \"CD\"` and `Major_Record_Format = \"DVD\"` instead of AND condition between `record_format = 'CD'` and `record_format = 'DVD'`. Do use double quotes around string literals \"CD\" and \"DVD\" instead of single quotes. The amended query now correctly counts records where the major record format is either CD or DVD, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orchestras WHERE record_format = 'CD' AND record_format = 'DVD';",
            "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format = \"CD\" OR Major_Record_Format = \"DVD\""
        ],
        "rule_sql": []
    },
    "859": {
        "db_id": "orchestra",
        "question": "Count the number of orchestras that have CD or DVD as their record format.",
        "ground_truth": "SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  \"CD\" OR Major_Record_Format  =  \"DVD\"",
        "amends": [
            "Do reference table `orchestra` instead of `orchestras` and use column `Major_Record_Format` instead of `record_format`. Do use double quotes `\"CD\"` and `\"DVD\"` instead of single quotes for string literals while maintaining the same OR logic for counting records in either format. The amended query now correctly counts records from the orchestra table where Major_Record_Format equals CD or DVD, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orchestras WHERE record_format = 'CD' OR record_format = 'DVD';",
            "SELECT COUNT(*) FROM orchestra WHERE \"Major_Record_Format\" = \"CD\" OR \"Major_Record_Format\" = \"DVD\""
        ],
        "rule_sql": []
    },
    "860": {
        "db_id": "orchestra",
        "question": "Show the years in which orchestras that have given more than one performance are founded.",
        "ground_truth": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Year_of_Founded` instead of `year_founded`. Do join table `orchestra AS T1` with `performance AS T2` instead of querying only `orchestras`. Do use join condition `T1.Orchestra_ID = T2.Orchestra_ID` instead of missing the join entirely. Do group by `T2.Orchestra_ID` instead of `orchestra_id`. Do use `HAVING COUNT(*) > 1` instead of `WHERE COUNT(performance_id) > 1` to properly filter aggregated results. The amended query now correctly retrieves founding years for orchestras with multiple performances by joining the necessary tables and applying the count filter at the appropriate aggregation level."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year_founded FROM orchestras WHERE COUNT(performance_id) > 1 GROUP BY orchestra_id",
            "SELECT T1.Year_of_Founded \nFROM orchestra AS T1\nJOIN performance AS T2 ON T1.Orchestra_ID = T2.Orchestra_ID\nGROUP BY T2.Orchestra_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "861": {
        "db_id": "orchestra",
        "question": "What are years of founding for orchestras that have had more than a single performance?",
        "ground_truth": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Year_of_Founded` instead of `year_of_founding` and do add table alias `T1` instead of omitting it. Do change FROM clause to join `orchestra AS T1` with `performance AS T2` instead of single table `orchestras` and do add `ON T1.Orchestra_ID = T2.Orchestra_ID` join condition instead of no join. Do add `GROUP BY T2.Orchestra_ID` instead of omitting grouping and do move filter to `HAVING COUNT(*) > 1` instead of `WHERE performance_count > 1`. The amended query now correctly identifies orchestras with multiple performances by joining the performance table and counting records per orchestra."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year_of_founding FROM orchestras WHERE performance_count > 1",
            "SELECT T1.Year_of_Founded \nFROM orchestra AS T1 \nJOIN performance AS T2 ON T1.Orchestra_ID = T2.Orchestra_ID \nGROUP BY T2.Orchestra_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "862": {
        "db_id": "network_1",
        "question": "How many high schoolers are there?",
        "ground_truth": "SELECT count(*) FROM Highschooler",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table, and do use the correct table name `Highschooler` instead of filtering by `grade_level = 'high school'` which suggests the wrong table structure. The amended query now correctly counts all records from the Highschooler table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade_level = 'high school';",
            "SELECT COUNT(*) FROM Highschooler;"
        ],
        "rule_sql": []
    },
    "863": {
        "db_id": "network_1",
        "question": "Count the number of high schoolers.",
        "ground_truth": "SELECT count(*) FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `students` and use the correct table name `count(*)` instead of `COUNT(*)` while maintaining the same aggregation logic. The amended query now correctly references the Highschooler table and uses consistent function casing to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade_level = 'high school';",
            "SELECT count(*) FROM Highschooler"
        ],
        "rule_sql": []
    },
    "864": {
        "db_id": "network_1",
        "question": "Show the names and grades of each high schooler.",
        "ground_truth": "SELECT name ,  grade FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12",
            "SELECT name, grade FROM Highschooler;"
        ],
        "rule_sql": []
    },
    "865": {
        "db_id": "network_1",
        "question": "What are the names and grades for each high schooler?",
        "ground_truth": "SELECT name ,  grade FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now correctly selects from the Highschooler table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12;",
            "SELECT name, grade FROM Highschooler;"
        ],
        "rule_sql": []
    },
    "866": {
        "db_id": "network_1",
        "question": "Show all the grades of the high schoolers.",
        "ground_truth": "SELECT grade FROM Highschooler",
        "amends": [
            "Do specify `grade` in the SELECT list instead of using `*` to select all columns. Do use the correct table name `Highschooler` instead of `high_schoolers`. The amended query now correctly returns only the grade column from the Highschooler table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM high_schoolers;",
            "SELECT grade FROM Highschooler;"
        ],
        "rule_sql": []
    },
    "867": {
        "db_id": "network_1",
        "question": "What is the grade of each high schooler?",
        "ground_truth": "SELECT grade FROM Highschooler",
        "amends": [
            "Do select only `grade` instead of both `name` and `grade`. Do reference the table as `Highschooler` instead of `high_schoolers`. Do remove the `WHERE grade > 12` filter instead of keeping it. The amended query now correctly selects only the grade column from the Highschooler table without any filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12;",
            "SELECT grade FROM Highschooler;"
        ],
        "rule_sql": []
    },
    "868": {
        "db_id": "network_1",
        "question": "What grade is Kyle in?",
        "ground_truth": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table in the FROM clause. Do use double quotes `\"Kyle\"` instead of single quotes `'Kyle'` for the string literal in the WHERE filter. The amended query now correctly retrieves grades from the Highschooler table for students named Kyle."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade FROM students WHERE name = 'Kyle';",
            "SELECT grade FROM Highschooler WHERE name = \"Kyle\";"
        ],
        "rule_sql": []
    },
    "869": {
        "db_id": "network_1",
        "question": "Return the grade for the high schooler named Kyle.",
        "ground_truth": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade FROM Highschooler WHERE name = 'Kyle';"
        ],
        "rule_sql": []
    },
    "870": {
        "db_id": "network_1",
        "question": "Show the names of all high schoolers in grade 10.",
        "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
        "amends": [
            "Do reference table `Highschooler` instead of `high_schoolers` and filter on `grade = 10` instead of `grade = 9`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE grade = 9;",
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ],
        "rule_sql": []
    },
    "871": {
        "db_id": "network_1",
        "question": "What are the names of all high schoolers in grade 10?",
        "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table. Do remove the `school_type = 'college'` filter instead of keeping it, as high school students should not be filtered by college type. The amended query now correctly selects names from the Highschooler table for 10th grade students without the inappropriate college filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE grade = 10 AND school_type = 'college';",
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ],
        "rule_sql": []
    },
    "872": {
        "db_id": "network_1",
        "question": "Show the ID of the high schooler named Kyle.",
        "ground_truth": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM Highschooler WHERE name = 'Kyle';"
        ],
        "rule_sql": []
    },
    "873": {
        "db_id": "network_1",
        "question": "What is Kyle's id?",
        "ground_truth": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [
            "Do reference table `Highschooler` instead of `users` in the FROM clause. Do use column `ID` instead of `id` in the SELECT list. Do use double quotes `\"Kyle\"` instead of single quotes `'Kyle'` for the string literal in the WHERE filter. The amended query now correctly retrieves the ID from the Highschooler table where the name matches Kyle."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM users WHERE name = 'Kyle';",
            "SELECT ID FROM Highschooler WHERE name = \"Kyle\""
        ],
        "rule_sql": []
    },
    "874": {
        "db_id": "network_1",
        "question": "How many high schoolers are there in grade 9 or 10?",
        "ground_truth": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM high_schoolers WHERE grade = 9 OR grade = 10;",
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ],
        "rule_sql": []
    },
    "875": {
        "db_id": "network_1",
        "question": "Count the number of high schoolers in grades 9 or 10.",
        "ground_truth": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10",
        "amends": [
            "Do use the correct table name `Highschooler` instead of the incorrect `high_schoolers`. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM high_schoolers WHERE grade = 9 OR grade = 10;",
            "SELECT COUNT(*) FROM Highschooler WHERE grade IN (9, 10);"
        ],
        "rule_sql": []
    },
    "876": {
        "db_id": "network_1",
        "question": "Show the number of high schoolers for each grade.",
        "ground_truth": "SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. Do add a space after `grade` in the SELECT clause instead of omitting it for proper formatting. Do remove the `ORDER BY grade` clause instead of keeping it since the grouping already provides the desired ordering. The amended query now correctly counts students by grade from the Highschooler table without unnecessary ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade, COUNT(*) FROM high_schoolers GROUP BY grade ORDER BY grade;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade;"
        ],
        "rule_sql": []
    },
    "877": {
        "db_id": "network_1",
        "question": "How many high schoolers are in each grade?",
        "ground_truth": "SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table. Do remove the `WHERE school_level = 'high school'` filter instead of keeping it, as the table name already implies the context. Do remove the `ORDER BY grade` clause instead of including it, as the grouping inherently organizes results. Do maintain the same `SELECT grade, COUNT(*)` and `GROUP BY grade` structure. The amended query now correctly focuses on the Highschooler table without redundant filtering and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade, COUNT(*) FROM students WHERE school_level = 'high school' GROUP BY grade ORDER BY grade;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade"
        ],
        "rule_sql": []
    },
    "878": {
        "db_id": "network_1",
        "question": "Which grade has the most high schoolers?",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Highschooler` instead of `students` and remove the explicit column alias `student_count` instead of keeping it. Do remove the `WHERE` filter `school_level = 'high school'` instead of including it since the table name already implies the context. Do use the aggregate function `count(*)` directly in the `ORDER BY` clause instead of referencing the alias `student_count`. The amended query now correctly identifies the most common grade among high school students by counting records per grade and ordering by the count in descending order.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the grade with the highest count rather than both the grade and its count. Do keep the `GROUP BY grade` and `ORDER BY count(*) DESC LIMIT 1` unchanged since they correctly identify the grade with the maximum frequency. The amended query now matches RIGHT_SQL's behavior by returning only the grade value with the highest occurrence count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count FROM students WHERE school_level = 'high school' GROUP BY grade ORDER BY student_count DESC LIMIT 1;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1",
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "879": {
        "db_id": "network_1",
        "question": "Return the grade that has the greatest number of high schoolers.",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `GROUP BY grade` instead of omitting it, as aggregation requires grouping by non-aggregated columns. Do move the `COUNT(*)` aggregate to the `ORDER BY` clause instead of placing it in the `SELECT` list without grouping. Do maintain the `DESC` ordering and `LIMIT 1` to find the grade with the highest count of students. The amended query now correctly groups by grade before counting and ordering, matching the intended behavior of finding the most common grade level."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade FROM high_schoolers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT grade FROM Highschooler GROUP BY grade ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "880": {
        "db_id": "network_1",
        "question": "Show me all grades that have at least 4 students.",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
        "amends": [
            "Do reference the `Highschooler` table instead of `students` in the FROM clause. Do use `HAVING count(*) >= 4` instead of `WHERE student_count >= 4` to filter aggregated results. Do remove the `COUNT(*) as student_count` column from the SELECT list instead of including it, since only the `grade` grouping column is needed. Do remove the alias `student_count` instead of keeping it as the filter condition now directly uses the aggregate function. The amended query now correctly filters groups based on aggregate conditions using HAVING instead of WHERE and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count FROM students GROUP BY grade WHERE student_count >= 4;",
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"
        ],
        "rule_sql": []
    },
    "881": {
        "db_id": "network_1",
        "question": "Which grades have 4 or more high schoolers?",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
        "amends": [
            "Do select only `grade` instead of selecting both `grade` and `COUNT(*) as student_count`. Do use `FROM Highschooler` instead of `FROM students` as the table source. Do remove the `WHERE grade >= 9` filter instead of keeping it. Do keep the `GROUP BY grade` clause. Do keep the `HAVING count(*) >= 4` condition but use the exact syntax `count(*)  >=  4` instead of `COUNT(*) >= 4`. The amended query now correctly identifies grades with at least 4 students in the Highschooler table without unnecessary columns or filters."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count \nFROM students \nWHERE grade >= 9 \nGROUP BY grade \nHAVING COUNT(*) >= 4;",
            "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*) >= 4"
        ],
        "rule_sql": []
    },
    "882": {
        "db_id": "network_1",
        "question": "Show the student IDs and numbers of friends corresponding to each.",
        "ground_truth": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",
        "amends": [
            "Do use table name `Friend` instead of `friends` to reference the correct table. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM friends GROUP BY student_id;",
            "SELECT student_id, COUNT(friend_id) AS number_of_friends FROM Friend GROUP BY student_id;"
        ],
        "rule_sql": []
    },
    "883": {
        "db_id": "network_1",
        "question": "How many friends does each student have?",
        "ground_truth": "SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",
        "amends": [
            "Do use table name `Friend` instead of `friends` to reference the correct table. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM friends GROUP BY student_id;",
            "SELECT student_id, COUNT(friend_id) AS friend_count FROM Friend GROUP BY student_id"
        ],
        "rule_sql": []
    },
    "884": {
        "db_id": "network_1",
        "question": "Show the names of high school students and their corresponding number of friends.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do select `T2.name` instead of `name` and maintain `count(*)` without change. Do use `FROM Friend AS T1 JOIN Highschooler AS T2` instead of `FROM students` with a single table. Do apply join condition `ON T1.student_id = T2.id` instead of a simple `WHERE grade = 'High School'` filter. Do group by `T1.student_id` instead of `name` to ensure proper aggregation. The amended query now correctly joins the Friend and Highschooler tables to count friends per student while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM students WHERE grade = 'High School' GROUP BY name;",
            "SELECT T2.name, COUNT(*) \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id"
        ],
        "rule_sql": []
    },
    "885": {
        "db_id": "network_1",
        "question": "What are the names of the high schoolers and how many friends does each have?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do specify `T2.name` from the `Highschooler` table instead of just `name` without table qualification. Do join `Friend AS T1` and `Highschooler AS T2` with an `INNER JOIN` on `T1.student_id = T2.id` instead of querying only the `high_schoolers` table. Do group by `T1.student_id` instead of grouping by `name` to ensure proper count aggregation per student. The amended query now correctly counts friends for each student by joining the Friend and Highschooler tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM high_schoolers GROUP BY name;",
            "SELECT T2.name, COUNT(T1.friend_id) AS friend_count\nFROM Friend AS T1\nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": []
    },
    "886": {
        "db_id": "network_1",
        "question": "What is the name of the high schooler who has the greatest number of friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do join `Friend AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying only the `highschooler` table. Do add `GROUP BY T1.student_id` to aggregate friend counts per student instead of attempting to aggregate without grouping. Do use `count(*)` to count friends instead of `COUNT(friend_id)` which would not work without proper grouping. The amended query now correctly identifies the student with the most friends by joining the Friend table with Highschooler, grouping by student, and counting friendships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM highschooler ORDER BY COUNT(friend_id) DESC LIMIT 1;",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "887": {
        "db_id": "network_1",
        "question": "Return the name of the high school student with the most friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do add `FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of omitting join relationships. Do add `GROUP BY T1.student_id` to aggregate by student instead of omitting grouping. Do change ordering to `ORDER BY count(*) DESC` based on friend count instead of `ORDER BY RANDOM()`. Do keep `LIMIT 1` to return one row but now based on highest friend count instead of random selection. The amended query now correctly identifies the student with the most friends by joining Friend and Highschooler tables, grouping by student, and ordering by friendship count descending."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students ORDER BY RANDOM() LIMIT 1;",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "888": {
        "db_id": "network_1",
        "question": "Show the names of high schoolers who have at least 3 friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
        "amends": [
            "Do use `T1.student_id = T2.id` as the join condition instead of the incorrect `id IN (SELECT id1 FROM Friend)` subquery approach. Do reference the table as `Friend AS T1` and `Highschooler AS T2` instead of only using Highschooler in the main query. Do select `T2.name` from the joined Highschooler table instead of selecting `name` directly from Highschooler without proper joining. Do group by `T1.student_id` instead of grouping by `id1` in the subquery. The amended query now correctly joins the tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM Highschooler WHERE id IN (SELECT id1 FROM Friend GROUP BY id1 HAVING COUNT(*) >= 3);",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nHAVING COUNT(T1.friend_id) >= 3;"
        ],
        "rule_sql": []
    },
    "889": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have 3 or more friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
        "amends": [
            "Do use `JOIN` between `Friend` and `Highschooler` tables on `T1.student_id = T2.id` instead of querying only the `high_schoolers` table. Do add `GROUP BY T1.student_id` to aggregate friend counts per student instead of assuming a direct `friend_count` column exists. Do move the count filter to `HAVING count(*) >= 3` instead of using `WHERE friend_count >= 3` since the count is derived from aggregation. Do select `T2.name` from the joined Highschooler table instead of selecting `name` directly from the original table. The amended query now correctly identifies students with at least three friends by counting actual friendship records rather than relying on a potentially non-existent column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE friend_count >= 3;",
            "SELECT T2.name \nFROM Friend T1 \nJOIN Highschooler T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": []
    },
    "890": {
        "db_id": "network_1",
        "question": "Show the names of all of the high schooler Kyle's friends.",
        "ground_truth": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM Highschooler WHERE ID IN (SELECT friend_id FROM Friend WHERE student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle'))"
        ],
        "rule_sql": []
    },
    "891": {
        "db_id": "network_1",
        "question": "Return the names of friends of the high school student Kyle.",
        "ground_truth": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do use explicit table aliases `T3.name` instead of ambiguous `name`. Do add `FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id JOIN Highschooler AS T3 ON T1.friend_id = T3.id` instead of simple `FROM friends`. Do filter on `T2.name = 'Kyle'` instead of `student_name = 'Kyle'` to properly reference the student's name from the Highschooler table. The amended query now correctly joins through the relationship tables to find friends of the specified student."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM friends WHERE student_name = 'Kyle';",
            "SELECT T3.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nJOIN Highschooler AS T3 ON T1.friend_id = T3.ID \nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": []
    },
    "892": {
        "db_id": "network_1",
        "question": "How many friends does the high school student Kyle have?",
        "ground_truth": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do join `Highschooler` table instead of omitting it, and do use `JOIN` with `T1.student_id = T2.id` instead of querying `friends` table directly. Do filter on `T2.name = 'Kyle'` instead of filtering on `student_name = 'Kyle'` and do remove the `school_level = 'high school'` filter instead of keeping it, since the join to `Highschooler` table inherently provides the correct high school context. The amended query now correctly counts friends by joining through proper table relationships rather than relying on potentially incorrect direct column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE student_name = 'Kyle' AND school_level = 'high school';",
            "SELECT COUNT(*) \nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": []
    },
    "893": {
        "db_id": "network_1",
        "question": "Count the number of friends Kyle has.",
        "ground_truth": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do add `JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of querying only the `friends` table. Do change the filter to `T2.name = \"Kyle\"` instead of `name = 'Kyle'` since the name column exists in the Highschooler table rather than the friends table. Do use proper table aliasing with `Friend AS T1` instead of the bare table name. The amended query now correctly joins the necessary tables to access the name information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE name = 'Kyle';",
            "SELECT COUNT(*) \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": []
    },
    "894": {
        "db_id": "network_1",
        "question": "Show ids of all students who do not have any friends.",
        "ground_truth": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `Highschooler` instead of `students` and table `Friend` instead of `friends`. Do remove the `WHERE` clause entirely instead of keeping the `NOT IN` predicate. The amended query now correctly uses set-based exclusion to find IDs in Highschooler that are not present in Friend, matching the RIGHT_SQL's behavior.",
            "Do select `id` instead of `ID` to match the correct column name. Do remove the second `UNION` clause with `SELECT friend_id FROM Friend` instead of including it, as the right query only needs to find students who are not in the Friend table at all rather than those who might appear as either student_id or friend_id. Do use proper case sensitivity for column names to ensure accurate data retrieval. The amended query now correctly identifies students who have no friends by excluding only those who appear as student_id in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM students WHERE id NOT IN (SELECT student_id FROM friends)",
            "SELECT ID FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend\nUNION\nSELECT friend_id FROM Friend",
            "SELECT id FROM Highschooler\nEXCEPT\nSELECT student_id FROM Friend"
        ],
        "rule_sql": []
    },
    "895": {
        "db_id": "network_1",
        "question": "What are the ids of high school students who do not have friends?",
        "ground_truth": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "amends": [
            "Do use a set operation with `EXCEPT` instead of a simple `WHERE` filter on `friend_count = 0`. Do query from the `Highschooler` table instead of `high_school_students`. Do exclude `student_id` values from the `Friend` table instead of checking for zero friend counts. Do remove the `WHERE` clause entirely instead of using it to filter for zero friendships. The amended query now correctly identifies students with no friends by excluding those who appear in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM high_school_students WHERE friend_count = 0;",
            "SELECT ID FROM Highschooler EXCEPT SELECT student_id FROM Friend"
        ],
        "rule_sql": []
    },
    "896": {
        "db_id": "network_1",
        "question": "Show names of all high school students who do not have any friends.",
        "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "amends": [
            "Do use `EXCEPT` set operation instead of filtering with `WHERE` conditions. Do change the data source to `Highschooler` instead of `students`. Do remove the `grade` filter condition instead of keeping it. Do remove the `friend_count` filter condition instead of keeping it. Do add a subquery with `JOIN` between `Friend` and `Highschooler` tables instead of omitting the friend relationship check. Do use `ON T1.student_id = T2.id` for the join condition instead of the previous filtering approach. The amended query now correctly identifies high school students without friends by using set operations rather than direct filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE grade = 'High School' AND friend_count = 0;",
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT H.name \nFROM Highschooler H\nJOIN Friend F ON H.ID = F.student_id"
        ],
        "rule_sql": []
    },
    "897": {
        "db_id": "network_1",
        "question": "What are the names of students who have no friends?",
        "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "amends": [
            "Do use `EXCEPT` to find students without friends instead of filtering for `friend_count = 0`. Do add a subquery with `JOIN` between `Friend` and `Highschooler` tables on `T1.student_id = T2.id` instead of omitting this relationship entirely. Do reference the correct table `Highschooler` instead of the non-existent `students` table. Do remove the incorrect `WHERE friend_count = 0` filter instead of keeping it, as the right approach identifies students without entries in the Friend table rather than relying on a potentially missing or incorrect friend_count column. The amended query now correctly identifies students with no friends by excluding those who appear in the Friend relationship table.",
            "Do use `EXCEPT` with a join-based subquery instead of `NOT IN` with a union of two columns. Do reference `T2.name` from the joined `Highschooler` table instead of directly selecting from the main table. Do join `Friend AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of using a union subquery that combines both sides of the friendship relationship. Do remove the union operation that was incorrectly treating both sides of the friendship symmetrically. The amended query now correctly identifies students who have no friends by excluding those who appear as either side in the Friend table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE friend_count = 0;",
            "SELECT name FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend UNION SELECT friend_id FROM Friend)",
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID"
        ],
        "rule_sql": []
    },
    "898": {
        "db_id": "network_1",
        "question": "Show the ids of high schoolers who have friends and are also liked by someone else.",
        "ground_truth": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "amends": [
            "Do use `INTERSECT` to find common IDs instead of complex joins and subqueries. Do select `student_id` from `Friend` instead of `h1.id` from multiple joined tables. Do select `liked_id` from `Likes` instead of filtering with `WHERE h1.id IN` subqueries. Do remove the `DISTINCT` keyword instead of keeping it since `INTERSECT` inherently returns unique values. Do eliminate the `Highschooler` table join instead of including unnecessary table relationships. Do remove the join conditions `h1.id = f.id1` and `h1.id = l.id2` instead of maintaining incorrect join logic. The amended query now correctly identifies students who are both friends and liked by someone, matching the RIGHT_SQL's behavior through set intersection rather than complex filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT h1.id\nFROM Highschooler h1\nJOIN Friend f ON h1.id = f.id1\nJOIN Likes l ON h1.id = l.id2\nWHERE h1.id IN (SELECT id2 FROM Likes)\nAND h1.id IN (SELECT id1 FROM Friend);",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ],
        "rule_sql": []
    },
    "899": {
        "db_id": "network_1",
        "question": "What are the ids of students who both have friends and are liked?",
        "ground_truth": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "amends": [
            "Do select `student_id` instead of `id` to match the column names in the source tables. Do use `INTERSECT` instead of multiple `IN` subqueries to find the intersection between friends and liked IDs more efficiently. Do reference tables `Friend` and `Likes` instead of `friends` and `likes` to use the correct table names. Do remove the redundant `WHERE` clause and subqueries instead of keeping the complex nested structure. The amended query now correctly identifies students who are both friends and liked by using set intersection semantics.",
            "Do reference `liked_id` from the Likes table instead of `student_id` in the second SELECT clause of the INTERSECT operation. This change correctly identifies the column containing the IDs of students who are liked rather than those who do the liking, ensuring the query properly intersects students who have friends with those who are liked by others. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM students WHERE id IN (SELECT student_id FROM friends) AND id IN (SELECT liked_id FROM likes);",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT student_id FROM Likes",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ],
        "rule_sql": []
    },
    "900": {
        "db_id": "network_1",
        "question": "Show name of all students who have some friends and also are liked by someone else.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "amends": [
            "Do use `INTERSECT` to find common names instead of `IN` and `NOT IN` subqueries. Do join `Friend` table with `Highschooler` on `student_id = id` instead of querying `students` table directly. Do join `Likes` table with `Highschooler` on `liked_id = id` instead of using a negative subquery condition. Do select from explicit table aliases `T1` and `T2` instead of assuming a single `students` table. Do use proper table names `Friend` and `Likes` instead of generic `friends` and `likes`. The amended query now correctly finds students who are both in the Friend table and liked in the Likes table using set intersection instead of incorrect exclusion logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE id IN (SELECT student_id FROM friends) AND id NOT IN (SELECT liked_id FROM likes);",
            "SELECT T1.name\nFROM Highschooler T1\nJOIN Friend ON T1.ID = Friend.student_id\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nJOIN Likes ON T2.ID = Likes.liked_id"
        ],
        "rule_sql": []
    },
    "901": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who both have friends and are liked?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "amends": [
            "Do use explicit `JOIN` syntax with table aliases instead of subqueries with `IN` clauses. Do reference `Friend.student_id` and `Likes.liked_id` instead of generic `id1` and `id2` columns. Do use `INTERSECT` to find the intersection of friends and liked students instead of multiple `IN` conditions. Do specify table aliases `T1` and `T2` for clarity instead of direct table references. Do join `Highschooler` on the appropriate foreign key columns (`student_id` and `liked_id`) instead of assuming generic `id` matches. The amended query now correctly identifies high schoolers who are both friends with someone and liked by someone using proper join semantics and set intersection."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM highschooler WHERE id IN (SELECT id1 FROM friend) AND id IN (SELECT id2 FROM likes)",
            "SELECT T1.name\nFROM Highschooler T1\nJOIN Friend F ON T1.ID = F.student_id\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nJOIN Likes L ON T2.ID = L.liked_id"
        ],
        "rule_sql": []
    },
    "902": {
        "db_id": "network_1",
        "question": "Count the number of likes for each student id.",
        "ground_truth": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM likes GROUP BY student_id;"
        ],
        "rule_sql": []
    },
    "903": {
        "db_id": "network_1",
        "question": "How many likes correspond to each student id?",
        "ground_truth": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM likes GROUP BY student_id;"
        ],
        "rule_sql": []
    },
    "904": {
        "db_id": "network_1",
        "question": "Show the names of high schoolers who have likes, and numbers of likes for each.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do use `T2.name` instead of `name` to explicitly reference the joined table's column. Do join `Likes AS T1` to `Highschooler AS T2` instead of joining `Highschooler` to `Likes` to establish the correct table relationship direction. Do use the join condition `T1.student_id = T2.id` instead of `Highschooler.id = Likes.student_id` to properly match the student ID from Likes to the ID in Highschooler. Do group by `T1.student_id` instead of `name` to ensure accurate count aggregation per student rather than potentially grouping by duplicate names. The amended query now correctly counts likes per student while properly handling the table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM Highschooler JOIN Likes ON Highschooler.id = Likes.student_id GROUP BY name",
            "SELECT T2.name, COUNT(*) AS number_of_likes\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": []
    },
    "905": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have likes, and how many likes does each have?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do select `T2.name` and `count(*)` without an alias instead of selecting `name` and `COUNT(*) as like_count`. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying only `high_schoolers` table. Do group by `T1.student_id` instead of grouping by `name`. Do remove the `HAVING like_count > 0` condition instead of keeping it since all groups will have at least one count. Do remove the `ORDER BY like_count DESC` clause instead of including it. The amended query now correctly counts likes per student by joining the Likes table with Highschooler table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) as like_count FROM high_schoolers GROUP BY name HAVING like_count > 0 ORDER BY like_count DESC;",
            "SELECT T2.name, COUNT(*)\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": []
    },
    "906": {
        "db_id": "network_1",
        "question": "What is the name of the high schooler who has the greatest number of likes?",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T2.name` from the `Highschooler` table instead of selecting just `name` without a table reference. Do change the FROM clause to use `Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of querying only the `highschooler` table. Do add `GROUP BY T1.student_id` to aggregate by student instead of omitting grouping. Do change the ORDER BY to use `count(*) DESC` instead of `likes DESC` to order by the count of likes rather than a direct column value. Do remove the direct reference to `likes` column since the count is now derived from the join and aggregation. The amended query now correctly identifies the student with the most likes by counting relationships in the Likes table rather than relying on a potentially non-existent likes column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM highschooler ORDER BY likes DESC LIMIT 1;",
            "SELECT T2.name\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "907": {
        "db_id": "network_1",
        "question": "Give the name of the student with the most likes.",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying a single table. Do add `GROUP BY T1.student_id` to aggregate likes per student instead of ordering individual records. Do order by `count(*) DESC` to rank by total like count instead of `likes DESC` which would sort by a single like value. Do remove the direct `ORDER BY likes` clause and instead use aggregate counting through grouping. The amended query now correctly identifies the student with the most likes by joining the Likes table with student information and counting occurrences per student."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students ORDER BY likes DESC LIMIT 1;",
            "SELECT T2.name\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "908": {
        "db_id": "network_1",
        "question": "Show the names of students who have at least 2 likes.",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do use `FROM Likes AS T1 JOIN Highschooler AS T2` with an explicit join instead of querying only `FROM students`. Do add the join condition `ON T1.student_id = T2.id` instead of missing the table relationship. Do add `GROUP BY T1.student_id` to aggregate by student instead of no grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE likes >= 2` on a non-aggregated column. The amended query now correctly counts likes per student and filters those with at least two likes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE likes >= 2;",
            "SELECT T2.name \nFROM Likes AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "909": {
        "db_id": "network_1",
        "question": "What are the names of students who have 2 or more likes?",
        "ground_truth": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying a single `students` table. Do use `GROUP BY T1.student_id` with `HAVING count(*) >= 2` instead of a simple `WHERE likes >= 2` filter. Do completely restructure the query to properly count relationships through the Likes table instead of assuming a direct likes column. The amended query now correctly identifies students who have at least two likes by joining the appropriate tables and using aggregate counting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE likes >= 2",
            "SELECT T2.name \nFROM Likes AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "910": {
        "db_id": "network_1",
        "question": "Show the names of students who have a grade higher than 5 and have at least 2 friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do use a `JOIN` between `Friend` as `T1` and `Highschooler` as `T2` on `T1.student_id = T2.id` instead of querying a single table. Do move the friends count filter to `HAVING count(*) >= 2` instead of using `friends >= 2` in the WHERE clause. Do add `GROUP BY T1.student_id` to support the aggregate count instead of omitting grouping. Do keep the grade filter `T2.grade > 5` in the WHERE clause but reference it through the joined table instead of directly. The amended query now correctly identifies students with at least two friends in grade above 5 by joining the Friend and Highschooler tables and using proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE grade > 5 AND friends >= 2;",
            "SELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nWHERE T2.grade > 5\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "911": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit `JOIN` syntax with `Friend AS T1 JOIN Highschooler AS T2` instead of a subquery in the WHERE clause. Do reference the joined table alias `T2.name` instead of the original table name `name`. Do move the grade filter to the `WHERE` clause with `T2.grade > 5` instead of keeping it in the main query's WHERE. Do add `GROUP BY T1.student_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using a correlated subquery. Do use proper table aliases `T1` and `T2` throughout instead of direct table references. The amended query now correctly identifies high schoolers with at least two friends using proper join and aggregation semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE grade > 5 AND (SELECT COUNT(*) FROM friends WHERE friends.student_id = high_schoolers.id) >= 2;",
            "SELECT T2.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nWHERE T2.grade > 5 \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "912": {
        "db_id": "network_1",
        "question": "How many likes does Kyle have?",
        "ground_truth": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do use `count(*)` with lowercase instead of `COUNT(*)` with uppercase. Do add `FROM Likes AS T1 JOIN Highschooler AS T2` instead of `FROM users`. Do add join condition `ON T1.student_id = T2.id` instead of omitting it. Do change filter to `WHERE T2.name = \"Kyle\"` instead of `WHERE name = 'Kyle'`. The amended query now correctly counts likes from the student named Kyle by joining the Likes and Highschooler tables instead of incorrectly querying a non-existent users table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE name = 'Kyle';",
            "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID WHERE T2.name = \"Kyle\""
        ],
        "rule_sql": []
    },
    "913": {
        "db_id": "network_1",
        "question": "Return the number of likes that the high schooler named Kyle has.",
        "ground_truth": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM likes WHERE student_id = (SELECT id FROM highschooler WHERE name = 'Kyle');"
        ],
        "rule_sql": []
    },
    "914": {
        "db_id": "network_1",
        "question": "Find the average grade of all students who have some friends.",
        "ground_truth": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do use `avg(grade)` from `Highschooler` instead of `AVG(grade)` from `students`. Do add a subquery with `id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)` instead of the simple filter `WHERE friend_count > 0`. Do change the table source to `Highschooler` instead of `students` and introduce a join between `Friend` and `Highschooler` tables instead of relying on a direct column filter. The amended query now correctly calculates average grades for students who have friends by verifying friendship relationships through the Friend table join rather than using a potentially incorrect friend_count field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE friend_count > 0",
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend)"
        ],
        "rule_sql": []
    },
    "915": {
        "db_id": "network_1",
        "question": "What is the average grade of students who have friends?",
        "ground_truth": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do select `avg(grade)` from `Highschooler` instead of `AVG(grade)` from `students`. Do use a subquery with `id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)` instead of filtering with `WHERE friend_count > 0`. Do join `Friend` table with `Highschooler` on `T1.student_id = T2.id` instead of relying on a direct `friend_count` column. The amended query now correctly identifies students who have friends by checking the Friend relationship table rather than assuming a friend_count column exists, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE friend_count > 0",
            "SELECT AVG(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ],
        "rule_sql": []
    },
    "916": {
        "db_id": "network_1",
        "question": "Find the minimum grade of students who have no friends.",
        "ground_truth": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do query the `Highschooler` table instead of the `students` table. Do use `min(grade)` with lowercase function name instead of `MIN(grade)`. Do change the subquery to use `Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of `SELECT friend_id FROM friends`, adding proper table aliases and join conditions. Do reference `T1.student_id` in the subquery's SELECT list instead of `friend_id`. The amended query now correctly identifies students without friends by properly joining the Friend and Highschooler tables to validate friend relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(grade) FROM students WHERE id NOT IN (SELECT friend_id FROM friends)",
            "SELECT min(grade) FROM Highschooler WHERE ID NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID)"
        ],
        "rule_sql": []
    },
    "917": {
        "db_id": "network_1",
        "question": "What is the lowest grade of students who do not have any friends?",
        "ground_truth": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do reference table `Highschooler` instead of `students` in the FROM clause. Do use the correct subquery structure with `Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of `SELECT DISTINCT student_id FROM friends`. Do remove the WHERE clause filter entirely instead of keeping it, as the filtering logic is now handled within the subquery. The amended query now correctly identifies minimum grades from Highschooler where IDs are not found in the Friend relationship table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(grade) FROM students WHERE id NOT IN (SELECT DISTINCT student_id FROM friends);",
            "SELECT MIN(grade) FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend)"
        ],
        "rule_sql": []
    },
    "918": {
        "db_id": "dog_kennels",
        "question": "Which states have both owners and professionals living there?",
        "ground_truth": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM owners INTERSECT SELECT state FROM professionals;"
        ],
        "rule_sql": []
    },
    "919": {
        "db_id": "dog_kennels",
        "question": "Find the states where both owners and professionals live.",
        "ground_truth": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT state FROM owners INTERSECT SELECT DISTINCT state FROM professionals;"
        ],
        "rule_sql": []
    },
    "920": {
        "db_id": "dog_kennels",
        "question": "What is the average age of the dogs who have gone through any treatments?",
        "ground_truth": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `avg(age)` with lowercase function instead of `AVG(age)` with uppercase function. Do filter with `dog_id IN (subquery)` instead of `treatment_id IS NOT NULL`. Do reference the `Dogs` table with proper capitalization instead of `dogs` lowercase. Do add a correlated subquery `SELECT dog_id FROM Treatments` to properly identify dogs that have received treatments instead of checking for non-null treatment_id directly in the dogs table. The amended query now correctly identifies dogs that have treatment records by checking against the Treatments table rather than relying on a potentially incorrect treatment_id field in the dogs table, ensuring the query matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": []
    },
    "921": {
        "db_id": "dog_kennels",
        "question": "Find the average age of the dogs who went through treatments.",
        "ground_truth": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `avg(age)` with lowercase function instead of `AVG(age)` with uppercase. Do filter using `dog_id IN (subquery)` instead of `treatment_id IS NOT NULL`. Do reference table as `Dogs` instead of `dogs`. Do add a correlated subquery `SELECT dog_id FROM Treatments` to properly identify dogs that have treatments instead of checking for non-null treatment_id values. The amended query now correctly calculates average age only for dogs that have corresponding treatment records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT avg(age) FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": []
    },
    "922": {
        "db_id": "dog_kennels",
        "question": "Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.",
        "ground_truth": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "amends": [
            "Do use `professional_id` instead of `id` in the SELECT list and change `cell_phone` to `cell_number` instead of keeping the original column name. Do add a UNION operation instead of using a single query with OR logic. Do change the first part to select from `Professionals` instead of `professionals` with proper table name casing. Do add a second query that performs a `JOIN` with `Treatments` table on `professional_id` instead of omitting this table entirely. Do move the count condition to `HAVING count(*) > 2` instead of using `treatment_count > 2` in the WHERE clause. Do use proper table aliasing with `AS T1` and `AS T2` instead of no aliases. Do include `GROUP BY T1.professional_id` instead of omitting grouping. The amended query now correctly handles the union of Indiana professionals and those with more than two treatments through proper table joining and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, last_name, cell_phone FROM professionals WHERE state = 'Indiana' OR treatment_count > 2;",
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "923": {
        "db_id": "dog_kennels",
        "question": "Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.",
        "ground_truth": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "amends": [
            "Do use `professional_id` instead of `id` and `cell_number` instead of `cell_phone` in the SELECT list. Do change the table name to `Professionals` instead of `professionals`. Do replace the WHERE clause with a UNION operation instead of using OR logic. Do add a second query that joins `Professionals AS T1` with `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of omitting this join. Do move the count condition to `HAVING count(*) > 2` instead of keeping it in the WHERE clause. Do use proper table aliases and group by `T1.professional_id` instead of not grouping. The amended query now correctly separates Indiana professionals from those with more than 2 treatments using UNION instead of incorrect OR logic that would miss the join requirement."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, last_name, cell_phone FROM professionals WHERE state = 'Indiana' OR treatment_count > 2",
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "924": {
        "db_id": "dog_kennels",
        "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .",
        "ground_truth": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter. Do add a correlated subquery that selects `dog_id` from the `treatments` table instead of omitting it. Do use `GROUP BY dog_id` and `HAVING sum(cost_of_treatment) > 1000` instead of filtering directly on `treatment_cost`. Do remove the direct column reference `treatment_cost` from the main query instead of keeping it, as the cost calculation now happens in the subquery. The amended query now correctly identifies dogs whose total treatment costs do not exceed 1000 by aggregating costs per dog in the treatments table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM dogs WHERE treatment_cost <= 1000;",
            "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)"
        ],
        "rule_sql": []
    },
    "925": {
        "db_id": "dog_kennels",
        "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?",
        "ground_truth": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "amends": [
            "Do use a subquery with `NOT IN` instead of multiple joins. Do filter by `dog_id` instead of `id` in the subquery. Do aggregate with `SUM(cost_of_treatment)` instead of filtering individual `cost` values. Do remove the joins with `owners` and `treatments` tables instead of including them. Do reference `cost_of_treatment` instead of `cost` in the aggregation. The amended query now correctly identifies dogs whose total treatment costs do not exceed 1000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name \nFROM dogs d \nJOIN owners o ON d.owner_id = o.id \nJOIN treatments t ON d.id = t.dog_id \nWHERE t.cost > 1000;",
            "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)"
        ],
        "rule_sql": []
    },
    "926": {
        "db_id": "dog_kennels",
        "question": "Which first names are used for professionals or owners but are not used as dog names?",
        "ground_truth": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT first_name \nFROM professionals \nWHERE first_name NOT IN (SELECT name FROM dogs)\nUNION\nSELECT DISTINCT first_name \nFROM owners \nWHERE first_name NOT IN (SELECT name FROM dogs);"
        ],
        "rule_sql": []
    },
    "927": {
        "db_id": "dog_kennels",
        "question": "Find the first names that are used for professionals or owners but are not used as dog names.",
        "ground_truth": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT first_name \nFROM professionals \nWHERE first_name NOT IN (SELECT name FROM dogs)\nUNION\nSELECT DISTINCT first_name \nFROM owners \nWHERE first_name NOT IN (SELECT name FROM dogs);"
        ],
        "rule_sql": []
    },
    "928": {
        "db_id": "dog_kennels",
        "question": "Which professional did not operate any treatment on dogs? List the professional's id, role and email.",
        "ground_truth": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of a `LEFT JOIN` with `IS NULL` filter. Do select `professional_id`, `role_code`, and `email_address` instead of `id`, `role`, and `email`. Do reference the `Professionals` table with proper casing instead of lowercase. Do join `Treatments` with an `INNER JOIN` on `professional_id` instead of a filtered `LEFT JOIN`. Do remove the `animal_type = 'Dog'` filter condition instead of including it. Do use table aliases `T1` and `T2` instead of single letters. The amended query now correctly identifies professionals who have never performed any treatments by using set difference rather than null checking, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.id, p.role, p.email \nFROM professionals p\nLEFT JOIN treatments t ON p.id = t.professional_id AND t.animal_type = 'Dog'\nWHERE t.professional_id IS NULL;",
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address \nFROM Professionals T1\nINNER JOIN Treatments T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": []
    },
    "929": {
        "db_id": "dog_kennels",
        "question": "Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
        "ground_truth": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do select `professional_id`, `role_code`, and `email_address` instead of `id`, `role`, and `email`. Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table as `Professionals` instead of `professionals`. Do join `Professionals AS T1` with `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of using a subquery with `professional_id` and `animal_type` filter. Do remove the `WHERE animal_type = 'dog'` condition instead of keeping it. The amended query now correctly excludes professionals who have any treatments rather than just those with dog treatments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, role, email FROM professionals WHERE id NOT IN (SELECT professional_id FROM treatments WHERE animal_type = 'dog')",
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": []
    },
    "930": {
        "db_id": "dog_kennels",
        "question": "Which owner owns the most dogs? List the owner id, first name and last name.",
        "ground_truth": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Dogs AS T1` to `Owners AS T2` on `T1.owner_id = T2.owner_id` instead of selecting from only `owners` table. Do select `T1.owner_id`, `T2.first_name`, and `T2.last_name` instead of including `COUNT(dog_id) as dog_count` in the SELECT list. Do use `count(*)` in the ORDER BY clause instead of ordering by the aliased `dog_count`. Do remove the explicit aggregation column from GROUP BY and instead group by `T1.owner_id` only. The amended query now correctly joins the Dogs and Owners tables to find the owner with the most dogs while properly handling the relationship between these tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_id, first_name, last_name, COUNT(dog_id) as dog_count FROM owners GROUP BY owner_id ORDER BY dog_count DESC LIMIT 1;",
            "SELECT T2.owner_id, T2.first_name, T2.last_name\nFROM Dogs AS T1\nJOIN Owners AS T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "931": {
        "db_id": "dog_kennels",
        "question": "Return the owner id, first name and last name of the owner who has the most dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `Dogs` and `Owners` tables with a `JOIN` on `T1.owner_id = T2.owner_id` instead of querying only the `owners` table. Do change the SELECT list to reference `T1.owner_id`, `T2.first_name`, and `T2.last_name` instead of `owner_id`, `first_name`, and `last_name` without table qualification. Do add `GROUP BY T1.owner_id` instead of omitting grouping. Do change the ORDER BY to use `count(*)` instead of `COUNT(dogs.owner_id)` without proper grouping. The amended query now correctly counts dogs per owner and returns the owner with the most dogs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_id, first_name, last_name FROM owners ORDER BY COUNT(dogs.owner_id) DESC LIMIT 1;",
            "SELECT T1.owner_id, T2.first_name, T2.last_name\nFROM Dogs T1\nJOIN Owners T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "932": {
        "db_id": "dog_kennels",
        "question": "Which professionals have done at least two treatments? List the professional's id, role, and first name.",
        "ground_truth": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do add `Treatments AS T2` table with `JOIN` instead of querying only `professionals` table. Do use `T1.professional_id = T2.professional_id` join condition instead of no join. Do change `role` to `role_code` instead of using incorrect column name. Do add `GROUP BY T1.professional_id` instead of omitting grouping. Do change `WHERE COUNT(treatment_id) = 1` to `HAVING count(*) >= 2` instead of using aggregate in WHERE clause with wrong condition. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly finds professionals with at least two treatments by properly joining tables and using HAVING clause for aggregate filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professional_id, role, first_name \nFROM professionals \nWHERE COUNT(treatment_id) = 1;",
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "933": {
        "db_id": "dog_kennels",
        "question": "What are the id, role, and first name of the professionals who have performed two or more treatments?",
        "ground_truth": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.professional_id`, `T1.role_code`, and `T1.first_name` instead of `id`, `role`, and `first_name` without table qualification. Do join `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of querying only the `professionals` table. Do use `GROUP BY T1.professional_id` with `HAVING count(*) >= 2` instead of filtering `WHERE treatment_count = 2` which incorrectly assumes a direct column rather than counting related treatment records. The amended query now correctly counts treatment associations per professional and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, role, first_name \nFROM professionals \nWHERE treatment_count = 2;",
            "SELECT T1.professional_id, T1.role_code, T1.first_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "934": {
        "db_id": "dog_kennels",
        "question": "What is the name of the breed with the most dogs?",
        "ground_truth": "SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add a `JOIN` between `Breeds AS T1` and `Dogs AS T2` on `T1.breed_code = T2.breed_code` instead of querying only the `dogs` table. Do specify the table alias `T1.breed_name` in the SELECT clause instead of just `breed_name`. Do include the proper join condition `T1.breed_code = T2.breed_code` instead of missing the relationship between breeds and dogs tables. The amended query now correctly joins the breeds and dogs tables to count dogs by breed and returns the breed with the highest count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT breed_name FROM dogs GROUP BY breed_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "935": {
        "db_id": "dog_kennels",
        "question": "Which breed do the most dogs have? Give me the breed name.",
        "ground_truth": "SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Breeds AS T1` and `Dogs AS T2` on `T1.breed_code = T2.breed_code` instead of querying only the `dogs` table. Do select `T1.breed_name` instead of `breed` and maintain the same aggregate count logic. Do group by `T1.breed_name` instead of `breed` to properly reference the joined table column. Do keep the `ORDER BY count(*) DESC LIMIT 1` unchanged as it correctly identifies the breed with the highest count. The amended query now properly joins the breed reference table to resolve breed names from codes and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT breed, COUNT(*) as count FROM dogs GROUP BY breed ORDER BY count DESC LIMIT 1;",
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "936": {
        "db_id": "dog_kennels",
        "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.",
        "ground_truth": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do remove `o.last_name` from the SELECT list and GROUP BY clause instead of including it, as the owner_id alone uniquely identifies each group. Do use `count(*)` in the ORDER BY instead of referencing the alias `treatment_count` since that alias is not available at the ORDER BY level. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `o`, `d`, and `t` for consistency, though this is primarily cosmetic. The amended query now correctly identifies the owner with the most treatments by counting all treatment records per owner without relying on an unavailable column alias."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.owner_id, o.last_name, COUNT(t.treatment_id) as treatment_count\nFROM owners o\nJOIN dogs d ON o.owner_id = d.owner_id\nJOIN treatments t ON d.dog_id = t.dog_id\nGROUP BY o.owner_id, o.last_name\nORDER BY treatment_count DESC\nLIMIT 1;",
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nJOIN Dogs T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "937": {
        "db_id": "dog_kennels",
        "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of unaliased table names. Do change the subquery approach to explicit `JOIN` operations with `Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id` instead of a subquery with implicit joins. Do add `GROUP BY T1.owner_id` at the main query level instead of grouping within a subquery. Do change the ordering criterion to `ORDER BY count(*) DESC` instead of `ORDER BY SUM(cost) DESC`. Do remove the `WHERE owner_id IN` subquery filter and instead use the join structure to naturally filter the results. The amended query now correctly identifies owners based on treatment count rather than treatment cost sum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_id, last_name \nFROM owners \nWHERE owner_id IN (\n    SELECT owner_id \n    FROM dogs \n    JOIN treatments ON dogs.dog_id = treatments.dog_id \n    GROUP BY owner_id \n    ORDER BY SUM(cost) DESC \n    LIMIT 1\n)",
            "SELECT T1.owner_id, T1.last_name\nFROM Owners AS T1\nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "938": {
        "db_id": "dog_kennels",
        "question": "What is the description of the treatment type that costs the least money in total?",
        "ground_truth": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
        "amends": [
            "Do select `T1.treatment_type_description` instead of `description` and add a `JOIN` with `Treatments AS T2` on `T1.treatment_type_code = T2.treatment_type_code` instead of querying only `treatment_types`. Do add `GROUP BY T1.treatment_type_code` instead of omitting grouping and change the ordering to `sum(cost_of_treatment) ASC` instead of `cost ASC`. The amended query now correctly finds the treatment type with the lowest total cost across all treatments rather than just the single cheapest treatment type instance, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM treatment_types ORDER BY cost ASC LIMIT 1;",
            "SELECT T1.treatment_type_description \nFROM Treatment_Types AS T1\nJOIN Treatments AS T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "939": {
        "db_id": "dog_kennels",
        "question": "Give me the description of the treatment type whose total cost is the lowest.",
        "ground_truth": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
        "amends": [
            "Do select `T1.treatment_type_description` instead of `description` and add a `JOIN` with `Treatments AS T2` on `T1.treatment_type_code = T2.treatment_type_code` instead of querying only `treatment_types`. Do add `GROUP BY T1.treatment_type_code` instead of omitting grouping and use `sum(cost_of_treatment)` for ordering instead of `total_cost`. Do order by `sum(cost_of_treatment) ASC` instead of `total_cost ASC` while keeping the `LIMIT 1`. The amended query now correctly calculates the total treatment cost per type before selecting the cheapest one, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM treatment_types ORDER BY total_cost ASC LIMIT 1;",
            "SELECT T1.treatment_type_description\nFROM Treatment_Types AS T1\nJOIN Treatments AS T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "940": {
        "db_id": "dog_kennels",
        "question": "Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.",
        "ground_truth": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
        "amends": [
            "Do change the SELECT list to `T1.owner_id, T1.zip_code` instead of `owner_id, zip_code, SUM(amount) as total_paid`. Do change the FROM clause to join `Owners AS T1` with `Dogs AS T2` on `T1.owner_id = T2.owner_id` and then join `Treatments AS T3` on `T2.dog_id = T3.dog_id` instead of using a single `payments` table. Do remove the `zip_code` from GROUP BY and use only `T1.owner_id` instead of grouping by both `owner_id, zip_code`. Do change the ORDER BY to `sum(T3.cost_of_treatment) DESC` instead of `total_paid ASC`. Do remove the alias `total_paid` and reference the aggregate function directly in ORDER BY. The amended query now correctly identifies the owner with the highest total treatment costs across their dogs instead of summarizing payments by zip code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_id, zip_code, SUM(amount) as total_paid\nFROM payments\nGROUP BY owner_id, zip_code\nORDER BY total_paid ASC\nLIMIT 1;",
            "SELECT T1.owner_id, T1.zip_code\nFROM Owners AS T1\nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "941": {
        "db_id": "dog_kennels",
        "question": "Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
        "amends": [
            "Do select only `owner_id` and `zip_code` instead of including `SUM(amount)` and aliasing it as `total_spent`. Do join `Treatments` table as `T3` instead of `purchases` table. Do use `T2.dog_id = T3.dog_id` join condition instead of `d.dog_id = p.dog_id`. Do group by only `owner_id` instead of both `owner_id` and `zip_code`. Do order by `sum(T3.cost_of_treatment)` in descending order instead of `total_spent` in ascending order. The amended query now correctly calculates the highest treatment cost per owner rather than purchase amounts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_id, zip_code, SUM(amount) as total_spent\nFROM owners o\nJOIN dogs d ON o.owner_id = d.owner_id\nJOIN purchases p ON d.dog_id = p.dog_id\nGROUP BY owner_id, zip_code\nORDER BY total_spent ASC\nLIMIT 1;",
            "SELECT o.owner_id, o.zip_code\nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nJOIN Treatments T3 ON d.dog_id = T3.dog_id\nGROUP BY o.owner_id\nORDER BY SUM(T3.cost_of_treatment) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "942": {
        "db_id": "dog_kennels",
        "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.",
        "ground_truth": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do join `Treatments AS T2` instead of querying only the `professionals` table. Do use `T1.professional_id = T2.professional_id` as the join condition instead of missing the join entirely. Do select `T1.cell_number` instead of `cell_phone` and qualify columns with table aliases. Do add `GROUP BY T1.professional_id` instead of omitting grouping. Do move the count filter to `HAVING count(*) >= 2` instead of using `WHERE COUNT(DISTINCT treatment_type) >= 2` which cannot reference aggregates in the WHERE clause. Do count all rows with `count(*)` instead of counting distinct `treatment_type` values. The amended query now correctly identifies professionals with at least two treatments by properly using aggregation with HAVING instead of the invalid WHERE clause with aggregate function."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professional_id, cell_phone \nFROM professionals \nWHERE COUNT(DISTINCT treatment_type) >= 2;",
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "943": {
        "db_id": "dog_kennels",
        "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.",
        "ground_truth": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T1.professional_id` and `T1.cell_number` instead of `id` and `cell_phone`. Do join `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of querying only the `professionals` table. Do use `GROUP BY T1.professional_id` with `HAVING count(*) >= 2` instead of `WHERE COUNT(DISTINCT treatment_type) >= 2` to properly aggregate and filter professionals with multiple treatments. The amended query now correctly identifies professionals who have provided at least two treatments by joining the relevant tables and using appropriate aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, cell_phone FROM professionals WHERE COUNT(DISTINCT treatment_type) >= 2;",
            "SELECT T1.professional_id, T1.cell_number\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "944": {
        "db_id": "dog_kennels",
        "question": "What are the first name and last name of the professionals who have done treatment with cost below average?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate professional records. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified column names. Do join `Professionals AS T1` with `Treatments AS T2` instead of querying only the Professionals table. Do filter on `cost_of_treatment` instead of `treatment_cost` to use the correct column name from the Treatments table. Do compare against the average `cost_of_treatment` instead of `treatment_cost` in the subquery to maintain consistency. The amended query now correctly identifies professionals whose treatment costs are below average by properly joining the relevant tables and using the correct column references.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the alias qualification from `cost_of_treatment` in the WHERE clause instead of keeping `T2.cost_of_treatment`. The amended query now correctly filters professionals based on treatment costs below the average without unnecessary join predicates and matches the RIGHT_SQL's behavior.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the table alias `T2.` from `cost_of_treatment` in the WHERE clause instead of keeping it. The amended query now correctly joins without an explicit condition and references the column directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM professionals WHERE treatment_cost < (SELECT AVG(treatment_cost) FROM treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"
        ],
        "rule_sql": []
    },
    "945": {
        "db_id": "dog_kennels",
        "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate professional records. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. Do join `Professionals AS T1` with `Treatments AS T2` instead of querying only the `professionals` table. Do use column name `cost_of_treatment` instead of `treatment_cost` in both the main filter and subquery. Do reference the correct table `Treatments` in the subquery instead of `treatments`. The amended query now correctly joins professionals with their treatments and filters based on the average treatment cost.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the table alias `T2.` from `cost_of_treatment` in the WHERE clause instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, as the RIGHT_SQL uses a cross join without explicit join predicates. Do keep the `DISTINCT` modifier, `T1.first_name` and `T1.last_name` column selections, `Professionals AS T1` and `Treatments AS T2` table sources, and the `cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)` filter condition unchanged, as these elements match between both queries. The amended query now matches RIGHT_SQL's behavior with a Cartesian product between Professionals and Treatments tables filtered by the cost comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM professionals WHERE treatment_cost < (SELECT AVG(treatment_cost) FROM treatments);",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (\n    SELECT AVG(cost_of_treatment)\n    FROM Treatments\n)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"
        ],
        "rule_sql": []
    },
    "946": {
        "db_id": "dog_kennels",
        "question": "List the date of each treatment, together with the first name of the professional who operated it.",
        "ground_truth": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do select `date_of_treatment` and `first_name` instead of `treatment_date` and `last_name`. Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.date_of_treatment` and `T2.first_name` instead of unqualified column names. Do specify `Treatments AS T1` and `Professionals AS T2` instead of simple table names. The amended query now correctly retrieves the treatment date and professional's first name with proper table aliasing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT treatment_date, last_name FROM treatments JOIN professionals ON treatments.professional_id = professionals.professional_id;",
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id;"
        ],
        "rule_sql": []
    },
    "947": {
        "db_id": "dog_kennels",
        "question": "What are the date and the operating professional's first name of each treatment?",
        "ground_truth": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do use `T1.date_of_treatment` instead of `date` and `T2.first_name` instead of `first_name` for explicit table aliases. Do specify `Treatments AS T1` instead of `treatments` and `Professionals AS T2` instead of `professionals` with proper table aliasing. Do join on `T1.professional_id = T2.professional_id` instead of `treatments.professional_id = professionals.id` to use the correct join condition between professional IDs. The amended query now correctly retrieves treatment dates and professional names using proper table aliases and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, first_name FROM treatments JOIN professionals ON treatments.professional_id = professionals.id",
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": []
    },
    "948": {
        "db_id": "dog_kennels",
        "question": "List the cost of each treatment and the corresponding treatment type description.",
        "ground_truth": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
        "amends": [
            "Do specify table aliases `T1.cost_of_treatment` and `T2.treatment_type_description` instead of unqualified column names `cost` and `treatment_type_description`. Do add a `JOIN` with `treatment_types AS T2` instead of querying only the `treatments` table. Do use the join condition `ON T1.treatment_type_code = T2.treatment_type_code` instead of omitting the necessary table relationship. The amended query now correctly retrieves treatment cost and description by properly joining the treatments table with treatment_types using the appropriate foreign key relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cost, treatment_type_description FROM treatments",
            "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"
        ],
        "rule_sql": []
    },
    "949": {
        "db_id": "dog_kennels",
        "question": "What are the cost and treatment type description of each treatment?",
        "ground_truth": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
        "amends": [
            "Do specify table aliases `T1.cost_of_treatment` and `T2.treatment_type_description` instead of unqualified `cost` and `treatment_type`. Do add `JOIN treatment_types AS T2` instead of querying only the `treatments` table. Do include the join condition `ON T1.treatment_type_code = T2.treatment_type_code` instead of omitting the necessary table relationship. The amended query now correctly joins the two related tables to retrieve the complete treatment information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cost, treatment_type FROM treatments;",
            "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"
        ],
        "rule_sql": []
    },
    "950": {
        "db_id": "dog_kennels",
        "question": "List each owner's first name, last name, and the size of his for her dog.",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference column `size_code` instead of `size` in the SELECT list. Do use table name `Owners` instead of `owner` and `Dogs` instead of `dog`. Do join on `T1.owner_id = T2.owner_id` instead of `owner.id = dog.owner_id`, correcting the join condition to use the proper column names. The amended query now correctly retrieves owner information with dog size codes using the proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner.first_name, owner.last_name, dog.size FROM owner JOIN dog ON owner.id = dog.owner_id",
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": []
    },
    "951": {
        "db_id": "dog_kennels",
        "question": "What are each owner's first name, last name, and the size of their dog?",
        "ground_truth": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. Do select `T2.size_code` instead of `dog_size`. Do use `Owners AS T1` and `Dogs AS T2` instead of unaliased `owners` and `dogs`. Do join on `T1.owner_id = T2.owner_id` instead of `owners.id = dogs.owner_id`. The amended query now correctly matches the intended logic by using proper table aliases and the correct join condition between owner_id fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, dog_size FROM owners JOIN dogs ON owners.id = dogs.owner_id",
            "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id;"
        ],
        "rule_sql": []
    },
    "952": {
        "db_id": "dog_kennels",
        "question": "List pairs of the owner's first name and the dogs's name.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names `owner` and `dog`. Do reference `T1.first_name` and `T2.name` instead of `owner.first_name` and `dog.name`. Do join on `T1.owner_id = T2.owner_id` instead of `owner.id = dog.owner_id`. Do use table names `Owners` and `Dogs` instead of `owner` and `dog`. The amended query now correctly matches the intended join logic and table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner.first_name, dog.name FROM owner JOIN dog ON owner.id = dog.owner_id",
            "SELECT T1.first_name, T2.name FROM Owners T1 JOIN Dogs T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": []
    },
    "953": {
        "db_id": "dog_kennels",
        "question": "What are each owner's first name and their dogs's name?",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use `T1.first_name` and `T2.name` as column selections instead of `owner_name` and `dog_name`. Do specify table aliases `AS T1` for `Owners` and `AS T2` for `Dogs` instead of using unaliased table names. Do join on `T1.owner_id = T2.owner_id` instead of `owners.id = dogs.owner_id` to correctly match the owner_id fields between tables. The amended query now correctly retrieves first names from the Owners table and dog names from the Dogs table using the proper join condition on owner_id fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_name, dog_name FROM owners JOIN dogs ON owners.id = dogs.owner_id;",
            "SELECT T1.first_name, T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": []
    },
    "954": {
        "db_id": "dog_kennels",
        "question": "List the names of the dogs of the rarest breed and the treatment dates of them.",
        "ground_truth": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",
        "amends": [
            "Do use `T1.name` and `T2.date_of_treatment` as column aliases instead of `d.name` and `t.treatment_date`. Do reference table aliases `Dogs AS T1` and `Treatments AS T2` instead of `dogs d` and `treatments t`. Do join on `T1.dog_id = T2.dog_id` instead of `d.dog_id = t.dog_id`. Do filter on `T1.breed_code` instead of `d.breed`. Do use `breed_code` in the subquery instead of `breed` for both the selection and grouping. The amended query now correctly matches the RIGHT_SQL's behavior with proper column references and table aliasing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name, t.treatment_date \nFROM dogs d \nJOIN treatments t ON d.dog_id = t.dog_id \nWHERE d.breed = (SELECT breed FROM dogs GROUP BY breed ORDER BY COUNT(*) ASC LIMIT 1)",
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs AS T1\nJOIN Treatments AS T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T2.date_of_treatment;"
        ],
        "rule_sql": []
    },
    "955": {
        "db_id": "dog_kennels",
        "question": "Which dogs are of the rarest breed? Show their names and treatment dates.",
        "ground_truth": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",
        "amends": [
            "Do use `T1.name` and `T2.date_of_treatment` instead of `d.name` and `t.treatment_date` for column aliases. Do reference `Dogs AS T1` and `Treatments AS T2` instead of `dogs d` and `treatments t` for table aliases. Do join on `T1.dog_id = T2.dog_id` instead of `d.dog_id = t.dog_id` for the join condition. Do filter on `T1.breed_code` instead of `d.breed` for the breed column reference. Do use `breed_code` instead of `breed` in the subquery's SELECT and GROUP BY clauses. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name, t.treatment_date \nFROM dogs d \nJOIN treatments t ON d.dog_id = t.dog_id \nWHERE d.breed = (SELECT breed FROM dogs GROUP BY breed ORDER BY COUNT(*) ASC LIMIT 1)\nORDER BY t.treatment_date DESC;",
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs AS T1\nJOIN Treatments AS T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "956": {
        "db_id": "dog_kennels",
        "question": "Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.owner_id` in the JOIN condition instead of `dogs.owner_id`. Do use `T1.owner_id = T2.owner_id` instead of `dogs.owner_id = owners.id`. Do reference `T1.state` in the WHERE clause instead of `owners.state`. The amended query now correctly joins on the owner_id field from both tables and uses proper table aliasing throughout."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner.first_name, dog.name FROM dogs JOIN owners ON dogs.owner_id = owners.id WHERE owners.state = 'Virginia';",
            "SELECT T2.first_name, T1.name \nFROM Dogs T1 \nJOIN Owners T2 ON T1.owner_id = T2.owner_id \nWHERE T2.state = 'Virginia'"
        ],
        "rule_sql": []
    },
    "957": {
        "db_id": "dog_kennels",
        "question": "Find the first names of owners living in Virginia and the names of dogs they own.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.first_name, d.name FROM owners o JOIN dogs d ON o.owner_id = d.owner_id WHERE o.state = 'Virginia';"
        ],
        "rule_sql": []
    },
    "958": {
        "db_id": "dog_kennels",
        "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?",
        "ground_truth": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use `T1.date_arrived` and `T1.date_departed` instead of `arriving_date` and `departing_date`. Do add `Treatments AS T2` table with `JOIN` instead of querying only the `dogs` table. Do use join condition `T1.dog_id = T2.dog_id` instead of filtering with `WHERE treatment = 'yes'`. Do remove the `WHERE` filter condition instead of keeping it, as the join now properly filters to dogs with treatments. The amended query now correctly retrieves distinct arrival and departure dates for dogs that have treatments by joining the Dogs and Treatments tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT arriving_date, departing_date FROM dogs WHERE treatment = 'yes';",
            "SELECT DISTINCT T1.date_arrived, T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id = T2.dog_id"
        ],
        "rule_sql": []
    },
    "959": {
        "db_id": "dog_kennels",
        "question": "Find the arriving date and the departing date of the dogs that received a treatment.",
        "ground_truth": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and use `date_arrived` and `date_departed` instead of `arrival_date` and `departure_date`. Do join `Treatments` table on `dog_id` instead of filtering only by `treatment_received = 'yes'`, and reference the table as `Dogs AS T1` instead of just `dogs`. Do remove the `WHERE` clause filter entirely instead of keeping it, as the join condition now properly identifies dogs that have received treatments. The amended query now correctly returns distinct arrival and departure dates for dogs that have treatment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM dogs WHERE treatment_received = 'yes';",
            "SELECT DISTINCT T1.date_arrived, T1.date_departed\nFROM Dogs AS T1\nJOIN Treatments ON T1.dog_id = Treatments.dog_id"
        ],
        "rule_sql": []
    },
    "960": {
        "db_id": "dog_kennels",
        "question": "List the last name of the owner owning the youngest dog.",
        "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
        "amends": [
            "Do add `T1.last_name` with table alias instead of `last_name` without qualification. Do add `FROM Owners AS T1 JOIN Dogs AS T2` with explicit join instead of single table `FROM owners`. Do add `ON T1.owner_id = T2.owner_id` join condition instead of omitting any join. Do add `WHERE T2.age = (SELECT max(age) FROM Dogs)` subquery filter instead of `ORDER BY dog_age ASC`. Do remove `LIMIT 1` instead of keeping it, as the subquery now precisely identifies the maximum age. The amended query now correctly finds owners with dogs of maximum age instead of attempting to sort by a non-existent column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM owners ORDER BY dog_age ASC LIMIT 1;",
            "SELECT T1.last_name \nFROM Owners AS T1 \nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id \nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ],
        "rule_sql": []
    },
    "961": {
        "db_id": "dog_kennels",
        "question": "Who owns the youngest dog? Give me his or her last name.",
        "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
        "amends": [
            "Do add `T1.last_name` with table alias instead of `last_name` without qualification. Do add `FROM Owners AS T1 JOIN Dogs AS T2` with explicit join instead of single table `FROM owners`. Do add `ON T1.owner_id = T2.owner_id` join condition instead of missing join predicate. Do add `WHERE T2.age = (SELECT max(age) FROM Dogs)` subquery filter instead of `ORDER BY dog_age ASC` sorting. Do remove `LIMIT 1` instead of keeping it, as the subquery filter now precisely identifies the maximum age record. The amended query now correctly joins the Owners and Dogs tables to find owners with dogs of maximum age, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM owners ORDER BY dog_age ASC LIMIT 1;",
            "SELECT T1.last_name \nFROM Owners AS T1 \nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id \nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ],
        "rule_sql": []
    },
    "962": {
        "db_id": "dog_kennels",
        "question": "List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.",
        "ground_truth": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "amends": [
            "Do reference the `email_address` column instead of `email` and use `OR` between state conditions instead of `AND` to properly select professionals from either Hawaii or Wisconsin, instead of incorrectly requiring both states simultaneously which would never match any records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM professionals WHERE state = 'Hawaii' AND state = 'Wisconsin';",
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ],
        "rule_sql": []
    },
    "963": {
        "db_id": "dog_kennels",
        "question": "What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?",
        "ground_truth": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "amends": [
            "Do reference the `email_address` column instead of `email` and use `OR` between state conditions instead of `AND` to correctly find professionals in either Hawaii or Wisconsin instead of incorrectly requiring both states simultaneously. Do use the correct table name `Professionals` instead of `professionals` to match the schema. The amended query now correctly returns email addresses for professionals located in either Hawaii or Wisconsin."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM professionals WHERE state = 'Hawaii' AND state = 'Wisconsin';",
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ],
        "rule_sql": []
    },
    "964": {
        "db_id": "dog_kennels",
        "question": "What are the arriving date and the departing date of all the dogs?",
        "ground_truth": "SELECT date_arrived ,  date_departed FROM Dogs",
        "amends": [
            "Do reference `date_arrived` and `date_departed` columns instead of `arrival_date` and `departure_date`. Do query from `Dogs` table instead of `cats` table. The amended query now correctly selects the appropriate date columns from the intended table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM cats;",
            "SELECT date_arrived, date_departed FROM Dogs;"
        ],
        "rule_sql": []
    },
    "965": {
        "db_id": "dog_kennels",
        "question": "List the arrival date and the departure date for all the dogs.",
        "ground_truth": "SELECT date_arrived ,  date_departed FROM Dogs",
        "amends": [
            "Do reference table `Dogs` instead of `cats` in the FROM clause. Do select columns `date_arrived` and `date_departed` instead of `arrival_date` and `departure_date` in the SELECT list. The amended query now correctly retrieves arrival and departure dates from the Dogs table instead of the cats table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM cats",
            "SELECT date_arrived, date_departed FROM Dogs;"
        ],
        "rule_sql": []
    },
    "966": {
        "db_id": "dog_kennels",
        "question": "How many dogs went through any treatments?",
        "ground_truth": "SELECT count(DISTINCT dog_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT dog_id` instead of `COUNT(*)` to count unique dogs rather than all treatment records. Do query from the `Treatments` table instead of `dogs` to access the treatment-specific data. Do remove the `WHERE treatment_id IS NOT NULL` filter instead of keeping it since counting distinct dog_ids inherently excludes null values. The amended query now correctly counts unique dogs that have received treatments rather than counting all treatment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NOT NULL;",
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ],
        "rule_sql": []
    },
    "967": {
        "db_id": "dog_kennels",
        "question": "Count the number of dogs that went through a treatment.",
        "ground_truth": "SELECT count(DISTINCT dog_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT dog_id` instead of `COUNT(*)` to count unique dogs rather than all treatment records. Do source from `Treatments` table instead of `dogs` table to access the correct treatment data. Do remove the `WHERE treatment = 'yes'` filter instead of keeping it since the count should include all treatments regardless of status. The amended query now correctly counts distinct dogs that have received treatments rather than counting all treatment records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment = 'yes';",
            "SELECT COUNT(DISTINCT dog_id) FROM Treatments;"
        ],
        "rule_sql": []
    },
    "968": {
        "db_id": "dog_kennels",
        "question": "How many professionals have performed any treatment to dogs?",
        "ground_truth": "SELECT count(DISTINCT professional_id) FROM Treatments",
        "amends": [
            "Do select `count(DISTINCT professional_id)` instead of `COUNT(*)` to count unique professionals rather than all rows. Do query from the `Treatments` table instead of the `professionals` table to access treatment-specific data. Do remove the `WHERE treatment_type = 'dog'` filter instead of keeping it, as the count should include all treatments rather than filtering by type. The amended query now correctly counts distinct professionals from the Treatments table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE treatment_type = 'dog'",
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ],
        "rule_sql": []
    },
    "969": {
        "db_id": "dog_kennels",
        "question": "Find the number of professionals who have ever treated dogs.",
        "ground_truth": "SELECT count(DISTINCT professional_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT professional_id` instead of `COUNT(*)` to count unique professionals rather than all records. Do query from the `Treatments` table instead of the `professionals` table to access the correct data source for treatment-related information. Do remove the `WHERE pet_type = 'dog'` filter instead of keeping it since the right query does not include any filtering conditions. Do change the aggregate function to count distinct professional identifiers instead of counting all rows to accurately measure the number of unique professionals providing treatments."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE pet_type = 'dog';",
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ],
        "rule_sql": []
    },
    "970": {
        "db_id": "dog_kennels",
        "question": "Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.",
        "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
        "amends": [
            "Do use `role_code` instead of `role` in the SELECT list to reference the correct column name. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate column while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role, street, city, state FROM professionals WHERE city LIKE '%West%';",
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ],
        "rule_sql": []
    },
    "971": {
        "db_id": "dog_kennels",
        "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
        "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
        "amends": [
            "Do use `role_code` instead of `role` in the SELECT list to reference the correct column name. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate column while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role, street, city, state FROM professionals WHERE city LIKE '%West%';",
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%'"
        ],
        "rule_sql": []
    },
    "972": {
        "db_id": "dog_kennels",
        "question": "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.",
        "ground_truth": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
        "amends": [
            "Do use `email_address` instead of `email` in the SELECT list. Do reference the table as `Owners` instead of `owners` to match the correct case. The amended query now correctly selects the appropriate email column and maintains proper table reference casing to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM owners WHERE state LIKE '%North%';",
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ],
        "rule_sql": []
    },
    "973": {
        "db_id": "dog_kennels",
        "question": "Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.",
        "ground_truth": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
        "amends": [
            "Do reference `email_address` instead of `email` in the SELECT list. Do use the correct table name `Owners` instead of `owners` in the FROM clause. The amended query now correctly retrieves the email address field from the Owners table with proper case sensitivity and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM owners WHERE state LIKE '%North%';",
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ],
        "rule_sql": []
    },
    "974": {
        "db_id": "dog_kennels",
        "question": "How many dogs have an age below the average?",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE age < (SELECT AVG(age) FROM dogs WHERE age IS NOT NULL);"
        ],
        "rule_sql": []
    },
    "975": {
        "db_id": "dog_kennels",
        "question": "Count the number of dogs of an age below the average.",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs )",
        "amends": [
            "Do use the comparison operator `<` instead of `>` in the WHERE filter. Do maintain the same aggregate function `AVG(age)` in the subquery instead of changing it. Do preserve the table name `Dogs` with consistent casing instead of using different case variations. Do keep the same structure with a correlated subquery filtering the main table instead of altering the approach. The amended query now correctly counts dogs younger than the average age instead of those older than average, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE age > (SELECT AVG(age) FROM dogs);",
            "SELECT COUNT(*) \nFROM Dogs \nWHERE age < (SELECT AVG(age) FROM Dogs)"
        ],
        "rule_sql": []
    },
    "976": {
        "db_id": "dog_kennels",
        "question": "How much does the most recent treatment cost?",
        "ground_truth": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
        "amends": [
            "Do select `cost_of_treatment` instead of using `MAX(cost)` aggregation. Do reference table `Treatments` instead of `treatments`. Do order by `date_of_treatment` instead of `date`. Do remove the unnecessary aggregation function and instead directly select the column value while maintaining the same ordering and limiting behavior to retrieve the most recent treatment cost."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(cost) FROM treatments ORDER BY date DESC LIMIT 1;",
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "977": {
        "db_id": "dog_kennels",
        "question": "Show me the cost of the most recently performed treatment.",
        "ground_truth": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
        "amends": [
            "Do reference the column `cost_of_treatment` instead of `cost` in the SELECT list. Do reference the column `date_of_treatment` instead of `treatment_date` in the ORDER BY clause. The amended query now correctly retrieves the most recent treatment cost using the proper column names from the Treatments table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cost FROM treatments ORDER BY treatment_date DESC LIMIT 1;",
            "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "978": {
        "db_id": "dog_kennels",
        "question": "How many dogs have not gone through any treatment?",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistency. Do reference the table as `Dogs` instead of `dogs` to match the correct case. Do change the filter to `dog_id NOT IN (subquery)` instead of `treatment_id IS NULL` to properly identify dogs without treatments. Do add a subquery `SELECT dog_id FROM Treatments` instead of omitting it, which correctly identifies dogs that have received treatments. The amended query now matches RIGHT_SQL's behavior by accurately counting dogs that have never received any treatment."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NULL;",
            "SELECT count(*) FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": []
    },
    "979": {
        "db_id": "dog_kennels",
        "question": "Tell me the number of dogs that have not received any treatment .",
        "ground_truth": "select count(*) from dogs where dog_id not in ( select dog_id from treatments )",
        "amends": [
            "Do use a subquery with `dog_id not in (select dog_id from treatments)` instead of checking `treatment_id IS NULL` directly. Do reference the `treatments` table instead of omitting it from the query structure. Do filter based on the absence of records in the treatments table instead of relying on a potentially incorrect NULL check in the dogs table. The amended query now correctly identifies dogs that have never received any treatment by checking for their absence in the treatments table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NULL;",
            "SELECT COUNT(*) \nFROM Dogs \nWHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": []
    },
    "980": {
        "db_id": "dog_kennels",
        "question": "How many owners temporarily do not have any dogs?",
        "ground_truth": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )",
        "amends": [
            "Do use a subquery with `NOT IN` filtering on `owner_id` instead of checking for `dog_id IS NULL`. Do reference the `Owners` table (capitalized) instead of `owners`. Do count all rows from the filtered result set instead of counting rows where a non-existent `dog_id` column would be null. The amended query now correctly identifies owners who do not have any dogs by checking for `owner_id` values that are not present in the Dogs table, rather than relying on a potentially non-existent or incorrectly named column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE dog_id IS NULL;",
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT DISTINCT owner_id FROM Dogs)"
        ],
        "rule_sql": []
    },
    "981": {
        "db_id": "dog_kennels",
        "question": "Find the number of owners who do not own any dogs at this moment.",
        "ground_truth": "SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs )",
        "amends": [
            "Do use a subquery with `NOT IN` to find owners without dogs instead of checking for `dog_id IS NULL` which incorrectly assumes a direct relationship. Do reference `owner_id` in both the main query and subquery instead of using `dog_id` which doesn't exist in the owners table. Do select from the `Dogs` table in the subquery to identify owners who have dogs instead of omitting this necessary join logic. The amended query now correctly identifies owners without any dogs by checking which owner_ids are not present in the Dogs table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE dog_id IS NULL;",
            "SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN (SELECT DISTINCT owner_id FROM Dogs)"
        ],
        "rule_sql": []
    },
    "982": {
        "db_id": "dog_kennels",
        "question": "How many professionals did not operate any treatment on dogs?",
        "ground_truth": "SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments )",
        "amends": [
            "Do remove the `WHERE animal_type = 'dog'` filter from the subquery instead of keeping it, as the correct logic requires checking for professionals not in any treatments regardless of animal type. Do use consistent table name casing `Professionals` instead of `professionals` to match the schema. The amended query now correctly counts professionals who have not provided any treatments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE professional_id NOT IN (SELECT professional_id FROM treatments WHERE animal_type = 'dog')",
            "SELECT COUNT(*) \nFROM Professionals p\nLEFT JOIN Treatments t ON p.professional_id = t.professional_id\nWHERE t.treatment_id IS NULL;"
        ],
        "rule_sql": []
    },
    "983": {
        "db_id": "dog_kennels",
        "question": "Find the number of professionals who have not treated any dogs.",
        "ground_truth": "SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE professional_id NOT IN (SELECT professional_id FROM treatments)"
        ],
        "rule_sql": []
    },
    "984": {
        "db_id": "dog_kennels",
        "question": "List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.",
        "ground_truth": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",
        "amends": [
            "Do use table name `Dogs` instead of `dogs` to match the correct schema. Do change the filter condition to `abandoned_yn = 1` instead of `abandoned = 0`, using the correct column name and value that properly identifies abandoned dogs. The amended query now correctly selects non-abandoned dogs by checking the abandoned_yn flag set to 1, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age, weight FROM dogs WHERE abandoned = 0;",
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ],
        "rule_sql": []
    },
    "985": {
        "db_id": "dog_kennels",
        "question": "What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.",
        "ground_truth": "SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",
        "amends": [
            "Do reference table `Dogs` instead of `dogs` to match the correct table name. Do change the filter condition to `abandoned_yn = 1` instead of `abandoned = 0` to use the correct column name and value for identifying abandoned dogs. The amended query now correctly selects non-abandoned dogs from the Dogs table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age, weight FROM dogs WHERE abandoned = 0;",
            "SELECT name, age, weight FROM Dogs WHERE abandoned_yn = '1';"
        ],
        "rule_sql": []
    },
    "986": {
        "db_id": "dog_kennels",
        "question": "What is the average age of all the dogs?",
        "ground_truth": "SELECT avg(age) FROM Dogs",
        "amends": [
            "Do select `avg(age)` instead of `AVG(height)` to calculate the average age rather than height. Do reference the table as `Dogs` instead of `dogs` to match the correct case sensitivity. The amended query now correctly calculates the average age from the Dogs table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(height) FROM dogs;",
            "SELECT AVG(age) FROM Dogs;"
        ],
        "rule_sql": []
    },
    "987": {
        "db_id": "dog_kennels",
        "question": "Compute the average age of all the dogs.",
        "ground_truth": "SELECT avg(age) FROM Dogs",
        "amends": [
            "Do reference table `Dogs` instead of `cats` to query the correct data source, and do use lowercase `avg` function instead of uppercase `AVG` for consistent function naming, though this is a cosmetic change that does not affect functionality. The amended query now correctly calculates the average age from the Dogs table instead of the cats table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM cats;",
            "SELECT avg(age) FROM Dogs;"
        ],
        "rule_sql": []
    },
    "988": {
        "db_id": "dog_kennels",
        "question": "What is the age of the oldest dog?",
        "ground_truth": "SELECT max(age) FROM Dogs",
        "amends": [
            "Do use `max(age)` instead of `MIN(age)` to find the maximum age instead of the minimum age. Do capitalize `Dogs` instead of `dogs` to match the correct table name case. The amended query now correctly returns the maximum age from the Dogs table instead of the minimum age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(age) FROM dogs;",
            "SELECT MAX(age) FROM Dogs;"
        ],
        "rule_sql": []
    },
    "989": {
        "db_id": "dog_kennels",
        "question": "Tell me the age of the oldest dog.",
        "ground_truth": "SELECT max(age) FROM Dogs",
        "amends": [
            "Do use `max(age)` instead of `MIN(age)` to calculate the maximum age instead of the minimum age. Do capitalize `Dogs` instead of `dogs` to match the proper table name casing. The amended query now correctly returns the maximum age from the Dogs table instead of the minimum age."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(age) FROM dogs;",
            "SELECT MAX(age) FROM Dogs;"
        ],
        "rule_sql": []
    },
    "990": {
        "db_id": "dog_kennels",
        "question": "How much does each charge type costs? List both charge type and amount.",
        "ground_truth": "SELECT charge_type ,  charge_amount FROM Charges",
        "amends": [
            "Do select `charge_amount` instead of using `SUM(amount)` aggregate function. Do remove the `GROUP BY charge_type` clause instead of keeping it, as the right query retrieves individual records rather than aggregated totals. The amended query now directly selects the charge_amount column from the Charges table without aggregation, matching the right SQL's behavior of returning individual charge records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT charge_type, SUM(amount) FROM charges GROUP BY charge_type;",
            "SELECT charge_type, charge_amount FROM Charges;"
        ],
        "rule_sql": []
    },
    "991": {
        "db_id": "dog_kennels",
        "question": "List each charge type and its amount.",
        "ground_truth": "SELECT charge_type ,  charge_amount FROM Charges",
        "amends": [
            "Do select the `charge_amount` column directly instead of using `SUM(amount)` aggregation. Do reference the table as `Charges` instead of `charges` with proper case sensitivity. Do remove the `GROUP BY charge_type` clause instead of keeping it since no aggregation is needed. The amended query now correctly retrieves individual charge records with their type and amount values rather than attempting to sum amounts by type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT charge_type, SUM(amount) FROM charges GROUP BY charge_type",
            "SELECT charge_type, charge_amount FROM Charges;"
        ],
        "rule_sql": []
    },
    "992": {
        "db_id": "dog_kennels",
        "question": "How much does the most expensive charge type costs?",
        "ground_truth": "SELECT max(charge_amount) FROM Charges",
        "amends": [
            "Do select `max(charge_amount)` instead of `MIN(cost)` to use the maximum aggregation function on the correct column. Do reference table `Charges` instead of `charge_types` to query from the appropriate data source. The amended query now correctly retrieves the maximum charge amount from the Charges table instead of attempting to find the minimum cost from an incorrect table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(cost) FROM charge_types;",
            "SELECT MAX(charge_amount) FROM Charges;"
        ],
        "rule_sql": []
    },
    "993": {
        "db_id": "dog_kennels",
        "question": "What is the charge amount of the most expensive charge type?",
        "ground_truth": "SELECT max(charge_amount) FROM Charges",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(charge_amount) FROM charges WHERE charge_type = (SELECT charge_type FROM charges ORDER BY charge_amount DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "994": {
        "db_id": "dog_kennels",
        "question": "List the email, cell phone and home phone of all the professionals.",
        "ground_truth": "SELECT email_address ,  cell_number ,  home_phone FROM professionals",
        "amends": [
            "Do select `email_address`, `cell_number`, and `home_phone` instead of `email` and `cell_phone`, adding the `home_phone` column instead of omitting it. The amended query now matches RIGHT_SQL's behavior by including all three specified columns from the professionals table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email, cell_phone FROM professionals;",
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ],
        "rule_sql": []
    },
    "995": {
        "db_id": "dog_kennels",
        "question": "What are the email, cell phone and home phone of each professional?",
        "ground_truth": "SELECT email_address ,  cell_number ,  home_phone FROM professionals",
        "amends": [
            "Do select `email_address`, `cell_number`, and `home_phone` instead of `email` and `cell_phone`, adding the `home_phone` column instead of omitting it. The amended query now matches the right SQL's behavior by including all three specified columns from the professionals table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email, cell_phone FROM professionals;",
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ],
        "rule_sql": []
    },
    "996": {
        "db_id": "dog_kennels",
        "question": "What are all the possible breed type and size type combinations?",
        "ground_truth": "SELECT DISTINCT breed_code ,  size_code FROM dogs",
        "amends": [
            "Do select `breed_code` and `size_code` instead of `breed_type` and `size_type`. Do use `DISTINCT` instead of `GROUP BY breed_type, size_type`. The amended query now correctly retrieves unique combinations of breed_code and size_code from the dogs table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT breed_type, size_type FROM dogs GROUP BY breed_type, size_type;",
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ],
        "rule_sql": []
    },
    "997": {
        "db_id": "dog_kennels",
        "question": "Find the distinct breed type and size type combinations for dogs.",
        "ground_truth": "SELECT DISTINCT breed_code ,  size_code FROM dogs",
        "amends": [
            "Do select `breed_code` and `size_code` instead of `breed` and `size`. Do use `DISTINCT` instead of `GROUP BY breed, size`. The amended query now matches the right SQL's behavior by selecting distinct breed and size codes rather than grouping by the original columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT breed, size FROM dogs GROUP BY breed, size",
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ],
        "rule_sql": []
    },
    "998": {
        "db_id": "dog_kennels",
        "question": "List the first name of all the professionals along with the description of the treatment they have done.",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate rows. Do select `T3.treatment_type_description` instead of `treatment_description` from the correct table. Do add `JOIN Treatment_types AS T3` instead of omitting this necessary table. Do use join condition `T1.professional_id = T2.professional_id` instead of `professionals.id = treatments.professional_id` with proper table aliases. Do add second join condition `T2.treatment_type_code = T3.treatment_type_code` instead of omitting this critical relationship. Do use table aliases `T1`, `T2`, and `T3` instead of no aliases for clarity. The amended query now correctly retrieves distinct professional names with their associated treatment type descriptions through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, treatment_description FROM professionals JOIN treatments ON professionals.id = treatments.professional_id;",
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;"
        ],
        "rule_sql": []
    },
    "999": {
        "db_id": "dog_kennels",
        "question": "What are each professional's first name and description of the treatment they have performed?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
        "amends": [
            "Do select `T1.first_name` and `T3.treatment_type_description` instead of `first_name` and `treatment_description`. Do add `DISTINCT` instead of omitting it. Do add `JOIN Treatment_types AS T3` instead of omitting this table. Do change the join condition to `T1.professional_id = T2.professional_id` instead of `professionals.id = treatments.professional_id`. Do add the join condition `T2.treatment_type_code = T3.treatment_type_code` instead of omitting it. The amended query now correctly retrieves distinct professional names with their associated treatment type descriptions by properly joining through the intermediate treatments table to the treatment types reference table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, treatment_description FROM professionals JOIN treatments ON professionals.id = treatments.professional_id",
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code"
        ],
        "rule_sql": []
    },
    "1000": {
        "db_id": "singer",
        "question": "How many singers are there?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `songs` table in the FROM clause. Do count records from the correct table instead of the wrong one. The amended query now correctly counts records from the singer table as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM songs;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": []
    },
    "1001": {
        "db_id": "singer",
        "question": "What is the count of singers?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `singers` table. Do remove the `WHERE age > 100` filter instead of keeping it. The amended query now correctly counts all records in the singer table without any age restriction, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM singers WHERE age > 100;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": []
    },
    "1002": {
        "db_id": "singer",
        "question": "List the name of singers in ascending order of net worth.",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions` instead of `net_worth` and use `ASC` ordering instead of `DESC`. The amended query now correctly references the proper column and table names with the intended ascending order by net worth."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth DESC;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ],
        "rule_sql": []
    },
    "1003": {
        "db_id": "singer",
        "question": "What are the names of singers ordered by ascending net worth?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct case sensitivity. Do reference the `singer` table instead of `singers` to use the correct table name. Do order by `Net_Worth_Millions` instead of `net_worth` to use the correct column name for ordering. The amended query now correctly selects from the proper table with accurate column references and ordering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth ASC;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC;"
        ],
        "rule_sql": []
    },
    "1004": {
        "db_id": "singer",
        "question": "What are the birth year and citizenship of singers?",
        "ground_truth": "SELECT Birth_Year ,  Citizenship FROM singer",
        "amends": [
            "Do reference the table as `singer` instead of `singers` to match the correct table name. Do capitalize column names as `Birth_Year` and `Citizenship` instead of lowercase `birth_year` and `citizenship` to match the correct column naming convention. The WHERE clause remains unchanged as `birth_year > 2000` since the filter logic is correct. The amended query now correctly references the singer table with proper column capitalization.",
            "Do include all records without any filter instead of filtering with `birth_year > 2000` in the WHERE clause. The amended query now matches RIGHT_SQL's behavior by returning all singer records regardless of birth year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_year, citizenship FROM singers WHERE birth_year > 2000;",
            "SELECT Birth_Year, Citizenship FROM singer WHERE birth_year > 2000",
            "SELECT Birth_Year, Citizenship FROM singer"
        ],
        "rule_sql": []
    },
    "1005": {
        "db_id": "singer",
        "question": "What are the birth years and citizenships of the singers?",
        "ground_truth": "SELECT Birth_Year ,  Citizenship FROM singer",
        "amends": [
            "Do reference the table as `singer` instead of `singers` to match the correct table name. Do capitalize column names as `Birth_Year` and `Citizenship` instead of lowercase `birth_year` and `citizenship` to match the correct column naming convention. The WHERE clause condition `birth_year > 2000` remains unchanged as it correctly filters for records after the year 2000. The amended query now correctly references the intended table and columns while preserving the filtering logic.",
            "Do include all records without any filter instead of applying `WHERE Birth_Year > 2000` which incorrectly restricts the results. The amended query now returns all singers regardless of birth year, matching the right SQL's behavior of showing complete data from the singer table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_year, citizenship FROM singers WHERE birth_year > 2000;",
            "SELECT Birth_Year, Citizenship FROM singer WHERE Birth_Year > 2000",
            "SELECT Birth_Year, Citizenship FROM singer"
        ],
        "rule_sql": []
    },
    "1006": {
        "db_id": "singer",
        "question": "List the name of singers whose citizenship is not \"France\".",
        "ground_truth": "SELECT Name FROM singer WHERE Citizenship != \"France\"",
        "amends": [
            "Do reference the table as `singer` instead of `singers` and use the column name `Name` instead of `name`. Do use the inequality filter `!= \"France\"` instead of the equality filter `= 'France'` and reference the column as `Citizenship` instead of `citizenship`. The amended query now correctly selects names of singers who are not French citizens instead of those who are French citizens."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE citizenship = 'France';",
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ],
        "rule_sql": []
    },
    "1007": {
        "db_id": "singer",
        "question": "What are the names of the singers who are not French citizens?",
        "ground_truth": "SELECT Name FROM singer WHERE Citizenship != \"France\"",
        "amends": [
            "Do reference the `Name` column instead of `name` and use table `singer` instead of `singers`. Do filter with `Citizenship != \"France\"` instead of `nationality != 'French'` to match the correct column name and country value format. The amended query now correctly selects from the appropriate table with the proper column references and filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE nationality != 'French';",
            "SELECT Name FROM singer WHERE Citizenship != \"France\";"
        ],
        "rule_sql": []
    },
    "1008": {
        "db_id": "singer",
        "question": "Show the name of singers whose birth year is either 1948 or 1949?",
        "ground_truth": "SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `singer` table instead of `singers` to use the correct table name. Do reference the `Birth_Year` column instead of `birth_year` to match the correct column name. The amended query now correctly selects from the singer table using the proper column names while maintaining the same filtering logic for birth years 1948 and 1949."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE birth_year = 1948 OR birth_year = 1949;",
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ],
        "rule_sql": []
    },
    "1009": {
        "db_id": "singer",
        "question": "What are the names of the singers whose birth years are either 1948 or 1949?",
        "ground_truth": "SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do reference the `singer` table instead of `singers` to use the correct table name. Do reference the `Birth_Year` column instead of `birth_year` to match the correct column name capitalization. The amended query now correctly references the proper table and column names while maintaining the same filtering logic for birth years 1948 and 1949."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE birth_year = 1948 OR birth_year = 1949;",
            "SELECT Name FROM singer WHERE Birth_Year = 1948 OR Birth_Year = 1949;"
        ],
        "rule_sql": []
    },
    "1010": {
        "db_id": "singer",
        "question": "What is the name of the singer with the largest net worth?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions DESC` instead of `net_worth ASC` to sort by the correct column name in descending order rather than ascending. The amended query now correctly retrieves the singer with the highest net worth from the proper table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth ASC LIMIT 1;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1011": {
        "db_id": "singer",
        "question": "What is the name of the singer who is worth the most?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions` instead of `net_worth` to use the proper column name for sorting by net worth in millions. The amended query now correctly selects from the singer table and orders by the appropriate net worth column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth DESC LIMIT 1;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1012": {
        "db_id": "singer",
        "question": "Show different citizenship of singers and the number of singers of each citizenship.",
        "ground_truth": "SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do reference the `Citizenship` column instead of `citizenship` to match the correct column name. Do group by `Citizenship` instead of `singer_id` to properly aggregate counts by citizenship rather than by individual singers. Do reference the `singer` table instead of `singers` to use the correct table name. The amended query now correctly counts singers grouped by their citizenship rather than producing counts per individual singer ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) FROM singers GROUP BY singer_id;",
            "SELECT Citizenship, COUNT(*) AS Number_of_Singers FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": []
    },
    "1013": {
        "db_id": "singer",
        "question": "For each citizenship, how many singers are from that country?",
        "ground_truth": "SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do reference the correct table name `singer` instead of `singers` in the FROM clause. Do use the correct column name `Citizenship` instead of `country` in both the SELECT list and GROUP BY clause, ensuring the aggregation aligns with the grouping criteria. Do maintain the COUNT(*) aggregation to preserve the row counting functionality while correcting the underlying table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Citizenship, COUNT(*) FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": []
    },
    "1014": {
        "db_id": "singer",
        "question": "Please show the most common citizenship of singers.",
        "ground_truth": "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `Citizenship` instead of `citizenship` for the column name and change the table reference to `singer` instead of `singers`. Do order by `COUNT(*) DESC` instead of `count ASC` to find the most common citizenship rather than the least common. Do remove the alias `count` from the SELECT clause instead of keeping it since it's not needed in the final output. Do maintain the `GROUP BY Citizenship` and `LIMIT 1` structure to return the single most frequent citizenship value. The amended query now correctly identifies the most common citizenship among singers rather than the least common."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM singers GROUP BY citizenship ORDER BY count ASC LIMIT 1;",
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "1015": {
        "db_id": "singer",
        "question": "What is the most common singer citizenship ?",
        "ground_truth": "select citizenship from singer group by citizenship order by count(*) desc limit 1",
        "amends": [
            "Do order by `count(*) desc` instead of `count ASC` to find the most common citizenship rather than the least common. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, as only the citizenship value is needed in the final result. Do keep the `GROUP BY citizenship` and `LIMIT 1` clauses unchanged. The amended query now correctly returns the most frequent citizenship among singers instead of the least frequent."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM singers GROUP BY citizenship ORDER BY count ASC LIMIT 1;",
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1016": {
        "db_id": "singer",
        "question": "Show different citizenships and the maximum net worth of singers of each citizenship.",
        "ground_truth": "SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do use column name `Net_Worth_Millions` instead of `net_worth` to match the actual column schema. Do use table name `singer` instead of `singers` to reference the correct table. Do use proper case `Citizenship` instead of `citizenship` for the grouping column to maintain consistency with the schema. The amended query now correctly aggregates maximum net worth by citizenship using the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship, MAX(net_worth) FROM singers GROUP BY citizenship;",
            "SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": []
    },
    "1017": {
        "db_id": "singer",
        "question": "For each citizenship, what is the maximum net worth?",
        "ground_truth": "SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do use `max(Net_Worth_Millions)` instead of `MIN(net_worth) as max_net_worth` to correctly calculate the maximum value rather than the minimum. Do reference `Citizenship` instead of `citizenship` to match the correct column name. Do remove the alias `max_net_worth` instead of keeping it since the right query doesn't include an alias. Do use table `singer` instead of `people` to query from the correct data source. The amended query now correctly calculates the maximum net worth by citizenship from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship, MIN(net_worth) as max_net_worth FROM people GROUP BY citizenship;",
            "SELECT Citizenship, MAX(Net_Worth_Millions) FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": []
    },
    "1018": {
        "db_id": "singer",
        "question": "Show titles of songs and names of singers.",
        "ground_truth": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",
        "amends": [
            "Do specify explicit table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with an explicit `ON T1.Singer_ID = T2.Singer_ID` condition instead of querying a single table without joins. Do reference columns with table aliases as `T2.Title` and `T1.Name` instead of unqualified `title` and `name`. Do query from the `singer` table as `T1` and `song` table as `T2` instead of only the `songs` table. The amended query now correctly joins the singer and song tables to retrieve song titles with corresponding singer names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, name FROM songs",
            "SELECT T2.Title, T1.Name FROM singer T1 JOIN song T2 ON T1.Singer_ID = T2.Singer_ID"
        ],
        "rule_sql": []
    },
    "1019": {
        "db_id": "singer",
        "question": "What are the song titles and singer names?",
        "ground_truth": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference columns as `T2.Title` and `T1.Name` instead of `title` and `name`. Do join `singer AS T1` to `song AS T2` instead of `songs` to `singers`. Do use the join condition `T1.Singer_ID = T2.Singer_ID` instead of `songs.singer_id = singers.id`. The amended query now correctly matches the intended behavior with proper table references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, name FROM songs JOIN singers ON songs.singer_id = singers.id",
            "SELECT T2.Title, T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID"
        ],
        "rule_sql": []
    },
    "1020": {
        "db_id": "singer",
        "question": "Show distinct names of singers that have songs with sales more than 300000.",
        "ground_truth": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000",
        "amends": [
            "Do use `DISTINCT T1.Name` instead of just `name` to eliminate duplicate singer names. Do join `singer AS T1` with `song AS T2` instead of querying only the singers table. Do specify the join condition `ON T1.Singer_ID = T2.Singer_ID` instead of missing the table relationship entirely. Do filter on `T2.Sales > 300000` instead of `sales > 300000` to correctly reference song sales rather than singer sales. The amended query now properly identifies singers who have songs with sales exceeding 300,000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE sales > 300000",
            "SELECT DISTINCT T1.Name \nFROM singer AS T1 \nJOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nWHERE T2.Sales > 300000"
        ],
        "rule_sql": []
    },
    "1021": {
        "db_id": "singer",
        "question": "what are the different names of the singers that have sales more than 300000?",
        "ground_truth": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000",
        "amends": [
            "Do use `DISTINCT T1.Name` instead of just `name` to eliminate duplicate singer names. Do join `singer AS T1` with `song AS T2` instead of querying only the `singers` table. Do specify the join condition `ON T1.Singer_ID = T2.Singer_ID` instead of missing the table relationship entirely. Do filter on `T2.Sales > 300000` instead of `sales > 300000` to correctly reference the song sales column rather than an ambiguous or non-existent singers sales column. The amended query now properly identifies singers who have songs with sales exceeding 300,000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE sales > 300000",
            "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
        ],
        "rule_sql": []
    },
    "1022": {
        "db_id": "singer",
        "question": "Show the names of singers that have more than one song.",
        "ground_truth": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do add table `song` with a `JOIN` on `singer.Singer_ID = song.Singer_ID` instead of querying only the `singers` table. Do change the source to `singer AS T1` instead of `singers`. Do use `GROUP BY T1.Name` with `HAVING COUNT(*) > 1` instead of filtering `song_count > 1` in the `WHERE` clause. Do select `T1.Name` with proper table qualification instead of just `name`. The amended query now correctly counts songs per singer and filters for those with more than one song, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE song_count > 1;",
            "SELECT T1.Name FROM singer AS T1 JOIN song ON T1.Singer_ID = song.Singer_ID GROUP BY T1.Name HAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "1023": {
        "db_id": "singer",
        "question": "What are the names of the singers that have more than one songs?",
        "ground_truth": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do join `singer` and `song` tables on `Singer_ID` instead of querying only the `singers` table without proper table relationships. Do use `GROUP BY T1.Name` with `HAVING COUNT(*) > 1` instead of applying the aggregate function `COUNT(songs)` directly in the `WHERE` clause without grouping. Do reference the joined table columns with proper aliases `T1.Name` instead of just `name` from an unspecified source. Do count all rows with `COUNT(*)` instead of attempting to count a specific column `songs` that may not exist in the schema. The amended query now correctly identifies singers who have more than one song by properly joining the related tables and using aggregate filtering in the HAVING clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE COUNT(songs) > 1",
            "SELECT T1.Name \nFROM singer T1\nJOIN song T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T1.Name\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": []
    },
    "1024": {
        "db_id": "singer",
        "question": "Show the names of singers and the total sales of their songs.",
        "ground_truth": "SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",
        "amends": [
            "Do reference `T1.Name` and `sum(T2.Sales)` instead of `singer_name` and `SUM(sales)`. Do join `singer AS T1` with `song AS T2` on `T1.Singer_ID = T2.Singer_ID` instead of querying only the `songs` table. Do group by `T1.Name` instead of `singer_name`. The amended query now correctly aggregates sales by singer name using the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT singer_name, SUM(sales) FROM songs GROUP BY singer_name;",
            "SELECT T1.Name, SUM(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name"
        ],
        "rule_sql": []
    },
    "1025": {
        "db_id": "singer",
        "question": "For each singer name, what is the total sales for their songs?",
        "ground_truth": "SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",
        "amends": [
            "Do reference `T1.Name` and `sum(T2.Sales)` instead of `singer_name` and `SUM(sales)`. Do join `singer AS T1` with `song AS T2` on `T1.Singer_ID = T2.Singer_ID` instead of querying only the `songs` table. Do use explicit table aliases and proper join conditions instead of omitting the table relationship. The amended query now correctly aggregates sales by singer name through the proper table relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT singer_name, SUM(sales) FROM songs GROUP BY singer_name;",
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer AS T1 \nJOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name"
        ],
        "rule_sql": []
    },
    "1026": {
        "db_id": "singer",
        "question": "List the name of singers that do not have any song.",
        "ground_truth": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "amends": [
            "Do select `Name` from `singer` instead of `name` from `singers`. Do use a `NOT IN` subquery checking for `Singer_ID` values that exist in the `song` table instead of filtering with `song_id IS NULL`. Do reference the correct table name `singer` instead of `singers` and use the proper column `Singer_ID` for the correlation instead of the incorrect `song_id` field. The amended query now correctly identifies singers who have no associated songs by checking for missing relationships in the song table rather than relying on null values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM singers WHERE song_id IS NULL;",
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ],
        "rule_sql": []
    },
    "1027": {
        "db_id": "singer",
        "question": "What is the sname of every sing that does not have any song?",
        "ground_truth": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "amends": [
            "Do select `Name` from the `singer` table instead of `sname` from `sing`. Do use a `WHERE` clause with `Singer_ID NOT IN` subquery instead of checking `song_id IS NULL`. Do reference the correct table name `singer` instead of `sing`. Do use the proper column name `Singer_ID` in both the main query and subquery instead of `song_id`. Do include a correlated subquery that checks for singers without songs in the `song` table instead of simply checking for null values. The amended query now correctly identifies singers who have no associated songs by using a NOT IN subquery rather than a simple null check."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sname FROM sing WHERE song_id IS NULL;",
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ],
        "rule_sql": []
    },
    "1028": {
        "db_id": "singer",
        "question": "Show the citizenship shared by singers with birth year before 1945 and after 1955.",
        "ground_truth": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "amends": [
            "Do use `INTERSECT` to find common citizenships instead of `OR` which would return all records matching either condition. Do reference the correct table name `singer` instead of `singers`. Do use proper column names `Citizenship` and `Birth_Year` with correct capitalization instead of lowercase `citizenship` and `birth_year`. Do split into two separate queries with `INTERSECT` to find citizenships that appear in both the pre-1945 and post-1955 birth year groups instead of using a single query with `OR` that returns citizenships from either group independently. The amended query now correctly identifies only those citizenships that have singers born both before 1945 AND after 1955, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT citizenship FROM singers WHERE birth_year < 1945 OR birth_year > 1955;",
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ],
        "rule_sql": []
    },
    "1029": {
        "db_id": "singer",
        "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
        "ground_truth": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "amends": [
            "Do use `INTERSECT` between two separate queries instead of `OR` in a single query. Do reference `Citizenship` with proper capitalization instead of lowercase `citizenship`. Do use table name `singer` instead of plural `singers`. Do remove `DISTINCT` since `INTERSECT` inherently returns distinct values instead of keeping it. Do maintain the same column selection `Citizenship` but with proper case handling. Do split the birth year conditions into separate queries with `Birth_Year < 1945` and `Birth_Year > 1955` instead of combining them with `OR`. The amended query now correctly finds citizenships that appear in both the pre-1945 and post-1955 birth year groups, matching the RIGHT_SQL's intersection behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT citizenship \nFROM singers \nWHERE birth_year < 1945 OR birth_year > 1955;",
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ],
        "rule_sql": []
    },
    "1030": {
        "db_id": "real_estate_properties",
        "question": "How many available features are there in total?",
        "ground_truth": "SELECT count(*) FROM Other_Available_Features",
        "amends": [
            "Do reference the `Other_Available_Features` table instead of the `features` table. Do filter for available status with `status = 'available'` instead of unavailable status with `status = 'unavailable'`. The amended query now correctly counts available features from the appropriate table, matching the intended behavior.",
            "Do remove the `WHERE status = 'available'` filter instead of keeping it, and do remove the `AS total_available_features` alias instead of including it. The amended query now counts all rows in the Other_Available_Features table without any status filtering, matching the behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM features WHERE status = 'unavailable';",
            "SELECT COUNT(*) AS total_available_features FROM Other_Available_Features WHERE status = 'available'",
            "SELECT COUNT(*) FROM Other_Available_Features;"
        ],
        "rule_sql": []
    },
    "1031": {
        "db_id": "real_estate_properties",
        "question": "What is the feature type name of feature AirCon?",
        "ground_truth": "SELECT T2.feature_type_name FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2 ON T1.feature_type_code  =  T2.feature_type_code WHERE T1.feature_name  =  \"AirCon\"",
        "amends": [
            "Do select `T2.feature_type_name` instead of `feature_name`. Do use `FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2` instead of `FROM features`. Do apply join condition `ON T1.feature_type_code = T2.feature_type_code` instead of no join. Do filter with `WHERE T1.feature_name = \"AirCon\"` instead of `WHERE feature_type = 'AirCon'`. The amended query now correctly joins reference tables to retrieve the feature type name rather than the feature name itself, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT feature_name FROM features WHERE feature_type = 'AirCon';",
            "SELECT T2.feature_type_name \nFROM Other_Available_Features AS T1 \nJOIN Ref_Feature_Types AS T2 ON T1.feature_type_code = T2.feature_type_code \nWHERE T1.feature_name = 'AirCon'"
        ],
        "rule_sql": []
    },
    "1032": {
        "db_id": "real_estate_properties",
        "question": "Show the property type descriptions of properties belonging to that code.",
        "ground_truth": "SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code",
        "amends": [
            "Do select `T2.property_type_description` from the joined table instead of directly selecting `property_type_description` from the base table. Do add a `JOIN` with `Ref_Property_Types AS T2` on `T1.property_type_code = T2.property_type_code` instead of querying only the `properties` table. Do use `GROUP BY T1.property_type_code` to aggregate results instead of filtering by `property_code = 'that code'`. Do remove the `WHERE` clause filter entirely instead of keeping the specific property code condition. The amended query now correctly retrieves property type descriptions by joining with the reference table and grouping by type code rather than filtering for a single specific property."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT property_type_description FROM properties WHERE property_code = 'that code';",
            "SELECT T2.property_type_description \nFROM Properties AS T1\nJOIN Ref_Property_Types AS T2 ON T1.property_type_code = T2.property_type_code\nGROUP BY T1.property_type_code"
        ],
        "rule_sql": []
    },
    "1033": {
        "db_id": "real_estate_properties",
        "question": "What are the names of properties that are either houses or apartments with more than 1 room?",
        "ground_truth": "SELECT property_name FROM Properties WHERE property_type_code  =  \"House\" UNION SELECT property_name FROM Properties WHERE property_type_code  =  \"Apartment\" AND room_count  >  1",
        "amends": [
            "Do select `property_name` instead of `name` and use `UNION` to combine results instead of `OR` logic. Do reference table `Properties` instead of `properties` and use column `property_type_code` instead of `type`. Do use exact string values `\"House\"` and `\"Apartment\"` instead of `'house'` and `'apartment'`. Do use column `room_count` instead of `rooms` and apply the `room_count > 1` filter only to the apartment condition instead of applying it to both house and apartment conditions. The amended query now correctly separates the house selection (without room count restriction) from the apartment selection (with room count requirement) using UNION, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM properties WHERE type = 'house' OR type = 'apartment' AND rooms > 1;",
            "SELECT property_name FROM Properties WHERE property_type_code = 'House' UNION SELECT property_name FROM Properties WHERE property_type_code = 'Apartment' AND room_count > 1"
        ],
        "rule_sql": []
    }
}