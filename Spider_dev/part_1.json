{
    "268": {
        "db_id": "employee_hire_evaluation",
        "question": "How many shops are there in each location?",
        "ground_truth": "SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",
        "amends": [
            "Do select `count(*)` and `LOCATION` instead of `location` and `COUNT(*)`. Do use `GROUP BY LOCATION` instead of `GROUP BY shop_id`. Do reference table `shop` instead of `shops`. The amended query now correctly groups by location and counts records per location rather than incorrectly grouping by shop_id while selecting location.",
            "Do place `count(*)` before `LOCATION` in the SELECT list instead of after it, maintaining the same aggregation logic. Do keep the `GROUP BY LOCATION` clause unchanged as it correctly groups by location. The amended query now matches RIGHT_SQL's behavior with identical output results."
        ],
        "rules": [
            "1) When the question asks for \"count of shops\" per location: compute the number of rows using the canonical key from the shop table. 2) When the question mentions \"location\": use the exact column token \"LOCATION\" with the correct case. 3) When the question asks for results \"per location\": organize results by grouping on the exact column \"LOCATION\". 4) When referring to the shops table: use the exact table name \"shop\" instead of \"shops\". 5) When producing output columns: maintain the order of location first followed by count.",
            "1) When answering about \"shops in each location\": make sure the output order: count of shops first, then location\n2) When the question asks for \"count of shops\": compute the number of rows using the canonical key for shops\n3) When the question says \"per location\"/\"by location\": organize results by the LOCATION column and compute count per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM shops GROUP BY shop_id;",
            "SELECT LOCATION, COUNT(*) FROM shop GROUP BY LOCATION;",
            "SELECT count(*), LOCATION FROM shop GROUP BY LOCATION"
        ],
        "rule_sql": [
            "SELECT Location, COUNT(Shop_ID) AS count_of_shops FROM shop GROUP BY Location ORDER BY count_of_shops DESC, Location;"
        ]
    },
    "743": {
        "db_id": "world_1",
        "question": "Which continent speaks the most languages?",
        "ground_truth": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do reference the `country` table as `T1` and `countrylanguage` as `T2` instead of using `country_languages`. Do join `T1.Code = T2.CountryCode` instead of grouping by `continent` directly. Do select `T1.Continent` instead of both `continent` and `language_count`. Do use `COUNT(*)` in the ORDER BY instead of the aliased `language_count`. Do remove the explicit column alias `language_count` instead of keeping it. The amended query now correctly joins the country and countrylanguage tables to count languages per continent and returns the continent with the highest count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which continent speaks the most languages\": make sure the output order: T1.Continent. 2) When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"count of languages per continent\": compute the number of rows using COUNT(*) and organize results by T1.Continent. 4) When the question mentions \"most languages\": rank rows by COUNT(*) in descending direction and keep the first 1 row. 5) When producing output: do not include explicit column aliases like language_count; only include T1.Continent."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(language) as language_count FROM country_languages GROUP BY continent ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Continent\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Continent\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "365": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all paragraph texts for the document \"Customer reviews\".",
        "ground_truth": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"",
        "amends": [
            "Do reference `paragraph_text` instead of `text` in the SELECT list. Do join `Documents AS T2` instead of omitting it, using `LEFT JOIN` on `T1.document_id = T2.document_id` instead of no join condition. Do filter on `T2.document_name = \"Customer reviews\"` instead of `document_title = 'Customer reviews'` in the WHERE clause. The amended query now correctly retrieves paragraph text by joining through the document relationship rather than relying on a non-existent title column in the paragraphs table."
        ],
        "rules": [
            "1) When the question asks for paragraph texts: select \"paragraph_text\" from table T1 instead of \"text\". 2) When joining tables for document relationships: combine T1 (paragraphs) and T2 (Documents) using LEFT JOIN where T1.document_id equals T2.document_id. 3) When filtering for document name \"Customer reviews\": use T2.document_name = \"Customer reviews\" instead of document_title = 'Customer reviews'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT text FROM paragraphs WHERE document_title = 'Customer reviews';",
            "SELECT p.Paragraph_Text \nFROM Paragraphs p\nLEFT JOIN Documents d ON p.Document_ID = d.Document_ID\nWHERE d.Document_Name = 'Customer reviews'"
        ],
        "rule_sql": [
            "SELECT p.Paragraph_Text \nFROM Paragraphs p \nLEFT JOIN Documents d ON p.Document_ID = d.Document_ID \nWHERE d.Document_Name = 'Customer reviews'"
        ]
    },
    "299": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "List document IDs, document names, and document descriptions for all documents.",
        "ground_truth": "SELECT document_id ,  document_name ,  document_description FROM Documents",
        "amends": [
            "Do add `document_description` to the SELECT list instead of omitting it. Do reference the table as `Documents` instead of `documents` to match the correct case. The amended query now includes all required columns and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"List document IDs, document names, and document descriptions for all documents\": make sure the output order: document_id, document_name, document_description. 2) When the question mentions \"document IDs\": \"document IDs\" actually means \"document_id in schema\". 3) When the question mentions \"document names\": \"document names\" actually means \"document_name in schema\". 4) When the question mentions \"document descriptions\": \"document descriptions\" actually means \"document_description in schema\". 5) When referencing the documents table: use the exact identifier \"Documents\" with the correct case instead of \"documents\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, document_name FROM documents;",
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents;"
        ],
        "rule_sql": [
            "SELECT Document_ID, Document_Name, Document_Description FROM Documents ORDER BY Document_ID;"
        ]
    },
    "130": {
        "db_id": "car_1",
        "question": "What are the names of all European countries with at least 3 manufacturers?",
        "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
        "amends": [
            "Do use `T1.CountryName` instead of `c.name` for the SELECT column. Do join `CONTINENTS AS T2` on `T1.Continent = T2.ContId` instead of omitting this table entirely. Do join `CAR_MAKERS AS T3` on `T1.CountryId = T3.Country` instead of joining `manufacturers m` on `c.id = m.country_id`. Do filter on `T2.Continent = 'europe'` instead of `c.continent = 'Europe'`. Do use `count(*) >= 3` instead of `COUNT(m.id) > 2` in the HAVING clause. The amended query now correctly joins through the continents table and uses proper threshold comparison for counting car makers per European country."
        ],
        "rules": [
            "1) When answering about European countries with manufacturers: make sure the output order: T1.CountryName. 2) When the question mentions \"European countries\": filter for T2.Continent = 'europe' exactly as shown. 3) When combining T1 and T2 for shared entities: link rows where T1.Continent = T2.ContId and keep only matching pairs. 4) When combining T1 and T3 for shared entities: link rows where T1.CountryId = T3.Country and keep only matching pairs. 5) When the question asks for countries with at least 3 manufacturers: count using count(*) >= 3 instead of counting specific columns. 6) When grouping by country: organize results by T1.CountryName and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name \nFROM countries c \nJOIN manufacturers m ON c.id = m.country_id \nWHERE c.continent = 'Europe' \nGROUP BY c.name \nHAVING COUNT(m.id) > 2;",
            "SELECT T1.CountryName\nFROM countries AS T1\nJOIN continents AS T2 ON T1.Continent = T2.ContId\nJOIN car_makers AS T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T1.CountryName\nFROM countries T1\nJOIN continents T2 ON T1.Continent = T2.ContId\nJOIN car_makers T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3\nORDER BY T1.CountryName;"
        ]
    },
    "999": {
        "db_id": "dog_kennels",
        "question": "What are each professional's first name and description of the treatment they have performed?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
        "amends": [
            "Do select `T1.first_name` and `T3.treatment_type_description` instead of `first_name` and `treatment_description`. Do add `DISTINCT` instead of omitting it. Do add `JOIN Treatment_types AS T3` instead of omitting this table. Do change the join condition to `T1.professional_id = T2.professional_id` instead of `professionals.id = treatments.professional_id`. Do add the join condition `T2.treatment_type_code = T3.treatment_type_code` instead of omitting it. The amended query now correctly retrieves distinct professional names with their associated treatment type descriptions by properly joining through the intermediate treatments table to the treatment types reference table."
        ],
        "rules": [
            "1) When the question asks for \"each professional's first name\": select \"T1\".\"first_name\" exactly as shown in the schema. 2) When the question asks for \"description of the treatment they have performed\": select \"T3\".\"treatment_type_description\" instead of \"treatment_description\". 3) When retrieving information about professionals and their treatments: join \"Professionals\" as T1 to \"treatments\" as T2 using \"T1\".\"professional_id\" = \"T2\".\"professional_id\". 4) When needing treatment type descriptions: join \"Treatment_types\" as T3 to T2 using \"T2\".\"treatment_type_code\" = \"T3\".\"treatment_type_code\". 5) When the question asks for \"each professional\": use DISTINCT to ensure each professional appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, treatment_description FROM professionals JOIN treatments ON professionals.id = treatments.professional_id",
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T3.treatment_type_description\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;"
        ]
    },
    "581": {
        "db_id": "student_transcripts_tracking",
        "question": "Describe the section h.",
        "ground_truth": "SELECT section_description FROM Sections WHERE section_name  =  'h'",
        "amends": [
            "Do select only `section_description` instead of all columns with `*`. Do reference the table as `Sections` (case-sensitive) instead of `sections`. The amended query now correctly retrieves only the section description from the specified table while maintaining the same filter condition."
        ],
        "rules": [
            "1) When the question asks to describe a specific section: select only the \"section_description\" column instead of all columns. 2) When referencing the Sections table: use the exact case-sensitive identifier \"Sections\" instead of lowercase \"sections\". 3) When filtering for a specific section: use the exact literal value 'h' to match the section name condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM sections WHERE section_name = 'h';",
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ],
        "rule_sql": [
            "SELECT section_description FROM Sections WHERE section_name = 'h';"
        ]
    },
    "892": {
        "db_id": "network_1",
        "question": "How many friends does the high school student Kyle have?",
        "ground_truth": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do join `Highschooler` table instead of omitting it, and do use `JOIN` with `T1.student_id = T2.id` instead of querying `friends` table directly. Do filter on `T2.name = 'Kyle'` instead of filtering on `student_name = 'Kyle'` and do remove the `school_level = 'high school'` filter instead of keeping it, since the join to `Highschooler` table inherently provides the correct high school context. The amended query now correctly counts friends by joining through proper table relationships rather than relying on potentially incorrect direct column references."
        ],
        "rules": [
            "1) When answering about \"how many friends does the high school student Kyle have\": make sure the output order: COUNT of friends. 2) When the question mentions \"Kyle\": \"Kyle\" actually means \"T2.name = 'Kyle'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of friends\": compute the number of rows using the canonical key token for friends relationships. 5) When the question mentions \"high school student\": this context is inherently provided by joining the Highschooler table (T2) and does not require an explicit school_level filter."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE student_name = 'Kyle' AND school_level = 'high school';",
            "SELECT COUNT(*) \nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Friend f\nJOIN Highschooler h ON f.student_id = h.ID\nWHERE h.name = 'Kyle'"
        ]
    },
    "893": {
        "db_id": "network_1",
        "question": "Count the number of friends Kyle has.",
        "ground_truth": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do add `JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of querying only the `friends` table. Do change the filter to `T2.name = \"Kyle\"` instead of `name = 'Kyle'` since the name column exists in the Highschooler table rather than the friends table. Do use proper table aliasing with `Friend AS T1` instead of the bare table name. The amended query now correctly joins the necessary tables to access the name information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of friends Kyle has\": make sure the output order: count of friends. 2) When the question mentions \"friends\": \"friends\" actually means \"rows in the Friend table (T1)\". 3) When the question mentions \"Kyle\": \"Kyle\" actually means \"T2.name = 'Kyle'\" in the Highschooler table. 4) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of friends\": compute the number of rows using the canonical key token for friends (T1.student_id)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM friends WHERE name = 'Kyle';",
            "SELECT COUNT(*) \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nWHERE T2.name = 'Kyle'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.name = 'Kyle'"
        ]
    },
    "640": {
        "db_id": "tvshow",
        "question": "What is the pixel aspect ratio and country of origin for all TV channels that do not use English?",
        "ground_truth": "SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",
        "amends": [
            "Do use column name `Pixel_aspect_ratio_PAR` instead of `pixel_aspect_ratio` and `country` instead of `country_of_origin` in the SELECT list. Do reference table `tv_channel` instead of `tv_channels` in the FROM clause. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [
            "1) When selecting pixel aspect ratio information: use column name \"Pixel_aspect_ratio_PAR\" exactly as shown in the schema. 2) When selecting country information: use column name \"country\" instead of \"country_of_origin\". 3) When referencing the TV channels table: use table name \"tv_channel\" instead of \"tv_channels\". 4) When filtering for non-English language channels: use condition language != 'English' with exact literal 'English'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pixel_aspect_ratio, country_of_origin FROM tv_channels WHERE language != 'English';",
            "SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';"
        ],
        "rule_sql": [
            "SELECT Pixel_aspect_ratio_PAR, Country FROM tv_channel WHERE Language != 'English';"
        ]
    },
    "470": {
        "db_id": "wta_1",
        "question": "What are the first names of all players, and their average rankings?",
        "ground_truth": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do reference `avg(ranking)` from the joined `rankings` table instead of attempting to average a column that doesn't exist in the original table. Do use table aliases `T1` and `T2` with qualified column references instead of unqualified column names. Do group by the qualified `T1.first_name` instead of the unqualified `first_name`. The amended query now correctly calculates average rankings by joining the necessary tables and matches the RIGHT_SQL's behavior.",
            "Do place `T1.first_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(ranking)` without an alias instead of `AVG(T2.ranking) AS average_ranking`. Do maintain the same `JOIN` on `T1.player_id = T2.player_id` and `GROUP BY T1.first_name` structure. The amended query now correctly calculates the average ranking per first name while maintaining the same logical behavior.",
            "Do place `avg(ranking)` first in the SELECT list instead of `T1.first_name`, and do remove the table alias from `first_name` instead of keeping it as `T1.first_name`. Do add the `AS` keyword for table aliases instead of omitting it, and do use consistent spacing around the equals operator in the join condition instead of inconsistent spacing. The grouping logic remains identical with `GROUP BY T1.first_name` in both queries. The amended query now correctly calculates the average ranking while maintaining proper SQL syntax and formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"first names of all players and their average rankings\": make sure the output order: T1.first_name, avg(T2.ranking). 2) When combining players table (T1) and rankings table (T2): link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 3) When the question asks for \"average rankings\": compute the average of T2.ranking values per group. 4) When the question says \"by first names\": organize results by T1.first_name and compute requested aggregates per group. 5) When using table aliases: use T1 for players table and T2 for rankings table with qualified column references.",
            "1) When answering about \"first names of all players and their average rankings\": make sure the output order: average ranking first, then first name. 2) When computing average rankings: use lowercase \"avg(ranking)\" without an alias instead of \"AVG(T2.ranking) AS average_ranking\". 3) When combining players table T1 and rankings table T2: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 4) When grouping by first name: organize results by T1.first_name and compute average ranking per group.",
            "1) When answering about \"first names of all players and their average rankings\": make sure the output order: average ranking first, then first name. 2) When selecting columns from the players table: use \"first_name\" without table alias instead of \"T1.first_name\". 3) When calculating average rankings: use \"avg(ranking)\" as the first output column. 4) When joining players and rankings tables: use consistent spacing around the equals operator in the join condition \"T1.player_id = T2.player_id\". 5) When grouping results by first name: use \"GROUP BY T1.first_name\" to organize results by player first names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, AVG(ranking) FROM players GROUP BY first_name;",
            "SELECT T1.first_name, AVG(T2.ranking) AS average_ranking\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT T1.first_name, avg(T2.ranking) FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name",
            "SELECT avg(ranking), T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT avg(ranking), first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ]
    },
    "281": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the names of employees who never won any award in the evaluation.",
        "ground_truth": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "amends": [
            "Do select `name` from `employee` instead of `employees` as the table source. Do use a `NOT IN` subquery filtering by `Employee_ID` from the `evaluation` table instead of a simple `WHERE award_count > 0` condition. Do remove the incorrect `award_count` filter and instead implement the proper exclusion logic based on employee evaluations. The amended query now correctly identifies employees who have not been evaluated by checking for their absence in the evaluation table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting employee names: use the exact table name \"employee\" instead of \"employees\" and select the \"name\" column. 2) When identifying employees who never won any award in the evaluation: use a NOT IN subquery that filters by \"Employee_ID\" from the \"evaluation\" table instead of checking award_count. 3) When combining employee and evaluation data: use \"Employee_ID\" as the matching key between tables, where employee.Employee_ID is not found in evaluation.Employee_ID. 4) When handling employee identifiers: use the exact column name \"Employee_ID\" with proper case and formatting as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE award_count > 0;",
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ],
        "rule_sql": [
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ]
    },
    "944": {
        "db_id": "dog_kennels",
        "question": "What are the first name and last name of the professionals who have done treatment with cost below average?",
        "ground_truth": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate professional records. Do reference columns with table aliases `T1.first_name` and `T1.last_name` instead of unqualified column names. Do join `Professionals AS T1` with `Treatments AS T2` instead of querying only the Professionals table. Do filter on `cost_of_treatment` instead of `treatment_cost` to use the correct column name from the Treatments table. Do compare against the average `cost_of_treatment` instead of `treatment_cost` in the subquery to maintain consistency. The amended query now correctly identifies professionals whose treatment costs are below average by properly joining the relevant tables and using the correct column references.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the alias qualification from `cost_of_treatment` in the WHERE clause instead of keeping `T2.cost_of_treatment`. The amended query now correctly filters professionals based on treatment costs below the average without unnecessary join predicates and matches the RIGHT_SQL's behavior.",
            "Do remove the `ON T1.professional_id = T2.professional_id` join condition instead of including it, and do remove the table alias `T2.` from `cost_of_treatment` in the WHERE clause instead of keeping it. The amended query now correctly joins without an explicit condition and references the column directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about professionals who have done treatment with cost below average: make sure the output order: first_name, last_name. 2) When the question mentions \"professionals\": \"professionals\" actually means \"Professionals AS T1\" in schema. 3) When the question mentions \"treatment with cost\": \"treatment cost\" actually means \"T2.cost_of_treatment\" in schema. 4) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal as shown in the amends; keep only matching pairs (inner match). 5) When filtering for cost below average: compare T2.cost_of_treatment against the average of T2.cost_of_treatment from all treatments. 6) When selecting professional information: use T1.first_name and T1.last_name with DISTINCT to remove duplicate professional records.",
            "1) When joining Professionals and Treatments tables: do not include any join condition between T1.professional_id and T2.professional_id, instead perform a cartesian product between the tables. 2) When filtering by cost_of_treatment below average: use the unqualified column name \"cost_of_treatment\" in the WHERE clause instead of the aliased form T2.cost_of_treatment. 3) When calculating the average cost of treatment: compute the average of the \"cost_of_treatment\" column from the Treatments table without any table alias qualification.",
            "1) When joining Professionals (T1) and Treatments tables: do not use any explicit join condition between T1.professional_id and T2.professional_id, instead perform a cross join without specified conditions. 2) When referencing the cost_of_treatment column in the WHERE clause: use the column name directly without table alias prefix (use cost_of_treatment instead of T2.cost_of_treatment). 3) When filtering for treatments with cost below average: compare cost_of_treatment against the average cost calculated from all treatments using (SELECT AVG(cost_of_treatment) FROM Treatments)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM professionals WHERE treatment_cost < (SELECT AVG(treatment_cost) FROM treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1\nJOIN Treatments AS T2\nWHERE T2.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM Professionals AS T1, Treatments AS T2\nWHERE cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);"
        ]
    },
    "32": {
        "db_id": "concert_singer",
        "question": "What are the names of all stadiums that did not have a concert in 2014?",
        "ground_truth": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do add explicit table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with `ON T1.stadium_id = T2.stadium_id` instead of a correlated subquery. Do reference `T2.name` in the second part instead of just `name`. Do specify `FROM concert AS T1` and `FROM stadium AS T2` instead of the singular table names `concerts` and `stadiums`. The amended query now correctly handles potential NULL values in the stadium_id comparison and matches the RIGHT_SQL's behavior using set operations."
        ],
        "rules": [
            "1) When combining stadium and concert tables: link rows where T2.stadium_id = T1.stadium_id using an inner join. 2) When filtering for concerts in 2014: include only rows where T1.year = 2014. 3) When finding stadiums without concerts in 2014: use set difference (EXCEPT) between all stadiums and stadiums that had concerts in 2014. 4) When selecting stadium names: output T2.name from the stadium table (T2). 5) When referencing table names: use exact table names \"concert\" and \"stadium\" (singular) as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM stadiums WHERE stadium_id NOT IN (SELECT stadium_id FROM concerts WHERE year = 2014);",
            "SELECT T2.Name\nFROM stadium AS T2\nEXCEPT\nSELECT T2.Name\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year = '2014'"
        ],
        "rule_sql": [
            "SELECT s.Name \nFROM stadium s\nEXCEPT\nSELECT s.Name \nFROM stadium s\nINNER JOIN concert c ON s.Stadium_ID = c.Stadium_ID\nWHERE c.Year = '2014';"
        ]
    },
    "870": {
        "db_id": "network_1",
        "question": "Show the names of all high schoolers in grade 10.",
        "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
        "amends": [
            "Do reference table `Highschooler` instead of `high_schoolers` and filter on `grade = 10` instead of `grade = 9`."
        ],
        "rules": [
            "1) When answering about \"high schoolers\": use the exact table name \"Highschooler\" as shown in the schema. 2) When filtering by grade 10: use the exact literal value 10 (not 9) for the grade column. 3) When selecting names: output the \"name\" column from the Highschooler table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE grade = 9;",
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ]
    },
    "971": {
        "db_id": "dog_kennels",
        "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
        "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
        "amends": [
            "Do use `role_code` instead of `role` in the SELECT list to reference the correct column name. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate column while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"role\": use the exact column name \"role_code\" from the Professionals table instead of \"role\". 2) When filtering for cities containing the substring 'West': use the exact literal 'West' with case sensitivity and apply pattern matching to find cities containing this substring anywhere in their name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role, street, city, state FROM professionals WHERE city LIKE '%West%';",
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%'"
        ],
        "rule_sql": [
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ]
    },
    "729": {
        "db_id": "world_1",
        "question": "What is the total population of Gelderland district?",
        "ground_truth": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
        "amends": [
            "Do query the `city` table instead of the `districts` table. Do use the `District` column filter instead of the `name` column filter. Do use the exact string value \"Gelderland\" instead of 'Gelderland'. Do use lowercase `sum` function instead of uppercase `SUM`. The amended query now correctly aggregates population data from cities within the Gelderland district rather than incorrectly attempting to sum population from a districts table."
        ],
        "rules": [
            "1) When answering about \"total population of Gelderland district\": query the \"city\" table instead of the \"districts\" table. 2) When filtering for Gelderland district: use the \"District\" column filter instead of the \"name\" column filter. 3) When specifying the literal value for Gelderland: use the exact string value \"Gelderland\" instead of 'Gelderland'. 4) When performing aggregation: use lowercase \"sum\" function instead of uppercase \"SUM\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(population) FROM districts WHERE name = 'Gelderland';",
            "SELECT sum(Population) FROM city WHERE District = 'Gelderland'"
        ],
        "rule_sql": [
            "SELECT sum(Population) FROM city WHERE District = \"Gelderland\""
        ]
    },
    "785": {
        "db_id": "world_1",
        "question": "What are the names of cities in Europe for which English is not the official language?",
        "ground_truth": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')",
        "amends": [
            "Do select `DISTINCT T2.Name` instead of `city_name` and use table `country AS T1` joined with `city AS T2` on `T2.CountryCode = T1.Code` instead of querying `cities` directly. Do filter with `T1.Continent = 'Europe'` instead of `continent = 'Europe'` and add a subquery condition `T1.Name NOT IN` instead of checking `official_language = 'English'`. The subquery correctly identifies countries where English is an official language by joining `country AS T3` with `countrylanguage AS T4` on `T3.Code = T4.CountryCode` and filtering for `T4.IsOfficial = 'T' AND T4.Language = 'English'`, ensuring only cities in European countries without English as an official language are returned. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about city names in Europe where English is not the official language: make sure the output order: T2.Name. 2) When the question mentions \"cities\": \"cities\" actually means \"city AS T2\" in schema. 3) When the question mentions \"Europe\": \"Europe\" actually means \"T1.Continent = 'Europe'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T2.CountryCode = T1.Code exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for countries where English is not the official language: use a subquery condition T1.Name NOT IN (select T3.Name from country AS T3 join countrylanguage AS T4 on T3.Code = T4.CountryCode where T4.IsOfficial = 'T' AND T4.Language = 'English'). 6) When selecting city names: use DISTINCT T2.Name to ensure unique city names are returned."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE continent = 'Europe' AND official_language = 'English';",
            "SELECT DISTINCT T2.Name \nFROM country AS T1 \nJOIN city AS T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT T3.Name \n    FROM country AS T3 \n    JOIN countrylanguage AS T4 ON T3.Code = T4.CountryCode \n    WHERE T4.IsOfficial = 'T' AND T4.Language = 'English'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Name \nFROM country AS T1 \nJOIN city AS T2 ON T2.CountryCode = T1.Code \nWHERE T1.Continent = 'Europe' \nAND T1.Name NOT IN (\n    SELECT T3.Name \n    FROM country AS T3 \n    JOIN countrylanguage AS T4 ON T3.Code = T4.CountryCode \n    WHERE T4.IsOfficial = 'T' AND T4.Language = 'English'\n)\nORDER BY T2.Name"
        ]
    },
    "625": {
        "db_id": "tvshow",
        "question": "List the Episode of all  TV series showed on TV Channel with series name \"Sky Radio\".",
        "ground_truth": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Episode` instead of `*` to return only the episode column rather than all columns. Do use `TV_Channel AS T1 JOIN TV_series AS T2` instead of `episodes` to properly join the channel and series tables. Do apply the join condition `ON T1.id = T2.Channel` instead of no join condition to correctly relate the tables. Do filter on `T1.series_name = \"Sky Radio\"` instead of `channel = 'Sky Radio'` to use the appropriate column name and table reference. The amended query now correctly retrieves episodes from the specified series by joining the related tables with proper relationships."
        ],
        "rules": [
            "1) When answering about \"List the Episode of all TV series showed on TV Channel with series name 'Sky Radio'\": make sure the output order: T2.Episode\n2) When the question mentions \"TV series showed on TV Channel\": use TV_Channel AS T1 JOIN TV_series AS T2 with join condition T1.id = T2.Channel to properly relate the tables\n3) When the question mentions \"series name 'Sky Radio'\": filter on T1.series_name = \"Sky Radio\" exactly as specified with double quotes\n4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM episodes WHERE channel = 'Sky Radio';",
            "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\""
        ],
        "rule_sql": [
            "SELECT T2.Episode\nFROM TV_Channel AS T1\nJOIN TV_series AS T2 ON T1.id = T2.Channel\nWHERE T1.series_name = \"Sky Radio\""
        ]
    },
    "440": {
        "db_id": "wta_1",
        "question": "What is the best rank of losers across all matches?",
        "ground_truth": "SELECT min(loser_rank) FROM matches",
        "amends": [
            "Do use the `min` aggregate function on `loser_rank` instead of the `max` aggregate function on `winner_rank`."
        ],
        "rules": [
            "1) When the question asks for the \"best rank of losers\": use the minimum value of \"loser_rank\" instead of the maximum value of \"winner_rank\". 2) When computing the best (lowest) rank: apply the min aggregate function to the exact column token \"loser_rank\" from the matches table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(winner_rank) FROM matches;",
            "SELECT MIN(loser_rank) AS best_rank FROM matches WHERE loser_rank IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT MIN(loser_rank) AS best_rank_of_losers FROM matches;"
        ]
    },
    "526": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and ids of every course with less than 2 sections?",
        "ground_truth": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",
        "amends": [
            "Do select `T1.course_name` and `T1.course_id` with explicit table aliases instead of `course_id` and `name` without table qualification. Do join `Sections AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do group by `T1.course_id` and use `HAVING count(*) <= 2` to filter courses with at most two sections instead of using `WHERE section_count > 2` to filter courses with more than two sections. The amended query now correctly identifies courses with exactly two or fewer sections by counting actual section records rather than relying on a potentially incorrect section_count column.",
            "Do maintain the same `SELECT` list order with `course_name` first instead of `course_id` first, though this is purely cosmetic. Do keep the same `FROM` source with `Courses AS T1` and the same `JOIN` type with `Sections AS T2` on the same predicate `T1.course_id = T2.course_id`. Do preserve the identical `GROUP BY T1.course_id` and `HAVING COUNT(*) <= 2` clause. The amended query now matches RIGHT_SQL's behavior with only insignificant formatting differences."
        ],
        "rules": [
            "1) When answering about course names and ids: make sure the output order: T1.course_id, T1.course_name. 2) When the question mentions \"course with less than 2 sections\": this means courses having at most 2 sections, requiring counting actual section records rather than using a section_count column. 3) When combining Courses as T1 and Sections as T2: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match). 4) When counting sections per course: group by T1.course_id and count the number of section records using count(*). 5) When filtering for courses with less than 2 sections: use having count(*) <= 2 to include courses with exactly two or fewer sections.",
            "1) When answering about \"names and ids of every course with less than 2 sections\": make sure the output order: course_name first, then course_id. 2) When combining Courses (T1) and Sections (T2) for shared entities: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match). 3) When the question asks for courses with \"less than 2 sections\": organize results by T1.course_id and compute the count of sections per course, keeping only those groups where the count is less than or equal to 2. 4) When counting sections per course: use the canonical key T1.course_id for grouping and count all matching rows from T2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id, name FROM courses WHERE section_count > 2;",
            "SELECT T1.course_id, T1.course_name\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2",
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": [
            "SELECT T1.course_name, T1.course_id\nFROM Courses T1\nINNER JOIN Sections T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2\nORDER BY T1.course_name, T1.course_id"
        ]
    },
    "509": {
        "db_id": "student_transcripts_tracking",
        "question": "How many courses in total are listed?",
        "ground_truth": "SELECT count(*) FROM Courses",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_courses FROM Courses;"
        ]
    },
    "217": {
        "db_id": "flight_2",
        "question": "How many 'United Airlines' flights depart from Airport 'AHD'?",
        "ground_truth": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do join `AIRLINES AS T1` and `FLIGHTS AS T2` instead of querying only the `flights` table. Do use `ON T2.Airline = T1.uid` for the join condition instead of missing the table relationship entirely. Do filter on `T1.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'` to reference the correct table and column. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'` to use the proper column name and table reference. Do use double quotes for string literals instead of single quotes. The amended query now correctly joins the airlines and flights tables to count United Airlines flights departing from AHD airport."
        ],
        "rules": [
            "1) When answering about \"United Airlines flights depart from Airport AHD\": make sure the output order: count of flights\n2) When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T1.Airline = \\\"United Airlines\\\"\" in schema\n3) When the question mentions \"depart from Airport AHD\": \"AHD\" actually means \"T2.SourceAirport = \\\"AHD\\\"\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T2.Airline = T1.uid exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2 flight records)\n6) When handling text literals: do not change case, spacing, or punctuation - use exact literals \\\"United Airlines\\\" and \\\"AHD\\\"\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms - use double quotes for identifiers and literals"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND departure_airport = 'AHD';",
            "SELECT COUNT(*) FROM airlines AS T1 JOIN flights AS T2 ON T2.Airline = T1.uid WHERE T1.Airline = \"United Airlines\" AND T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T2\nJOIN airlines T1 ON T2.Airline = T1.uid\nWHERE T1.Airline = \"United Airlines\" \nAND T2.SourceAirport = \"AHD\""
        ]
    },
    "851": {
        "db_id": "orchestra",
        "question": "What are the major record formats of orchestras, sorted by their frequency?",
        "ground_truth": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
        "amends": [
            "Do use `Major_Record_Format` instead of `record_format` for the column name in the SELECT list and GROUP BY clause. Do use `orchestra` instead of `orchestras` for the table name. Do remove the explicit `COUNT(*) as frequency` column from the SELECT list instead of including it. Do change the ORDER BY direction to `ASC` instead of `DESC` for the count ordering. Do reference the count implicitly in ORDER BY instead of using an alias. The amended query now correctly selects and groups by the Major_Record_Format column from the orchestra table with ascending count ordering.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, and do remove the explicit `COUNT(*)` reference from the ORDER BY clause instead of keeping it, allowing the implicit count-based ordering to function correctly while only returning the grouped Major_Record_Format values."
        ],
        "rules": [
            "1) When the question mentions \"major record formats\": use the exact column name \"Major_Record_Format\" from the orchestra table. 2) When counting entities in the orchestra table: count using the canonical key (implicit count of rows) rather than specifying an explicit count column. 3) When the question asks for sorting by frequency: order the results by the count in ascending direction (ASC) rather than descending. 4) When producing output: include only the Major_Record_Format column in the results, not the count values themselves.",
            "1) When answering about \"major record formats of orchestras sorted by frequency\": make sure the output order: Major_Record_Format only without count values. 2) When the question asks for sorting by frequency: order the results by the count of orchestras in descending frequency order. 3) When grouping by Major_Record_Format: organize results by Major_Record_Format and compute the count per group. 4) When producing output: do not include the count column in the final results, only show the Major_Record_Format values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_format, COUNT(*) as frequency FROM orchestras GROUP BY record_format ORDER BY frequency DESC;",
            "SELECT Major_Record_Format, COUNT(*) FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;",
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC;"
        ],
        "rule_sql": [
            "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) DESC;"
        ]
    },
    "139": {
        "db_id": "car_1",
        "question": "What is the maximum accelerate for different number of cylinders?",
        "ground_truth": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",
        "amends": [
            "Do use column name `Accelerate` instead of `acceleration` and place it as the first argument to `MAX` instead of second. Do use column name `Cylinders` instead of `cylinders` and place it as the second column instead of first in the SELECT list. Do reference table `CARS_DATA` instead of `cars` in the FROM clause. The amended query now correctly retrieves the maximum acceleration grouped by cylinders from the specified table."
        ],
        "rules": [
            "1) When answering about maximum acceleration for different number of cylinders: make sure the output order is Accelerate first, then Cylinders. 2) When the question mentions \"acceleration\": \"acceleration\" actually means \"Accelerate\" in schema. 3) When the question mentions \"cylinders\": \"cylinders\" actually means \"Cylinders\" in schema. 4) When the question asks for maximum acceleration per cylinders: organize results by Cylinders and compute maximum Accelerate per group. 5) When referencing the table: use table name CARS_DATA exactly as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cylinders, MAX(acceleration) FROM cars GROUP BY cylinders;",
            "SELECT MAX(Accelerate) AS MaxAccelerate, Cylinders FROM cars_data GROUP BY Cylinders"
        ],
        "rule_sql": [
            "SELECT MAX(Accelerate) AS MaxAccelerate, Cylinders FROM cars_data GROUP BY Cylinders ORDER BY MaxAccelerate, Cylinders;"
        ]
    },
    "84": {
        "db_id": "pets_1",
        "question": "What is the last name of the student who has a cat that is 3 years old?",
        "ground_truth": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
        "amends": [
            "Do use `T1.lname` instead of `last_name` for the column selection. Do join `student AS T1` instead of querying `students` table directly. Do add `has_pet AS T2` join on `T1.stuid = T2.stuid` instead of omitting this relationship table. Do add `pets AS T3` join on `T3.petid = T2.petid` instead of accessing pet attributes directly from students. Do filter on `T3.pet_age = 3` instead of `pet_age = 3` to reference the correct table. Do filter on `T3.pettype = 'cat'` instead of `pet_type = 'cat'` with the correct column name. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping the ordering and limiting as the query logic now correctly returns all matching records. The amended query now properly joins through the relationship tables to access pet information and returns all students with 3-year-old cats instead of just one student."
        ],
        "rules": [
            "1) When selecting student last name: use \"T1.lname\" instead of \"last_name\" as the output column. 2) When accessing student information: use table \"student AS T1\" instead of \"students\" table. 3) When relating students to pets: join \"has_pet AS T2\" on \"T1.stuid = T2.stuid\" to connect student and pet relationship. 4) When accessing pet attributes: join \"pets AS T3\" on \"T3.petid = T2.petid\" to get pet details. 5) When filtering by pet age: use \"T3.pet_age = 3\" to reference the correct table and column. 6) When filtering by pet type: use \"T3.pettype = 'cat'\" with exact column name and literal value. 7) When the question asks for a student with specific pet attributes: do not apply ordering or limiting as it should return all matching records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE pet_type = 'cat' AND pet_age = 3 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.LName FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ],
        "rule_sql": [
            "SELECT T1.LName FROM student AS T1 JOIN has_pet AS T2 ON T1.StuID = T2.StuID JOIN pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ]
    },
    "766": {
        "db_id": "world_1",
        "question": "What is the total number of people living in the nations that do not use English?",
        "ground_truth": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\")",
        "amends": [
            "Do reference the `country` table instead of `nations` and use `sum(Population)` instead of `SUM(population)`. Do replace the simple `WHERE language != 'English'` filter with a subquery that checks `Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\")` instead of the incorrect direct column reference. Do add the necessary join between `country` and `countrylanguage` tables on `T1.Code = T2.CountryCode` instead of omitting this relationship. The amended query now correctly identifies countries where English is not an official language by properly joining through the countrylanguage table instead of incorrectly assuming the language column exists directly in the country table."
        ],
        "rules": [
            "1) When answering about \"total number of people living in nations that do not use English\": make sure the output order: sum(Population) 2) When the question mentions \"nations\": \"nations\" actually means \"country table\" in schema 3) When the question mentions \"do not use English\": this means countries where \"English\" is not listed as a language in the countrylanguage table 4) When combining country (T1) and countrylanguage (T2) for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match) 5) When filtering for countries without English: use the condition T1.Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\") instead of direct column filtering 6) When computing total population: use sum(Population) with exact case and spelling as shown in the amends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(population) FROM nations WHERE language != 'English';",
            "SELECT SUM(Population) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ],
        "rule_sql": [
            "SELECT SUM(Population) \nFROM country AS T1 \nWHERE T1.Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English'\n)"
        ]
    },
    "1013": {
        "db_id": "singer",
        "question": "For each citizenship, how many singers are from that country?",
        "ground_truth": "SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do reference the correct table name `singer` instead of `singers` in the FROM clause. Do use the correct column name `Citizenship` instead of `country` in both the SELECT list and GROUP BY clause, ensuring the aggregation aligns with the grouping criteria. Do maintain the COUNT(*) aggregation to preserve the row counting functionality while correcting the underlying table and column references."
        ],
        "rules": [
            "1) When answering about \"citizenship and count of singers\": make sure the output order: Citizenship, COUNT(*) 2) When the question mentions \"citizenship\": \"citizenship\" actually means \"Citizenship in schema\" 3) When the question asks for \"count of singers\": compute the number of rows using the table singer 4) When the question says \"per citizenship\"/\"by citizenship\": organize results by Citizenship and compute requested aggregates per group 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 6) When handling text literals: do not change case, spacing, or punctuation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Citizenship, COUNT(*) FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT \"Citizenship\", COUNT(*) FROM \"singer\" GROUP BY \"Citizenship\""
        ]
    },
    "92": {
        "db_id": "car_1",
        "question": "How many countries exist?",
        "ground_truth": "SELECT count(*) FROM COUNTRIES;",
        "amends": [
            "Do reference the `COUNTRIES` table instead of the `cities` table in the FROM clause. Do maintain the `COUNT(*)` aggregate function without changes. The amended query now correctly counts records from the COUNTRIES table instead of the cities table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many countries exist\": use the COUNTRIES table to count records. 2) When counting entities: use COUNT(*) to count all rows from the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities;",
            "SELECT COUNT(*) FROM countries;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM countries;"
        ]
    },
    "323": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of templates with template type code PP or PPT?",
        "ground_truth": "SELECT template_id FROM Templates WHERE template_type_code  =  \"PP\" OR template_type_code  =  \"PPT\"",
        "amends": [
            "Do select `template_id` instead of `id` and change the table name to `Templates` instead of `templates`. Do use `OR` logic with `template_type_code = \"PP\"` OR `template_type_code = \"PPT\"` instead of incorrectly using `AND` with both conditions simultaneously. Do use double quotes `\"PP\"` and `\"PPT\"` instead of single quotes for the string literals. The amended query now correctly retrieves templates of either type PP or PPT instead of incorrectly requiring both types simultaneously."
        ],
        "rules": [
            "1) When selecting template identifiers: use \"template_id\" instead of \"id\" as the output column. 2) When referring to the templates table: use the exact table name \"Templates\" with proper capitalization. 3) When filtering for template type codes \"PP\" or \"PPT\": use OR logic with the exact string literals \"PP\" and \"PPT\" in double quotes, not AND logic that would require both conditions simultaneously. 4) When comparing template type codes: use the exact column name \"template_type_code\" with the specified values \"PP\" or \"PPT\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM templates WHERE template_type_code = 'PP' AND template_type_code = 'PPT';",
            "SELECT Template_ID FROM Templates WHERE Template_Type_Code = \"PP\" OR Template_Type_Code = \"PPT\""
        ],
        "rule_sql": [
            "SELECT template_id FROM Templates WHERE template_type_code = \"PP\" OR template_type_code = \"PPT\""
        ]
    },
    "107": {
        "db_id": "car_1",
        "question": "Which of the countries has the most car makers? List the country name.",
        "ground_truth": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;",
        "amends": [
            "Do join `COUNTRIES` as `T2` on `T1.Country = T2.CountryId` instead of querying only `car_makers` without any join. Do select `T2.CountryName` instead of `country` to get the proper country name from the joined table. Do order by `Count(*) DESC` instead of `ASC` to find the country with the highest count rather than the lowest. Do use table aliases `T1` and `T2` instead of no aliases for clarity. The amended query now correctly identifies the country with the most car makers by joining to the countries table and ordering in descending order."
        ],
        "rules": [
            "1) When answering about \"countries with the most car makers\": make sure the output order: T2.CountryName. 2) When the question mentions \"country name\": \"country name\" actually means \"T2.CountryName\" in schema. 3) When the question asks for \"most car makers\": rank rows by Count(*) in descending direction and keep the first 1 row. 4) When combining T1 and T2 for shared entities: link rows where T1.Country = T2.CountryId exactly as shown in the amends; keep only matching pairs (inner match). 5) When counting car makers: compute the number of rows using the canonical key from car_makers table (T1.Country) per country group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) as maker_count FROM car_makers GROUP BY country ORDER BY maker_count ASC LIMIT 1;",
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T1.Country\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.CountryName\nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nGROUP BY T2.CountryName\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "539": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the program which most number of students are enrolled in. List both the id and the summary.",
        "ground_truth": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `T1.degree_program_id` and `T1.degree_summary_name` instead of `program_id` and `summary`. Do add `FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id` instead of just `FROM programs`. Do add `GROUP BY T1.degree_program_id` instead of omitting it. Do use `count(*)` in the `ORDER BY` instead of `COUNT(student_id)`. The amended query now correctly joins the necessary tables, groups by program ID, and counts all enrolled students to identify the most popular degree program."
        ],
        "rules": [
            "1) When answering about \"most number of students enrolled in a program\": make sure the output order: T1.degree_program_id, T1.degree_summary_name. 2) When combining Degree_Programs and Student_Enrolment tables: link rows where T1.degree_program_id = T2.degree_program_id and keep only matching pairs (inner match). 3) When counting enrolled students per program: organize results by T1.degree_program_id and compute count(*) per group. 4) When finding the program with most students: rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT program_id, summary FROM programs ORDER BY COUNT(student_id) DESC LIMIT 1;",
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs AS T1\nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id\nORDER BY count(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.degree_program_id, T1.degree_summary_name\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nGROUP BY T1.degree_program_id, T1.degree_summary_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "573": {
        "db_id": "student_transcripts_tracking",
        "question": "Show the date of the transcript which shows the least number of results, also list the id.",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do add table `Transcript_Contents AS T1` and `Transcripts AS T2` with a `JOIN` on `T1.transcript_id = T2.transcript_id` instead of querying only the `transcripts` table. Do change the SELECT list to include `T2.transcript_date` and `T1.transcript_id` instead of `transcript_date` and `transcript_id` without table qualification. Do add `GROUP BY T1.transcript_id` and change the ORDER BY to `count(*) ASC` instead of `results_count ASC`. The amended query now correctly aggregates transcript contents and orders by the count of records per transcript_id, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the date of the transcript which shows the least number of results\": make sure the output order: T2.transcript_date, T1.transcript_id 2) When the question asks for \"least number of results\": count the number of records per transcript using count(*) on T1.transcript_id and order by this count in ascending order 3) When combining Transcript_Contents AS T1 and Transcripts AS T2: link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match) 4) When grouping results: organize by T1.transcript_id to compute the count of records per transcript 5) When selecting the transcript with the minimum count: take only the first row after ordering by count(*) ASC"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT transcript_date, transcript_id FROM transcripts ORDER BY results_count ASC LIMIT 1;",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nINNER JOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "383": {
        "db_id": "course_teach",
        "question": "List the names of teachers in ascending order of age.",
        "ground_truth": "SELECT Name FROM teacher ORDER BY Age ASC",
        "amends": [
            "Do use table name `teacher` instead of `teachers` and select column `Name` instead of `name`. Do order by `Age ASC` instead of `age DESC`, changing both the column name and sort direction. The amended query now correctly references the intended table and column names with proper casing and applies ascending ordering instead of descending."
        ],
        "rules": [
            "1) When the question mentions \"teachers\": use the exact table name \"teacher\" instead of \"teachers\". 2) When selecting teacher names: use the exact column name \"Name\" instead of \"name\". 3) When ordering by age in ascending order: use the exact column name \"Age\" and apply ascending (ASC) ordering instead of descending (DESC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers ORDER BY age DESC;",
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher ORDER BY Age ASC;"
        ]
    },
    "161": {
        "db_id": "car_1",
        "question": "How many countries has more than 2 car makers ?",
        "ground_truth": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2",
        "amends": [
            "Do join `car_makers` as `t2` on `t1.countryid=t2.country` instead of querying only the `countries` table. Do add `GROUP BY t1.countryid` instead of aggregating without grouping. Do move the count filter to `HAVING count(*) > 2` instead of using `WHERE car_makers > 2` which incorrectly references a column that doesn't exist in the countries table. The amended query now correctly counts car makers per country and filters for countries with more than 2 car makers, matching the intended behavior.",
            "Do remove the subquery wrapper instead of keeping it, as the outer COUNT(*) was incorrectly counting the grouped rows rather than the actual country count. Do maintain the same `JOIN` on `t1.CountryId=t2.Country` instead of changing it. Do preserve the `GROUP BY t1.CountryId` and `HAVING COUNT(*) > 2` clauses instead of modifying them. The amended query now correctly counts countries with more than 2 car makers by eliminating the redundant subquery structure."
        ],
        "rules": [
            "1) When answering about \"countries with more than 2 car makers\": make sure to join table \"car_makers\" as \"t2\" with table \"countries\" as \"t1\" where \"t1.countryid\" equals \"t2.country\". 2) When counting car makers per country: group the results by \"t1.countryid\" and count using the canonical key from the car_makers table. 3) When filtering for countries with more than 2 car makers: apply the condition \"count(*) > 2\" in the HAVING clause instead of using WHERE with a non-existent column.",
            "1) When counting countries with more than 2 car makers: use the canonical key \"t1.CountryId\" for counting countries instead of counting grouped rows. 2) When combining countries and car_makers tables: link rows where \"t1.CountryId = t2.Country\" exactly as shown and keep only matching pairs (inner match). 3) When grouping by country: organize results by \"t1.CountryId\" and compute the count of car makers per country. 4) When filtering for countries with more than 2 car makers: apply the condition \"COUNT(*) > 2\" to the grouped results. 5) When the question asks \"how many countries\": count the distinct country identifiers that satisfy the condition of having more than 2 car makers."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE car_makers > 2;",
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)",
            "SELECT COUNT(*) \nFROM countries t1 \nJOIN car_makers t2 ON t1.CountryId = t2.Country \nGROUP BY t1.CountryId \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)"
        ]
    },
    "153": {
        "db_id": "car_1",
        "question": "In which years cars were produced weighing no less than 3000 and no more than 4000 ?",
        "ground_truth": "select distinct year from cars_data where weight between 3000 and 4000;",
        "amends": [
            "Do use `distinct` for unique years instead of omitting it. Do reference table `cars_data` instead of `cars`. Do apply filter `weight between 3000 and 4000` instead of `weight < 3000 OR weight > 4000` to select cars within the weight range rather than outside it. The amended query now correctly returns distinct years from the cars_data table for vehicles weighing between 3000 and 4000 pounds."
        ],
        "rules": [
            "1) When answering about \"years cars were produced weighing no less than 3000 and no more than 4000\": make sure the output order: year. 2) When the question asks for distinct years: compute the number of unique values of the exact token \"year\". 3) When the question mentions \"cars\": \"cars\" actually means \"cars_data\" in schema. 4) When filtering by weight between 3000 and 4000: apply the condition weight between 3000 and 4000 inclusive to select vehicles within the specified weight range rather than outside it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM cars WHERE weight < 3000 OR weight > 4000;",
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ]
    },
    "881": {
        "db_id": "network_1",
        "question": "Which grades have 4 or more high schoolers?",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
        "amends": [
            "Do select only `grade` instead of selecting both `grade` and `COUNT(*) as student_count`. Do use `FROM Highschooler` instead of `FROM students` as the table source. Do remove the `WHERE grade >= 9` filter instead of keeping it. Do keep the `GROUP BY grade` clause. Do keep the `HAVING count(*) >= 4` condition but use the exact syntax `count(*)  >=  4` instead of `COUNT(*) >= 4`. The amended query now correctly identifies grades with at least 4 students in the Highschooler table without unnecessary columns or filters."
        ],
        "rules": [
            "1) When answering about \"which grades have 4 or more high schoolers\": make sure the output order: grade. 2) When the question mentions \"high schoolers\": \"high schoolers\" actually means \"records in the Highschooler table\". 3) When counting students: use count(*) to count all rows in the Highschooler table. 4) When grouping by grade: organize results by the grade column from the Highschooler table. 5) When filtering for grades with 4 or more students: keep only groups where count(*) >= 4. 6) When handling the grade column: use the exact column name grade without any WHERE filtering conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count \nFROM students \nWHERE grade >= 9 \nGROUP BY grade \nHAVING COUNT(*) >= 4;",
            "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*) >= 4"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4 ORDER BY grade;"
        ]
    },
    "828": {
        "db_id": "orchestra",
        "question": "What are the record companies of orchestras in descending order of years in which they were founded?",
        "ground_truth": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC",
        "amends": [
            "Do reference `Record_Company` instead of `o.record_company` and remove `o.founded_year` from the SELECT list instead of including it. Do reference table `orchestra` instead of `orchestras o` with alias. Do change ORDER BY to `Year_of_Founded DESC` instead of `o.founded_year ASC` by using a different column name and reversing the sort direction. The amended query now correctly selects only the record company column from the orchestra table and orders by year of founding in descending order."
        ],
        "rules": [
            "1) When answering about \"record companies of orchestras\": make sure the output order: \"Record_Company\" only. 2) When the question mentions \"years in which they were founded\": \"years\" actually means \"Year_of_Founded in schema\". 3) When the question asks for \"descending order\": rank rows by \"Year_of_Founded\" in descending direction. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"Record_Company\" and \"Year_of_Founded\". 5) When referring to table roles: use table \"orchestra\" as the base table without additional aliases."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT o.record_company, o.founded_year FROM orchestras o ORDER BY o.founded_year ASC;",
            "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC;"
        ],
        "rule_sql": [
            "SELECT \"Record_Company\" FROM \"orchestra\" ORDER BY \"Year_of_Founded\" DESC;"
        ]
    },
    "364": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?",
        "ground_truth": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",
        "amends": [
            "Do use `T1.paragraph_text` instead of `text` for the column selection. Do add `JOIN Documents AS T2` instead of querying only the paragraphs table. Do use `ON T1.document_id = T2.document_id` instead of no join condition. Do filter on `T2.Document_Name = 'Welcome to NY'` instead of `document_title = 'Welcome to NY'` to properly reference the document name from the joined table. Do add table aliases `T1` and `T2` instead of using unqualified column references. The amended query now correctly joins the tables and filters on the document name from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"paragraphs in a document titled 'Welcome to NY'\": make sure to join tables T1 (paragraphs) and T2 (Documents) using T1.document_id = T2.document_id to properly link paragraphs to their documents. 2) When the question mentions \"texts of paragraphs\": \"text\" actually means \"T1.paragraph_text\" in the schema. 3) When filtering for document title: use T2.Document_Name = 'Welcome to NY' with exact case and spacing to match the specified document name. 4) When selecting output columns: include T1.paragraph_id and T1.paragraph_text in that order. 5) When combining T1 and T2 for shared entities: link rows where T1.document_id = T2.document_id exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT paragraph_id, text FROM paragraphs WHERE document_title = 'Welcome to NY';",
            "SELECT T1.Paragraph_ID, T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Welcome to NY'"
        ],
        "rule_sql": [
            "SELECT p.Paragraph_ID, p.Paragraph_Text \nFROM Paragraphs p\nJOIN Documents d ON p.Document_ID = d.Document_ID\nWHERE d.Document_Name = 'Welcome to NY'"
        ]
    },
    "619": {
        "db_id": "tvshow",
        "question": "What is the air date of TV series with Episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\";",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT air_date FROM tv_series WHERE episode = 'A Love of a Lifetime';"
        ],
        "rule_sql": [
            "SELECT Air_Date FROM TV_series WHERE Episode = 'A Love of a Lifetime';"
        ]
    },
    "284": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shop has the most employees? Give me the shop name.",
        "ground_truth": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `shop` table instead of `shop_name` from the `shops` table. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying a single table. Do add `GROUP BY t1.shop_id` to aggregate by shop instead of omitting grouping. Do order by `count(*) DESC` to find the shop with the most hires instead of `employee_count ASC` for the smallest shop. The amended query now correctly identifies the shop with the highest number of hiring records, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which shop has the most employees\": make sure the output order: t2.name. 2) When the question mentions \"shop name\": \"shop name\" actually means \"t2.name in schema\". 3) When combining hiring AS t1 and shop AS t2 for shared entities: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of employees\" per shop: compute the number of rows using t1.shop_id as the grouping key and count(*) as the aggregate. 5) When the question mentions \"most employees\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops ORDER BY employee_count ASC LIMIT 1;",
            "SELECT t2.Name \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.Name \nFROM hiring AS t1 \nINNER JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "659": {
        "db_id": "poker_player",
        "question": "What are the names of poker players?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `player_name` from `poker_players`. Do join `poker_player` as `T2` on `T1.People_ID = T2.People_ID` instead of querying `poker_players` directly with a `WHERE player_id = 1` filter. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves player names by joining the people table with poker player information through the proper relationship."
        ],
        "rules": [
            "1) When answering about \"names of poker players\": make sure the output order: T1.Name. 2) When the question mentions \"poker players\": \"poker players\" actually means \"people who are poker players in schema\" requiring joining people table with poker_player table. 3) When combining T1 (people) and T2 (poker_player) for shared entities: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match). 4) When the wrong query uses a specific player_id filter (player_id = 1): do not apply any player_id filter since the question asks for all poker players."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM poker_players WHERE player_id = 1;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Name;"
        ]
    },
    "569": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the last transcript release date?",
        "ground_truth": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1",
        "amends": [
            "Do select `transcript_date` instead of `MAX(release_date)` and remove the aggregate function. Do use a simple `FROM Transcripts` source instead of a subquery approach. Do remove the `WHERE` filter entirely instead of using a nested subquery. Do add `ORDER BY transcript_date DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using maximum aggregation. Do reference the correct column name `transcript_date` instead of `release_date` and use proper table name casing `Transcripts` instead of `transcripts`. The amended query now correctly retrieves the most recent transcript date by direct ordering and limiting instead of using nested aggregation which could return incorrect results when transcript_id and date ordering don't align."
        ],
        "rules": [
            "1) When the question asks for the \"last transcript release date\": use the exact column name \"transcript_date\" from table \"Transcripts\" instead of \"release_date\". 2) When retrieving the most recent date: order rows by \"transcript_date\" in descending order and take only the first row instead of using maximum aggregation. 3) When selecting from the Transcripts table: use the exact table name \"Transcripts\" with proper casing instead of \"transcripts\". 4) When the question asks for a single most recent value: use a limit of 1 instead of subqueries or complex aggregation approaches."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(release_date) FROM transcripts WHERE transcript_id = (SELECT MAX(transcript_id) FROM transcripts);",
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ]
    },
    "63": {
        "db_id": "pets_1",
        "question": "Find the id of students who do not have a cat pet.",
        "ground_truth": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "amends": [
            "Do select `stuid` instead of `id` and use `EXCEPT` set operation instead of a simple `WHERE` filter. Do change the source from `students` to `student` instead of the original table name. Do add joins with `has_pet` and `pets` tables instead of omitting them, specifically using `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` and `JOIN pets AS T3 ON T3.petid = T2.petid` instead of no joins. Do move the pet filter condition to `WHERE T3.pettype = 'cat'` instead of `WHERE pet = 'cat'`, and use `pettype` instead of `pet` as the column reference. The amended query now correctly identifies students without cats by using an EXCEPT operation to remove those who have cats, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for student id: use \"stuid\" instead of \"id\" as the column name. 2) When the question asks about students who do not have a cat pet: use an EXCEPT set operation to remove students who have cats from all students instead of a simple WHERE filter. 3) When working with the student table: use \"student\" as the table name instead of \"students\". 4) When combining student data with pet information: join \"student\" as T1 with \"has_pet\" as T2 using \"T1.stuid = T2.stuid\" and join \"has_pet\" as T2 with \"pets\" as T3 using \"T3.petid = T2.petid\". 5) When filtering for cat pets: use \"T3.pettype = 'cat'\" as the condition instead of \"pet = 'cat'\", and use \"pettype\" instead of \"pet\" as the column reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE pet = 'cat';",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT T1.StuID FROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'"
        ],
        "rule_sql": [
            "SELECT stuid FROM Student\nEXCEPT\nSELECT T1.stuid FROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.stuid = T2.stuid\nJOIN Pets AS T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'cat'"
        ]
    },
    "866": {
        "db_id": "network_1",
        "question": "Show all the grades of the high schoolers.",
        "ground_truth": "SELECT grade FROM Highschooler",
        "amends": [
            "Do specify `grade` in the SELECT list instead of using `*` to select all columns. Do use the correct table name `Highschooler` instead of `high_schoolers`. The amended query now correctly returns only the grade column from the Highschooler table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks to show grades of high schoolers: select only the \"grade\" column from the \"Highschooler\" table. 2) When referring to the table containing high schooler information: use the exact table name \"Highschooler\" (not \"high_schoolers\"). 3) When selecting specific columns instead of all columns: explicitly list the required column \"grade\" rather than using the wildcard *."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM high_schoolers;",
            "SELECT grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler"
        ]
    },
    "192": {
        "db_id": "flight_2",
        "question": "Return the number of flights.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS",
        "amends": [
            "Do query the `FLIGHTS` table instead of the `passengers` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency, though this is purely cosmetic. The amended query now correctly counts records from the FLIGHTS table instead of the passengers table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of flights\": query the \"FLIGHTS\" table instead of the \"passengers\" table. 2) When counting flights: use lowercase \"count(*)\" to count all records from the \"FLIGHTS\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM passengers;",
            "SELECT count(*) FROM flights"
        ],
        "rule_sql": [
            "SELECT count(*) FROM flights;"
        ]
    },
    "873": {
        "db_id": "network_1",
        "question": "What is Kyle's id?",
        "ground_truth": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [
            "Do reference table `Highschooler` instead of `users` in the FROM clause. Do use column `ID` instead of `id` in the SELECT list. Do use double quotes `\"Kyle\"` instead of single quotes `'Kyle'` for the string literal in the WHERE filter. The amended query now correctly retrieves the ID from the Highschooler table where the name matches Kyle."
        ],
        "rules": [
            "1) When answering about \"Kyle's id\": make sure the output order: \"ID\" from table \"Highschooler\". 2) When the question mentions \"id\": \"id\" actually means \"ID\" in schema. 3) When the question mentions \"Kyle\": use the exact string literal \"Kyle\" with double quotes. 4) When filtering for a specific name: match rows where the name equals \"Kyle\" exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM users WHERE name = 'Kyle';",
            "SELECT ID FROM Highschooler WHERE name = \"Kyle\""
        ],
        "rule_sql": [
            "SELECT ID FROM Highschooler WHERE name = \"Kyle\";"
        ]
    },
    "466": {
        "db_id": "wta_1",
        "question": "What is the name of the winner with the most rank points who participated in the Australian Open tournament?",
        "ground_truth": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do filter on `tourney_name` instead of `tournament` in the WHERE clause, as the correct column name for identifying the Australian Open tournament is `tourney_name` rather than the non-existent `tournament` column. This amendment ensures the query correctly identifies matches from the Australian Open tournament before selecting the winner with the highest ranking points."
        ],
        "rules": [
            "1) When the question mentions \"Australian Open tournament\": use the exact literal value 'Australian Open' to filter the \"tourney_name\" column. 2) When answering about \"winner with the most rank points\": order results by \"winner_rank_points\" in descending order and take the first row. 3) When selecting the winner's name: output the \"winner_name\" column from the matches table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name FROM matches WHERE tournament = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;",
            "SELECT winner_name \nFROM matches \nWHERE tourney_name = 'Australian Open' \nORDER BY winner_rank_points DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;"
        ]
    },
    "979": {
        "db_id": "dog_kennels",
        "question": "Tell me the number of dogs that have not received any treatment .",
        "ground_truth": "select count(*) from dogs where dog_id not in ( select dog_id from treatments )",
        "amends": [
            "Do use a subquery with `dog_id not in (select dog_id from treatments)` instead of checking `treatment_id IS NULL` directly. Do reference the `treatments` table instead of omitting it from the query structure. Do filter based on the absence of records in the treatments table instead of relying on a potentially incorrect NULL check in the dogs table. The amended query now correctly identifies dogs that have never received any treatment by checking for their absence in the treatments table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting dogs that have not received any treatment: use a subquery to check for dog_id values that are not present in the treatments table instead of checking for NULL values in the dogs table. 2) When combining information about dogs and treatments: reference both the dogs table and treatments table, filtering based on absence of records in the treatments table. 3) When identifying dogs without treatments: use the exact identifier \"dog_id\" to match between the dogs table and treatments table subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NULL;",
            "SELECT COUNT(*) \nFROM Dogs \nWHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_dogs_without_treatment\nFROM Dogs d\nWHERE d.dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ]
    },
    "599": {
        "db_id": "tvshow",
        "question": "What is the content of TV Channel with serial name \"Sky Radio\"?",
        "ground_truth": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do select `Content` instead of `*` for all columns. Do reference table `TV_Channel` instead of `tv_channels`. Do filter on `series_name` instead of `channel_name`. Do use double quotes `\"Sky Radio\"` instead of single quotes for the string literal. The amended query now correctly retrieves the specified content from the TV_Channel table based on the series name rather than channel name."
        ],
        "rules": [
            "1) When answering about \"content of TV Channel with serial name\": make sure the output order: Content. 2) When the question mentions \"serial name\": \"serial name\" actually means \"series_name in schema\". 3) When the question mentions \"TV Channel\": use table \"TV_Channel\" instead of \"tv_channels\". 4) When filtering for the literal \"Sky Radio\": use double quotes \"Sky Radio\" exactly as specified. 5) When selecting content from TV_Channel: select only the \"Content\" column instead of all columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM tv_channels WHERE channel_name = 'Sky Radio';",
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ],
        "rule_sql": [
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ]
    },
    "359": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many paragraphs for the document with name 'Summer Show'?",
        "ground_truth": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
        "amends": [
            "Do add `JOIN Documents AS T2 ON T1.document_ID = T2.document_ID` instead of querying only the `paragraphs` table. Do move the filter `document_name = 'Summer Show'` to the joined `Documents` table instead of applying it directly to `paragraphs`. Do reference the joined table alias `T2` in the WHERE clause instead of the original table name. The amended query now correctly joins the tables and filters on the document name from the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"paragraphs for document with name 'Summer Show'\": combine tables paragraphs (T1) and Documents (T2) using the join condition T1.document_ID = T2.document_ID, keeping only matching pairs (inner match). 2) When the question mentions \"document with name 'Summer Show'\": apply the filter T2.document_name = 'Summer Show' exactly as specified (case-sensitive). 3) When the question asks for \"how many paragraphs\": count the number of rows using the canonical key from the paragraphs table after applying the join and filter conditions."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE document_name = 'Summer Show';",
            "SELECT COUNT(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Summer Show'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Paragraphs T1\nINNER JOIN Documents T2 ON T1.Document_ID = T2.Document_ID\nWHERE T2.Document_Name = 'Summer Show'"
        ]
    },
    "960": {
        "db_id": "dog_kennels",
        "question": "List the last name of the owner owning the youngest dog.",
        "ground_truth": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )",
        "amends": [
            "Do add `T1.last_name` with table alias instead of `last_name` without qualification. Do add `FROM Owners AS T1 JOIN Dogs AS T2` with explicit join instead of single table `FROM owners`. Do add `ON T1.owner_id = T2.owner_id` join condition instead of omitting any join. Do add `WHERE T2.age = (SELECT max(age) FROM Dogs)` subquery filter instead of `ORDER BY dog_age ASC`. Do remove `LIMIT 1` instead of keeping it, as the subquery now precisely identifies the maximum age. The amended query now correctly finds owners with dogs of maximum age instead of attempting to sort by a non-existent column."
        ],
        "rules": [
            "1) When answering about \"last name of the owner\": make sure the output column is T1.last_name with table alias qualification. 2) When combining Owners and Dogs tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match). 3) When the question asks for owners with the youngest dog: use WHERE T2.age = (SELECT max(age) FROM Dogs) to filter for dogs with maximum age instead of sorting. 4) When the question mentions \"youngest dog\": \"youngest\" actually means \"maximum age\" in the Dogs table. 5) When the question asks for a single result from a subquery filter: do not use LIMIT 1 as the subquery precisely identifies the maximum age."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM owners ORDER BY dog_age ASC LIMIT 1;",
            "SELECT T1.last_name \nFROM Owners AS T1 \nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id \nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ],
        "rule_sql": [
            "SELECT T1.last_name\nFROM Owners T1\nINNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id\nWHERE T2.age = (SELECT MAX(age) FROM Dogs)"
        ]
    },
    "367": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document ids and the number of paragraphs in each document. Order by document id.",
        "ground_truth": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT document_id, COUNT(*) FROM paragraphs GROUP BY document_id ORDER BY paragraph_id;"
        ],
        "rule_sql": [
            "SELECT d.Document_ID, COUNT(p.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents d\nLEFT JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID\nORDER BY d.Document_ID;"
        ]
    },
    "378": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Give the ids of documents that have between one and two paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs GROUP BY document_id HAVING COUNT(*) = 1 OR COUNT(*) = 2;"
        ],
        "rule_sql": [
            "SELECT Document_ID \nFROM Documents \nWHERE Document_ID IN (\n    SELECT Document_ID \n    FROM Paragraphs \n    GROUP BY Document_ID \n    HAVING COUNT(Paragraph_ID) BETWEEN 1 AND 2\n)"
        ]
    },
    "626": {
        "db_id": "tvshow",
        "question": "What is the episode for the TV series named \"Sky Radio\"?",
        "ground_truth": "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select only `T2.Episode` instead of selecting all columns with `*`. Do join `TV_Channel AS T1` with `TV_series AS T2` instead of querying only `tv_series` alone. Do use the join condition `T1.id = T2.Channel` instead of no join condition. Do filter on `T1.series_name = \"Sky Radio\"` instead of filtering on `name = 'Sky Radio'`. The amended query now correctly retrieves episodes from the specific channel series rather than incorrectly querying the series table directly."
        ],
        "rules": [
            "1) When answering about \"the episode for the TV series named 'Sky Radio'\": make sure the output order: T2.Episode. 2) When the question mentions \"TV series named 'Sky Radio'\": \"Sky Radio\" actually means T1.series_name in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for \"Sky Radio\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM tv_series WHERE name = 'Sky Radio';",
            "SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": [
            "SELECT T2.Episode FROM TV_Channel T1 JOIN TV_series T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
        ]
    },
    "117": {
        "db_id": "car_1",
        "question": "What is the average miles per gallon(mpg) of the cars with 4 cylinders?",
        "ground_truth": "SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;",
        "amends": [
            "Do select `avg(mpg)` instead of `AVG(horsepower)` to calculate the average miles per gallon rather than horsepower. Do reference table `CARS_DATA` instead of `cars` to use the correct table name. Do filter on `Cylinders = 4` instead of `cylinders = 4` to use the proper column name capitalization. The amended query now correctly calculates average MPG for 4-cylinder vehicles from the appropriate data source."
        ],
        "rules": [
            "1) When answering about \"average miles per gallon of cars with 4 cylinders\": make sure to calculate the average of \"mpg\" column instead of \"horsepower\". 2) When referencing the cars data table: use the exact table name \"CARS_DATA\" instead of \"cars\". 3) When filtering for 4-cylinder vehicles: use the exact column name \"Cylinders\" with proper capitalization and filter for value 4."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE cylinders = 4;",
            "SELECT AVG(MPG) FROM cars_data WHERE Cylinders = 4"
        ],
        "rule_sql": [
            "SELECT AVG(MPG) FROM CARS_DATA WHERE Cylinders = 4;"
        ]
    },
    "437": {
        "db_id": "wta_1",
        "question": "Find the average rank of winners in all matches.",
        "ground_truth": "SELECT avg(winner_rank) FROM matches",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(winner_rank) FROM matches WHERE winner_rank IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT AVG(winner_rank) AS average_winner_rank FROM matches WHERE winner_rank IS NOT NULL;"
        ]
    },
    "171": {
        "db_id": "car_1",
        "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';",
        "amends": [
            "Do use `DISTINCT T1.model` instead of `model` without distinct. Do join `MODEL_LIST AS T1`, `CAR_NAMES AS T2`, `CARS_DATA AS T3`, and `CAR_MAKERS AS T4` instead of querying only `cars`. Do use `ON T1.Model = T2.Model` and `ON T2.MakeId = T3.Id` and `ON T1.Maker = T4.Id` instead of no join conditions. Do filter with `T3.weight < 3500` instead of `weight < 3500`. Do use `T4.FullName != 'Ford Motor Company'` instead of `manufacturer = 'Ford Motor Company'` to exclude rather than include Ford vehicles. The amended query now correctly identifies distinct car models under 3500 pounds from manufacturers other than Ford Motor Company."
        ],
        "rules": [
            "1) When answering about \"models lighter than 3500 but not built by Ford Motor Company\": make sure the output order: T1.model\n2) When the question mentions \"models\": \"models\" actually means \"T1.model in schema\"\n3) When the question mentions \"lighter than 3500\": use T3.weight < 3500 as the filter condition\n4) When the question mentions \"not built by Ford Motor Company\": use T4.FullName != 'Ford Motor Company' to exclude Ford vehicles\n5) When combining multiple tables for this query: link T1 and T2 using T1.Model = T2.Model, link T2 and T3 using T2.MakeId = T3.Id, and link T1 and T4 using T1.Maker = T4.Id, keeping only matching pairs (inner match)\n6) When selecting distinct models: use DISTINCT T1.model to avoid duplicate model names\n7) When handling the manufacturer name: preserve the exact literal 'Ford Motor Company' with the exact case and spacing"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight < 3500 AND manufacturer = 'Ford Motor Company';",
            "SELECT DISTINCT T1.Model\nFROM model_list AS T1\nJOIN car_names AS T2 ON T1.Model = T2.Model\nJOIN cars_data AS T3 ON T2.MakeId = T3.Id\nJOIN car_makers AS T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model\nFROM model_list T1\nJOIN car_names T2 ON T1.Model = T2.Model\nJOIN cars_data T3 ON T2.MakeId = T3.Id\nJOIN car_makers T4 ON T1.Maker = T4.Id\nWHERE T3.Weight < 3500\nAND T4.FullName != 'Ford Motor Company'\nORDER BY T1.Model;"
        ]
    },
    "61": {
        "db_id": "pets_1",
        "question": "Find the major and age of students who do not have a cat pet.",
        "ground_truth": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter to exclude students with cats. Do add joins between `student`, `has_pet`, and `pets` tables instead of querying only the `students` table. Do reference `stuid` as the join condition instead of filtering directly on `pet`. Do use proper table aliases `T1`, `T2`, and `T3` instead of no aliases. Do filter on `pettype = 'cat'` in the subquery instead of `pet != 'cat'` in the main query. The amended query now correctly identifies students without cats by checking the pet relationships through proper table joins."
        ],
        "rules": [
            "1) When answering about students who do not have a cat pet: use a subquery with NOT IN instead of a simple WHERE filter to exclude students with cats. 2) When combining student, has_pet, and pets tables: add joins between these tables instead of querying only the students table. 3) When linking tables: reference stuid as the join condition instead of filtering directly on pet. 4) When using table aliases: use proper table aliases T1, T2, and T3 instead of no aliases. 5) When filtering for cat pets: filter on pettype = 'cat' in the subquery instead of pet != 'cat' in the main query."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, age FROM students WHERE pet != 'cat';",
            "SELECT T1.Major, T1.Age\nFROM Student T1\nWHERE T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T2.PetID = T3.PetID\n    WHERE T3.PetType = 'cat'\n)"
        ],
        "rule_sql": [
            "SELECT T1.Major, T1.Age FROM Student T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet T2 JOIN Pets T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'cat')"
        ]
    },
    "978": {
        "db_id": "dog_kennels",
        "question": "How many dogs have not gone through any treatment?",
        "ground_truth": "SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments )",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistency. Do reference the table as `Dogs` instead of `dogs` to match the correct case. Do change the filter to `dog_id NOT IN (subquery)` instead of `treatment_id IS NULL` to properly identify dogs without treatments. Do add a subquery `SELECT dog_id FROM Treatments` instead of omitting it, which correctly identifies dogs that have received treatments. The amended query now matches RIGHT_SQL's behavior by accurately counting dogs that have never received any treatment."
        ],
        "rules": [
            "1) When counting entities: use count(*) instead of COUNT(*) for consistency. 2) When referencing the Dogs table: use exact case \"Dogs\" instead of \"dogs\". 3) When identifying dogs without treatments: use dog_id NOT IN (subquery) instead of treatment_id IS NULL. 4) When creating the subquery for treatments: select dog_id FROM Treatments to identify dogs that have received treatments. 5) When counting dogs without any treatment: ensure the query accurately counts dogs that have never received any treatment by excluding those found in the Treatments subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM dogs WHERE treatment_id IS NULL;",
            "SELECT count(*) FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments)"
        ]
    },
    "561": {
        "db_id": "student_transcripts_tracking",
        "question": "Which address holds the most number of students currently? List the address id and all lines.",
        "ground_truth": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T1.line_1` and `T1.line_2` instead of `line1`, `line2`, and `line3`. Do remove the `student_count` alias and count aggregation from the SELECT list instead of including it. Do join on `T2.current_address_id` instead of `students.address_id`. Do remove the explicit column alias for the count instead of keeping `as student_count`. Do reference the count directly in ORDER BY instead of using the alias. The amended query now correctly retrieves address details with student counts using the proper join condition and ordering."
        ],
        "rules": [
            "1) When answering about \"which address holds the most number of students currently\": make sure the output order: address_id, line_1, line_2. 2) When counting students per address: compute the number of rows using the join condition on T2.current_address_id. 3) When combining addresses (T1) and students (T2) for shared entities: link rows where T1.address_id = T2.current_address_id and keep only matching pairs (inner match). 4) When the question mentions \"most number of students\": rank addresses by student count in descending order and keep the first 1 row. 5) When selecting address details: include T1.address_id, T1.line_1, and T1.line_2 instead of line1, line2, and line3."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT address_id, line1, line2, line3, COUNT(*) as student_count \nFROM addresses \nJOIN students ON addresses.address_id = students.address_id \nGROUP BY address_id \nORDER BY student_count DESC \nLIMIT 1;",
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses T1\nJOIN Students T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT a.address_id, a.line_1, a.line_2\nFROM Addresses a\nINNER JOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id, a.line_1, a.line_2\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;"
        ]
    },
    "412": {
        "db_id": "museum_visit",
        "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.",
        "ground_truth": "SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC",
        "amends": [
            "Do reference table `visitor` instead of `visitors` in the FROM clause. Do use column `Level_of_membership` instead of `membership_level` in both the WHERE filter and ORDER BY clause. Do sort by `Level_of_membership DESC` instead of `ASC` to order in descending rather than ascending sequence. The amended query now correctly references the proper table and column names with the intended sort direction."
        ],
        "rules": [
            "1) When the question mentions \"visitors\": use table \"visitor\" instead of \"visitors\". 2) When the question mentions \"membership level\": use column \"Level_of_membership\" instead of \"membership_level\" for both filtering and ordering. 3) When the question asks to order by level from high to low: sort by \"Level_of_membership\" in descending order (DESC) rather than ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM visitors WHERE membership_level > 4 ORDER BY membership_level ASC;",
            "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC;"
        ]
    },
    "62": {
        "db_id": "pets_1",
        "question": "What major is every student who does not own a cat as a pet, and also how old are they?",
        "ground_truth": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use a subquery with `NOT IN` instead of a simple `WHERE` filter to exclude students with cats. Do add joins between `student`, `has_pet`, and `pets` tables instead of querying only the `students` table. Do reference `stuid` as the join condition instead of assuming direct pet ownership in the main table. Do filter on `pettype = 'cat'` in the subquery instead of checking `pet != 'cat'` directly. Do use proper table aliases `T1`, `T2`, and `T3` instead of unspecified table references. The amended query now correctly identifies students without cats by checking through the relationship tables instead of making incorrect assumptions about pet data storage."
        ],
        "rules": [
            "1) When answering about students who do not own a cat as a pet: use a subquery with NOT IN instead of a simple WHERE filter to exclude students with cats. 2) When combining student, has_pet, and pets tables: add joins between these tables instead of querying only the students table. 3) When linking tables: reference stuid as the join condition instead of assuming direct pet ownership in the main table. 4) When filtering for cat ownership: filter on pettype = 'cat' in the subquery instead of checking pet != 'cat' directly. 5) When referencing tables: use proper table aliases T1, T2, and T3 instead of unspecified table references."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT major, age FROM students WHERE pet != 'cat';",
            "SELECT T1.Major, T1.Age\nFROM Student T1\nWHERE T1.StuID NOT IN (\n    SELECT T2.StuID\n    FROM Has_Pet T2\n    JOIN Pets T3 ON T2.PetID = T3.PetID\n    WHERE T3.PetType = 'cat'\n);"
        ],
        "rule_sql": [
            "SELECT T1.Major, T1.Age FROM Student T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet T2 JOIN Pets T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'cat')"
        ]
    },
    "946": {
        "db_id": "dog_kennels",
        "question": "List the date of each treatment, together with the first name of the professional who operated it.",
        "ground_truth": "SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do select `date_of_treatment` and `first_name` instead of `treatment_date` and `last_name`. Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.date_of_treatment` and `T2.first_name` instead of unqualified column names. Do specify `Treatments AS T1` and `Professionals AS T2` instead of simple table names. The amended query now correctly retrieves the treatment date and professional's first name with proper table aliasing."
        ],
        "rules": [
            "1) When the question asks for \"date of each treatment\": select \"date_of_treatment\" from table \"Treatments\" (aliased as T1) instead of \"treatment_date\". 2) When the question asks for \"first name of the professional\": select \"first_name\" from table \"Professionals\" (aliased as T2) instead of \"last_name\". 3) When combining tables Treatments and Professionals: use table aliases T1 for Treatments and T2 for Professionals. 4) When referencing columns from joined tables: qualify column names with their table aliases as T1.date_of_treatment and T2.first_name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT treatment_date, last_name FROM treatments JOIN professionals ON treatments.professional_id = professionals.professional_id;",
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id = T2.professional_id;"
        ],
        "rule_sql": [
            "SELECT T1.date_of_treatment, T2.first_name FROM Treatments T1 JOIN Professionals T2 ON T1.professional_id = T2.professional_id;"
        ]
    },
    "469": {
        "db_id": "wta_1",
        "question": "Find the average ranking for each player and their first name.",
        "ground_truth": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do change the GROUP BY clause to use `T1.first_name` instead of `player_id`. Do move the `first_name` column to the SELECT list after the aggregate function instead of placing it first. Do reference the `first_name` column with table alias `T1` instead of without qualification. The amended query now correctly joins the necessary tables and groups by the appropriate non-aggregated column to match the intended behavior.",
            "Do place `T1.first_name` after the aggregate function instead of listing it first in the SELECT clause. Do use lowercase `avg(ranking)` without an alias instead of `AVG(T2.ranking) AS average_ranking`. Do maintain the same `JOIN` on `T1.player_id = T2.player_id` and `GROUP BY T1.first_name` structure. The amended query now correctly calculates the average ranking per first name while maintaining the same logical behavior."
        ],
        "rules": [
            "1) When answering about \"average ranking for each player and their first name\": make sure the output order: average ranking first, then first name. 2) When combining players table (T1) and rankings table (T2): link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 3) When grouping by player first name: organize results by T1.first_name and compute average ranking per group. 4) When selecting columns: place the aggregate function AVG(ranking) before T1.first_name in the output.",
            "1) When answering about \"average ranking for each player and their first name\": make sure the output order: average ranking calculation first, then first name. 2) When computing average ranking: use lowercase avg(ranking) without an alias instead of AVG(T2.ranking) AS average_ranking. 3) When combining players T1 and rankings T2: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 4) When grouping by first name: organize results by T1.first_name and compute the average ranking per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, AVG(ranking) FROM players GROUP BY player_id;",
            "SELECT T1.first_name, AVG(T2.ranking) AS average_ranking\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nGROUP BY T1.first_name",
            "SELECT AVG(T2.ranking), T1.first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT avg(ranking), first_name FROM players JOIN rankings ON players.player_id = rankings.player_id GROUP BY first_name"
        ]
    },
    "442": {
        "db_id": "wta_1",
        "question": "How many distinct countries do players come from?",
        "ground_truth": "SELECT count(DISTINCT country_code) FROM players",
        "amends": [
            "Do `count(DISTINCT country_code)` instead of `COUNT(*)` to count distinct country codes rather than all rows. Do add the `country_code` column reference instead of omitting it to specify what to count distinctly. The amended query now correctly counts distinct country codes instead of total player records, matching the intended behavior."
        ],
        "rules": [
            "1) When counting distinct countries: use the exact column token \"country_code\" from the players table to count distinct values. 2) When the question asks for \"distinct countries\": compute the number of unique values in the \"country_code\" column rather than counting all rows. 3) When the question mentions \"countries\": \"countries\" actually means \"country_code\" in the players schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ]
    },
    "548": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name of the course with the most students enrolled?",
        "ground_truth": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id` instead of querying only the `courses` table. Do add `GROUP BY T1.course_name` instead of omitting grouping. Do change `ORDER BY count(*) DESC` instead of `ORDER BY student_count ASC` to order by enrollment count rather than student count. Do change `LIMIT 1` to return the course with the highest enrollment instead of the lowest student count. The amended query now correctly identifies the most popular course by enrollment count rather than relying on potentially incorrect student_count data."
        ],
        "rules": [
            "1) When answering about \"course with the most students enrolled\": make sure the output order: T1.course_name. 2) When the question mentions \"most students enrolled\": actually means \"count of students per course\" in schema. 3) When combining T1 (courses) and T2 (Student_Enrolment_Courses) for shared entities: link rows where T1.course_id = T2.course_id; keep only matching pairs (inner match). 4) When the question asks for \"count of students enrolled per course\": compute the number of rows using the canonical key from the join (T2.course_id). 5) When the question asks for \"most\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row. 6) When producing output: include only T1.course_name as the result."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.course_name\nFROM Courses AS T1\nJOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.course_name\nFROM Courses T1\nINNER JOIN Student_Enrolment_Courses T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id, T1.course_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "742": {
        "db_id": "world_1",
        "question": "Which continent has the most diverse languages?",
        "ground_truth": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Continent` instead of `continent` and reference the `country` table instead of `countries`. Do add a `JOIN` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying a single table. Do count all rows with `COUNT(*)` instead of counting `language` specifically. Do order by `COUNT(*) DESC` instead of `language_count DESC` while keeping the same `LIMIT 1` logic. The amended query now correctly identifies the continent with the most languages by joining the country and countrylanguage tables and counting all language records per continent.",
            "Do remove `COUNT(*) as language_count` from the SELECT list instead of including it, as the RIGHT_SQL only needs to return the continent with the highest language count rather than both the continent and the count value. The amended query now correctly returns just the continent name while maintaining the same grouping, ordering, and limit logic to identify the continent with the most languages, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"continent with the most diverse languages\": use T1.Continent for continent information and join with countrylanguage as T2 on T1.Code = T2.CountryCode. 2) When counting languages per continent: count all rows using COUNT(*) instead of counting specific language column. 3) When ordering results to find the continent with most languages: order by the count in descending order and keep only the top result with LIMIT 1. 4) When combining country and countrylanguage tables: link rows where T1.Code equals T2.CountryCode and keep only matching pairs (inner match). 5) When grouping results: organize by T1.Continent to compute aggregates per continent.",
            "1) When answering about \"which continent has the most diverse languages\": make sure the output order: only return the continent name without the count value. 2) When the question asks for the continent with the most languages: rank continents by language count in descending order and keep the first 1 row. 3) When counting languages per continent: compute the number of rows using the canonical key for languages (T2.CountryCode + T2.Language) or count distinct language names if specified in schema. 4) When combining country and countrylanguage tables: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 5) When grouping by continent: organize results by T1.Continent and compute language count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(language) as language_count FROM countries GROUP BY continent ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Continent, COUNT(*) as language_count\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T1.Continent\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Continent\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Continent\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "1027": {
        "db_id": "singer",
        "question": "What is the sname of every sing that does not have any song?",
        "ground_truth": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "amends": [
            "Do select `Name` from the `singer` table instead of `sname` from `sing`. Do use a `WHERE` clause with `Singer_ID NOT IN` subquery instead of checking `song_id IS NULL`. Do reference the correct table name `singer` instead of `sing`. Do use the proper column name `Singer_ID` in both the main query and subquery instead of `song_id`. Do include a correlated subquery that checks for singers without songs in the `song` table instead of simply checking for null values. The amended query now correctly identifies singers who have no associated songs by using a NOT IN subquery rather than a simple null check."
        ],
        "rules": [
            "1) When answering about \"sname of every sing that does not have any song\": select \"Name\" from the \"singer\" table instead of \"sname\" from \"sing\". 2) When identifying singers without songs: use a WHERE clause with \"Singer_ID NOT IN\" subquery instead of checking for null values. 3) When referencing the singer table: use the correct table name \"singer\" instead of \"sing\". 4) When using the singer identifier: use the proper column name \"Singer_ID\" in both the main query and subquery instead of \"song_id\". 5) When checking for singers without songs: include a correlated subquery that checks for singers without songs in the \"song\" table instead of simply checking for null values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT sname FROM sing WHERE song_id IS NULL;",
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ],
        "rule_sql": [
            "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
        ]
    },
    "737": {
        "db_id": "world_1",
        "question": "How many languages are spoken in Aruba?",
        "ground_truth": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages` table. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no join. Do filter on `T1.Name = \"Aruba\"` instead of `country = 'Aruba'`. Do count `T2.Language` instead of `COUNT(*)`. The amended query now correctly counts languages by joining country and countrylanguage tables and filtering by country name instead of a non-existent country column."
        ],
        "rules": [
            "1) When answering about \"languages spoken in Aruba\": make sure the output order: count of languages\n2) When the question mentions \"Aruba\": \"Aruba\" actually means \"T1.Name = 'Aruba'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"count of languages\": compute the number of unique values of T2.Language using the exact token from the amends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Aruba';",
            "SELECT COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ]
    },
    "972": {
        "db_id": "dog_kennels",
        "question": "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.",
        "ground_truth": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
        "amends": [
            "Do use `email_address` instead of `email` in the SELECT list. Do reference the table as `Owners` instead of `owners` to match the correct case. The amended query now correctly selects the appropriate email column and maintains proper table reference casing to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for email information: use the exact column name \"email_address\" instead of \"email\" from the Professionals table. 2) When referencing the owners table: use the exact table name \"Owners\" with proper case instead of \"owners\". 3) When the question mentions \"state whose name contains the substring 'North'\": use the exact literal '%North%' with proper case and percentage wildcards for pattern matching."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM owners WHERE state LIKE '%North%';",
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ]
    },
    "138": {
        "db_id": "car_1",
        "question": "What is the average edispl for all volvos?",
        "ground_truth": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';",
        "amends": [
            "Do join `CAR_NAMES AS T1` and `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do filter on `T1.Model = 'volvo'` instead of `make = 'Toyota'`. Do select `avg(T2.edispl)` with explicit table qualification instead of `AVG(edispl)` without table reference. The amended query now correctly joins the necessary tables and filters by model rather than make, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average edispl for all volvos\": make sure the output order: avg(T2.edispl). 2) When the question mentions \"volvos\": \"volvos\" actually means \"T1.Model = 'volvo'\" in schema. 3) When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match). 4) When computing average edispl: use T2.edispl with explicit table qualification instead of unqualified edispl."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(edispl) FROM cars WHERE make = 'Toyota';",
            "SELECT AVG(T2.Edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ]
    },
    "73": {
        "db_id": "pets_1",
        "question": "Find the average weight for each pet type.",
        "ground_truth": "SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do calculate `avg(weight)` instead of `AVG(age)` as average_weight. Do select `pettype` instead of `pet_type` in the GROUP BY clause. Do remove the alias `as average_weight` instead of keeping it. The amended query now correctly calculates average weight by pet type rather than average age.",
            "Do use lowercase `avg(weight)` instead of uppercase `AVG(weight)` and lowercase `pettype` instead of uppercase `PetType` in the SELECT list. Do place `avg(weight)` before `pettype` instead of after it in the column order. Do use lowercase `pets` instead of uppercase `Pets` and lowercase `pettype` instead of uppercase `PetType` in the GROUP BY clause. The amended query now matches the correct behavior with proper lowercase identifiers and column ordering."
        ],
        "rules": [
            "1) When the question asks for \"average weight\": calculate the average of the \"weight\" column instead of \"age\". 2) When grouping by pet type: use the exact column name \"pettype\" instead of \"pet_type\" in the GROUP BY clause. 3) When the question asks for average weight per pet type: do not include an alias like \"as average_weight\" in the output.",
            "1) When the question asks for average weight per pet type: compute the average of the \"weight\" column for each distinct value of \"pettype\". 2) When ordering output columns: place the aggregate result \"avg(weight)\" before the grouping column \"pettype\". 3) When using identifiers from the Pets table: use lowercase identifiers \"pets\", \"pettype\", and \"weight\" exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_weight FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(weight) FROM Pets GROUP BY PetType;",
            "SELECT avg(weight), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT AVG(weight), pettype FROM pets GROUP BY pettype"
        ]
    },
    "1020": {
        "db_id": "singer",
        "question": "Show distinct names of singers that have songs with sales more than 300000.",
        "ground_truth": "SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000",
        "amends": [
            "Do use `DISTINCT T1.Name` instead of just `name` to eliminate duplicate singer names. Do join `singer AS T1` with `song AS T2` instead of querying only the singers table. Do specify the join condition `ON T1.Singer_ID = T2.Singer_ID` instead of missing the table relationship entirely. Do filter on `T2.Sales > 300000` instead of `sales > 300000` to correctly reference song sales rather than singer sales. The amended query now properly identifies singers who have songs with sales exceeding 300,000, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct names of singers\": use DISTINCT T1.Name to eliminate duplicate singer names. 2) When combining singers and songs tables: link rows where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match). 3) When filtering for songs with sales more than 300000: apply the condition T2.Sales > 300000 to reference song sales rather than singer sales. 4) When answering about singers with songs meeting criteria: make sure the output order: T1.Name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE sales > 300000",
            "SELECT DISTINCT T1.Name \nFROM singer AS T1 \nJOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nWHERE T2.Sales > 300000"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Name \nFROM singer T1 \nINNER JOIN song T2 ON T1.Singer_ID = T2.Singer_ID \nWHERE T2.Sales > 300000 \nORDER BY T1.Name"
        ]
    },
    "85": {
        "db_id": "pets_1",
        "question": "Find the average age of students who do not have any pet .",
        "ground_truth": "select avg(age) from student where stuid not in (select stuid from has_pet)",
        "amends": [
            "Do reference the `student` table instead of `students` in the FROM clause. Do use a subquery with `stuid not in (select stuid from has_pet)` instead of the `pet_count > 0` WHERE filter. Do remove the aggregate function reference to `pet_count` instead of keeping it, as the correct logic checks for absence in the has_pet relationship table rather than counting pets. The amended query now correctly identifies students without pets by checking their absence in the has_pet table rather than relying on a potentially incorrect or missing pet_count field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average age of students who do not have any pet\": make sure the output order: AVG(age). 2) When the question mentions \"students\": \"students\" actually means \"student in schema\". 3) When checking for students without pets: use a subquery with stuid not in (select stuid from has_pet) instead of checking pet_count > 0. 4) When combining student and has_pet tables for absence checking: link rows where stuid values match between the tables to identify students not present in has_pet."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM students WHERE pet_count > 0;",
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ],
        "rule_sql": [
            "SELECT AVG(Age) FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet)"
        ]
    },
    "913": {
        "db_id": "network_1",
        "question": "Return the number of likes that the high schooler named Kyle has.",
        "ground_truth": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM likes WHERE student_id = (SELECT id FROM highschooler WHERE name = 'Kyle');"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Likes \nJOIN Highschooler ON Likes.student_id = Highschooler.ID \nWHERE Highschooler.name = 'Kyle'"
        ]
    },
    "973": {
        "db_id": "dog_kennels",
        "question": "Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.",
        "ground_truth": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
        "amends": [
            "Do reference `email_address` instead of `email` in the SELECT list. Do use the correct table name `Owners` instead of `owners` in the FROM clause. The amended query now correctly retrieves the email address field from the Owners table with proper case sensitivity and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"email\": use the exact column name \"email_address\" from the Professionals table instead. 2) When referencing the owners table: use the exact table name \"Owners\" with proper case sensitivity. 3) When the question mentions \"owners living in a state whose name contains the substring 'North'\": filter rows where the state column contains the literal substring 'North' exactly as specified."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM owners WHERE state LIKE '%North%';",
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, email_address FROM Owners WHERE state LIKE '%North%';"
        ]
    },
    "503": {
        "db_id": "battle_death",
        "question": "How many battles did not lose any ship with tonnage '225'?",
        "ground_truth": "SELECT count(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage  =  '225' );",
        "amends": [
            "Do reference the `battle` table instead of `battles` in the FROM clause. Do use a subquery with `NOT IN` filtering on `id` against `lost_in_battle` values from the `ship` table instead of a direct `WHERE ship_tonnage != '225'` filter. Do check for ships with `tonnage = '225'` in the subquery instead of comparing battle attributes directly. Do remove the incorrect `ship_tonnage` column reference since this attribute belongs to ships rather than battles. The amended query now correctly counts battles where no ship of 225 tonnage was lost, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"battles that did not lose any ship with tonnage '225'\": use the \"battle\" table instead of \"battles\" as the main data source. 2) When counting battles where no ship of 225 tonnage was lost: use a subquery with NOT IN filtering on battle id against lost_in_battle values from the ship table. 3) When checking for ships with specific tonnage: verify ships with tonnage = '225' exactly (preserving the literal value) in the subquery instead of comparing battle attributes directly. 4) When referencing ship attributes: do not use ship_tonnage column reference from the battle table since this attribute belongs to ships rather than battles."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM battles WHERE ship_tonnage != '225';",
            "SELECT COUNT(*) \nFROM battle \nWHERE id NOT IN (\n    SELECT lost_in_battle \n    FROM ship \n    WHERE tonnage = '225'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM battle \nWHERE id NOT IN (\n    SELECT lost_in_battle \n    FROM ship \n    WHERE tonnage = '225'\n)"
        ]
    },
    "927": {
        "db_id": "dog_kennels",
        "question": "Find the first names that are used for professionals or owners but are not used as dog names.",
        "ground_truth": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name \nFROM professionals \nWHERE first_name NOT IN (SELECT name FROM dogs)\nUNION\nSELECT DISTINCT first_name \nFROM owners \nWHERE first_name NOT IN (SELECT name FROM dogs);"
        ],
        "rule_sql": [
            "SELECT DISTINCT first_name \nFROM (\n    SELECT first_name FROM Professionals\n    UNION \n    SELECT first_name FROM Owners\n)\nWHERE first_name NOT IN (SELECT name FROM Dogs WHERE name IS NOT NULL)"
        ]
    },
    "910": {
        "db_id": "network_1",
        "question": "Show the names of students who have a grade higher than 5 and have at least 2 friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do use a `JOIN` between `Friend` as `T1` and `Highschooler` as `T2` on `T1.student_id = T2.id` instead of querying a single table. Do move the friends count filter to `HAVING count(*) >= 2` instead of using `friends >= 2` in the WHERE clause. Do add `GROUP BY T1.student_id` to support the aggregate count instead of omitting grouping. Do keep the grade filter `T2.grade > 5` in the WHERE clause but reference it through the joined table instead of directly. The amended query now correctly identifies students with at least two friends in grade above 5 by joining the Friend and Highschooler tables and using proper aggregation."
        ],
        "rules": [
            "1) When answering about student names: select \"T2\".\"name\" from the \"Highschooler\" table instead of \"name\" from a \"students\" table. 2) When combining Friend and Highschooler tables: link rows where \"T1\".\"student_id\" = \"T2\".\"id\" and keep only matching pairs (inner match). 3) When filtering by grade higher than 5: apply the condition \"T2\".\"grade\" > 5 in the WHERE clause. 4) When counting friends per student: group by \"T1\".\"student_id\" and count the number of friend relationships. 5) When requiring at least 2 friends: filter groups using HAVING count(*) >= 2 instead of using a direct column comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE grade > 5 AND friends >= 2;",
            "SELECT T2.name \nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nWHERE T2.grade > 5\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nWHERE T2.grade > 5\nGROUP BY T1.student_id\nHAVING COUNT(*) >= 2"
        ]
    },
    "968": {
        "db_id": "dog_kennels",
        "question": "How many professionals have performed any treatment to dogs?",
        "ground_truth": "SELECT count(DISTINCT professional_id) FROM Treatments",
        "amends": [
            "Do select `count(DISTINCT professional_id)` instead of `COUNT(*)` to count unique professionals rather than all rows. Do query from the `Treatments` table instead of the `professionals` table to access treatment-specific data. Do remove the `WHERE treatment_type = 'dog'` filter instead of keeping it, as the count should include all treatments rather than filtering by type. The amended query now correctly counts distinct professionals from the Treatments table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting professionals: count distinct \"professional_id\" values instead of counting all rows. 2) When accessing treatment data: use the \"Treatments\" table instead of the \"professionals\" table. 3) When counting professionals who performed treatments: include all treatments without filtering by treatment type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE treatment_type = 'dog'",
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ]
    },
    "778": {
        "db_id": "world_1",
        "question": "What are the country codes for countries that do not speak English?",
        "ground_truth": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "amends": [
            "Do query the `countrylanguage` table instead of the `countries` table. Do use `EXCEPT` to exclude English-speaking countries instead of a simple inequality filter. Do reference `CountryCode` instead of `country_code` and `LANGUAGE` instead of `language`. Do use double quotes around 'English' instead of single quotes. The amended query now correctly identifies country codes where English is not spoken by excluding those where it is spoken, matching the RIGHT_SQL's set-based logic."
        ],
        "rules": [
            "1) When answering about countries that do not speak English: query the \"countrylanguage\" table instead of the \"countries\" table. 2) When excluding English-speaking countries: use EXCEPT to exclude countries where \"LANGUAGE\" equals \"English\" instead of a simple inequality filter. 3) When referencing country codes: use \"CountryCode\" instead of \"country_code\" as the column name. 4) When referencing languages: use \"LANGUAGE\" instead of \"language\" as the column name. 5) When using the literal value for English: use double quotes around \"English\" instead of single quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language != 'English';",
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
        ],
        "rule_sql": [
            "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE \"LANGUAGE\" = \"English\""
        ]
    },
    "691": {
        "db_id": "voter_1",
        "question": "What is last date created of votes from the state 'CA'?",
        "ground_truth": "SELECT max(created) FROM votes WHERE state  =  'CA'",
        "amends": [
            "Do use the column name `created` instead of `created_at` in the MAX function. Do maintain the same filter condition `state = 'CA'` without changes. The amended query now correctly references the actual column name and matches the behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"last date created\": use the MAX function on the exact column name \"created\" to find the most recent timestamp. 2) When filtering for votes from the state 'CA': use the exact literal value 'CA' with the state column filter. 3) When referring to column names in the schema: use the exact token \"created\" instead of \"created_at\" as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(created_at) FROM votes WHERE state = 'CA';",
            "SELECT MAX(created) FROM VOTES WHERE state = 'CA';"
        ],
        "rule_sql": [
            "SELECT MAX(created) FROM VOTES WHERE state = 'CA';"
        ]
    },
    "106": {
        "db_id": "car_1",
        "question": "What is the name of each continent and how many car makers are there in each one?",
        "ground_truth": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",
        "amends": [
            "Do add `CONTINENTS AS T1` and `COUNTRIES AS T2` tables with proper joins instead of querying `car_makers` alone. Do use `JOIN COUNTRIES AS T2 ON T1.ContId = T2.continent` instead of missing the countries-continents relationship. Do use `JOIN car_makers AS T3 ON T2.CountryId = T3.Country` instead of directly grouping by continent from car_makers. Do select `T1.Continent` with proper table qualification instead of just `continent`. The amended query now correctly links continents to countries to car manufacturers and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name of each continent and how many car makers are there in each one\": make sure the output order: T1.Continent first, then count of car makers. 2) When combining tables for continents, countries, and car makers: link T1 and T2 where T1.ContId = T2.continent, then link T2 and T3 where T2.CountryId = T3.Country, keeping only matching pairs (inner match). 3) When counting car makers per continent: compute the number of rows using T3's canonical key for car makers (likely T3.Id or similar, though not explicitly shown in amends). 4) When grouping results: organize by T1.Continent to get counts per continent. 5) When selecting continent name: use T1.Continent with proper table qualification instead of just continent."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(*) FROM car_makers GROUP BY continent;",
            "SELECT T1.Continent, COUNT(T3.Id) AS NumberOfCarMakers\nFROM continents AS T1\nJOIN countries AS T2 ON T1.ContId = T2.Continent\nJOIN car_makers AS T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent"
        ],
        "rule_sql": [
            "SELECT T1.Continent, COUNT(T3.Id) AS NumberOfCarMakers\nFROM continents T1\nINNER JOIN countries T2 ON T1.ContId = T2.Continent\nINNER JOIN car_makers T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent\nORDER BY T1.Continent, NumberOfCarMakers;"
        ]
    },
    "637": {
        "db_id": "tvshow",
        "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
        "ground_truth": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `JOIN` with `cartoon` table on `T1.id = T2.Channel` instead of querying only `tv_channels` table. Do reference `directed_by` column from the joined `cartoon` table instead of `director` column from the base table. Do use `INTERSECT` to find series directed by both 'Michael Chang' and 'Ben Jones' instead of using `OR` logic that would return series directed by either. Do split into two separate queries with specific `directed_by` filters instead of combining conditions with mixed `AND/OR` precedence. Do add table aliases `T1` and `T2` for clarity instead of using unqualified column references. The amended query now correctly finds series directed by both specified directors through set intersection."
        ],
        "rules": [
            "1) When answering about TV channels playing cartoons: combine the tv_channels table (as T1) with the cartoon table (as T2) by linking rows where T1.id equals T2.Channel. 2) When the question mentions \"directed by Ben Jones and Michael Chang\": use the directed_by column from T2 (cartoon table) instead of any director column from T1. 3) When finding series directed by both specified directors: use INTERSECT to find the intersection of series directed by 'Michael Chang' and series directed by 'Ben Jones' instead of using OR logic. 4) When outputting results: return series_name and country columns from the tv_channels table (T1)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name, country FROM tv_channels WHERE director = 'Ben Jones' OR director = 'Michael Chang' AND genre = 'cartoon';",
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.directed_by = 'Michael Chang'"
        ],
        "rule_sql": [
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel AS T1\nJOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel AS T1\nJOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ]
    },
    "19": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity for the stadium with the highest average attendance?",
        "ground_truth": "SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",
        "amends": [
            "Do reference table `stadium` instead of `stadiums` in the FROM clause. Do order by `average` instead of `capacity` in the ORDER BY clause. The amended query now correctly references the intended table and sorts by the average column rather than capacity, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about stadium information: use table \"stadium\" (not \"stadiums\") as the base table T1. 2) When the question asks for the stadium with highest average attendance: order rows by column \"average\" in descending direction and keep only the first row. 3) When producing output for stadium details: include columns \"name\" and \"capacity\" in that order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY capacity DESC LIMIT 1;",
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, capacity FROM stadium ORDER BY average DESC LIMIT 1;"
        ]
    },
    "564": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the average transcript date?",
        "ground_truth": "SELECT avg(transcript_date) FROM Transcripts",
        "amends": [
            "Do reference the correct table name `Transcripts` instead of `transcript` and use the proper column name `transcript_date` instead of `date` for the AVG function, as the original query referenced incorrect schema elements that would cause execution errors. The amended query now correctly calculates the average of transcript dates from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"transcript date\": use the exact column name \"transcript_date\" from table \"Transcripts\". 2) When calculating average of transcript dates: compute the average of the \"transcript_date\" column from table \"Transcripts\". 3) When referencing table names: use the exact table name \"Transcripts\" instead of variations like \"transcript\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(date) FROM transcript;",
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ],
        "rule_sql": [
            "SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;"
        ]
    },
    "714": {
        "db_id": "world_1",
        "question": "What are the population and life expectancies in Brazil?",
        "ground_truth": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
        "amends": [
            "Do select `Population` and `LifeExpectancy` instead of `population` and `life_expectancy`. Do use table `country` instead of `countries`. Do filter on `Name = \"Brazil\"` instead of `name = 'Brazil'` with proper column name and quote style. The amended query now correctly retrieves population and life expectancy data for Brazil from the country table."
        ],
        "rules": [
            "1) When the question asks about population and life expectancy: select \"Population\" and \"LifeExpectancy\" columns from the country table. 2) When filtering for Brazil: use the condition Name = \"Brazil\" with exact case and double quotes. 3) When referring to the countries table: use the exact table name \"country\" instead of \"countries\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE name = 'Brazil';",
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ],
        "rule_sql": [
            "SELECT Population, LifeExpectancy FROM country WHERE Name = \"Brazil\";"
        ]
    },
    "628": {
        "db_id": "tvshow",
        "question": "How many cartoons did each director create?",
        "ground_truth": "SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",
        "amends": [
            "Do use the column name `Directed_by` instead of `director` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. Do reference the table name `cartoon` instead of `cartoons` in the FROM clause. The amended query now correctly counts records grouped by the director column using the proper table and column names from the schema."
        ],
        "rules": [
            "1) When the question asks about \"director\": use the exact column name \"Directed_by\" from the schema instead of \"director\". 2) When counting records per director: place the count result first in the output order before the director name. 3) When referencing the cartoon table: use the exact table name \"cartoon\" instead of \"cartoons\". 4) When grouping by director: use the exact column name \"Directed_by\" in both the grouping and output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT director, COUNT(*) FROM cartoons GROUP BY director;",
            "SELECT count(*), Directed_by FROM Cartoon GROUP BY Directed_by"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, Directed_by FROM Cartoon GROUP BY Directed_by ORDER BY count DESC;"
        ]
    },
    "617": {
        "db_id": "tvshow",
        "question": "What is minimum and maximum share of TV series?",
        "ground_truth": "SELECT max(SHARE) , min(SHARE) FROM TV_series;",
        "amends": [
            "Do use table name `TV_series` instead of `movies` with filter `WHERE type = 'TV Series'`. Do swap the column order by placing `max(SHARE)` first instead of `MIN(share) AS min_share` first. Do remove the column aliases `min_share` and `max_share` instead of keeping them. Do use uppercase function names `max` and `min` instead of mixed case `MIN` and `MAX`. The amended query now correctly selects from the dedicated TV_series table and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about minimum and maximum share of TV series: use the table name \"TV_series\" instead of \"movies\". 2) When computing aggregate values for TV series: use uppercase function names \"max\" and \"min\" instead of mixed case \"MIN\" and \"MAX\". 3) When ordering output columns for minimum and maximum share: place \"max(SHARE)\" first instead of \"MIN(share)\" first. 4) When selecting aggregate values: remove column aliases \"min_share\" and \"max_share\" instead of keeping them."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(share) AS min_share, MAX(share) AS max_share FROM movies WHERE type = 'TV Series';",
            "SELECT max(Share), min(Share) FROM TV_series"
        ],
        "rule_sql": [
            "SELECT max(Share), min(Share) FROM TV_series"
        ]
    },
    "241": {
        "db_id": "flight_2",
        "question": "Find all airlines that have at least 10 flights.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
        "amends": [
            "Do add table `AIRLINES AS T1` and `FLIGHTS AS T2` in the FROM clause instead of only having `flights`. Do use `JOIN` with the predicate `T1.uid = T2.Airline` instead of no join condition. Do specify `T1.Airline` in the SELECT list instead of just `airline` to clarify the source table. The amended query now correctly joins the airlines and flights tables to count flights per airline and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"airlines that have at least 10 flights\": make sure the output order: T1.Airline. 2) When the question mentions \"airlines\": \"airlines\" actually means \"T1.Airline in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.Airline). 5) When the question says \"at least 10\": include only groups where the count is greater than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 10",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) >= 10"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(T2.Airline) >= 10\nORDER BY T1.Airline"
        ]
    },
    "762": {
        "db_id": "world_1",
        "question": "Find the name, population and expected life length of asian country with the largest area?",
        "ground_truth": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference table `country` instead of `countries` and use exact column names `Name`, `Population`, and `LifeExpectancy` instead of `name`, `population`, and `life_expectancy`. Do filter on `Continent = \"Asia\"` instead of `continent = 'Asia'` using double quotes for the string literal. Do order by `SurfaceArea DESC` instead of `area DESC` to match the correct column name. The amended query now correctly references the proper table schema and column names to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"asian country with the largest area\": make sure the output order: Name, Population, LifeExpectancy 2) When the question mentions \"name\": \"name\" actually means \"Name in schema\" 3) When the question mentions \"population\": \"population\" actually means \"Population in schema\" 4) When the question mentions \"expected life length\": \"expected life length\" actually means \"LifeExpectancy in schema\" 5) When the question mentions \"largest area\": \"area\" actually means \"SurfaceArea in schema\" 6) When the question mentions \"asian country\": filter rows where Continent = \"Asia\" exactly 7) When the question asks for \"largest area\": rank rows by SurfaceArea in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE continent = 'Asia' ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1"
        ]
    },
    "996": {
        "db_id": "dog_kennels",
        "question": "What are all the possible breed type and size type combinations?",
        "ground_truth": "SELECT DISTINCT breed_code ,  size_code FROM dogs",
        "amends": [
            "Do select `breed_code` and `size_code` instead of `breed_type` and `size_type`. Do use `DISTINCT` instead of `GROUP BY breed_type, size_type`. The amended query now correctly retrieves unique combinations of breed_code and size_code from the dogs table."
        ],
        "rules": [
            "1) When the question asks for breed type and size type combinations: use \"breed_code\" and \"size_code\" columns from the Dogs table instead of \"breed_type\" and \"size_type\". 2) When retrieving all possible combinations of two columns: use DISTINCT to get unique pairs of values from \"breed_code\" and \"size_code\". 3) When the question asks for combinations without aggregation: do not use GROUP BY, use DISTINCT on the column pair instead."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed_type, size_type FROM dogs GROUP BY breed_type, size_type;",
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ]
    },
    "994": {
        "db_id": "dog_kennels",
        "question": "List the email, cell phone and home phone of all the professionals.",
        "ground_truth": "SELECT email_address ,  cell_number ,  home_phone FROM professionals",
        "amends": [
            "Do select `email_address`, `cell_number`, and `home_phone` instead of `email` and `cell_phone`, adding the `home_phone` column instead of omitting it. The amended query now matches RIGHT_SQL's behavior by including all three specified columns from the professionals table."
        ],
        "rules": [
            "1) When the question asks for \"email\": use the exact column name \"email_address\" from the Professionals table. 2) When the question asks for \"cell phone\": use the exact column name \"cell_number\" from the Professionals table. 3) When the question asks for \"home phone\": use the exact column name \"home_phone\" from the Professionals table. 4) When answering about \"List the email, cell phone and home phone of all the professionals\": make sure the output order: email_address, cell_number, home_phone."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email, cell_phone FROM professionals;",
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ],
        "rule_sql": [
            "SELECT email_address, cell_number, home_phone FROM Professionals;"
        ]
    },
    "400": {
        "db_id": "course_teach",
        "question": "What is the name of each teacher and what course they teach?",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `course_arrange AS T1` joined with `course AS T2` on `T1.Course_ID = T2.Course_ID` instead of directly joining `teachers` with `courses`. Do add a second join with `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of the incorrect join condition `teachers.teacher_id = students.student_id` which referenced a non-existent table. The amended query now correctly establishes relationships through the junction table and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about teacher names and courses they teach: make sure the output order: T3.Name, T2.Course\n2) When combining course_arrange (T1) and course (T2): link rows where T1.Course_ID = T2.Course_ID and keep only matching pairs (inner match)\n3) When combining course_arrange (T1) and teacher (T3): link rows where T1.Teacher_ID = T3.Teacher_ID and keep only matching pairs (inner match)\n4) When selecting teacher names: use T3.Name instead of teacher_name\n5) When selecting course names: use T2.Course instead of course_name"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers JOIN courses ON teachers.teacher_id = students.student_id;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID;"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange T1 INNER JOIN course T2 ON T1.Course_ID = T2.Course_ID INNER JOIN teacher T3 ON T1.Teacher_ID = T3.Teacher_ID"
        ]
    },
    "727": {
        "db_id": "world_1",
        "question": "Give the total surface area covered by countries in Asia or Europe.",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` to match the correct column name. Do reference the `Continent` column instead of `continent` to match the correct column name. Do reference the `country` table instead of `countries` to match the correct table name. Do use double quotes around string literals \"Asia\" and \"Europe\" instead of single quotes to match the correct string formatting. The amended query now correctly calculates the sum of surface areas for Asian and European countries from the proper table with accurate column references and string formatting."
        ],
        "rules": [
            "1) When the question asks about surface area: use the exact column name \"SurfaceArea\" from the country table. 2) When the question mentions continents: use the exact column name \"Continent\" from the country table. 3) When the question refers to countries: use the exact table name \"country\" instead of \"countries\". 4) When filtering for specific continents \"Asia\" or \"Europe\": use double quotes around the literal values \"Asia\" and \"Europe\" exactly as shown. 5) When calculating total surface area for multiple continents: sum the \"SurfaceArea\" values where \"Continent\" equals either \"Asia\" or \"Europe\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM countries WHERE continent = 'Asia' OR continent = 'Europe';",
            "SELECT SUM(SurfaceArea) FROM country WHERE Continent = \"Asia\" OR Continent = \"Europe\";"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) FROM country WHERE Continent = \"Asia\" OR Continent = \"Europe\";"
        ]
    },
    "624": {
        "db_id": "tvshow",
        "question": "What is the name of the series that has the episode \"A Love of a Lifetime\"?",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do add `TV_Channel AS T1` and `TV_series AS T2` as FROM sources instead of only `episodes`. Do use `JOIN` with `ON T1.id = T2.Channel` instead of querying a single table. Do reference `T1.series_name` instead of just `series_name`. Do filter on `T2.Episode = \"A Love of a Lifetime\"` instead of `episode_title = 'A Love of a Lifetime'`. The amended query now correctly joins the channel and series tables to find the series name for the specified episode, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a series name for a specific episode: use TV_Channel as T1 and TV_series as T2 as FROM sources instead of only episodes. 2) When combining T1 and T2: link rows where T1.id = T2.Channel and keep only matching pairs (inner match). 3) When referencing the series name: use T1.series_name instead of just series_name. 4) When filtering for the episode \"A Love of a Lifetime\": use T2.Episode = \"A Love of a Lifetime\" with exact case and punctuation as shown."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name FROM episodes WHERE episode_title = 'A Love of a Lifetime'",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ],
        "rule_sql": [
            "SELECT T1.series_name FROM TV_Channel AS T1 INNER JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ]
    },
    "546": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names of all courses that have some students enrolled?",
        "ground_truth": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
        "amends": [
            "Do add `DISTINCT` modifier and join `Student_Enrolment_Courses` table instead of querying only the `courses` table. Do use `JOIN` with `T1.course_id = T2.course_id` predicate instead of filtering by `student_count = 0`. Do remove the `WHERE` clause condition instead of keeping the incorrect filter that doesn't account for enrollment relationships. The amended query now correctly identifies courses with student enrollments by joining the enrollment table rather than relying on a potentially incorrect student_count field."
        ],
        "rules": [
            "1) When answering about courses with enrolled students: join the courses table (T1) with the Student_Enrolment_Courses table (T2) using the exact key equality T1.course_id = T2.course_id to find matching enrollment records. 2) When the question asks for course names with enrollments: use DISTINCT modifier on course_name to return each course only once, regardless of how many students are enrolled. 3) When combining T1 and T2 for shared entities: perform an inner match to keep only courses that have at least one enrollment record in the Student_Enrolment_Courses table. 4) When the original query incorrectly filters by student_count = 0: remove any WHERE clause conditions that filter based on student_count field since enrollment relationships are determined through the join with Student_Enrolment_Courses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_count = 0;",
            "SELECT DISTINCT c.course_name\nFROM Courses c\nJOIN Student_Enrolment_Courses sec ON c.course_id = sec.course_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.course_name\nFROM Courses c\nINNER JOIN Student_Enrolment_Courses sec ON c.course_id = sec.course_id;"
        ]
    },
    "670": {
        "db_id": "poker_player",
        "question": "Give average earnings of poker players who are taller than 200.",
        "ground_truth": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200",
        "amends": [
            "Do join `people AS T1` and `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do reference `T2.Earnings` instead of `earnings` from the wrong table. Do filter on `T1.Height > 200` instead of `height > 200` from the incorrect table. The amended query now correctly joins related tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average earnings of poker players\": make sure the output order: average of T2.Earnings. 2) When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID and keep only matching pairs (inner match). 3) When the question mentions \"poker players who are taller than 200\": filter rows where T1.Height > 200. 4) When computing average earnings: use T2.Earnings from the poker_player table, not earnings from the poker_players table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE height > 200",
            "SELECT AVG(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Earnings) FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ]
    },
    "805": {
        "db_id": "world_1",
        "question": "Return the names of the 3 countries with the fewest people.",
        "ground_truth": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do use column name `Name` instead of `name` and `Population` instead of `population` to match the correct case sensitivity. Do use `ASC` ordering instead of `DESC` to sort by population in ascending order instead of descending. Do use table name `country` instead of `countries` to reference the correct table. The amended query now correctly selects from the proper table with accurate column names and ascending population ordering."
        ],
        "rules": [
            "1) When the question asks for country names: use column \"Name\" from table \"country\" instead of \"name\" from other tables. 2) When the question asks about population counts: use column \"Population\" from table \"country\" to get accurate population data. 3) When the question asks for countries with the fewest people: sort by \"Population\" in ascending order (ASC) instead of descending order (DESC). 4) When the question specifies \"3 countries\": limit the results to exactly 3 rows. 5) When referencing the country table: use table name \"country\" instead of \"countries\" to access the correct data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population DESC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ]
    },
    "875": {
        "db_id": "network_1",
        "question": "Count the number of high schoolers in grades 9 or 10.",
        "ground_truth": "SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10",
        "amends": [
            "Do use the correct table name `Highschooler` instead of the incorrect `high_schoolers`. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "1) When the question asks about \"high schoolers\": use the exact table name \"Highschooler\" with the correct case and spelling. 2) When counting entities from the Highschooler table: count using the canonical key for high schoolers (typically a primary key column, though not explicitly specified in this schema). 3) When filtering for grades 9 or 10: use the exact numeric values 9 and 10 without quotes since grade appears to be a numeric field."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM high_schoolers WHERE grade = 9 OR grade = 10;",
            "SELECT COUNT(*) FROM Highschooler WHERE grade IN (9, 10);"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Highschooler WHERE grade = 9 OR grade = 10;"
        ]
    },
    "671": {
        "db_id": "poker_player",
        "question": "What are the names of poker players in descending order of earnings?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from `poker_players`. Do join `poker_player` as `T2` on `T1.People_ID = T2.People_ID` instead of querying only the `poker_players` table. Do order by `T2.Earnings DESC` instead of `earnings ASC`, changing both the sort direction and the source table for the earnings column. The amended query now correctly joins the people and poker_player tables to retrieve player names with their corresponding earnings data and sorts them in descending order by earnings, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about poker player names: select \"T1.Name\" from the \"people\" table instead of \"name\" from \"poker_players\". 2) When combining people and poker_player tables: link rows where \"T1.People_ID = T2.People_ID\" and keep only matching pairs (inner match). 3) When ordering by earnings in descending order: sort by \"T2.Earnings DESC\" instead of \"earnings ASC\", changing both the sort direction and the source table for the earnings column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY earnings ASC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ]
    },
    "342": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes, and how many documents use each type?",
        "ground_truth": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference `T1.template_type_code` in both SELECT and GROUP BY instead of directly using `template_type_code` without table qualification. Do remove the `ORDER BY document_count DESC` clause instead of keeping it, as the right query focuses only on aggregation without sorting. Do remove the alias `document_count` from the COUNT(*) expression instead of keeping it, since the right query returns the count without column naming. The amended query now correctly joins the Templates and Documents tables to count documents per template type while matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different template type codes and how many documents use each type\": make sure to join Templates table as T1 to Documents table as T2 on T1.template_id = T2.template_id instead of querying only one table. 2) When selecting template type codes: use T1.template_type_code in both SELECT and GROUP BY instead of unqualified template_type_code. 3) When counting documents per template type: count using the join result without column aliases instead of using document_count alias. 4) When producing the final result: do not include ORDER BY clause as the question does not require sorting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) as document_count FROM documents GROUP BY template_type_code ORDER BY document_count DESC;",
            "SELECT T1.Template_Type_Code, COUNT(*) \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nGROUP BY T1.Template_Type_Code"
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code, COUNT(*) \nFROM Templates T1 \nJOIN Documents T2 ON T1.Template_ID = T2.Template_ID \nGROUP BY T1.Template_Type_Code"
        ]
    },
    "475": {
        "db_id": "wta_1",
        "question": "find the code of the country where has the greatest number of players.",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `GROUP BY country_code` and order by `count(*) DESC` instead of selecting individual records with `ORDER BY player_id DESC`. Do add the grouping operation to count occurrences per country instead of retrieving a single random country code. Do change the ordering criteria to frequency-based ranking instead of arbitrary player ID ordering. The amended query now correctly identifies the most frequent country code by count rather than returning an arbitrary country from the last player record.",
            "Do remove `COUNT(*) as player_count` from the SELECT list instead of including it, and do reference `count(*)` directly in the ORDER BY clause instead of using the alias `player_count`. Do keep the same GROUP BY on `country_code` and maintain the DESC ordering with LIMIT 1. The amended query now correctly returns only the country_code with the highest player count while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the country with the greatest number of players: group results by the exact token \"country_code\" from the players table. 2) When counting players per country: count the number of rows using the canonical key for players (player_id) to determine frequency. 3) When ranking countries by player count: order the results by the count of players in descending order to find the highest count. 4) When selecting the top result: return only the first row after ordering by count to get the country with the greatest number of players.",
            "1) When counting players per country: use the exact column token \"country_code\" for grouping and count all rows using count(*) 2) When finding the country with the greatest number of players: order the results by count(*) in descending direction and keep only the first row 3) When outputting results: include only the \"country_code\" column in the output, not the count value"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players ORDER BY player_id DESC LIMIT 1;",
            "SELECT country_code, COUNT(*) as player_count FROM players GROUP BY country_code ORDER BY player_count DESC LIMIT 1;",
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "5": {
        "db_id": "concert_singer",
        "question": "What is the average, minimum, and maximum age for all French singers?",
        "ground_truth": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use filter condition `country = 'France'` instead of `nationality = 'France'` in the WHERE clause. The amended query now correctly calculates age statistics for French singers from the appropriate table with the correct country filter."
        ],
        "rules": [
            "1) When answering about \"average, minimum, and maximum age for all French singers\": make sure the output order: AVG(age), MIN(age), MAX(age). 2) When the question mentions \"French singers\": \"French\" actually means \"country = 'France'\" in schema. 3) When the question mentions \"singers\": \"singers\" actually means table \"singer\" in schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age), MIN(age), MAX(age) FROM singers WHERE nationality = 'France';",
            "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age, MAX(Age) AS Maximum_Age FROM singer WHERE Country = 'France';"
        ],
        "rule_sql": [
            "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age, MAX(Age) AS Maximum_Age FROM singer WHERE Country = 'France';"
        ]
    },
    "293": {
        "db_id": "employee_hire_evaluation",
        "question": "Which district has both stores with less than 3000 products and stores with more than 10000 products?",
        "ground_truth": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "amends": [
            "Do reference table `shop` instead of `stores` and column `Number_products` instead of `products`. Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with conflicting conditions `products < 3000 AND products > 10000`. Do split the logic into two separate `SELECT` statements: one for `Number_products < 3000` and another for `Number_products > 10000`, then intersect the results to find districts that satisfy both conditions simultaneously, which correctly implements the intended logic instead of the impossible condition that would return no results."
        ],
        "rules": [
            "1) When the question mentions \"stores\": use table \"shop\" instead. 2) When the question mentions \"products\": use column \"Number_products\" instead. 3) When finding districts with both stores having less than 3000 products and stores having more than 10000 products: use INTERSECT between two separate queries - one for \"Number_products < 3000\" and another for \"Number_products > 10000\" - instead of combining both conditions in a single WHERE clause. 4) When selecting districts: ensure the output column is \"district\" from the \"shop\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district FROM stores WHERE products < 3000 AND products > 10000;",
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ],
        "rule_sql": [
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ]
    },
    "482": {
        "db_id": "wta_1",
        "question": "How many matches were played in each year?",
        "ground_truth": "SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",
        "amends": [
            "Do place the `COUNT(*)` column first in the SELECT list instead of placing `year` first. Do use uppercase `YEAR` for both the column reference and GROUP BY clause instead of lowercase `year`. The amended query now correctly groups by and returns the year column while maintaining the same aggregation logic."
        ],
        "rules": [
            "1) When answering about \"matches played in each year\": make sure the output order: COUNT(*) first, then YEAR. 2) When referring to the year column: use uppercase \"YEAR\" for both column reference and grouping instead of lowercase \"year\". 3) When counting matches per year: compute the number of rows using COUNT(*) while grouping by YEAR."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM matches GROUP BY year;",
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR"
        ],
        "rule_sql": [
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR ORDER BY COUNT(*) DESC, YEAR;"
        ]
    },
    "492": {
        "db_id": "battle_death",
        "question": "List the name and tonnage ordered by in descending alphaetical order for the names.",
        "ground_truth": "SELECT name ,  tonnage FROM ship ORDER BY name DESC",
        "amends": [
            "Do use table name `ship` instead of `ships` in the FROM clause. Do change the sort direction to `DESC` instead of `ASC` in the ORDER BY clause. The amended query now correctly references the intended table and sorts results in descending order by name."
        ],
        "rules": [
            "1) When the question asks for ships information: use the table name \"ship\" exactly as specified in the schema. 2) When ordering by name in descending alphabetical order: sort the \"name\" column in descending direction (Z to A). 3) When selecting output columns: include both \"name\" and \"tonnage\" columns in the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, tonnage FROM ships ORDER BY name ASC;",
            "SELECT name, tonnage FROM ship ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name, tonnage FROM ship ORDER BY name DESC;"
        ]
    },
    "1004": {
        "db_id": "singer",
        "question": "What are the birth year and citizenship of singers?",
        "ground_truth": "SELECT Birth_Year ,  Citizenship FROM singer",
        "amends": [
            "Do reference the table as `singer` instead of `singers` to match the correct table name. Do capitalize column names as `Birth_Year` and `Citizenship` instead of lowercase `birth_year` and `citizenship` to match the correct column naming convention. The WHERE clause remains unchanged as `birth_year > 2000` since the filter logic is correct. The amended query now correctly references the singer table with proper column capitalization.",
            "Do include all records without any filter instead of filtering with `birth_year > 2000` in the WHERE clause. The amended query now matches RIGHT_SQL's behavior by returning all singer records regardless of birth year."
        ],
        "rules": [
            "1) When the question mentions \"singers\": use the exact table name \"singer\" instead of \"singers\". 2) When selecting columns \"birth year\" and \"citizenship\": use the exact column names \"Birth_Year\" and \"Citizenship\" with proper capitalization. 3) When filtering by birth year greater than 2000: keep the condition \"birth_year > 2000\" unchanged as the filter logic is correct.",
            "1) When answering about \"birth year and citizenship of singers\": make sure the output order: Birth_Year, Citizenship. 2) When the question asks for all singers: include all records without any filter condition on birth_year or other columns. 3) When handling the singer table: use the exact column identifiers Birth_Year and Citizenship as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_year, citizenship FROM singers WHERE birth_year > 2000;",
            "SELECT Birth_Year, Citizenship FROM singer WHERE birth_year > 2000",
            "SELECT Birth_Year, Citizenship FROM singer"
        ],
        "rule_sql": [
            "SELECT Birth_Year, Citizenship FROM singer;"
        ]
    },
    "441": {
        "db_id": "wta_1",
        "question": "find the number of distinct country codes of all players.",
        "ground_truth": "SELECT count(DISTINCT country_code) FROM players",
        "amends": [
            "Do use `count(DISTINCT country_code)` instead of `COUNT(country_code)` to count unique country codes rather than counting all non-null values, which eliminates duplicate country codes from the count. The amended query now matches RIGHT_SQL's behavior by providing a distinct count of country codes."
        ],
        "rules": [
            "1) When the question asks for \"distinct country codes\": compute the number of unique values of the exact token \"country_code\" rather than counting all non-null values. 2) When counting distinct values: use the exact identifier \"country_code\" without quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(country_code) FROM players;",
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT country_code) FROM players;"
        ]
    },
    "822": {
        "db_id": "orchestra",
        "question": "How many conductors are there?",
        "ground_truth": "SELECT count(*) FROM conductor",
        "amends": [
            "Do query the `conductor` table instead of the `employees` table. Do use the table name `conductor` instead of filtering `employees` with `WHERE job_title = 'conductor'`. The amended query now correctly counts records from the conductor table directly rather than filtering employees by job title, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many conductors\": query the \"conductor\" table directly instead of filtering another table. 2) When counting conductors: count all records from the \"conductor\" table using the canonical key for conductors."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'conductor';",
            "SELECT COUNT(*) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(Conductor_ID) FROM conductor;"
        ]
    },
    "354": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the different descriptions for templates that have been used in a document.",
        "ground_truth": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
        "amends": [
            "Do add `Ref_template_types AS T1`, `Templates AS T2`, and `Documents AS T3` tables instead of querying only `documents`. Do change the SELECT list to `T1.template_type_description` instead of `template_id`. Do add `JOIN Templates AS T2 ON T1.template_type_code = T2.template_type_code` and `JOIN Documents AS T3 ON T2.Template_ID = T3.template_ID` instead of no joins. The amended query now correctly retrieves distinct template type descriptions by properly joining through the template hierarchy rather than just selecting template IDs from documents."
        ],
        "rules": [
            "1) When answering about \"different descriptions for templates used in a document\": make sure the output order: T1.template_type_description. 2) When the question mentions \"descriptions for templates\": \"descriptions\" actually means \"T1.template_type_description\" in schema. 3) When combining T1, T2, and T3 for shared entities: link rows where T1.template_type_code = T2.template_type_code and T2.Template_ID = T3.template_ID; keep only matching pairs (inner match). 4) When the question asks for \"different descriptions\": compute the number of unique values of T1.template_type_description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT template_id FROM documents;",
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types AS T1\nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nJOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.template_type_description\nFROM Ref_Template_Types T1\nINNER JOIN Templates T2 ON T1.template_type_code = T2.template_type_code\nINNER JOIN Documents T3 ON T2.Template_ID = T3.Template_ID\nORDER BY T1.template_type_description;"
        ]
    },
    "623": {
        "db_id": "tvshow",
        "question": "What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.",
        "ground_truth": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\";",
        "amends": [
            "Do select `series_name` from the `TV_Channel` table instead of `tv_channel` from the `tv_series` table. Do add a `JOIN` between `TV_Channel AS T1` and `TV_series AS T2` on `T1.id = T2.Channel` instead of querying only the `tv_series` table. Do filter on `T2.Episode = \"A Love of a Lifetime\"` instead of `episode = 'A Love of a Lifetime'` to maintain the correct table reference in the WHERE clause. The amended query now correctly retrieves the series name from the TV_Channel table by joining with TV_series where the specific episode matches, ensuring the result matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"TV Channel of TV series\": the TV Channel's series name is stored in the \"TV_Channel\" table as \"series_name\" column, not in the \"tv_series\" table. 2) When combining information about TV series and TV channels: link rows where \"TV_Channel\".id equals \"TV_series\".Channel to find matching records between the two tables. 3) When filtering for a specific episode \"A Love of a Lifetime\": use the exact literal \"A Love of a Lifetime\" with double quotes and filter on the \"TV_series\" table's \"Episode\" column. 4) When the question asks to list the TV Channel's series name: output the \"series_name\" column from the \"TV_Channel\" table as the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tv_channel FROM tv_series WHERE episode = 'A Love of a Lifetime';",
            "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
        ],
        "rule_sql": [
            "SELECT TV_Channel.series_name FROM TV_Channel JOIN TV_series ON TV_Channel.id = TV_series.Channel WHERE TV_series.Episode = \"A Love of a Lifetime\""
        ]
    },
    "826": {
        "db_id": "orchestra",
        "question": "What are the names of conductors whose nationalities are not \"USA\"?",
        "ground_truth": "SELECT Name FROM conductor WHERE Nationality != 'USA'",
        "amends": [
            "Do reference table `conductor` instead of `conductors`. Do use column `Name` instead of `name`. Do use column `Nationality` instead of `nationality`. Do use inequality filter `!= 'USA'` instead of equality filter `= 'USA'`. The amended query now correctly filters for non-USA conductors using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks about conductors: use table \"conductor\" instead of \"conductors\". 2) When the question mentions \"names\": use column \"Name\" instead of \"name\". 3) When the question mentions \"nationalities\": use column \"Nationality\" instead of \"nationality\". 4) When filtering for conductors whose nationalities are not \"USA\": use inequality filter != 'USA' instead of equality filter = 'USA'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE nationality = 'USA';",
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor WHERE Nationality != 'USA';"
        ]
    },
    "259": {
        "db_id": "employee_hire_evaluation",
        "question": "How many employees are there?",
        "ground_truth": "SELECT count(*) FROM employee",
        "amends": [
            "Do reference the `employee` table instead of the `customers` table in the FROM clause, changing the source data being queried. The amended query now correctly counts records from the employee table instead of the customers table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many employees\": make sure to count records from the \"employee\" table instead of the \"customers\" table. 2) When counting entities: use the canonical counting method for all records in the specified table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers;",
            "SELECT COUNT(*) FROM employee;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM employee;"
        ]
    },
    "112": {
        "db_id": "car_1",
        "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?",
        "ground_truth": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';",
        "amends": [
            "Do join `CAR_NAMES` as `T2` on `T1.Id = T2.MakeId` instead of querying only the `cars` table. Do select `Accelerate` from `CARS_DATA` as `T1` instead of selecting `acceleration` from `cars`. Do filter on `T2.Make = 'amc hornet sportabout (sw)'` instead of filtering on both `model = 'amc hornet sportabout (sw)'` and `make = 'amc'`. Do remove the incorrect `make` filter condition instead of including it. The amended query now correctly joins the necessary tables and uses the proper column relationships to match the intended behavior."
        ],
        "rules": [
            "1) When answering about car acceleration for a specific model: select \"Accelerate\" from \"CARS_DATA\" as T1 instead of \"acceleration\" from \"cars\". 2) When the question mentions \"amc hornet sportabout (sw)\": this value should be matched against \"Make\" in \"CAR_NAMES\" as T2, not against \"model\" or \"make\" in the \"cars\" table. 3) When combining car data with car names: link rows where T1.Id = T2.MakeId and keep only matching pairs (inner join). 4) When filtering for specific car models: use T2.Make = 'amc hornet sportabout (sw)' as the filter condition, and do not include additional make filters."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT acceleration FROM cars WHERE model = 'amc hornet sportabout (sw)' AND make = 'amc';",
            "SELECT T1.Accelerate \nFROM cars_data T1\nJOIN car_names T2 ON T1.Id = T2.MakeId\nWHERE T2.Make = 'amc hornet sportabout (sw)'"
        ],
        "rule_sql": [
            "SELECT T1.Accelerate FROM cars_data AS T1 INNER JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'"
        ]
    },
    "237": {
        "db_id": "flight_2",
        "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "amends": [
            "Do use `INTERSECT` to find airlines serving both airports instead of joining the same table twice with separate conditions. Do reference `T1.Airline` instead of `a.name` and use proper table aliases `T1` and `T2` instead of `a`, `f1`, and `f2`. Do join on `T1.uid = T2.Airline` instead of `a.id = f1.airline_id` and use `T2.SourceAirport` instead of `f1.departure_airport`. Do remove the `DISTINCT` keyword since `INTERSECT` inherently returns distinct results. Do structure the query as two separate `SELECT` statements combined with `INTERSECT` instead of a single query with multiple joins. The amended query now correctly identifies airlines that serve both APG and CVO airports using set intersection logic."
        ],
        "rules": [
            "1) When the question asks for airlines that serve both airports 'APG' and 'CVO': use INTERSECT to combine results from two separate queries instead of joining the same table multiple times. 2) When referencing airline names: use the exact identifier \"T1.Airline\" instead of a.name. 3) When joining tables: use the exact key equality \"T1.uid = T2.Airline\" instead of a.id = f1.airline_id. 4) When filtering by departure airport: use the exact identifier \"T2.SourceAirport\" instead of f1.departure_airport and preserve the exact literals 'APG' and 'CVO' with proper case and quotes. 5) When using INTERSECT: do not include DISTINCT keyword since INTERSECT inherently returns distinct results. 6) When structuring the query: use two separate SELECT statements combined with INTERSECT instead of a single query with multiple joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM airlines a\nJOIN flights f1 ON a.id = f1.airline_id\nJOIN flights f2 ON a.id = f2.airline_id\nWHERE f1.departure_airport = 'APG' AND f2.departure_airport = 'CVO';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'"
        ]
    },
    "166": {
        "db_id": "car_1",
        "question": "For all of the 4 cylinder cars, which model has the most horsepower?",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` instead of `model, MAX(horsepower)` and remove the aggregate function. Do use `FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2` instead of `FROM cars` and add the required table join. Do specify `ON T1.MakeId = T2.Id` instead of omitting the join condition. Do move the filter to `WHERE T2.Cylinders = 4` instead of keeping it in WHERE but change the table reference. Do remove `GROUP BY model` since no aggregation is needed. Do order by `T2.horsepower DESC` instead of `MAX(horsepower) DESC` to use the direct column value. The amended query now correctly retrieves the model with the highest horsepower among 4-cylinder cars by properly joining the necessary tables and eliminating the unnecessary aggregation."
        ],
        "rules": [
            "1) When answering about \"4 cylinder cars\": filter rows where T2.Cylinders = 4. 2) When combining CAR_NAMES and CARS_DATA tables: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match). 3) When the question asks for \"which model has the most horsepower\": select T1.Model and order by T2.horsepower DESC to find the highest value. 4) When the question mentions \"model\": \"model\" actually means T1.Model in the schema. 5) When the question mentions \"horsepower\": \"horsepower\" actually means T2.horsepower in the schema. 6) When producing output: do not use aggregation functions like MAX() when the question asks for the model with the highest value, instead use direct column ordering."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model, MAX(horsepower) FROM cars WHERE cylinders = 4 GROUP BY model ORDER BY MAX(horsepower) DESC LIMIT 1;",
            "SELECT T1.Model\nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Cylinders = 4\nORDER BY T2.Horsepower DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names T1 INNER JOIN cars_data T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY CAST(T2.Horsepower AS NUMERIC) DESC LIMIT 1;"
        ]
    },
    "22": {
        "db_id": "concert_singer",
        "question": "Show the stadium name and the number of concerts in each stadium.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",
        "amends": [
            "Do join `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of querying only the `concerts` table. Do select `T2.name` instead of `stadium_name` to properly reference the joined table's column. Do group by `T1.stadium_id` instead of `stadium_name` to ensure correct aggregation with the join relationship. The amended query now correctly counts concerts per stadium by joining the necessary tables and using proper column references."
        ],
        "rules": [
            "1) When answering about \"stadium name and number of concerts in each stadium\": make sure the output order: T2.name, count of concerts. 2) When the question mentions \"stadium name\": \"stadium name\" actually means \"T2.name in schema\". 3) When combining concerts as T1 and stadium as T2 for shared entities: link rows where T1.stadium_id = T2.stadium_id; keep only matching pairs (inner match). 4) When the question asks for \"number of concerts in each stadium\": compute the count using T1.stadium_id as the counting key per stadium group. 5) When the question says \"per stadium\": organize results by T1.stadium_id and compute count of concerts per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name, COUNT(*) FROM concerts GROUP BY stadium_name;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS number_of_concerts\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID;"
        ],
        "rule_sql": [
            "SELECT T2.Name, COUNT(T1.concert_ID) \nFROM concert T1 \nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID \nGROUP BY T1.Stadium_ID \nORDER BY T2.Name, COUNT(T1.concert_ID)"
        ]
    },
    "911": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit `JOIN` syntax with `Friend AS T1 JOIN Highschooler AS T2` instead of a subquery in the WHERE clause. Do reference the joined table alias `T2.name` instead of the original table name `name`. Do move the grade filter to the `WHERE` clause with `T2.grade > 5` instead of keeping it in the main query's WHERE. Do add `GROUP BY T1.student_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using a correlated subquery. Do use proper table aliases `T1` and `T2` throughout instead of direct table references. The amended query now correctly identifies high schoolers with at least two friends using proper join and aggregation semantics."
        ],
        "rules": [
            "1) When combining Friend and Highschooler tables: link rows where T1.student_id equals T2.id using an inner join. 2) When filtering by grade: apply condition T2.grade > 5 to select high schoolers with grades over 5. 3) When counting friends per student: group results by T1.student_id and count the number of friend records for each student. 4) When requiring minimum friend count: include only groups having count(*) >= 2. 5) When selecting output columns: return T2.name as the result column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM high_schoolers WHERE grade > 5 AND (SELECT COUNT(*) FROM friends WHERE friends.student_id = high_schoolers.id) >= 2;",
            "SELECT T2.name \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nWHERE T2.grade > 5 \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Friend T1 \nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID \nWHERE T2.grade > 5 \nGROUP BY T1.student_id \nHAVING COUNT(*) >= 2"
        ]
    },
    "196": {
        "db_id": "flight_2",
        "question": "Return the number of airlines in the USA.",
        "ground_truth": "SELECT count(*) FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use `count(*)` instead of `COUNT(*)` for consistent lowercase function naming. Do reference table `AIRLINES` instead of `airlines` to match the actual table name case. Do filter on `Country = \"USA\"` instead of `country = 'United States'` to use the correct column name with proper capitalization and the standardized country code value instead of the full country name. The amended query now correctly counts airlines from the United States using the proper country code identifier."
        ],
        "rules": [
            "1) When answering about \"number of airlines in the USA\": use count(*) instead of COUNT(*) for consistent lowercase function naming. 2) When referencing the airlines table: use AIRLINES instead of airlines to match the actual table name case. 3) When filtering for airlines from the United States: use Country = \"USA\" instead of country = 'United States' to use the correct column name with proper capitalization and the standardized country code value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airlines WHERE country = 'United States';",
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM AIRLINES WHERE Country = \"USA\""
        ]
    },
    "598": {
        "db_id": "tvshow",
        "question": "How many different series and contents are listed in the TV Channel table?",
        "ground_truth": "SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",
        "amends": [
            "Do select `count(DISTINCT series_name)` and `count(DISTINCT content)` instead of just `COUNT(*)`. Do add distinct counting for both `series_name` and `content` columns instead of counting all rows without distinction. The amended query now correctly counts unique series names and unique content values separately instead of providing a single total row count, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"different series and contents\": count distinct values for both \"series_name\" and \"content\" columns separately instead of counting all rows. 2) When counting distinct entities: use DISTINCT counting for each specified column (\"series_name\" and \"content\") rather than a single COUNT(*) that counts total rows. 3) When the question mentions \"series\" and \"contents\": these refer to the exact column tokens \"series_name\" and \"content\" in the TV_Channel table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM TV_Channel;",
            "SELECT COUNT(DISTINCT series_name) AS unique_series_count, COUNT(DISTINCT Content) AS unique_content_count FROM TV_Channel;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT series_name) AS distinct_series, COUNT(DISTINCT Content) AS distinct_contents FROM TV_Channel;"
        ]
    },
    "734": {
        "db_id": "world_1",
        "question": "How many type of governments are in Africa?",
        "ground_truth": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  \"Africa\"",
        "amends": [
            "Do use `count(DISTINCT GovernmentForm)` instead of `COUNT(*)` to count distinct government forms rather than all rows. Do reference table `country` instead of `countries` as the correct table name. Do use column `Continent` instead of `continent` with proper capitalization. Do use double quotes `\"Africa\"` instead of single quotes `'Africa'` for the continent filter value. The amended query now correctly counts distinct government forms in African countries rather than counting all rows, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"type of governments\": use \"GovernmentForm\" column to count distinct government forms rather than counting all rows. 2) When referencing the table containing country data: use table name \"country\" instead of \"countries\". 3) When filtering by continent: use column \"Continent\" with exact capitalization. 4) When filtering for African countries: use literal value \"Africa\" with double quotes exactly as specified. 5) When counting distinct government forms: use count(DISTINCT GovernmentForm) to count unique government types rather than total rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Africa';",
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = \"Africa\";"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa';"
        ]
    },
    "552": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the date and id of the transcript with at least 2 courses listed?",
        "ground_truth": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
        "amends": [
            "Do use explicit table aliases `T2.transcript_date` and `T1.transcript_id` instead of ambiguous column names `date` and `id`. Do join tables `Transcript_Contents AS T1` and `Transcripts AS T2` with `ON T1.transcript_id = T2.transcript_id` instead of querying a single table. Do add `GROUP BY T1.transcript_id` instead of omitting grouping. Do move the count condition to `HAVING count(*) >= 2` instead of using `WHERE COUNT(course_id) >= 2` which is invalid syntax. Do remove the incorrect `course_id` reference and use `count(*)` instead. The amended query now correctly counts transcripts with multiple entries by joining the related tables and using proper grouping with HAVING.",
            "Do select `T1.transcript_id` and `T2.transcript_date` instead of `T2.transcript_id` and `T2.transcript_date`. Do maintain the same `FROM` clause with `Transcript_Contents AS T1` and `JOIN Transcripts AS T2` on `T1.transcript_id = T2.transcript_id`. Do preserve the `GROUP BY T1.transcript_id` and `HAVING COUNT(*) >= 2` clauses without changes. The amended query now correctly selects the transcript_id from the grouping table T1 instead of T2, ensuring proper grouping semantics while maintaining the same filtering logic for transcripts with at least two contents.",
            "Do include `T2.transcript_date` in the SELECT list instead of omitting it, and do reorder the columns as `T2.transcript_date, T1.transcript_id` instead of `T1.transcript_id, T2.transcript_date`. The amended query now correctly includes all necessary columns while maintaining the same grouping and filtering logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"transcript with at least 2 courses listed\": make sure the output order: T2.transcript_date, T1.transcript_id. 2) When combining Transcript_Contents as T1 and Transcripts as T2: link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match). 3) When counting courses per transcript: group results by T1.transcript_id and compute count(*) per group. 4) When filtering for transcripts with at least 2 courses: apply the condition count(*) >= 2 after grouping (HAVING clause equivalent). 5) When the question asks for \"date and id\": use T2.transcript_date for date and T1.transcript_id for id with exact identifier tokens.",
            "1) When answering about transcripts with at least 2 courses: select T1.transcript_id and T2.transcript_date as output columns. 2) When combining Transcript_Contents and Transcripts tables: link rows where T1.transcript_id = T2.transcript_id using an inner match. 3) When grouping by transcript_id: use T1.transcript_id as the grouping key. 4) When filtering for transcripts with at least 2 courses: count all rows per group and keep only groups where the count is greater than or equal to 2.",
            "1) When answering about \"date and id of the transcript with at least 2 courses listed\": make sure the output order: T2.transcript_date, T1.transcript_id\n2) When the question asks for transcripts with at least 2 courses: count the number of courses per transcript using T1.transcript_id and keep only those transcripts where the count is 2 or more\n3) When combining Transcript_Contents (T1) and Transcripts (T2): link rows where T1.transcript_id = T2.transcript_id and keep only matching pairs (inner match)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT date, id FROM transcript WHERE COUNT(course_id) >= 2",
            "SELECT T2.transcript_id, T2.transcript_date\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2",
            "SELECT T1.transcript_id, T2.transcript_date\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2",
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents AS T1\nJOIN Transcripts AS T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.transcript_date, T1.transcript_id\nFROM Transcript_Contents T1\nINNER JOIN Transcripts T2 ON T1.transcript_id = T2.transcript_id\nGROUP BY T1.transcript_id\nHAVING COUNT(*) >= 2\nORDER BY T2.transcript_date, T1.transcript_id"
        ]
    },
    "353": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the distinct template type descriptions for the templates ever used by any document?",
        "ground_truth": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
        "amends": [
            "Do select `T1.template_type_description` instead of `template_type` from the SELECT list. Do add `Ref_template_types AS T1` and `Templates AS T2` to the FROM clause instead of only `documents` and `templates`. Do change the join condition to `T1.template_type_code = T2.template_type_code` instead of `documents.template_id = templates.id`. Do add a second join `JOIN Documents AS T3 ON T2.Template_ID = T3.template_ID` instead of having only one join. The amended query now correctly retrieves template type descriptions from the appropriate reference table through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"distinct template type descriptions for templates ever used by any document\": make sure the output order: T1.template_type_description. 2) When the question mentions \"template type descriptions\": \"template type descriptions\" actually means \"T1.template_type_description in schema\". 3) When combining T1 (Ref_template_types) and T2 (Templates) for shared entities: link rows where T1.template_type_code = T2.template_type_code exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 (Templates) and T3 (Documents) for shared entities: link rows where T2.Template_ID = T3.template_ID exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"distinct template type descriptions\": compute the number of unique values of the exact token T1.template_type_description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT template_type FROM documents JOIN templates ON documents.template_id = templates.id",
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types AS T1\nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nJOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Template_Type_Description\nFROM Ref_Template_Types T1\nINNER JOIN Templates T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nINNER JOIN Documents T3 ON T2.Template_ID = T3.Template_ID\nORDER BY T1.Template_Type_Description;"
        ]
    },
    "266": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the cities that have more than one employee under age 30.",
        "ground_truth": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause, as the correct table name is singular. Do maintain the same SELECT list with `city`, WHERE filter with `age < 30`, GROUP BY clause with `city`, and HAVING condition with `count(*) > 1` without any changes to the logic or structure. The amended query now matches RIGHT_SQL's behavior with the corrected table reference."
        ],
        "rules": [
            "1) When the question asks about \"employees\": use the exact table name \"employee\" (singular form) instead of \"employees\". 2) When filtering for employees under age 30: use the condition \"age < 30\" exactly as specified. 3) When grouping results by city: use the column \"city\" for grouping. 4) When counting employees per city: use count(*) to count all rows in each group. 5) When filtering groups to show cities with more than one employee: use the condition \"count(*) > 1\" to only include cities with multiple employees. 6) When selecting output columns: include only \"city\" in the result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM employees WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1;"
        ]
    },
    "133": {
        "db_id": "car_1",
        "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.",
        "ground_truth": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;",
        "amends": [
            "Do select `T1.Model` from the `CAR_NAMES` table instead of selecting `model` from the `cars` table. Do join `CARS_DATA AS T2` using `ON T1.MakeId = T2.Id` instead of querying a single table without any joins. Do order by `T2.mpg` instead of ordering by `mpg` without table qualification. The amended query now correctly retrieves the car model with the highest MPG by properly joining the car names with their corresponding performance data."
        ],
        "rules": [
            "1) When answering about \"which model saves the most gasoline\": make sure the output order: T1.Model 2) When the question mentions \"model\": \"model\" actually means \"T1.Model in CAR_NAMES table\" 3) When combining T1 (CAR_NAMES) and T2 (CARS_DATA) for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question mentions \"maximum miles per gallon\" or \"most gasoline\": rank rows by T2.mpg in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.MPG DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM car_names T1 INNER JOIN cars_data T2 ON T1.MakeId = T2.Id ORDER BY CAST(T2.MPG AS REAL) DESC LIMIT 1;"
        ]
    },
    "900": {
        "db_id": "network_1",
        "question": "Show name of all students who have some friends and also are liked by someone else.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "amends": [
            "Do use `INTERSECT` to find common names instead of `IN` and `NOT IN` subqueries. Do join `Friend` table with `Highschooler` on `student_id = id` instead of querying `students` table directly. Do join `Likes` table with `Highschooler` on `liked_id = id` instead of using a negative subquery condition. Do select from explicit table aliases `T1` and `T2` instead of assuming a single `students` table. Do use proper table names `Friend` and `Likes` instead of generic `friends` and `likes`. The amended query now correctly finds students who are both in the Friend table and liked in the Likes table using set intersection instead of incorrect exclusion logic."
        ],
        "rules": [
            "1) When the question asks for students who have friends and are liked by someone: use INTERSECT to find common students between those who have friends and those who are liked, instead of using IN and NOT IN subqueries. 2) When joining the Friend table with Highschooler: link rows where Friend.student_id equals Highschooler.id. 3) When joining the Likes table with Highschooler: link rows where Likes.liked_id equals Highschooler.id. 4) When selecting from multiple tables: use explicit table aliases T1 and T2 instead of assuming a single students table. 5) When referring to table names: use exact table names \"Friend\" and \"Likes\" instead of generic \"friends\" and \"likes\". 6) When producing output: select the name column from the intersected result set."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE id IN (SELECT student_id FROM friends) AND id NOT IN (SELECT liked_id FROM likes);",
            "SELECT T1.name\nFROM Highschooler T1\nJOIN Friend ON T1.ID = Friend.student_id\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nJOIN Likes ON T2.ID = Likes.liked_id"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM Highschooler T1\nWHERE T1.ID IN (\n    SELECT student_id FROM Friend\n)\nINTERSECT\nSELECT T2.name\nFROM Highschooler T2\nWHERE T2.ID IN (\n    SELECT liked_id FROM Likes\n)"
        ]
    },
    "745": {
        "db_id": "world_1",
        "question": "What is the number of nations that use English and Dutch?",
        "ground_truth": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "amends": [
            "Do use a subquery with `INTERSECT` to find countries that speak both English and Dutch instead of a single `WHERE` clause with conflicting `language = 'English' AND language = 'Dutch'` conditions. Do join `country` and `countrylanguage` tables on `Code = CountryCode` instead of querying only the `nations` table. Do filter for English in one branch and Dutch in another branch with separate queries instead of trying to match both languages simultaneously in one condition. Do select `Name` from the `country` table instead of counting directly from an unspecified source. Do use proper table aliases `T1` and `T2` instead of unspecified table references. The amended query now correctly identifies countries where both languages are spoken by intersecting two separate queries for each language."
        ],
        "rules": [
            "1) When the question asks for nations that use both English and Dutch: use an intersection approach with separate queries for each language instead of a single condition with conflicting language requirements. 2) When combining country and countrylanguage tables: link rows where T1.Code = T2.CountryCode to connect countries with their languages. 3) When filtering for English language: use the exact literal 'English' in the condition for one branch of the intersection. 4) When filtering for Dutch language: use the exact literal 'Dutch' in the condition for the other branch of the intersection. 5) When selecting country names: use T1.Name from the country table as the identifier for nations. 6) When counting distinct nations: count the number of unique T1.Name values that appear in both language groups after the intersection operation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM nations WHERE language = 'English' AND language = 'Dutch';",
            "SELECT COUNT(*) \nFROM (\n    SELECT c.Name \n    FROM country c \n    JOIN countrylanguage cl1 ON c.Code = cl1.CountryCode \n    WHERE cl1.Language = 'English'\n    INTERSECT\n    SELECT c.Name \n    FROM country c \n    JOIN countrylanguage cl2 ON c.Code = cl2.CountryCode \n    WHERE cl2.Language = 'Dutch'\n) AS T1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfNations\nFROM (\n    SELECT c.Name\n    FROM country c\n    JOIN countrylanguage cl ON c.Code = cl.CountryCode\n    WHERE cl.Language = 'English'\n    INTERSECT\n    SELECT c.Name\n    FROM country c\n    JOIN countrylanguage cl ON c.Code = cl.CountryCode\n    WHERE cl.Language = 'Dutch'\n)"
        ]
    },
    "129": {
        "db_id": "car_1",
        "question": "Which countries in europe have at least 3 car manufacturers?",
        "ground_truth": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;",
        "amends": [
            "Do select `T1.CountryName` from the `COUNTRIES` table instead of `country` from `car_manufacturers`. Do join `CONTINENTS AS T2` on `T1.Continent = T2.ContId` and `CAR_MAKERS AS T3` on `T1.CountryId = T3.Country` instead of querying a single table. Do filter with `T2.Continent = 'europe'` instead of `continent = 'Europe'` and maintain the same `GROUP BY T1.CountryName` and `HAVING count(*) >= 3` logic. The amended query now correctly joins multiple tables to establish proper relationships between countries, continents, and car manufacturers while maintaining the same grouping and filtering behavior."
        ],
        "rules": [
            "1) When answering about \"countries in europe with at least 3 car manufacturers\": make sure the output order: T1.CountryName\n2) When the question mentions \"countries\": \"countries\" actually means \"T1.CountryName in COUNTRIES table\"\n3) When the question mentions \"europe\": \"europe\" actually means \"T2.Continent = 'europe'\" with exact lowercase spelling\n4) When combining COUNTRIES (T1) and CONTINENTS (T2): link rows where T1.Continent = T2.ContId and keep only matching pairs (inner match)\n5) When combining COUNTRIES (T1) and CAR_MAKERS (T3): link rows where T1.CountryId = T3.Country and keep only matching pairs (inner match)\n6) When the question asks for \"at least 3 car manufacturers\": organize results by T1.CountryName and compute count of car manufacturers per country using count(*) >= 3\n7) When counting car manufacturers: use the join relationship T1.CountryId = T3.Country to establish the connection between countries and their manufacturers"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM car_manufacturers WHERE continent = 'Europe' GROUP BY country HAVING COUNT(*) >= 3;",
            "SELECT T1.CountryName \nFROM countries AS T1\nJOIN continents AS T2 ON T1.Continent = T2.ContId\nJOIN car_makers AS T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3"
        ],
        "rule_sql": [
            "SELECT T1.CountryName\nFROM countries T1\nINNER JOIN continents T2 ON T1.Continent = T2.ContId\nINNER JOIN car_makers T3 ON T1.CountryId = T3.Country\nWHERE T2.Continent = 'europe'\nGROUP BY T1.CountryName\nHAVING COUNT(*) >= 3\nORDER BY T1.CountryName"
        ]
    },
    "219": {
        "db_id": "flight_2",
        "question": "How many United Airlines flights go to City 'Aberdeen'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRPORTS` as `T2` on `T1.DestAirport = T2.AirportCode` and `AIRLINES` as `T3` on `T3.uid = T1.Airline` instead of querying only the `flights` table. Do filter on `T2.City = \"Aberdeen\"` instead of `destination_city = 'Aberdeen'` and on `T3.Airline = \"United Airlines\"` instead of `airline = 'United Airlines'`. The amended query now correctly joins related tables to validate airport cities and airline names through proper foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"United Airlines flights to Aberdeen\": make sure the output order: count of flights\n2) When the question mentions \"United Airlines\": \"United Airlines\" actually means \"T3.Airline = \\\"United Airlines\\\"\" in schema\n3) When the question mentions \"City 'Aberdeen'\": \"Aberdeen\" actually means \"T2.City = \\\"Aberdeen\\\"\" in schema\n4) When combining T1 (flights) and T2 (AIRPORTS) for shared entities: link rows where T1.DestAirport = T2.AirportCode; keep only matching pairs (inner match)\n5) When combining T1 (flights) and T3 (AIRLINES) for shared entities: link rows where T3.uid = T1.Airline; keep only matching pairs (inner match)\n6) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T1's primary key)\n7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \\\"United Airlines\\\" and \\\"Aberdeen\\\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'United Airlines' AND destination_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights T1 JOIN airports T2 ON T1.DestAirport = T2.AirportCode JOIN airlines T3 ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nJOIN airports T2 ON T1.DestAirport = T2.AirportCode\nJOIN airlines T3 ON T3.uid = T1.Airline\nWHERE T3.Airline = \"United Airlines\" AND T2.City = \"Aberdeen\""
        ]
    },
    "94": {
        "db_id": "car_1",
        "question": "What is the full name of each car maker, along with its id and how many models it produces?",
        "ground_truth": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",
        "amends": [
            "Do join `MODEL_LIST` as `T2` on `T1.Id = T2.Maker` instead of querying only `car_makers` without any join. Do use `T1.Id` and `T1.FullName` in the SELECT list instead of `car_makers.id` and `car_makers.full_name`. Do group by only `T1.Id` instead of grouping by both `car_makers.id` and `car_makers.full_name`. Do remove the alias `model_count` from the count instead of keeping it. The amended query now correctly counts models per car maker by joining with the model table and matches the RIGHT_SQL's behavior.",
            "Do use `count(*)` instead of `COUNT(T2.ModelId)` to count all rows in each group rather than counting non-null ModelId values. Do reorder the SELECT list as `T1.FullName, T1.Id` instead of `T1.Id, T1.FullName` while maintaining the same logical output. Do add the `AS` keyword for table aliases as `CAR_MAKERS AS T1` and `MODEL_LIST AS T2` instead of omitting it, though this is purely syntactic. The amended query now correctly counts all car models per manufacturer regardless of null ModelId values and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about car makers and their model counts: join table MODEL_LIST as T2 with car_makers as T1 using the condition T1.Id = T2.Maker to link models to their makers. 2) When selecting output columns: use T1.Id and T1.FullName exactly as shown in the schema. 3) When counting models per car maker: count using the joined T2 table rows rather than counting from T1 alone. 4) When grouping results: group by only T1.Id instead of grouping by both T1.Id and T1.FullName. 5) When presenting results: do not use aliases like model_count for the count column.",
            "1) When counting models per car maker: count all rows in each group using count(*) instead of counting non-null values of a specific column. 2) When ordering output columns for car maker information: present FullName before Id in the output order. 3) When using table aliases: include the AS keyword for clarity when defining table aliases CAR_MAKERS AS T1 and MODEL_LIST AS T2."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT car_makers.id, car_makers.full_name, COUNT(*) as model_count \nFROM car_makers \nGROUP BY car_makers.id, car_makers.full_name",
            "SELECT T1.Id, T1.FullName, COUNT(T2.ModelId) \nFROM car_makers T1 \nJOIN model_list T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id",
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM car_makers AS T1 \nJOIN model_list AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id, COUNT(*) \nFROM car_makers AS T1 \nJOIN model_list AS T2 ON T1.Id = T2.Maker \nGROUP BY T1.Id \nORDER BY T1.FullName, T1.Id"
        ]
    },
    "997": {
        "db_id": "dog_kennels",
        "question": "Find the distinct breed type and size type combinations for dogs.",
        "ground_truth": "SELECT DISTINCT breed_code ,  size_code FROM dogs",
        "amends": [
            "Do select `breed_code` and `size_code` instead of `breed` and `size`. Do use `DISTINCT` instead of `GROUP BY breed, size`. The amended query now matches the right SQL's behavior by selecting distinct breed and size codes rather than grouping by the original columns."
        ],
        "rules": [
            "1) When the question asks for distinct breed type and size type combinations: use DISTINCT instead of GROUP BY to get unique combinations. 2) When selecting breed type information: use the exact column token \"breed_code\" instead of \"breed\". 3) When selecting size type information: use the exact column token \"size_code\" instead of \"size\". 4) When outputting the results: maintain the column order as breed_code followed by size_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed, size FROM dogs GROUP BY breed, size",
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT DISTINCT breed_code, size_code FROM Dogs;"
        ]
    },
    "240": {
        "db_id": "flight_2",
        "question": "Which airlines have departures from CVO but not from APG airports?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "amends": [
            "Do join `AIRLINES` and `FLIGHTS` tables on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do filter for `SourceAirport = \"CVO\"` instead of `departure_airport = 'CVO'`. Do use `EXCEPT` to exclude airlines that also serve `\"APG\"` instead of the contradictory `departure_airport != 'APG'` condition. Do select `T1.Airline` from the joined result instead of `airline` directly from flights. Do remove the `DISTINCT` modifier since `EXCEPT` inherently returns unique results. The amended query now correctly identifies airlines that serve CVO but not APG, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining AIRLINES and FLIGHTS tables: link rows where T1.uid = T2.Airline and keep only matching pairs (inner match). 2) When filtering for departures from CVO airport: use T2.SourceAirport = \"CVO\" instead of departure_airport = 'CVO'. 3) When excluding airlines that serve APG airport: use EXCEPT to remove airlines that have T2.SourceAirport = \"APG\" instead of using a contradictory condition. 4) When selecting airline names: use T1.Airline from the joined result instead of airline directly from flights. 5) When ensuring unique results: do not use DISTINCT modifier since EXCEPT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT airline FROM flights WHERE departure_airport = 'CVO' AND departure_airport != 'APG';",
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'CVO'\nEXCEPT\nSELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'APG'"
        ]
    },
    "336": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the lowest version number, along with its corresponding template type code.",
        "ground_truth": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
        "amends": [
            "Do use `MIN` aggregate function on `Version_Number` instead of `MAX` on `version_number`, and do reference the table as `Templates` with proper case instead of `templates` lowercase. The amended query now correctly retrieves the minimum version number per template type rather than the maximum, matching the intended behavior.",
            "Do use lowercase `min(Version_Number)` without an alias instead of `MIN(Version_Number) AS Lowest_Version_Number` with an alias. Do use lowercase `template_type_code` instead of `Template_Type_Code` in both the SELECT list and GROUP BY clause. Do remove the alias `Lowest_Version_Number` instead of keeping it. The amended query now matches the right SQL's behavior with consistent lowercase function and column names and no output column aliasing.",
            "Do include the comma separator between `min(Version_Number)` and `template_type_code` in the SELECT list instead of omitting it, as the missing comma would cause a syntax error. The amended query now correctly retrieves the minimum version number for each template type code from the Templates table with proper SQL syntax.",
            "Do include the space after the comma in `min(Version_Number) , template_type_code` instead of omitting it to maintain proper SQL syntax formatting, though this is purely cosmetic and does not affect the query's logical behavior or results. The amended query now matches RIGHT_SQL's behavior with identical functionality.",
            "Do include the space after the comma in `min(Version_Number) , template_type_code` instead of omitting it, as the spacing difference affects query formatting consistency while maintaining identical semantic behavior. The amended query now matches RIGHT_SQL's behavior with proper spacing conventions.",
            "Do include the space after `min(Version_Number)` instead of omitting it, and do add proper spacing around the comma in the SELECT list instead of having no spacing. The amended query now matches RIGHT_SQL's behavior with correct formatting while maintaining the same logical structure and functionality.",
            "Do include the space after `min(Version_Number)` instead of omitting it, and do add proper spacing around the comma in the SELECT list instead of having no space. Do maintain the same GROUP BY clause with `template_type_code` instead of changing it. The amended query now matches RIGHT_SQL's behavior with corrected formatting while preserving the same logical structure and output.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with proper formatting.",
            "Do include the space after the comma in `template_type_code` instead of omitting it, as the RIGHT_SQL maintains proper column spacing. The amended query now matches RIGHT_SQL's behavior with identical column formatting.",
            "Do include the space after the comma in the SELECT list instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space after the comma in `template_type_code` instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical column formatting and spacing.",
            "Do include the space after the comma in the SELECT list instead of omitting it, as the RIGHT_SQL maintains proper column separation syntax. The amended query now matches RIGHT_SQL's behavior with identical output structure and results.",
            "Do include the space before `template_type_code` in the SELECT list instead of omitting it, as the RIGHT_SQL maintains consistent spacing around the comma separator. The amended query now matches RIGHT_SQL's behavior with identical column selection and grouping logic.",
            "Do include the space after the comma in the SELECT list instead of omitting it, maintaining the proper syntax for separating columns. The amended query now matches RIGHT_SQL's behavior with correct column formatting.",
            "Do include the space after the comma in the SELECT list instead of omitting it, maintaining the proper syntax for separating columns. The amended query now matches RIGHT_SQL's behavior with correct column formatting."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(version_number), template_type_code FROM templates GROUP BY template_type_code;",
            "SELECT MIN(Version_Number) AS Lowest_Version_Number, Template_Type_Code FROM Templates GROUP BY Template_Type_Code;",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number), template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code",
            "SELECT min(Version_Number) , template_type_code FROM Templates GROUP BY template_type_code"
        ],
        "rule_sql": []
    },
    "344": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the code of the template type that is most commonly used in documents.",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do specify `T1.template_type_code` in the SELECT clause with table alias qualification instead of just `template_type_code` without table reference. Do maintain the same `GROUP BY T1.template_type_code`, `ORDER BY count(*) DESC`, and `LIMIT 1` structure as the original query. The amended query now correctly joins the Templates and Documents tables to ensure template_type_code is properly sourced from the Templates table while counting document associations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most commonly used template type in documents\": make sure the output order: T1.template_type_code\n2) When combining Templates table (T1) and Documents table (T2): link rows where T1.template_id = T2.template_id and keep only matching pairs (inner match)\n3) When counting documents per template type: compute the number of rows using the join relationship between T1 and T2\n4) When the question asks for the most common template type: rank template types by document count in descending order and keep the first 1 row\n5) When selecting template_type_code: use T1.template_type_code with table alias qualification instead of unqualified template_type_code"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM documents GROUP BY template_type_code ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.Template_Type_Code\nFROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID\nGROUP BY T1.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.template_type_code\nFROM Templates T1\nINNER JOIN Documents T2 ON T1.template_id = T2.template_id\nGROUP BY T1.template_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "176": {
        "db_id": "car_1",
        "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?",
        "ground_truth": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do use `SELECT T1.Id, T1.Maker` instead of `SELECT maker, COUNT(*) as model_count`. Do join `MODEL_LIST AS T2` on `T1.Id = T2.Maker` instead of querying only `car_makers`. Do remove the `WHERE` clause and instead use `HAVING count(*) >= 2` after grouping by `T1.Id`. Do add a second query with `INTERSECT` that joins `CAR_NAMES AS T3` on `T2.model = T3.model` and uses `HAVING count(*) > 3` instead of the incorrect `cars_produced > 3` filter. Do use proper table aliases `T1`, `T2`, and `T3` instead of bare table names. The amended query now correctly finds makers with at least 2 models and more than 3 cars produced by using intersection of two properly joined queries."
        ],
        "rules": [
            "1) When answering about car makers that produce at least 2 models and make more than 3 cars: make sure the output order: T1.Id, T1.Maker. 2) When the question asks for \"ids and makers of all car makers\": select T1.Id and T1.Maker from the car_makers table. 3) When the question mentions \"produce at least 2 models\": join MODEL_LIST AS T2 on T1.Id = T2.Maker and use HAVING count(*) >= 2 after grouping by T1.Id. 4) When the question mentions \"make more than 3 cars\": join CAR_NAMES AS T3 on T2.model = T3.model and use HAVING count(*) > 3 after grouping. 5) When combining both conditions for car makers: use INTERSECT between the two queries to find makers satisfying both conditions. 6) When using table aliases: use T1 for car_makers, T2 for MODEL_LIST, and T3 for CAR_NAMES consistently. 7) When joining tables: link car_makers to MODEL_LIST using T1.Id = T2.Maker, and link MODEL_LIST to CAR_NAMES using T2.model = T3.model."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, COUNT(*) as model_count FROM car_makers WHERE model_count >= 2 AND cars_produced > 3 GROUP BY maker",
            "SELECT T1.Id, T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nJOIN car_names T3 ON T2.Model = T3.Model\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ]
    },
    "786": {
        "db_id": "world_1",
        "question": "Which unique cities are in Asian countries where Chinese is the official language ?",
        "ground_truth": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  \"asia\"",
        "amends": [
            "Do select `t3.name` from the `city` table instead of `city` from the `cities` table. Do join three tables with `country as t1 JOIN countrylanguage as t2 ON t1.code = t2.countrycode JOIN city as t3 ON t1.code = t3.countrycode` instead of querying a single table. Do add filters for `t2.isofficial = 't'` and `t2.language = 'chinese'` instead of just `language = 'Chinese'`. Do use `t1.continent = \"asia\"` instead of `continent = 'Asia'`. The amended query now correctly retrieves city names where Chinese is an official language in Asian countries, matching the RIGHT_SQL's behavior.",
            "Do remove the `t1.Continent = 'Asia'` filter from the `WHERE` clause instead of keeping it there, and do add `t1.continent = \"asia\"` to the end of the `WHERE` clause instead of omitting it, while maintaining the same join structure with `JOIN countrylanguage as t2 ON t1.Code = t2.CountryCode` and `JOIN city as t3 ON t1.Code = t3.CountryCode`. The amended query now correctly filters for Asian countries while preserving the distinct city names where Chinese is an official language, matching the right SQL's behavior.",
            "Do use double quotes `\"asia\"` instead of single quotes `'Asia'` for the continent filter to match the case-sensitive value. The amended query now correctly returns distinct city names where Chinese is an official language in Asian countries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"unique cities in Asian countries where Chinese is the official language\": make sure the output order: t3.name. 2) When the question mentions \"cities\": \"cities\" actually means \"t3.name in city table\". 3) When combining tables for shared entities: link rows where t1.code = t2.countrycode and t1.code = t3.countrycode; keep only matching pairs (inner match). 4) When filtering for Asian countries: use t1.continent = \"asia\" exactly as specified. 5) When filtering for official Chinese language: use t2.isofficial = 't' and t2.language = 'chinese' exactly as specified. 6) When selecting unique cities: return distinct values of t3.name.",
            "1) When the question asks for cities in Asian countries where Chinese is the official language: use \"asia\" (lowercase) as the continent filter value instead of 'Asia' (title case). 2) When filtering by continent in the country table: use the exact identifier \"continent\" (lowercase) instead of \"Continent\" (title case). 3) When combining country, countrylanguage, and city tables: link rows where country.Code equals countrylanguage.CountryCode and country.Code equals city.CountryCode, keeping only matching pairs (inner match). 4) When filtering for official languages: use the exact literal 'T' for the IsOfficial column and 'Chinese' for the Language column. 5) When selecting unique city names: use DISTINCT on the city.Name column to return only distinct city names.",
            "1) When filtering by continent in the country table: use the exact literal value \"asia\" (lowercase) instead of 'Asia' to match case-sensitive data. 2) When answering about unique cities in Asian countries where Chinese is the official language: make sure the output order includes only distinct city names from the city table. 3) When combining country, countrylanguage, and city tables: link rows where country.Code equals countrylanguage.CountryCode and country.Code equals city.CountryCode, keeping only matching pairs (inner match). 4) When filtering for official languages: use the exact literal value 'T' for the IsOfficial column in countrylanguage table. 5) When filtering for Chinese language: use the exact literal value 'Chinese' for the Language column in countrylanguage table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT city FROM cities WHERE continent = 'Asia' AND language = 'Chinese';",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t1.Continent = 'Asia' \nAND t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese'",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nAND t1.Continent = 'Asia'",
            "SELECT DISTINCT t3.Name \nFROM country as t1 \nJOIN countrylanguage as t2 ON t1.Code = t2.CountryCode \nJOIN city as t3 ON t1.Code = t3.CountryCode \nWHERE t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nAND t1.Continent = \"asia\""
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.Name \nFROM country t1 \nINNER JOIN countrylanguage t2 ON t1.Code = t2.CountryCode \nINNER JOIN city t3 ON t1.Code = t3.CountryCode \nWHERE t1.continent = 'asia' \nAND t2.IsOfficial = 'T' \nAND t2.Language = 'Chinese' \nORDER BY t3.Name;"
        ]
    },
    "936": {
        "db_id": "dog_kennels",
        "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.",
        "ground_truth": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do remove `o.last_name` from the SELECT list and GROUP BY clause instead of including it, as the owner_id alone uniquely identifies each group. Do use `count(*)` in the ORDER BY instead of referencing the alias `treatment_count` since that alias is not available at the ORDER BY level. Do reference tables with aliases `T1`, `T2`, and `T3` instead of `o`, `d`, and `t` for consistency, though this is primarily cosmetic. The amended query now correctly identifies the owner with the most treatments by counting all treatment records per owner without relying on an unavailable column alias."
        ],
        "rules": [
            "1) When counting treatments per owner: use count(*) to count all treatment records for each owner group. 2) When grouping by owner: group only by T1.owner_id since it uniquely identifies each owner and T1.last_name is not needed for grouping. 3) When ordering results by treatment count: use count(*) directly in the ORDER BY clause instead of referencing an alias that is not available at that level. 4) When combining tables T1 (owners), T2 (dogs), and T3 (treatments): link T1 to T2 using T1.owner_id = T2.owner_id and T2 to T3 using T2.dog_id = T3.dog_id to find treatments for each owner's dogs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT o.owner_id, o.last_name, COUNT(t.treatment_id) as treatment_count\nFROM owners o\nJOIN dogs d ON o.owner_id = d.owner_id\nJOIN treatments t ON d.dog_id = t.dog_id\nGROUP BY o.owner_id, o.last_name\nORDER BY treatment_count DESC\nLIMIT 1;",
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nJOIN Dogs T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nJOIN Dogs T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "168": {
        "db_id": "car_1",
        "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?",
        "ground_truth": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;",
        "amends": [
            "Do select `makeid` and `make` from `car_names` instead of `make_id` and `name` from `cars`. Do join `cars_data` with `car_names` on `t1.id=t2.makeid` instead of querying a single table. Do filter on `horsepower > (subquery)` instead of `horsepower != (subquery)`. Do keep the `cylinders < 4` filter but apply it to `cars_data` instead of the original table. Do use table aliases `t1` and `t2` instead of no aliases. The amended query now correctly joins the two tables and uses the proper inequality comparison to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cars that do not have minimum horsepower: use a subquery to find the minimum horsepower value from cars_data table 2) When filtering for cars with less than 4 cylinders: apply the condition cylinders < 4 to the cars_data table (T1) 3) When selecting make information: select makeid and make from car_names table (T2) instead of make_id and name from cars table 4) When combining cars_data and car_names tables: link rows where T1.id = T2.makeid using inner join 5) When filtering for cars that do not have minimum horsepower: use horsepower > (SELECT MIN(horsepower) FROM cars_data) instead of != comparison 6) When using table aliases: refer to cars_data as T1 and car_names as T2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT make_id, name FROM cars WHERE cylinders < 4 AND horsepower != (SELECT MIN(horsepower) FROM cars);",
            "SELECT t2.MakeId, t2.Make \nFROM cars_data t1 \nJOIN car_names t2 ON t1.Id = t2.MakeId \nWHERE t1.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) \nAND t1.Cylinders < 4"
        ],
        "rule_sql": [
            "SELECT T2.MakeId, T2.Make \nFROM cars_data T1\nINNER JOIN car_names T2 ON T1.Id = T2.MakeId\nWHERE T1.Horsepower > (SELECT MIN(Horsepower) FROM cars_data)\nAND T1.Cylinders < 4"
        ]
    },
    "602": {
        "db_id": "tvshow",
        "question": "What are the Package Options of the TV Channels whose series names are Sky Radio?",
        "ground_truth": "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do reference the column as `Package_Option` instead of `Package_Options` to match the correct column name. Do reference the table as `TV_Channel` instead of `TV_Channels` to use the correct singular table name. Do use double quotes `\"Sky Radio\"` instead of single quotes `'Sky Radio'` for the string literal format. The amended query now correctly retrieves the package option from the TV channel table for the specified series."
        ],
        "rules": [
            "1) When the question asks about \"Package Options\": use the exact column name \"Package_Option\" from table \"TV_Channel\". 2) When the question refers to \"TV Channels\": use the exact table name \"TV_Channel\" (singular form). 3) When filtering for series names equal to \"Sky Radio\": use double quotes around the literal value as \"Sky Radio\" exactly. 4) When answering about package options for TV channels with specific series names: make sure the output order shows only the Package_Option column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT Package_Options FROM TV_Channels WHERE Series_Name = 'Sky Radio';",
            "SELECT \"Package_Option\" FROM \"TV_Channel\" WHERE \"series_name\" = \"Sky Radio\";"
        ],
        "rule_sql": [
            "SELECT Package_Option FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ]
    },
    "732": {
        "db_id": "world_1",
        "question": "How many unique languages are spoken in the world?",
        "ground_truth": "SELECT count(DISTINCT LANGUAGE) FROM countrylanguage",
        "amends": [
            "Do select `count(DISTINCT LANGUAGE)` instead of `COUNT(*)`. Do query from `countrylanguage` table instead of `languages` table. The amended query now correctly counts distinct languages from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"unique languages spoken in the world\": count distinct values of the LANGUAGE column. 2) When the question mentions \"languages\": use the \"countrylanguage\" table instead of \"languages\" table. 3) When counting distinct languages: use the exact column token \"LANGUAGE\" from the countrylanguage table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages;",
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Language) FROM countrylanguage;"
        ]
    },
    "390": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers who are aged either 32 or 33?",
        "ground_truth": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` and use column names `Name` and `Age` instead of `name` and `age` to match the correct schema, while maintaining the same filter condition `Age = 32 OR Age = 33` instead of changing the logic. The amended query now correctly selects from the intended table with proper column names while preserving the original age filter behavior."
        ],
        "rules": [
            "1) When the question asks about teachers: use the table \"teacher\" instead of \"teachers\" to match the schema. 2) When selecting teacher names: use the column \"Name\" instead of \"name\" to match the schema. 3) When filtering by age: use the column \"Age\" instead of \"age\" to match the schema. 4) When filtering for ages 32 or 33: maintain the exact condition \"Age = 32 OR Age = 33\" to preserve the original logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE age = 32 OR age = 33;",
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33'"
        ]
    },
    "391": {
        "db_id": "course_teach",
        "question": "What is the hometown of the youngest teacher?",
        "ground_truth": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
        "amends": [
            "Do reference the table as `teacher` instead of `teachers` to match the correct schema. Do capitalize column names as `Hometown` and `Age` instead of lowercase `hometown` and `age` to maintain proper case sensitivity. The amended query now correctly selects from the teacher table with proper column casing while preserving the same ordering and limiting behavior."
        ],
        "rules": [
            "1) When the question asks about \"teachers\": use the exact table name \"teacher\" instead of \"teachers\" to match the schema. 2) When selecting column names: use exact case-sensitive identifiers \"Hometown\" and \"Age\" instead of lowercase versions. 3) When finding the youngest teacher: order by \"Age\" in ascending order and take the first result to get the minimum age value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM teachers ORDER BY age ASC LIMIT 1;",
            "SELECT Hometown FROM teacher ORDER BY CAST(Age AS INTEGER) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1;"
        ]
    },
    "458": {
        "db_id": "wta_1",
        "question": "What are the full names of all left handed players, in order of birth date?",
        "ground_truth": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
        "amends": [
            "Do reference column `hand` instead of `handedness` in the WHERE clause. Do use filter value `'L'` instead of `'right'` for the hand condition. Do remove `DESC` from the ORDER BY clause instead of keeping descending order. The amended query now correctly filters for left-handed players and sorts by birth date in ascending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"left handed players\": filter rows where the exact column \"hand\" equals the exact literal 'L'. 2) When ordering by birth date: sort rows in ascending order (earliest to latest) using the \"birth_date\" column. 3) When selecting player names: output both \"first_name\" and \"last_name\" columns to get full names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE handedness = 'right' ORDER BY birth_date DESC;",
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players WHERE hand = 'L' ORDER BY birth_date ASC;"
        ]
    },
    "362": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the details for the paragraph that includes the text 'Korea ' ?",
        "ground_truth": "select other_details from paragraphs where paragraph_text like 'korea'",
        "amends": [
            "Do select `other_details` instead of `*` for the column list. Do reference `paragraph_text` instead of `text` as the source column. Do use a case-sensitive `like 'korea'` pattern instead of a case-insensitive `LIKE '%Korea%'` pattern. The amended query now correctly filters for exact case matches on the paragraph_text column and returns only the other_details field instead of all columns.",
            "Do use lowercase `like 'korea'` instead of mixed case `LIKE 'Korea '` to ensure case-insensitive matching and remove the trailing space that would prevent matching most Korean-related text. The amended query now matches the right SQL's behavior by properly searching for the lowercase term without extraneous whitespace."
        ],
        "rules": [
            "1) When selecting details about paragraphs: return only the \"other_details\" column instead of all columns. 2) When filtering for text containing 'Korea': use the exact column name \"paragraph_text\" instead of \"text\". 3) When matching the text pattern 'Korea': use case-sensitive matching with pattern 'korea' instead of case-insensitive matching with pattern '%Korea%'.",
            "1) When the question asks for details about paragraphs containing specific text: use the exact table name \"Paragraphs\" and column name \"other_details\" as shown in the schema. 2) When searching for text patterns in \"paragraph_text\": use lowercase 'like' operator with exact literal 'korea' (case-insensitive matching) and ensure no trailing spaces in the search pattern. 3) When the question mentions \"details for the paragraph\": return the \"other_details\" column from the matching rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE text LIKE '%Korea%';",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE 'Korea '",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE 'korea'"
        ],
        "rule_sql": [
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%';"
        ]
    },
    "524": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and descriptions for all the sections?",
        "ground_truth": "SELECT section_name ,  section_description FROM Sections",
        "amends": [
            "Do use `section_name` and `section_description` instead of `name` and `description` for the column selection. Do reference the table as `Sections` instead of `sections` for proper case sensitivity. Do remove the `WHERE id > 0` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all section names and descriptions from the Sections table without unnecessary filtering."
        ],
        "rules": [
            "1) When selecting columns from the Sections table: use \"section_name\" and \"section_description\" instead of \"name\" and \"description\". 2) When referencing the Sections table: use \"Sections\" with proper case sensitivity instead of \"sections\". 3) When retrieving all records from a table: do not apply any WHERE filter like \"id > 0\" unless explicitly required by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, description FROM sections WHERE id > 0",
            "SELECT section_name, section_description FROM Sections;"
        ],
        "rule_sql": [
            "SELECT section_name, section_description FROM Sections;"
        ]
    },
    "886": {
        "db_id": "network_1",
        "question": "What is the name of the high schooler who has the greatest number of friends?",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` from a single table. Do join `Friend AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying only the `highschooler` table. Do add `GROUP BY T1.student_id` to aggregate friend counts per student instead of attempting to aggregate without grouping. Do use `count(*)` to count friends instead of `COUNT(friend_id)` which would not work without proper grouping. The amended query now correctly identifies the student with the most friends by joining the Friend table with Highschooler, grouping by student, and counting friendships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the high schooler who has the greatest number of friends\": make sure the output order: T2.name. 2) When the question mentions \"high schooler\": \"high schooler\" actually means \"T2.name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of friends\": compute the number of rows using the canonical key token for friends (e.g., T1.student_id). 5) When the question says \"per student\"/\"by student\": organize results by T1.student_id and compute requested aggregates per group. 6) When the question mentions \"greatest number\" or \"top\": rank rows by count of friends in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM highschooler ORDER BY COUNT(friend_id) DESC LIMIT 1;",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "611": {
        "db_id": "tvshow",
        "question": "List the title of all  Cartoons showed on TV Channel with series name \"Sky Radio\".",
        "ground_truth": "SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = \"Sky Radio\";",
        "amends": [
            "Do select `T2.Title` instead of `title` and specify the table alias. Do join `TV_Channel AS T1` to `Cartoon AS T2` instead of querying only `Cartoons` table. Do use `ON T1.id = T2.Channel` for the join condition instead of a simple WHERE filter. Do filter on `T1.series_name = \"Sky Radio\"` instead of `channel = 'Sky Radio'` to properly reference the channel table. The amended query now correctly joins the channel table to retrieve cartoons associated with the specified channel series name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Cartoons showed on TV Channel with series name 'Sky Radio'\": make sure the output order: T2.Title 2) When the question mentions \"TV Channel with series name 'Sky Radio'\": \"series name\" actually means \"T1.series_name in schema\" and the literal value must be exactly \"Sky Radio\" 3) When combining TV_Channel (T1) and Cartoon (T2) for shared entities: link rows where T1.id = T2.Channel exactly as shown in the amends; keep only matching pairs (inner match) 4) When selecting the title of cartoons: use T2.Title as the exact column token from the Cartoon table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM Cartoons WHERE channel = 'Sky Radio';",
            "SELECT T2.Title \nFROM TV_Channel AS T1 \nJOIN Cartoon AS T2 ON T1.id = T2.Channel \nWHERE T1.series_name = 'Sky Radio'"
        ],
        "rule_sql": [
            "SELECT T2.Title FROM TV_Channel T1 INNER JOIN Cartoon T2 ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio' ORDER BY T2.Title"
        ]
    },
    "813": {
        "db_id": "world_1",
        "question": "Return the names of cities that have a population between 160000 and 900000 .",
        "ground_truth": "select name from city where population between 160000 and 900000",
        "amends": [
            "Do reference the table as `city` instead of `cities` to match the correct schema. Do use `BETWEEN 160000 AND 900000` instead of `< 160000 OR > 900000` to select cities within the population range rather than outside it, which completely reverses the logic from excluding to including the specified range. The amended query now correctly returns cities with populations between 160,000 and 900,000 instead of those outside this range."
        ],
        "rules": [
            "1) When the question asks for cities with population between 160000 and 900000: use the table name \"city\" instead of \"cities\" to match the schema. 2) When selecting cities within a population range: use BETWEEN 160000 AND 900000 instead of population < 160000 OR population > 900000 to include the specified range rather than exclude it. 3) When the question mentions \"cities\": the exact identifier in the schema is \"city\" table. 4) When the question asks for population between 160000 and 900000: use inclusive range checking with exact literals 160000 and 900000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cities WHERE population < 160000 OR population > 900000;",
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ],
        "rule_sql": [
            "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000"
        ]
    },
    "696": {
        "db_id": "voter_1",
        "question": "What are the number of votes from state 'NY' or 'CA'?",
        "ground_truth": "SELECT count(*) FROM votes WHERE state  =  'NY' OR state  =  'CA'",
        "amends": [
            "Do use `OR` operator between state conditions instead of `AND` operator, as a record cannot simultaneously have both 'NY' and 'CA' values for the state column. Do maintain the same `COUNT(*)` aggregation and table source without changes to other clauses. The amended query now correctly counts records where state is either 'NY' or 'CA' instead of incorrectly requiring both values simultaneously, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for records matching multiple state values with 'or' logic: use OR operator between state conditions instead of AND operator, as a record cannot simultaneously have both 'NY' and 'CA' values for the state column. 2) When counting votes from specific states: maintain the COUNT(*) aggregation and table source without changes to other clauses. 3) When filtering for state values 'NY' or 'CA': ensure the condition correctly counts records where state is either 'NY' or 'CA' instead of requiring both values simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE state = 'NY' AND state = 'CA';",
            "SELECT COUNT(*) FROM VOTES WHERE state = 'NY' OR state = 'CA'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM VOTES WHERE state = 'NY' OR state = 'CA'"
        ]
    },
    "496": {
        "db_id": "battle_death",
        "question": "What are the death and injury situations caused by the ship with tonnage 't'?",
        "ground_truth": "SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'",
        "amends": [
            "Do select specific columns `T1.killed` and `T1.injured` instead of using `SELECT *`. Do join tables `death AS T1` and `ship AS t2` with an `INNER JOIN` on `T1.caused_by_ship_id = T2.id` instead of querying only the `accidents` table. Do filter on `T2.tonnage = 't'` in the `WHERE` clause instead of filtering `tonnage` directly from a single table. The amended query now correctly retrieves accident data by joining related tables and filtering based on ship tonnage, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about death and injury situations: make sure the output order: T1.killed, T1.injured 2) When the question mentions \"ship with tonnage 't'\": filter rows where T2.tonnage = 't' exactly 3) When combining death and ship tables: link rows where T1.caused_by_ship_id = T2.id and keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation of 't'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accidents WHERE tonnage = 't';",
            "SELECT T1.killed, T1.injured FROM death AS T1 INNER JOIN ship AS T2 ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'"
        ],
        "rule_sql": [
            "SELECT T1.killed, T1.injured FROM death T1 INNER JOIN ship T2 ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'"
        ]
    },
    "169": {
        "db_id": "car_1",
        "question": "What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?",
        "ground_truth": "select max(mpg) from cars_data where cylinders  =  8 or year  <  1980",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to ensure querying the correct data source. The amended query now matches RIGHT_SQL's behavior by using the proper table name while maintaining the same aggregation and filtering logic."
        ],
        "rules": [
            "1) When answering about maximum miles per gallon: use the table \"cars_data\" instead of \"cars\" to ensure querying the correct data source. 2) When filtering for cars with 8 cylinders or produced before 1980: apply the condition cylinders = 8 OR year < 1980 to select the appropriate rows. 3) When computing the maximum value: calculate the maximum of the mpg column from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(mpg) FROM cars WHERE cylinders = 8 OR year < 1980;",
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ],
        "rule_sql": [
            "SELECT MAX(MPG) FROM cars_data WHERE Cylinders = 8 OR Year < 1980;"
        ]
    },
    "178": {
        "db_id": "car_1",
        "question": "What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?",
        "ground_truth": "select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  3 union select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country join model_list as t3 on t2.id  =  t3.maker where t3.model  =  'fiat';",
        "amends": [
            "Do join `car_makers as t2` on `t1.countryid = t2.country` instead of querying `countries` table alone. Do add `GROUP BY t1.countryid` and move the count filter to `HAVING count(*) > 3` instead of using `WHERE car_makers_count > 3`. Do add a second query with `UNION` that joins `model_list as t3` on `t2.id = t3.maker` with filter `t3.model = 'fiat'` instead of the simple `OR model = 'fiat'` condition. Do use explicit table aliases `t1.countryid` and `t1.countryname` instead of bare column names `id` and `name`. The amended query now correctly counts car makers per country and handles the Fiat model condition through proper table joins and union operation."
        ],
        "rules": [
            "1) When answering about countries with car makers: join \"countries\" as T1 with \"car_makers\" as T2 where T1.countryid = T2.country to link countries to their car makers. 2) When counting car makers per country: group results by T1.countryid and count using T2.id to get the number of car makers for each country. 3) When filtering for countries with more than 3 car makers: use HAVING count(*) > 3 after grouping by T1.countryid. 4) When answering about countries producing Fiat model: join \"car_makers\" as T2 with \"model_list\" as T3 where T2.id = T3.maker and filter for T3.model = 'fiat' exactly. 5) When combining both conditions with OR: use UNION to combine results from the car maker count condition and the Fiat model condition. 6) When selecting country information: use T1.countryid and T1.countryname as the exact output columns for country IDs and names."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM countries WHERE car_makers_count > 3 OR model = 'fiat'",
            "SELECT t1.CountryId, t1.CountryName\nFROM countries t1\nJOIN car_makers t2 ON t1.CountryId = t2.Country\nGROUP BY t1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT t1.CountryId, t1.CountryName\nFROM countries t1\nJOIN car_makers t2 ON t1.CountryId = t2.Country\nJOIN model_list t3 ON t2.Id = t3.Maker\nWHERE t3.Model = 'fiat'"
        ],
        "rule_sql": [
            "SELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ]
    },
    "414": {
        "db_id": "museum_visit",
        "question": "Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.",
        "ground_truth": "SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC",
        "amends": [
            "Do use column alias `Level_of_membership` instead of `membership_level` in the SELECT list. Do reference table `visitor` instead of `visitors` in the FROM clause. Do change the ORDER BY direction to `DESC` instead of `ASC` for the `age` column. The amended query now correctly matches the intended behavior with the proper table name, column alias, and descending age ordering."
        ],
        "rules": [
            "1) When the question asks for \"membership level\": use the exact column token \"Level_of_membership\" from the visitor table. 2) When referencing the table containing visitor information: use the exact table name \"visitor\" instead of \"visitors\". 3) When sorting by age from old to young: order by the age column in descending direction (DESC) instead of ascending (ASC). 4) When selecting output columns: maintain the order of name followed by Level_of_membership as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, membership_level FROM visitors WHERE membership_level > 4 ORDER BY age ASC;",
            "SELECT Name, Level_of_membership FROM visitor WHERE Level_of_membership > 4 ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Level_of_membership FROM visitor WHERE Level_of_membership > 4 ORDER BY Age DESC;"
        ]
    },
    "489": {
        "db_id": "wta_1",
        "question": "Find the number of players for each hand type.",
        "ground_truth": "SELECT count(*) ,  hand FROM players GROUP BY hand",
        "amends": [
            "Do place the `hand` column after the aggregate function instead of before it in the SELECT list. Do maintain the same `COUNT(*)` aggregate function and `GROUP BY hand` clause without changes. The amended query now correctly follows standard SQL syntax where non-aggregated columns should appear after aggregate functions in the SELECT list when using GROUP BY, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of players for each hand type\": make sure the output order: count first, then hand type. 2) When the question asks for \"number of players\": compute the count of rows using the canonical key for players. 3) When the question says \"for each hand type\": organize results by the exact token \"hand\" and compute the count per group. 4) When producing output: place the aggregate count column before the grouping column \"hand\" in the result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hand, COUNT(*) FROM players GROUP BY hand;",
            "SELECT COUNT(*), hand FROM players GROUP BY hand"
        ],
        "rule_sql": [
            "SELECT COUNT(player_id) AS count, hand FROM players GROUP BY hand ORDER BY count DESC, hand;"
        ]
    },
    "667": {
        "db_id": "poker_player",
        "question": "What is the money rank of the tallest poker player?",
        "ground_truth": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1",
        "amends": [
            "Do select `T2.Money_Rank` from the joined table instead of `money_rank` directly from the poker_players table. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the poker_players table. Do order by `T1.Height` from the people table instead of `height` from the poker_players table. The amended query now correctly retrieves money rank by joining the people and poker_player tables and ordering by height from the people table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"money rank of the tallest poker player\": make sure the output order: T2.Money_Rank. 2) When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID exactly as shown; keep only matching pairs (inner match). 3) When the question mentions \"tallest\": rank rows by T1.Height in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT money_rank FROM poker_players ORDER BY height DESC LIMIT 1;",
            "SELECT T2.Money_Rank \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nORDER BY T1.Height DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Money_Rank FROM people T1 INNER JOIN poker_player T2 ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC LIMIT 1"
        ]
    },
    "148": {
        "db_id": "car_1",
        "question": "What is the number of car models created by the car maker American Motor Company?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';",
        "amends": [
            "Do add `JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker` instead of querying only the `car_makers` table. Do change the filter to `T1.FullName = 'American Motor Company'` instead of `maker = 'American Motor Company'` to use the correct column name for the full company name. The amended query now correctly joins the model list table and filters by the proper full name column, matching the RIGHT_SQL's behavior of counting models from American Motor Company rather than just counting the maker entry itself."
        ],
        "rules": [
            "1) When answering about \"number of car models created by a car maker\": join the car_makers table (T1) with the MODEL_LIST table (T2) using T1.Id = T2.Maker to link models to their makers. 2) When the question mentions \"American Motor Company\": use the exact literal 'American Motor Company' and filter on T1.FullName = 'American Motor Company' to identify the correct car maker. 3) When counting car models for a specific maker: count the number of rows in the joined result where T1.FullName matches the specified maker name, as this represents the count of models associated with that maker."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE maker = 'American Motor Company';",
            "SELECT COUNT(*) AS model_count\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nWHERE T1.FullName = 'American Motor Company'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS number_of_models\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nWHERE cm.FullName = 'American Motor Company'"
        ]
    },
    "294": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
        "ground_truth": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "amends": [
            "Do reference table `shop` instead of `shops` and use column `Number_products` instead of `products_sold`. Do use `INTERSECT` to find districts that meet both conditions instead of using `AND` with contradictory filters `products_sold < 3000 AND products_sold > 10000` which would return no results. Do split the query into two separate SELECT statements with `INTERSECT` to properly find districts where some shops have fewer than 3000 products and other shops have more than 10000 products, instead of incorrectly trying to find shops that simultaneously have both conditions. The amended query now correctly identifies districts containing shops with both low and high product counts."
        ],
        "rules": [
            "1) When the question mentions \"shops\": use table \"shop\" instead of \"shops\" and column \"Number_products\" instead of \"products_sold\". 2) When finding districts with both shops selling less than 3000 products and shops selling more than 10000 products: use INTERSECT to combine results from two separate queries - one for districts with shops having \"Number_products\" < 3000 and another for districts with shops having \"Number_products\" > 10000. 3) When filtering shops by product count: use exact numeric comparisons \"Number_products\" < 3000 and \"Number_products\" > 10000 with the literal values as specified. 4) When the question asks about districts containing both types of shops: do not use AND with contradictory filters on the same row, as no shop can simultaneously have both \"Number_products\" < 3000 and \"Number_products\" > 10000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district FROM shops WHERE products_sold < 3000 AND products_sold > 10000;",
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ],
        "rule_sql": [
            "SELECT District FROM shop WHERE Number_products < 3000\nINTERSECT\nSELECT District FROM shop WHERE Number_products > 10000"
        ]
    },
    "77": {
        "db_id": "pets_1",
        "question": "Find the id of the pet owned by student whose last name is \u2018Smith\u2019.",
        "ground_truth": "SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith'",
        "amends": [
            "Do select `T2.petid` instead of `pet_id` and use table aliases `T1` and `T2` instead of direct table references. Do add `JOIN has_pet AS T2 ON T1.stuid = T2.stuid` instead of querying only the students table. Do filter on `T1.Lname = 'Smith'` instead of `last_name = 'Smith'` to use the correct column name from the joined table structure. The amended query now correctly retrieves pet information through the relationship table instead of assuming pets are directly stored in the students table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"pet owned by student\": use the relationship table \"has_pet\" as T2 to link students and pets instead of assuming pets are directly in the students table. 2) When combining students and has_pet tables: link rows where T1.stuid = T2.stuid and keep only matching pairs (inner match). 3) When the question mentions \"last name\": \"last name\" actually means \"Lname\" in the students table (T1.Lname). 4) When filtering for students with last name 'Smith': use T1.Lname = 'Smith' with exact case and spacing. 5) When selecting the pet identifier: use T2.petid instead of pet_id to match the correct column name from the relationship table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_id FROM students WHERE last_name = 'Smith';",
            "SELECT T2.PetID \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nWHERE T1.LName = 'Smith'"
        ],
        "rule_sql": [
            "SELECT T2.PetID \nFROM Student T1 \nINNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID \nWHERE T1.Lname = 'Smith'"
        ]
    },
    "919": {
        "db_id": "dog_kennels",
        "question": "Find the states where both owners and professionals live.",
        "ground_truth": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT state FROM owners INTERSECT SELECT DISTINCT state FROM professionals;"
        ],
        "rule_sql": [
            "SELECT DISTINCT o.state\nFROM Owners o\nINNER JOIN Professionals p ON o.state = p.state"
        ]
    },
    "432": {
        "db_id": "wta_1",
        "question": "Count the number of matches.",
        "ground_truth": "SELECT count(*) FROM matches",
        "amends": [
            "Do query the `matches` table instead of the `players` table. The amended query now correctly counts records from the matches table as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"matches\": query the \"matches\" table instead of the \"players\" table. 2) When counting matches: count all records from the \"matches\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT COUNT(*) FROM matches;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM matches;"
        ]
    },
    "361": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show paragraph details for paragraph with text 'Korea ' .",
        "ground_truth": "select other_details from paragraphs where paragraph_text like 'korea'",
        "amends": [
            "Do select `other_details` instead of `*` for the column list. Do reference `paragraph_text` instead of `text` as the column name in the WHERE clause. Do use `LIKE` with lowercase `'korea'` instead of `=` with uppercase `'Korea'` for pattern matching instead of exact case-sensitive matching. The amended query now correctly filters for text containing 'korea' case-insensitively and returns only the other_details column as specified."
        ],
        "rules": [
            "1) When selecting columns for paragraph details: use \"other_details\" instead of all columns (*). 2) When filtering for text containing 'Korea': use \"paragraph_text\" column instead of \"text\" column. 3) When pattern matching for 'Korea': use LIKE operator with lowercase 'korea' for case-insensitive matching instead of exact case-sensitive matching with uppercase 'Korea'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE text = 'Korea';",
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%';"
        ],
        "rule_sql": [
            "SELECT other_details FROM Paragraphs WHERE paragraph_text LIKE '%korea%'"
        ]
    },
    "514": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the zip code for Port Chelsea?",
        "ground_truth": "SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea'",
        "amends": [
            "Do select `zip_postcode` instead of `zip_code` from the `Addresses` table instead of the `cities` table, and filter on `city = 'Port Chelsea'` instead of `city_name = 'Port Chelsea'`. The amended query now correctly retrieves postal codes from the appropriate address table using the correct column names."
        ],
        "rules": [
            "1) When the question asks for \"zip code\": use the exact column \"zip_postcode\" from the \"Addresses\" table. 2) When filtering for city \"Port Chelsea\": use the exact literal 'Port Chelsea' with the column \"city\" from the \"Addresses\" table. 3) When selecting from the database: use the \"Addresses\" table instead of any \"cities\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM cities WHERE city_name = 'Port Chelsea';",
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ],
        "rule_sql": [
            "SELECT zip_postcode FROM Addresses WHERE city = 'Port Chelsea';"
        ]
    },
    "12": {
        "db_id": "concert_singer",
        "question": "List all song names by singers above the average age.",
        "ground_truth": "SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer)",
        "amends": [
            "Do reference table `singer` instead of `songs` in the FROM clause. Do use column `age` instead of `singer_age` in both the main query and subquery. Do reference table `singer` instead of `singers` in the subquery's FROM clause. Do use aggregate function `avg(age)` instead of `AVG(singer_age)` in the subquery. The amended query now correctly filters songs based on singers whose age exceeds the average age of all singers, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"song names by singers above the average age\": make sure the output order: song_name. 2) When the question mentions \"singers\": \"singers\" actually means \"singer in schema\". 3) When the question mentions \"age\": \"age\" actually means \"age in schema\". 4) When filtering singers by age above average: compute the average age from all singers using avg(age) and compare each singer's age to that average value. 5) When the question asks for \"song names by singers\": ensure the result includes only songs from singers who meet the age condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE singer_age > (SELECT AVG(singer_age) FROM singers);",
            "SELECT Song_Name FROM singer WHERE Age > (SELECT AVG(Age) FROM singer)"
        ],
        "rule_sql": [
            "SELECT s.Song_Name \nFROM singer s\nWHERE s.Age > (SELECT AVG(Age) FROM singer)\nORDER BY s.Song_Name;"
        ]
    },
    "751": {
        "db_id": "world_1",
        "question": "How many continents speak Chinese?",
        "ground_truth": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"",
        "amends": [
            "Do use `COUNT(DISTINCT Continent)` instead of `COUNT(*)` to count distinct continents rather than all rows. Do add `JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode` instead of querying only the countries table to properly relate countries with their languages. Do reference `T2.Language = \"Chinese\"` instead of `language = 'Chinese'` to filter by language in the correct joined table. Do specify `FROM country AS T1` instead of `FROM countries` to use the correct table name and alias. The amended query now correctly counts distinct continents where Chinese is spoken by properly joining the country and countrylanguage tables."
        ],
        "rules": [
            "1) When counting distinct continents: use COUNT(DISTINCT T1.Continent) instead of COUNT(*) to count unique continents rather than all rows. 2) When combining country and countrylanguage tables: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 3) When filtering by Chinese language: use T2.Language = \"Chinese\" with exact case and double quotes as shown in the schema. 4) When referring to the country table: use the exact table name \"country\" with alias T1 instead of \"countries\". 5) When answering about continents that speak Chinese: make sure the output order is a single count of distinct continents."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Chinese';",
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'Chinese'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Continent) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = \"Chinese\""
        ]
    },
    "189": {
        "db_id": "flight_2",
        "question": "How many airports do we have?",
        "ground_truth": "SELECT count(*) FROM AIRPORTS",
        "amends": [
            "Do use the table name `AIRPORTS` instead of `airports` to match the correct case sensitivity, though this may be a cosmetic difference depending on database configuration. Do maintain the identical `COUNT(*)` aggregation and `WHERE country = 'USA'` filter without any changes to the SELECT list, FROM clause, WHERE conditions, or other query components. The amended query now matches RIGHT_SQL's behavior with proper table name casing.",
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to maintain consistent function casing. The amended query now matches RIGHT_SQL's behavior with identical functionality.",
            "Do include all airports without any country filter instead of filtering for `country = 'USA'`. The amended query now matches RIGHT_SQL's behavior by counting all records in the AIRPORTS table."
        ],
        "rules": [
            "1) When counting airports: use the exact table name \"AIRPORTS\" with uppercase letters as shown in the schema. 2) When filtering for airports in the USA: use the exact literal value 'USA' with uppercase letters in the country column condition. 3) When performing the count: use COUNT(*) to count all rows that match the specified conditions.",
            "1) When counting entities from a table: use lowercase count(*) function instead of uppercase COUNT(*) to maintain consistent function casing",
            "1) When answering about \"how many airports\": count all records in the \"AIRPORTS\" table without any country filter. 2) When the question asks for \"count of airports\": compute the number of rows using all records from the \"AIRPORTS\" table. 3) When handling text literals: do not include any country filter condition like 'country = \"USA\"' as the question does not specify any country restriction."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM airports WHERE country = 'USA';",
            "SELECT COUNT(*) FROM AIRPORTS WHERE country = 'USA';",
            "SELECT count(*) FROM AIRPORTS WHERE country = 'USA'",
            "SELECT count(*) FROM AIRPORTS"
        ],
        "rule_sql": [
            "SELECT count(*) FROM AIRPORTS;"
        ]
    },
    "103": {
        "db_id": "car_1",
        "question": "Which distinct car models are the produced after 1980?",
        "ground_truth": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;",
        "amends": [
            "Do add `MODEL_LIST AS T1` joined to `CAR_NAMES AS T2` on `T1.model = T2.model` instead of querying `cars` directly. Do add another join to `CARS_DATA AS T3` on `T2.MakeId = T3.id` instead of missing these table relationships. Do move the year filter to `T3.year > 1980` instead of applying it to an unspecified source. Do specify the table alias with `T1.model` instead of just `model` to avoid ambiguity. The amended query now correctly joins the three required tables to filter cars by year while maintaining the distinct model selection, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"distinct car models produced after 1980\": make sure the output order: T1.model 2) When the question mentions \"car models\": \"car models\" actually means \"T1.model in schema\" 3) When the question mentions \"after 1980\": apply the year filter to T3.year > 1980 4) When combining MODEL_LIST as T1 and CAR_NAMES as T2: link rows where T1.model = T2.model and keep only matching pairs (inner match) 5) When combining T2 and CARS_DATA as T3: link rows where T2.MakeId = T3.id and keep only matching pairs (inner match) 6) When selecting distinct values: compute the number of unique values of T1.model"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT model FROM cars WHERE year > 1980;",
            "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Model\nFROM model_list T1\nINNER JOIN car_names T2 ON T1.Model = T2.Model\nINNER JOIN cars_data T3 ON T2.MakeId = T3.Id\nWHERE T3.Year > 1980\nORDER BY T1.Model"
        ]
    },
    "710": {
        "db_id": "world_1",
        "question": "Which region is the city Kabul located in?",
        "ground_truth": "SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  \"Kabul\"",
        "amends": [
            "Do join `country AS T1` and `city AS T2` instead of querying only `cities` table. Do use `LEFT JOIN` on `T1.Code = T2.CountryCode` instead of no join condition. Do select `Region` from the joined table instead of `region` from a single table. Do filter on `T2.Name = \"Kabul\"` instead of `city = 'Kabul'`. Do use proper table aliases and qualified column references instead of unqualified column names. The amended query now correctly retrieves the region by joining country and city tables with proper relationship mapping."
        ],
        "rules": [
            "1) When the question asks about a city's region: join table \"country\" as T1 and table \"city\" as T2 using LEFT JOIN on T1.Code = T2.CountryCode instead of querying a single table. 2) When filtering for a specific city name: use T2.Name = \"Kabul\" with exact case and double quotes instead of city = 'Kabul'. 3) When selecting the region information: use T1.Region from the joined country table instead of region from a cities table. 4) When combining country and city tables: use the exact join condition T1.Code = T2.CountryCode to link countries with their cities."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM cities WHERE city = 'Kabul';",
            "SELECT T1.Region FROM country AS T1 LEFT JOIN city AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
        ],
        "rule_sql": [
            "SELECT T1.Region FROM country AS T1 LEFT JOIN city AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = \"Kabul\""
        ]
    },
    "33": {
        "db_id": "concert_singer",
        "question": "Show the name and theme for all concerts and the number of singers in each concert.",
        "ground_truth": "SELECT T2.concert_name ,  T2.theme ,  count(*) FROM singer_in_concert AS T1 JOIN concert AS T2 ON T1.concert_id  =  T2.concert_id GROUP BY T2.concert_id",
        "amends": [
            "Do select `concert_name` and `theme` instead of `name` and `theme`. Do join `singer_in_concert` with `concert` on `concert_id` instead of querying only the `concerts` table. Do count all rows with `count(*)` instead of counting `singer_id`. Do group by `T2.concert_id` instead of `concert_id` without table qualification. The amended query now correctly aggregates singer counts per concert by properly joining the concert and singer association tables."
        ],
        "rules": [
            "1) When the question asks for concert name and theme: select \"concert_name\" and \"theme\" columns instead of generic \"name\" and \"theme\". 2) When counting singers in concerts: join \"singer_in_concert\" table with \"concert\" table using \"concert_id\" as the linking key. 3) When counting the number of singers per concert: use count(*) to count all rows in the joined singer association table rather than counting a specific singer_id column. 4) When grouping by concert identifier: use the fully qualified \"T2.concert_id\" with table alias qualification instead of unqualified \"concert_id\". 5) When organizing results by concert: group by the concert's canonical key \"T2.concert_id\" to ensure proper aggregation per concert entity."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, theme, COUNT(singer_id) AS singer_count FROM concerts GROUP BY concert_id",
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS singer_count\nFROM concert c\nLEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID\nGROUP BY c.concert_ID, c.concert_Name, c.Theme"
        ],
        "rule_sql": [
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS number_of_singers FROM concert c LEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID GROUP BY c.concert_ID"
        ]
    },
    "1030": {
        "db_id": "real_estate_properties",
        "question": "How many available features are there in total?",
        "ground_truth": "SELECT count(*) FROM Other_Available_Features",
        "amends": [
            "Do reference the `Other_Available_Features` table instead of the `features` table. Do filter for available status with `status = 'available'` instead of unavailable status with `status = 'unavailable'`. The amended query now correctly counts available features from the appropriate table, matching the intended behavior.",
            "Do remove the `WHERE status = 'available'` filter instead of keeping it, and do remove the `AS total_available_features` alias instead of including it. The amended query now counts all rows in the Other_Available_Features table without any status filtering, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When answering about \"available features\": use the table \"Other_Available_Features\" instead of \"features\". 2) When filtering for available status: use the condition status = 'available' instead of status = 'unavailable'. 3) When counting available features: count all rows from \"Other_Available_Features\" where status equals 'available'.",
            "1) When counting all available features: count all rows in the \"Other_Available_Features\" table without any filtering conditions. 2) When the question asks for \"how many available features are there in total\": do not apply any status filter and include all rows from the \"Other_Available_Features\" table. 3) When producing output for count results: do not use column aliases like \"total_available_features\" and return the count directly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM features WHERE status = 'unavailable';",
            "SELECT COUNT(*) AS total_available_features FROM Other_Available_Features WHERE status = 'available'",
            "SELECT COUNT(*) FROM Other_Available_Features;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Other_Available_Features;"
        ]
    },
    "757": {
        "db_id": "world_1",
        "question": "What is the language that is used by the largest number of Asian nations?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
        "amends": [
            "Do use `T2.Language` from the `countrylanguage` table instead of `language` from a non-existent column. Do join `country AS T1` and `countrylanguage AS T2` with `ON T1.Code = T2.CountryCode` instead of querying a single `countries` table. Do filter on `T1.Continent = \"Asia\"` instead of `continent = 'Asia'` to reference the correct table. Do group by `T2.Language` instead of `language` to match the selected column. Do order by `COUNT(*) DESC` instead of `count DESC` to reference the aggregate function directly rather than an alias. The amended query now correctly identifies the most spoken language in Asia by joining the appropriate tables and properly referencing schema elements.",
            "Do remove `COUNT(*) AS count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T2.Language`. Do use double quotes `\"Asia\"` for the string literal instead of single quotes `'Asia'` in the WHERE clause. Do remove the space between `COUNT` and `(*)` in the ORDER BY clause instead of having a space, making it `COUNT(*)` instead of `COUNT (*)`. The amended query now correctly returns only the language column while maintaining the same grouping, ordering, and limiting behavior to match RIGHT_SQL's output."
        ],
        "rules": [
            "1) When answering about \"language used by Asian nations\": make sure the output order: T2.Language, COUNT(*) as count\n2) When the question mentions \"Asian nations\": \"Asian nations\" actually means \"T1.Continent = 'Asia' in schema\"\n3) When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"largest number\": rank rows by COUNT(*) in descending direction and keep the first 1 row\n5) When the question says \"by language\": organize results by T2.Language and compute COUNT(*) per group\n6) When counting entities: compute the number of rows using the join relationship T1.Code = T2.CountryCode\n7) When handling text literals: do not change case, spacing, or punctuation - use exact value 'Asia'",
            "1) When answering about \"the language that is used by the largest number of Asian nations\": make sure the output order: T2.Language only. 2) When the question mentions \"Asian nations\": \"Asia\" actually means \"Asia\" in schema and must be written with double quotes as \"Asia\". 3) When the question asks for \"largest number\": rank rows by COUNT(*) in descending order and keep the first 1 row. 4) When counting entities: use COUNT(*) without any space between COUNT and (*). 5) When combining country AS T1 and countrylanguage AS T2: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 6) When the question says \"by Asian nations\": filter rows where T1.Continent = \"Asia\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM countries WHERE continent = 'Asia' GROUP BY language ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Language, COUNT(*) AS count\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = \"Asia\"\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language\nFROM country AS T1\nINNER JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Continent = 'Asia'\nGROUP BY T2.Language\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "72": {
        "db_id": "pets_1",
        "question": "What is the average and maximum age for each pet type?",
        "ground_truth": "SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do use column name `pet_age` instead of `age` in aggregate functions. Do use `max` function instead of `MIN` for calculating maximum age. Do remove the alias `average_age` instead of keeping it. Do remove the alias `maximum_age` instead of keeping it. Do use column name `pettype` instead of `pet_type` in GROUP BY clause. The amended query now correctly calculates average and maximum pet ages by pet type without unnecessary aliases.",
            "Do use lowercase `avg(pet_age)` and `max(pet_age)` instead of uppercase `AVG(pet_age)` and `MAX(pet_age)`. Do place `pettype` at the end of the SELECT list instead of at the beginning. Do use lowercase table name `pets` instead of uppercase `Pets` and lowercase column name `pettype` instead of uppercase `PetType` in both SELECT and GROUP BY clauses. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When the question mentions \"age\": \"age\" actually means \"pet_age\" in schema. 2) When calculating maximum age: use the max function instead of min function. 3) When the question asks for results without specific aliases: do not add aliases like \"average_age\" or \"maximum_age\" to the output columns. 4) When the question mentions \"pet type\": \"pet type\" actually means \"pettype\" in schema. 5) When the question asks for results \"for each pet type\": organize results by the exact token \"pettype\" and compute requested aggregates per group.",
            "1) When the question asks for average and maximum age for each pet type: compute average using lowercase avg(pet_age) and maximum using lowercase max(pet_age). 2) When organizing results by pet type: use lowercase pettype as the grouping key in both SELECT and GROUP BY clauses. 3) When producing output columns: place pettype at the end of the SELECT list instead of the beginning. 4) When referring to the table: use lowercase pets instead of uppercase Pets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_age, MIN(age) as maximum_age FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(pet_age), MAX(pet_age) FROM Pets GROUP BY PetType;",
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ]
    },
    "925": {
        "db_id": "dog_kennels",
        "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?",
        "ground_truth": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "amends": [
            "Do use a subquery with `NOT IN` instead of multiple joins. Do filter by `dog_id` instead of `id` in the subquery. Do aggregate with `SUM(cost_of_treatment)` instead of filtering individual `cost` values. Do remove the joins with `owners` and `treatments` tables instead of including them. Do reference `cost_of_treatment` instead of `cost` in the aggregation. The amended query now correctly identifies dogs whose total treatment costs do not exceed 1000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for dogs whose owners have not spent more than 1000 for treatment: use a subquery with NOT IN instead of multiple joins to filter dogs. 2) When filtering by treatment costs: aggregate using SUM(\"cost_of_treatment\") instead of filtering individual cost values. 3) When referencing treatment costs: use the exact column name \"cost_of_treatment\" instead of \"cost\". 4) When identifying dogs in the subquery: filter by \"dog_id\" instead of \"id\". 5) When combining treatment data: remove joins with \"owners\" and \"treatments\" tables and instead use a subquery approach."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name \nFROM dogs d \nJOIN owners o ON d.owner_id = o.id \nJOIN treatments t ON d.id = t.dog_id \nWHERE t.cost > 1000;",
            "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)"
        ],
        "rule_sql": [
            "SELECT name \nFROM Dogs \nWHERE dog_id NOT IN (\n    SELECT dog_id \n    FROM Treatments \n    GROUP BY dog_id \n    HAVING SUM(cost_of_treatment) > 1000\n)"
        ]
    },
    "721": {
        "db_id": "world_1",
        "question": "Give the name of the country in Asia with the lowest life expectancy.",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `country` instead of `countries`. Do use the correct column name `Continent` instead of `continent` and use double quotes around the string literal \"Asia\" instead of single quotes. Do order by `LifeExpectancy` in ascending order (default) instead of descending order with `DESC`, and use the correct column name `LifeExpectancy` instead of `life_expectancy`. The amended query now correctly retrieves the country with the lowest life expectancy in Asia, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for country names: use the exact column \"Name\" from table \"country\" (not \"name\" from other tables). 2) When filtering for countries in Asia: use the exact column \"Continent\" with the exact string literal \"Asia\" (with double quotes). 3) When finding the lowest life expectancy: order by \"LifeExpectancy\" in ascending order (default) to get the minimum value. 4) When retrieving a single result: take only the first row after ordering to get the country with the lowest life expectancy."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Asia' ORDER BY life_expectancy DESC LIMIT 1;",
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"
        ]
    },
    "579": {
        "db_id": "student_transcripts_tracking",
        "question": "List all the student details in reversed lexicographical order.",
        "ground_truth": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC",
        "amends": [
            "Do select `other_student_details` instead of `*` to return only specific columns instead of all columns. Do order by `other_student_details DESC` instead of `name ASC` to sort by a different column in descending order instead of ascending order. The amended query now correctly returns only the other_student_details column sorted in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"student details\": select only the \"other_student_details\" column instead of all columns. 2) When the question specifies \"reversed lexicographical order\": sort the results by \"other_student_details\" in descending order instead of ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM students ORDER BY name ASC;",
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ],
        "rule_sql": [
            "SELECT other_student_details FROM Students ORDER BY other_student_details DESC;"
        ]
    },
    "471": {
        "db_id": "wta_1",
        "question": "Find the total ranking points for each player and their first name.",
        "ground_truth": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
        "amends": [
            "Do add the `rankings` table with a `JOIN` on `T1.player_id = T2.player_id` instead of querying only the `players` table. Do change the GROUP BY clause to use `T1.first_name` instead of `player_id`. Do include the table alias `T1` for `first_name` in the SELECT list instead of referencing it directly. Do remove the explicit column `first_name` from the SELECT list and instead include only the aggregate function `sum(ranking_points)` with the correct table alias. The amended query now correctly joins the players and rankings tables to calculate total ranking points per player name.",
            "Do place the aggregate function `sum(ranking_points)` first in the SELECT list instead of placing `T1.first_name` first, and do remove the alias `total_ranking_points` instead of keeping it, while maintaining the same FROM clause with `JOIN` on `T1.player_id = T2.player_id` and GROUP BY `T1.first_name`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total ranking points for each player and their first name\": make sure the output order: first_name, sum(ranking_points) 2) When combining players table (T1) and rankings table (T2) for shared entities: link rows where T1.player_id = T2.player_id exactly as shown in the amends; keep only matching pairs (inner match) 3) When the question says \"per player\": organize results by T1.first_name and compute sum of ranking_points per group 4) When the question asks for \"total ranking points\": compute the sum of T2.ranking_points for each group 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms",
            "1) When answering about \"total ranking points for each player and their first name\": make sure the output order: SUM(T2.ranking_points) first, then T1.first_name. 2) When computing aggregate values: do not assign aliases to aggregate functions like SUM(T2.ranking_points). 3) When combining players T1 and rankings T2: link rows where T1.player_id = T2.player_id and keep only matching pairs (inner match). 4) When grouping by player attributes: organize results by T1.first_name and compute the sum of ranking_points per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, SUM(ranking_points) FROM players GROUP BY player_id",
            "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name",
            "SELECT sum(T2.ranking_points), T1.first_name FROM players T1 JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ],
        "rule_sql": [
            "SELECT T1.first_name, SUM(T2.ranking_points) FROM players T1 INNER JOIN rankings T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name"
        ]
    },
    "588": {
        "db_id": "tvshow",
        "question": "What are the names of all cartoons directed by Ben Jones?",
        "ground_truth": "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";",
        "amends": [
            "Do reference the table as `Cartoon` instead of `cartoons` and use the column `Directed_by` instead of `director` for the filter condition. Do use double quotes around the string literal \"Ben Jones\" instead of single quotes. Do capitalize the output column as `Title` instead of `title` to match the correct column name. The amended query now correctly references the proper table and column names while maintaining the same filtering logic for director Ben Jones."
        ],
        "rules": [
            "1) When the question asks about cartoons directed by Ben Jones: use the table name \"Cartoon\" instead of \"cartoons\". 2) When filtering for director Ben Jones: use the column \"Directed_by\" instead of \"director\" and the exact string literal \"Ben Jones\" with double quotes. 3) When selecting cartoon titles: use the column \"Title\" instead of \"title\" for the output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons WHERE director = 'Ben Jones';",
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon WHERE Directed_by = \"Ben Jones\";"
        ]
    },
    "847": {
        "db_id": "orchestra",
        "question": "What are the names of conductors who have conducted orchestras founded after the year 2008?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008",
        "amends": [
            "Do use `T1.Name` with table alias instead of `name` without qualification. Do join `conductor AS T1` to `orchestra AS T2` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only the `conductors` table. Do filter on `Year_of_Founded > 2008` instead of `orchestra_founded_year > 2008`. The amended query now correctly joins the conductor and orchestra tables to find conductors leading orchestras founded after 2008, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"conductors who have conducted orchestras founded after the year 2008\": make sure the output order: T1.Name. 2) When combining T1 (conductors) and T2 (orchestra) for shared entities: link rows where T1.Conductor_ID = T2.Conductor_ID exactly as shown; keep only matching pairs (inner match). 3) When filtering orchestras by foundation year: use T2.Year_of_Founded > 2008 instead of orchestra_founded_year > 2008. 4) When selecting conductor names: use T1.Name with table alias qualification instead of unqualified name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors WHERE orchestra_founded_year > 2008;",
            "SELECT T1.Name \nFROM conductor AS T1\nJOIN orchestra AS T2 ON T1.Conductor_ID = T2.Conductor_ID\nWHERE T2.Year_of_Founded > 2008;"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nWHERE T2.Year_of_Founded > 2008\nORDER BY T1.Name;"
        ]
    },
    "517": {
        "db_id": "student_transcripts_tracking",
        "question": "How many departments offer any degree?",
        "ground_truth": "SELECT count(DISTINCT department_id) FROM Degree_Programs",
        "amends": [
            "Do count `DISTINCT department_id` from the `Degree_Programs` table instead of counting all rows from the `departments` table. Do remove the `WHERE degree IS NOT NULL` filter instead of keeping it, as the distinct count inherently handles null values appropriately. The amended query now correctly counts unique department IDs from the Degree_Programs table, matching the intended behavior."
        ],
        "rules": [
            "1) When counting departments that offer degrees: count distinct \"department_id\" values from the \"Degree_Programs\" table instead of counting all rows from the \"departments\" table. 2) When handling null values in degree programs: do not apply a \"degree IS NOT NULL\" filter as the distinct count inherently handles null values appropriately."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE degree IS NOT NULL;",
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT department_id) FROM Degree_Programs;"
        ]
    },
    "861": {
        "db_id": "orchestra",
        "question": "What are years of founding for orchestras that have had more than a single performance?",
        "ground_truth": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Year_of_Founded` instead of `year_of_founding` and do add table alias `T1` instead of omitting it. Do change FROM clause to join `orchestra AS T1` with `performance AS T2` instead of single table `orchestras` and do add `ON T1.Orchestra_ID = T2.Orchestra_ID` join condition instead of no join. Do add `GROUP BY T2.Orchestra_ID` instead of omitting grouping and do move filter to `HAVING COUNT(*) > 1` instead of `WHERE performance_count > 1`. The amended query now correctly identifies orchestras with multiple performances by joining the performance table and counting records per orchestra."
        ],
        "rules": [
            "1) When answering about \"years of founding for orchestras that have had more than a single performance\": make sure the output order: T1.Year_of_Founded. 2) When the question mentions \"orchestras that have had more than a single performance\": join table \"orchestra AS T1\" with table \"performance AS T2\" using the condition T1.Orchestra_ID = T2.Orchestra_ID and keep only matching pairs (inner match). 3) When counting performances per orchestra: group by T2.Orchestra_ID and count the number of rows using the canonical key. 4) When filtering for orchestras with more than one performance: apply the condition COUNT(*) > 1 after grouping. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like Year_of_Founded."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year_of_founding FROM orchestras WHERE performance_count > 1",
            "SELECT T1.Year_of_Founded \nFROM orchestra AS T1 \nJOIN performance AS T2 ON T1.Orchestra_ID = T2.Orchestra_ID \nGROUP BY T2.Orchestra_ID \nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.\"Year_of_Founded\"\nFROM orchestra AS T1\nINNER JOIN performance AS T2 ON T1.\"Orchestra_ID\" = T2.\"Orchestra_ID\"\nGROUP BY T2.\"Orchestra_ID\"\nHAVING COUNT(*) > 1\nORDER BY T1.\"Year_of_Founded\""
        ]
    },
    "150": {
        "db_id": "car_1",
        "question": "What are the names and ids of all makers with more than 3 models?",
        "ground_truth": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",
        "amends": [
            "Do select `T1.FullName` and `T1.Id` instead of `maker_id` and `maker_name`. Do use `FROM CAR_MAKERS AS T1` joined with `MODEL_LIST AS T2` on `T1.Id = T2.Maker` instead of querying only the `makers` table. Do add `GROUP BY T1.Id` and move the count filter to `HAVING count(*) > 3` instead of using `WHERE model_count > 3` without grouping. The amended query now correctly counts models per maker and filters makers with more than 3 models, matching the intended behavior.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing the order. Do keep the identical `FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker` join structure instead of altering any join logic. Do preserve the exact `GROUP BY T1.Id` grouping and `HAVING COUNT(*) > 3` aggregation filter instead of modifying the grouping or filtering logic. The amended query now matches RIGHT_SQL's behavior with identical logical execution despite minor formatting differences.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing the order. Do keep the same table aliases `AS T1` and `AS T2` instead of modifying them. Do preserve the identical join condition `T1.Id = T2.Maker` instead of altering the relationship. Do retain the same grouping `GROUP BY T1.Id` instead of modifying the grouping criteria. Do continue using the same aggregate condition `HAVING COUNT(*) > 3` instead of changing the threshold. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output.",
            "Do maintain the same column selection `T1.Id, T1.FullName` instead of changing it. Do keep the same table sources `car_makers AS T1` and `model_list AS T2` with the same join type `JOIN` and identical join condition `T1.Id = T2.Maker` instead of altering them. Do preserve the identical `GROUP BY T1.Id` clause and `HAVING COUNT(*) > 3` condition instead of modifying them. The amended query now matches RIGHT_SQL's behavior as there are no substantive differences between the queries beyond potential case sensitivity in table names which should be ignored per the instructions.",
            "Do maintain the same column selection order with `T1.FullName, T1.Id` instead of `T1.Id, T1.FullName` to match the RIGHT_SQL's output format. Do preserve the identical join logic with `JOIN model_list AS T2 ON T1.Id = T2.Maker` as both queries use the same join condition and table relationships. Do keep the same grouping with `GROUP BY T1.Id` and identical aggregation condition `HAVING COUNT(*) > 3` to filter for makers with more than three models. The amended query now matches RIGHT_SQL's behavior with only the column order adjustment."
        ],
        "rules": [
            "1) When answering about \"names and ids of all makers with more than 3 models\": make sure the output order: T1.FullName, T1.Id. 2) When the question mentions \"makers\": \"makers\" actually means \"CAR_MAKERS AS T1\" in schema. 3) When the question mentions \"models\": \"models\" actually means \"MODEL_LIST AS T2\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.Maker; keep only matching pairs (inner match). 5) When the question asks for \"count of models per maker\": compute the number of rows using T2.Maker as the grouping key and count per group. 6) When the question asks for \"more than 3 models\": filter groups where count(*) > 3 using HAVING clause after grouping.",
            "1) When answering about \"names and ids of all makers with more than 3 models\": make sure the output order: T1.Id, T1.FullName 2) When combining car_makers and model_list tables: link rows where T1.Id = T2.Maker and keep only matching pairs (inner match) 3) When grouping by maker: organize results by T1.Id and compute requested aggregates per group 4) When counting models per maker: compute the number of rows using the join relationship and filter for makers with COUNT(*) > 3",
            "1) When counting models per maker: use the exact join condition T1.Id = T2.Maker to link car_makers and model_list tables. 2) When grouping by maker: use T1.Id as the grouping key instead of other identifiers. 3) When filtering for makers with more than 3 models: apply the condition COUNT(*) > 3 exactly as specified. 4) When selecting output columns: maintain the exact order T1.Id, T1.FullName without reordering. 5) When using table aliases: preserve T1 for car_makers and T2 for model_list without swapping or modifying them.",
            "1) When counting models per maker: use the canonical key T1.Id for grouping and count all rows in the joined result using COUNT(*) 2) When filtering for makers with more than 3 models: apply the condition COUNT(*) > 3 in the grouping filter 3) When selecting output columns for makers: include both T1.Id and T1.FullName to show the maker's identifier and name 4) When combining car_makers and model_list tables: link rows where T1.Id = T2.Maker using an inner join to match makers with their models",
            "1) When answering about \"names and ids of all makers with more than 3 models\": make sure the output order: T1.FullName, T1.Id\n2) When combining car_makers as T1 and model_list as T2: link rows where T1.Id = T2.Maker exactly as shown in the amends; keep only matching pairs (inner match)\n3) When the question asks for \"makers with more than 3 models\": organize results by T1.Id and compute COUNT(*) per group, then filter for groups where COUNT(*) > 3"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker_id, maker_name FROM makers WHERE model_count > 3;",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.Id, T1.FullName\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3",
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.FullName, T1.Id\nFROM car_makers AS T1\nINNER JOIN model_list AS T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id\nHAVING COUNT(*) > 3\nORDER BY T1.FullName, T1.Id"
        ]
    },
    "322": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes?",
        "ground_truth": "SELECT DISTINCT template_type_code FROM Templates",
        "amends": [
            "Do select `template_type_code` instead of `template_type` and use `DISTINCT` instead of `GROUP BY` for deduplication. Do reference the table as `Templates` (case-sensitive) instead of `templates`. The amended query now correctly retrieves distinct template type codes from the Templates table."
        ],
        "rules": [
            "1) When the question asks for \"different template type codes\": select distinct \"template_type_code\" from \"Templates\". 2) When referring to the templates table: use the exact identifier \"Templates\" with proper case sensitivity. 3) When deduplicating values: use DISTINCT instead of GROUP BY for retrieving unique values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type FROM templates GROUP BY template_type;",
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ]
    },
    "608": {
        "db_id": "tvshow",
        "question": "For each language, list the number of TV Channels that use it.",
        "ground_truth": "SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",
        "amends": [
            "Do use the exact table name `TV_Channel` instead of `tv_channels` to match the correct schema. Do maintain the same column name `LANGUAGE` and aggregation `count(*)` with identical `GROUP BY LANGUAGE` logic, as there are no substantive differences in the SELECT list, aggregates, or grouping between the queries. The amended query now matches RIGHT_SQL's behavior by using the correct table reference while preserving identical query logic and results."
        ],
        "rules": [
            "1) When the question asks for \"number of TV Channels\" per language: count the rows using the canonical table \"TV_Channel\" and group by the exact column \"LANGUAGE\". 2) When choosing table identifiers: use the exact table name \"TV_Channel\" with double quotes as shown in the schema, not alternative names like \"tv_channels\". 3) When counting entities: use count(*) to count all rows in each language group rather than counting specific columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) FROM tv_channels GROUP BY language;",
            "SELECT Language, COUNT(*) FROM TV_Channel GROUP BY Language"
        ],
        "rule_sql": [
            "SELECT \"Language\", COUNT(*) AS number_of_tv_channels FROM \"TV_Channel\" GROUP BY \"Language\""
        ]
    },
    "64": {
        "db_id": "pets_1",
        "question": "What are the ids of the students who do not own cats as pets?",
        "ground_truth": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "amends": [
            "Do use `EXCEPT` set operation instead of simple `WHERE` filtering to exclude students with cats. Do reference `stuid` instead of `student_id` and `student` table instead of `students`. Do add joins to `has_pet` and `pets` tables through `T1.stuid = T2.stuid` and `T3.petid = T2.petid` instead of directly filtering on a non-existent `pet_type` column. Do filter with `T3.pettype = 'cat'` in the exclusion subquery instead of `pet_type != 'cat'` in the main query. Do use table aliases `T1`, `T2`, `T3` for clarity instead of no aliases. The amended query now correctly identifies students without cats by excluding those who have cat pets through the proper relationship tables."
        ],
        "rules": [
            "1) When the question asks for student ids who do not own cats: use the exact identifier \"stuid\" from the \"student\" table instead of \"student_id\" from \"students\". 2) When identifying students with cat pets: join tables using T1.stuid = T2.stuid and T3.petid = T2.petid, then filter with T3.pettype = 'cat' exactly. 3) When excluding students with cats: use EXCEPT set operation to remove students who have cat pets from all students, rather than simple WHERE filtering. 4) When handling table references: use aliases T1 for student table, T2 for has_pet table, and T3 for pets table as established in the joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id FROM students WHERE pet_type != 'cat';",
            "SELECT StuID FROM Student\nEXCEPT\nSELECT T1.StuID\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T3.PetType = 'cat'"
        ],
        "rule_sql": [
            "SELECT T1.StuID FROM Student T1\nEXCEPT\nSELECT T1.StuID FROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T3.PetType = 'cat'"
        ]
    },
    "10": {
        "db_id": "concert_singer",
        "question": "Show all countries and the number of singers in each country.",
        "ground_truth": "SELECT country ,  count(*) FROM singer GROUP BY country",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause, correcting the table name to match the intended data source. The amended query now matches RIGHT_SQL's behavior with the proper table reference."
        ],
        "rules": [
            "1) When the question asks for countries and singer counts: use the exact table name \"singer\" instead of \"singers\" as shown in the schema. 2) When counting singers per country: count using the canonical key from the singer table (though not explicitly shown, the amendment indicates the table reference correction is the primary requirement)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Country, COUNT(*) AS NumberOfSingers FROM singer GROUP BY Country;"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(*) AS NumberOfSingers FROM singer GROUP BY Country;"
        ]
    },
    "248": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights leaving from APG.",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `SourceAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table references."
        ],
        "rules": [
            "1) When answering about \"flight numbers of flights leaving from APG\": make sure the output order: FlightNo. 2) When the question mentions \"flight numbers\": \"flight numbers\" actually means \"FlightNo in schema\". 3) When the question mentions \"leaving from APG\": \"leaving from APG\" actually means \"SourceAirport = \\\"APG\\\" in schema\". 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \\\"APG\\\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT FlightNo FROM flights WHERE SourceAirport = \"APG\" ORDER BY FlightNo;"
        ]
    },
    "934": {
        "db_id": "dog_kennels",
        "question": "What is the name of the breed with the most dogs?",
        "ground_truth": "SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add a `JOIN` between `Breeds AS T1` and `Dogs AS T2` on `T1.breed_code = T2.breed_code` instead of querying only the `dogs` table. Do specify the table alias `T1.breed_name` in the SELECT clause instead of just `breed_name`. Do include the proper join condition `T1.breed_code = T2.breed_code` instead of missing the relationship between breeds and dogs tables. The amended query now correctly joins the breeds and dogs tables to count dogs by breed and returns the breed with the highest count, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"breed with the most dogs\": make sure to join Breeds as T1 and Dogs as T2 using the exact join condition T1.breed_code = T2.breed_code to establish the relationship between breeds and dogs. 2) When counting dogs per breed: count using the canonical key from the Dogs table (T2.breed_code) to determine the number of dogs for each breed. 3) When selecting the breed name: use the exact identifier T1.breed_name from the Breeds table instead of just breed_name. 4) When finding the breed with the highest count: rank rows by the count of dogs in descending order and keep only the first row (top result)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT breed_name FROM dogs GROUP BY breed_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.breed_name\nFROM Breeds AS T1\nJOIN Dogs AS T2 ON T1.breed_code = T2.breed_code\nGROUP BY T1.breed_code, T1.breed_name\nORDER BY COUNT(T2.breed_code) DESC\nLIMIT 1;"
        ]
    },
    "425": {
        "db_id": "museum_visit",
        "question": "What is the total ticket expense of the visitors whose membership level is 1?",
        "ground_truth": "SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1",
        "amends": [
            "Do use `sum(t2.Total_spent)` instead of `SUM(ticket_price)` for the aggregate calculation. Do join `visit AS t2` on `t1.id = t2.visitor_id` instead of querying only the `visitors` table. Do reference `t1.Level_of_membership` instead of `membership_level` in the WHERE filter condition. Do add the required table join structure instead of querying a single table. The amended query now correctly calculates total spending from the visit table for visitors with the specified membership level."
        ],
        "rules": [
            "1) When answering about \"total ticket expense of visitors whose membership level is 1\": make sure the output order: sum(t2.Total_spent). 2) When the question mentions \"membership level is 1\": \"membership level\" actually means \"t1.Level_of_membership = 1\" in schema. 3) When combining visitors and visit tables for shared entities: link rows where t1.id = t2.visitor_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When calculating total expense: use sum(t2.Total_spent) instead of SUM(ticket_price) for the aggregate calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(ticket_price) FROM visitors WHERE membership_level = 1;",
            "SELECT SUM(t2.Total_spent) AS total_expense\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nWHERE t1.Level_of_membership = 1"
        ],
        "rule_sql": [
            "SELECT SUM(t2.Total_spent) \nFROM visitor t1\nINNER JOIN visit t2 ON t1.ID = t2.visitor_ID\nWHERE t1.Level_of_membership = 1"
        ]
    },
    "338": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the template type code of the template that is used by a document named Data base.",
        "ground_truth": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"",
        "amends": [
            "Do add table `Documents AS T2` with a `JOIN` on `T1.template_id = T2.template_id` instead of querying only the `templates` table. Do reference `template_type_code` as `T1.template_type_code` instead of just `template_type_code`. Do move the filter condition to `T2.document_name = \"Data base\"` instead of `document_name = 'Data base'` on the templates table. Do use double quotes around the string literal \"Data base\" instead of single quotes. The amended query now correctly joins the Templates and Documents tables to find template_type_code based on document_name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about template type code for a document: make sure the output order: T1.template_type_code\n2) When the question mentions \"document named Data base\": \"Data base\" actually means T2.document_name = \"Data base\" in schema\n3) When combining Templates (T1) and Documents (T2) for shared entities: link rows where T1.template_id = T2.template_id; keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation - use exact literal \"Data base\" with double quotes"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM templates WHERE document_name = 'Data base';",
            "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id = T2.template_id WHERE T2.document_name = \"Data base\""
        ],
        "rule_sql": [
            "SELECT T1.Template_Type_Code\nFROM Templates T1\nINNER JOIN Documents T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Document_Name = \"Data base\""
        ]
    },
    "80": {
        "db_id": "pets_1",
        "question": "For students who have pets , how many pets does each student have ? list their ids instead of names .",
        "ground_truth": "select count(*) ,  t1.stuid from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid group by t1.stuid",
        "amends": [
            "Do select `count(*)` and `t1.stuid` instead of `student_id` and `COUNT(*) as pet_count`. Do use `FROM student as t1 JOIN has_pet as t2` instead of `FROM students` to properly join the student and pet tables. Do apply the join condition `on t1.stuid = t2.stuid` instead of omitting the table relationship. Do remove the `HAVING pet_count > 0` filter instead of keeping it, as counting joined pet records inherently excludes students without pets. The amended query now correctly counts pets per student by joining the relevant tables and matches the RIGHT_SQL's behavior.",
            "Do place `count(*)` before `t1.stuid` in the SELECT list instead of having `t1.StuID` first. Do use lowercase `stuid` instead of mixed case `StuID` for consistency. Do maintain the same FROM clause with `student as t1` joining `has_pet as t2` on `t1.stuid = t2.stuid` instead of changing the join logic. Do keep the GROUP BY clause with `t1.stuid` instead of modifying the grouping. The amended query now correctly outputs the count of pets per student while maintaining the same logical behavior as the right SQL."
        ],
        "rules": [
            "1) When answering about \"students who have pets\": use table aliases T1 for \"student\" and T2 for \"has_pet\" exactly as specified. 2) When joining student and pet tables: link rows where T1.StuID = T2.StuID to match students with their pets. 3) When counting pets per student: use count(*) to count all pet records for each student. 4) When selecting student identifiers: use T1.StuID instead of student_id to match the exact column name. 5) When grouping results: organize by T1.StuID to show pet counts for each individual student. 6) When the question asks for \"how many pets each student has\": do not apply additional filters like HAVING pet_count > 0 since the join inherently excludes students without pets.",
            "1) When answering about \"how many pets each student has\": make sure the output order: count of pets first, then student id. 2) When referring to student identifiers: use lowercase \"stuid\" consistently instead of mixed case \"StuID\". 3) When counting pets per student: count all rows from the Has_Pet table for each student using the join condition t1.stuid = t2.stuid. 4) When organizing results by student: group by t1.stuid to compute aggregates per student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) as pet_count FROM students GROUP BY student_id HAVING pet_count > 0",
            "SELECT t1.StuID, COUNT(*) \nFROM Student AS t1 \nJOIN Has_Pet AS t2 ON t1.StuID = t2.StuID \nGROUP BY t1.StuID",
            "SELECT count(*), t1.stuid FROM student as t1 JOIN has_pet as t2 ON t1.stuid = t2.stuid GROUP BY t1.stuid"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS pet_count, T1.StuID AS stuid\nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nGROUP BY T1.StuID\nORDER BY pet_count, stuid"
        ]
    },
    "182": {
        "db_id": "flight_2",
        "question": "Which abbreviation corresponds to Jetblue Airways?",
        "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference column `Abbreviation` instead of `abbreviation` to match the correct case sensitivity. Do reference column `Airline` instead of `name` to use the proper column name for airline identification. Do reference table `AIRLINES` instead of `airlines` to maintain consistent uppercase naming convention. Do use double quotes `\"JetBlue Airways\"` instead of single quotes for string literal consistency. The amended query now correctly retrieves the abbreviation by matching the airline name in the appropriate column with proper case handling."
        ],
        "rules": [
            "1) When the question asks for an abbreviation corresponding to an airline name: use column \"Abbreviation\" from table \"AIRLINES\" to retrieve the abbreviation. 2) When matching airline names in the database: use column \"Airline\" with the exact literal value \"JetBlue Airways\" to identify the correct airline. 3) When handling string literals for airline names: use double quotes around \"JetBlue Airways\" to maintain proper formatting and case sensitivity. 4) When referencing database objects: use uppercase table name \"AIRLINES\" instead of lowercase to match the schema's naming convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT abbreviation FROM airlines WHERE name = 'JetBlue Airways';",
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ],
        "rule_sql": [
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ]
    },
    "144": {
        "db_id": "car_1",
        "question": "What is the number of cars with more than 4 cylinders?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do use filter condition `Cylinders > 4` instead of `cylinders <= 4` in the WHERE clause, changing both the column name case and the inequality direction. The amended query now correctly counts records with more than 4 cylinders from the CARS_DATA table instead of counting those with 4 or fewer cylinders from a differently named table."
        ],
        "rules": [
            "1) When referencing the cars table: use the exact table name \"CARS_DATA\" with double quotes and proper case as shown in the schema. 2) When filtering for cars with more than 4 cylinders: use the condition \"Cylinders\" > 4 with the exact column name case and inequality direction. 3) When counting cars: count all rows from \"CARS_DATA\" that satisfy the cylinder condition rather than counting rows with 4 or fewer cylinders."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE cylinders <= 4;",
            "SELECT COUNT(*) FROM cars_data WHERE Cylinders > 4"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM \"cars_data\" WHERE \"Cylinders\" > 4"
        ]
    },
    "228": {
        "db_id": "flight_2",
        "question": "Give the code of the airport with the least flights.",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do add a `JOIN` with `FLIGHTS` table instead of querying `airports` alone. Do change the `SELECT` list to `T1.AirportCode` instead of `airport_code`. Do add grouping by `T1.AirportCode` instead of no grouping. Do change the `ORDER BY` to `count(*)` instead of `flight_count DESC`. Do remove the explicit `DESC` ordering and instead use the default ascending order. Do add join conditions `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of no join conditions. The amended query now correctly counts flights per airport by joining with the flights table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"airport with the least flights\": make sure the output order: T1.AirportCode. 2) When the question mentions \"airport code\": \"airport code\" actually means \"T1.AirportCode in schema\". 3) When the question asks for \"count of flights\": compute the number of rows using the canonical key from the FLIGHTS table. 4) When combining T1 (airports) and T2 (FLIGHTS) for shared entities: link rows where T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport; keep only matching pairs. 5) When the question asks for \"least flights\": rank rows by count of flights in ascending order and keep the first 1 row. 6) When the question says \"per airport\": organize results by T1.AirportCode and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airport_code FROM airports ORDER BY flight_count DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nLEFT JOIN flights T2 ON T1.AirportCode = T2.SourceAirport OR T1.AirportCode = T2.DestAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(T2.Airline || T2.FlightNo) ASC\nLIMIT 1;"
        ]
    },
    "200": {
        "db_id": "flight_2",
        "question": "Return the name of the airport with code 'AKO'.",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
        "amends": [
            "Do select `AirportName` instead of `name` and filter on `AirportCode = \"AKO\"` instead of `code = 'DEN'`."
        ],
        "rules": [
            "1) When the question asks for the name of an airport: use the exact column token \"AirportName\" from the airports table. 2) When filtering by airport code: use the exact literal value 'AKO' with the correct case and quotes as specified in the question. 3) When the question specifies a particular airport code: filter using AirportCode = \"AKO\" to match exactly the requested code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE code = 'DEN';",
            "SELECT AirportName FROM airports WHERE AirportCode = 'AKO';"
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE AirportCode = 'AKO';"
        ]
    },
    "151": {
        "db_id": "car_1",
        "question": "Which distinctive models are produced by maker with the full name General Motors or weighing more than 3500?",
        "ground_truth": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "amends": [
            "Do use explicit table joins with `CAR_NAMES AS T1 JOIN MODEL_LIST AS T2` instead of querying a single undefined table. Do reference specific columns `T2.Model` instead of the ambiguous `model`. Do add proper join conditions `ON T1.Model = T2.Model` and `ON T2.Maker = T3.Id` and `ON T1.MakeId = T4.Id` instead of missing table relationships. Do filter by `T3.FullName = 'General Motors'` instead of the incorrect `maker` reference. Do use `T4.weight > 3500` instead of the unqualified `weight` column. The amended query now correctly joins multiple tables and qualifies all column references to match the intended logic."
        ],
        "rules": [
            "1) When answering about \"distinctive models\": make sure the output order: T2.Model\n2) When the question mentions \"maker with the full name General Motors\": \"maker\" actually means \"T3.FullName in schema\" and filter using T3.FullName = 'General Motors'\n3) When the question mentions \"weighing more than 3500\": \"weighing\" actually means \"T4.weight in schema\" and filter using T4.weight > 3500\n4) When combining tables for shared entities: link rows where T1.Model = T2.Model and T2.Maker = T3.Id and T1.MakeId = T4.Id; keep only matching pairs (inner match)\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation of 'General Motors'"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT model FROM cars WHERE maker = 'General Motors' OR weight > 3500;",
            "SELECT DISTINCT T2.Model \nFROM car_names AS T1 \nJOIN model_list AS T2 ON T1.Model = T2.Model \nJOIN car_makers AS T3 ON T2.Maker = T3.Id \nJOIN cars_data AS T4 ON T1.MakeId = T4.Id \nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Model\nFROM car_names T1\nJOIN model_list T2 ON T1.Model = T2.Model\nJOIN car_makers T3 ON T2.Maker = T3.Id\nJOIN cars_data T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500\nORDER BY T2.Model"
        ]
    },
    "1023": {
        "db_id": "singer",
        "question": "What are the names of the singers that have more than one songs?",
        "ground_truth": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "amends": [
            "Do join `singer` and `song` tables on `Singer_ID` instead of querying only the `singers` table without proper table relationships. Do use `GROUP BY T1.Name` with `HAVING COUNT(*) > 1` instead of applying the aggregate function `COUNT(songs)` directly in the `WHERE` clause without grouping. Do reference the joined table columns with proper aliases `T1.Name` instead of just `name` from an unspecified source. Do count all rows with `COUNT(*)` instead of attempting to count a specific column `songs` that may not exist in the schema. The amended query now correctly identifies singers who have more than one song by properly joining the related tables and using aggregate filtering in the HAVING clause."
        ],
        "rules": [
            "1) When answering about \"names of singers that have more than one songs\": make sure the output order: T1.Name\n2) When the question mentions \"singers that have more than one songs\": join table \"singer\" as T1 and table \"song\" as T2 where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match)\n3) When counting songs per singer: organize results by T1.Name and compute COUNT(*) per group\n4) When filtering for singers with more than one song: use HAVING COUNT(*) > 1 instead of WHERE clause for aggregate conditions\n5) When referencing singer names: use T1.Name with exact alias T1 from the joined singer table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers WHERE COUNT(songs) > 1",
            "SELECT T1.Name \nFROM singer T1\nJOIN song T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T1.Name\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM singer AS T1 \nINNER JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name \nHAVING COUNT(*) > 1 \nORDER BY T1.Name"
        ]
    },
    "764": {
        "db_id": "world_1",
        "question": "What is average life expectancy in the countries where English is not the official language?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")",
        "amends": [
            "Do use `avg(LifeExpectancy)` instead of `AVG(life_expectancy)` to reference the correct column name. Do reference table `country` instead of `countries` with the proper table name. Do replace the simple `WHERE official_language != 'English'` filter with a subquery that checks `Name NOT IN` a correlated subquery instead of using a direct column comparison. Do implement a subquery that joins `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of assuming language data exists in the main table. Do add the condition `T2.Language = \"English\" AND T2.IsOfficial = \"T\"` to properly filter for countries where English is an official language, instead of just checking for any non-English language presence. The amended query now correctly calculates average life expectancy for countries where English is not an official language by properly correlating country data with language information through the appropriate join relationship."
        ],
        "rules": [
            "1) When answering about average life expectancy: use avg(LifeExpectancy) to reference the correct column name. 2) When referencing the countries table: use table country instead of countries with the proper table name. 3) When filtering for countries where English is not the official language: implement a subquery that checks Name NOT IN a correlated subquery instead of using a direct column comparison. 4) When combining country and language data: join country AS T1 with countrylanguage AS T2 on T1.Code = T2.CountryCode instead of assuming language data exists in the main table. 5) When identifying countries where English is an official language: add the condition T2.Language = \"English\" AND T2.IsOfficial = \"T\" to properly filter for official English language status."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE official_language != 'English';",
            "SELECT AVG(LifeExpectancy) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\n)"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) \nFROM country \nWHERE Name NOT IN (\n    SELECT T1.Name \n    FROM country AS T1 \n    JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \n    WHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\n)"
        ]
    },
    "431": {
        "db_id": "wta_1",
        "question": "Find the total number of matches.",
        "ground_truth": "SELECT count(*) FROM matches",
        "amends": [
            "Do query the `matches` table instead of the `players` table. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistency. The amended query now correctly counts records from the matches table rather than players."
        ],
        "rules": [
            "1) When answering about \"total number of matches\": query the \"matches\" table instead of the \"players\" table. 2) When counting records: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" for consistency."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players;",
            "SELECT count(*) FROM matches;"
        ],
        "rule_sql": [
            "select count(*) from matches"
        ]
    },
    "680": {
        "db_id": "poker_player",
        "question": "What are the names and birth dates of people, ordered by their names in alphabetical order?",
        "ground_truth": "SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, birth_date FROM people ORDER BY birth_date DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Birth_Date FROM people ORDER BY Name ASC;"
        ]
    },
    "257": {
        "db_id": "flight_2",
        "question": "Find the name of airports which do not have any flight in and out.",
        "ground_truth": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "amends": [
            "Do reference `AirportName` instead of `name` and `AirportCode` instead of `airport_id` in the SELECT clause and WHERE condition. Do use `SourceAirport` instead of `departure_airport` and `DestAirport` instead of `arrival_airport` in the subquery. Do combine the two NOT IN subqueries into a single UNION operation instead of separate subqueries, which improves efficiency by scanning the Flights table only once. Do reference the correct table names `Airports` and `Flights` with proper capitalization instead of lowercase table names. The amended query now correctly identifies airports that have never been used as either source or destination in any flight, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about airports without flights: use \"AirportName\" instead of \"name\" in the SELECT clause. 2) When identifying airports by their code: use \"AirportCode\" instead of \"airport_id\" in the WHERE condition. 3) When checking for departure airports in flights: use \"SourceAirport\" instead of \"departure_airport\". 4) When checking for arrival airports in flights: use \"DestAirport\" instead of \"arrival_airport\". 5) When combining flight departure and arrival checks: use a single UNION operation instead of separate subqueries to scan the Flights table only once. 6) When referencing table names: use \"Airports\" and \"Flights\" with proper capitalization instead of lowercase names. 7) When finding airports without any flights: check that \"AirportCode\" is not in the combined set of \"SourceAirport\" and \"DestAirport\" values from the Flights table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE airport_id NOT IN (SELECT departure_airport FROM flights) AND airport_id NOT IN (SELECT arrival_airport FROM flights);",
            "SELECT AirportName \nFROM airports \nWHERE AirportCode NOT IN (\n    SELECT SourceAirport FROM flights\n    UNION\n    SELECT DestAirport FROM flights\n)"
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"
        ]
    },
    "267": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the number of shops in each location.",
        "ground_truth": "SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",
        "amends": [
            "Do select `count(*)` and `LOCATION` instead of `location` and `COUNT(*)`. Do use `GROUP BY LOCATION` instead of `GROUP BY shop_id`. Do reference table `shop` instead of `shops`. The amended query now correctly groups by location and counts records per location rather than incorrectly grouping by shop_id while selecting location.",
            "Do place the `count(*)` column before `LOCATION` in the SELECT list instead of having `LOCATION` first. Do maintain the same GROUP BY clause with `LOCATION` and keep the same table source and aggregation logic. The amended query now correctly matches the RIGHT_SQL's column ordering while preserving identical result behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of shops in each location\": select \"LOCATION\" and count all rows per location group. 2) When grouping by location: use \"GROUP BY LOCATION\" instead of grouping by shop_id. 3) When referencing the shops table: use the exact table name \"shop\" instead of \"shops\". 4) When counting shops: use count(*) to count all records in each location group.",
            "1) When answering about \"number of shops in each location\": make sure the output order: count(*) column first, then LOCATION column. 2) When the question asks for \"number of shops\": compute the count of all rows using count(*). 3) When the question says \"in each location\": organize results by the LOCATION column and compute the count per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM shops GROUP BY shop_id;",
            "SELECT LOCATION, COUNT(*) FROM shop GROUP BY LOCATION;",
            "SELECT count(*), LOCATION FROM shop GROUP BY LOCATION"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS shop_count, Location FROM shop GROUP BY Location;"
        ]
    },
    "914": {
        "db_id": "network_1",
        "question": "Find the average grade of all students who have some friends.",
        "ground_truth": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do use `avg(grade)` from `Highschooler` instead of `AVG(grade)` from `students`. Do add a subquery with `id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)` instead of the simple filter `WHERE friend_count > 0`. Do change the table source to `Highschooler` instead of `students` and introduce a join between `Friend` and `Highschooler` tables instead of relying on a direct column filter. The amended query now correctly calculates average grades for students who have friends by verifying friendship relationships through the Friend table join rather than using a potentially incorrect friend_count field."
        ],
        "rules": [
            "1) When answering about \"average grade of all students who have some friends\": make sure the output order: avg(grade). 2) When the question mentions \"students who have some friends\": use a subquery with id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id) instead of a simple friend_count filter. 3) When combining Friend and Highschooler tables: link rows where T1.student_id = T2.id and keep only matching pairs (inner match). 4) When computing average grade: use avg(grade) from Highschooler table instead of students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE friend_count > 0",
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend)"
        ],
        "rule_sql": [
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ]
    },
    "386": {
        "db_id": "course_teach",
        "question": "What is the age and hometown of every teacher?",
        "ground_truth": "SELECT Age ,  Hometown FROM teacher",
        "amends": [
            "Do select `Age` and `Hometown` columns instead of `name` and `subject`. Do reference the `teacher` table instead of `teachers`. The amended query now correctly retrieves age and hometown information from the teacher table as intended."
        ],
        "rules": [
            "1) When answering about \"age and hometown of every teacher\": make sure the output order: Age, Hometown. 2) When the question mentions \"teacher\": \"teacher\" actually means table \"teacher\" in schema. 3) When selecting columns for teacher information: use exact column tokens \"Age\" and \"Hometown\" from table \"teacher\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, subject FROM teachers;",
            "SELECT Age, Hometown FROM teacher;"
        ],
        "rule_sql": [
            "SELECT Age, Hometown FROM teacher;"
        ]
    },
    "127": {
        "db_id": "car_1",
        "question": "What is the average weight of cars each year?",
        "ground_truth": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",
        "amends": [
            "Do use `avg(Weight)` with uppercase column name instead of `AVG(weight)` with lowercase. Do place the aggregate function first in the SELECT list instead of the year column. Do reference the correct table name `CARS_DATA` instead of `cars`. Do maintain the same GROUP BY logic with `YEAR` instead of `year` while preserving the uppercase column reference. The amended query now correctly calculates average weight by year from the CARS_DATA table."
        ],
        "rules": [
            "1) When answering about \"average weight of cars each year\": make sure the output order: avg(Weight) first, then YEAR. 2) When the question mentions \"cars\": \"cars\" actually means \"CARS_DATA\" in schema. 3) When the question mentions \"weight\": \"weight\" actually means \"Weight\" in schema with exact uppercase spelling. 4) When the question says \"each year\": organize results by YEAR and compute average weight per year. 5) When choosing identifier delimiters: do not replace uppercase column names with lowercase forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, AVG(weight) FROM cars GROUP BY year;",
            "SELECT avg(Weight), Year FROM CARS_DATA GROUP BY Year"
        ],
        "rule_sql": [
            "SELECT AVG(Weight) AS average_weight, Year FROM cars_data GROUP BY Year ORDER BY average_weight, Year;"
        ]
    },
    "102": {
        "db_id": "car_1",
        "question": "What is the maker of the carr produced in the earliest year and what year was it?",
        "ground_truth": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",
        "amends": [
            "Do select `T2.Make` and `T1.Year` instead of `maker` and `MIN(year)`. Do join `CAR_NAMES AS T2` on `T1.Id = T2.MakeId` instead of querying a single table. Do use `WHERE T1.Year = (SELECT min(YEAR) FROM CARS_DATA)` instead of `WHERE year = (SELECT MAX(year) FROM cars)`. Do reference the correct table aliases `T1` and `T2` instead of the original table references. The amended query now correctly retrieves the make and year from joined tables using the proper minimum year calculation."
        ],
        "rules": [
            "1) When answering about \"maker of the car produced in the earliest year\": make sure the output order: T2.Make, T1.Year\n2) When the question mentions \"maker\": \"maker\" actually means \"T2.Make\" in schema\n3) When the question mentions \"earliest year\": use the minimum value of T1.Year from CARS_DATA table\n4) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.MakeId exactly as shown in the amends; keep only matching pairs (inner match)\n5) When filtering for the earliest year: use WHERE T1.Year = (SELECT min(YEAR) FROM CARS_DATA) to find cars produced in the minimum year"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT maker, MIN(year) FROM cars WHERE year = (SELECT MAX(year) FROM cars);",
            "SELECT T2.Make, T1.Year \nFROM cars_data AS T1\nJOIN car_names AS T2 ON T1.Id = T2.MakeId\nWHERE T1.Year = (SELECT MIN(Year) FROM cars_data)"
        ],
        "rule_sql": [
            "SELECT T2.Make, T1.Year \nFROM cars_data T1 \nINNER JOIN car_names T2 ON T1.Id = T2.MakeId \nWHERE T1.Year = (SELECT min(Year) FROM cars_data)"
        ]
    },
    "937": {
        "db_id": "dog_kennels",
        "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of unaliased table names. Do change the subquery approach to explicit `JOIN` operations with `Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id` instead of a subquery with implicit joins. Do add `GROUP BY T1.owner_id` at the main query level instead of grouping within a subquery. Do change the ordering criterion to `ORDER BY count(*) DESC` instead of `ORDER BY SUM(cost) DESC`. Do remove the `WHERE owner_id IN` subquery filter and instead use the join structure to naturally filter the results. The amended query now correctly identifies owners based on treatment count rather than treatment cost sum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"owner who spent the most on treatments\": use explicit table aliases T1 for Owners, T2 for Dogs, and T3 for Treatments instead of unaliased table names. 2) When combining tables for shared entities: link rows where T1.owner_id = T2.owner_id and T2.dog_id = T3.dog_id; keep only matching pairs (inner match). 3) When the question asks for \"the most\" by treatment spending: group results by T1.owner_id and compute the count of treatments using T3 records. 4) When ranking for \"the most\": order rows by count(*) in descending direction and keep only the first row. 5) When producing output: include T1.owner_id and T1.last_name in the result columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, last_name \nFROM owners \nWHERE owner_id IN (\n    SELECT owner_id \n    FROM dogs \n    JOIN treatments ON dogs.dog_id = treatments.dog_id \n    GROUP BY owner_id \n    ORDER BY SUM(cost) DESC \n    LIMIT 1\n)",
            "SELECT T1.owner_id, T1.last_name\nFROM Owners AS T1\nJOIN Dogs AS T2 ON T1.owner_id = T2.owner_id\nJOIN Treatments AS T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T1.last_name\nFROM Owners T1\nINNER JOIN Dogs T2 ON T1.owner_id = T2.owner_id\nINNER JOIN Treatments T3 ON T2.dog_id = T3.dog_id\nGROUP BY T1.owner_id, T1.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "159": {
        "db_id": "car_1",
        "question": "How many cars have a larger accelerate than the car with the largest horsepower?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );",
        "amends": [
            "Do reference the correct table name `CARS_DATA` instead of `cars` in both the main query and subquery. Do use the column `Accelerate` instead of `horsepower` in the WHERE filter condition. Do change the subquery logic to select `Accelerate` ordered by `Horsepower DESC` with `LIMIT 1` instead of using `MAX(horsepower)` aggregate function. The amended query now correctly counts records where acceleration exceeds the acceleration value from the car with the highest horsepower, matching the intended behavior."
        ],
        "rules": [
            "1) When referencing the cars table: use the exact table name \"CARS_DATA\" instead of \"cars\". 2) When comparing acceleration values: use the column \"Accelerate\" for the comparison condition. 3) When finding the car with the largest horsepower: select the \"Accelerate\" value from the row with the highest \"Horsepower\" by ordering by \"Horsepower DESC\" and taking the first result, rather than using MAX aggregate on horsepower. 4) When counting cars with larger acceleration: count records where \"Accelerate\" is greater than the acceleration value from the car with the highest horsepower."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cars \nWHERE accelerate > (SELECT MAX(horsepower) FROM cars);",
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY Horsepower DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY CAST(Horsepower AS NUMERIC) DESC \n    LIMIT 1\n)"
        ]
    },
    "230": {
        "db_id": "flight_2",
        "question": "What airline serves the most flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRLINES` as `T1` to `FLIGHTS` as `T2` on `T1.uid=T2.Airline` instead of querying only the `flights` table. Do select `T1.Airline` instead of `airline` from the flights table. Do order by `count(*) DESC` instead of `flight_count ASC` to find the airline with the most flights rather than the fewest. Do remove the explicit column alias `flight_count` instead of keeping it since the ORDER BY clause now uses the aggregate function directly. The amended query now correctly identifies the airline with the highest number of flights by joining to the airlines table and sorting in descending order, matching the RIGHT_SQL's behavior.",
            "Do select only `T1.Airline` instead of selecting both `T1.Airline` and `COUNT(*)` in the SELECT list. Do maintain the same `JOIN` on `T1.uid=T2.Airline` instead of changing the join condition. Do keep the `GROUP BY T1.Airline` grouping instead of altering the grouping criteria. Do preserve the `ORDER BY count(*) DESC` ordering instead of modifying the sort direction. Do retain the `LIMIT 1` constraint instead of changing the row limit. The amended query now correctly returns only the airline name with the highest flight count instead of returning both the airline name and the count value."
        ],
        "rules": [
            "1) When answering about \"What airline serves the most flights\": make sure the output order: T1.Airline 2) When combining T1 (AIRLINES) and T2 (FLIGHTS) for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match) 3) When the question mentions \"most flights\": rank rows by count(*) in descending direction and keep the first 1 row 4) When counting flights: compute the number of rows using the join relationship between T1 and T2 5) When selecting airline information: use T1.Airline instead of any airline column from T2 (FLIGHTS) table",
            "1) When answering about \"What airline serves the most flights?\": make sure the output order: T1.Airline only without the count value. 2) When combining airlines T1 and flights T2: link rows where T1.uid = T2.Airline exactly as shown and keep only matching pairs (inner match). 3) When the question asks for \"count of flights\": compute the number of rows using the join relationship between airlines and flights. 4) When the question mentions \"most flights\": rank airlines by flight count in descending order and keep only the first 1 row. 5) When grouping by airline: organize results by T1.Airline and compute flight counts per airline."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count FROM flights GROUP BY airline ORDER BY flight_count ASC LIMIT 1;",
            "SELECT T1.Airline, COUNT(*) \nFROM airlines T1 \nJOIN flights T2 ON T1.uid = T2.Airline \nGROUP BY T1.Airline \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "495": {
        "db_id": "battle_death",
        "question": "What is the average number of injuries caused each time?",
        "ground_truth": "SELECT avg(injured) FROM death",
        "amends": [
            "Do reference the `death` table instead of the `incidents` table. Do aggregate the `injured` column instead of the `injuries` column. Do remove the `WHERE injuries > 0` filter instead of keeping it. The amended query now correctly calculates the average of injured individuals from the death table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"average number of injuries\": use the \"injured\" column from the \"death\" table instead of the \"injuries\" column from the \"incidents\" table. 2) When calculating the average: compute the average of all values in the \"injured\" column without applying any filter for positive values. 3) When referencing the table: use the \"death\" table as the source table instead of the \"incidents\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(injuries) FROM incidents WHERE injuries > 0;",
            "SELECT AVG(injured) AS average_injuries FROM death;"
        ],
        "rule_sql": [
            "SELECT AVG(injured) AS average_injuries FROM death;"
        ]
    },
    "350": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the template type description of the template type with the code AD.",
        "ground_truth": "SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  \"AD\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` and use double quotes `\"AD\"` instead of single quotes `'AD'` for the string literal, while keeping the same column selection `template_type_description` and filter condition `template_type_code = 'AD'` unchanged. The amended query now correctly references the intended table and uses consistent string quoting to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about template type descriptions: make sure the output order: template_type_description. 2) When the question mentions \"template type with the code AD\": \"AD\" actually means \"template_type_code = \\\"AD\\\"\" in schema. 3) When selecting from template types: use table \"Ref_template_types\" instead of \"template_types\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_description FROM template_types WHERE template_type_code = 'AD';",
            "SELECT template_type_description FROM Ref_template_types WHERE template_type_code = \"AD\""
        ],
        "rule_sql": [
            "SELECT template_type_description FROM Ref_Template_Types WHERE Template_Type_Code = 'AD';"
        ]
    },
    "1": {
        "db_id": "concert_singer",
        "question": "What is the total number of singers?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of `singers` to use the correct table name. Do use lowercase `count(*)` instead of uppercase `COUNT(*)` for consistent function casing. Do remove the `WHERE name IS NOT NULL` filter instead of keeping it to count all records regardless of null values. The amended query now correctly counts all rows in the singer table without unnecessary filtering."
        ],
        "rules": [
            "1) When the question asks for \"singers\": use the exact table name \"singer\" instead of \"singers\". 2) When counting all records in a table: use lowercase \"count(*)\" function and do not apply any WHERE filters to include all rows regardless of null values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM singers WHERE name IS NOT NULL;",
            "SELECT count(*) FROM singer"
        ],
        "rule_sql": [
            "SELECT count(*) FROM singer"
        ]
    },
    "242": {
        "db_id": "flight_2",
        "question": "Which airlines have at least 10 flights?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
        "amends": [
            "Do add a `FROM` clause with `AIRLINES AS T1` instead of omitting it, and do add a `JOIN` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of querying only the `flights` table. Do reference `T1.Airline` in the `SELECT` list instead of just `airline` to ensure the correct column from the joined table is selected. The amended query now correctly joins the airlines and flights tables to count flights per airline, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"airlines with at least 10 flights\": make sure the output order: T1.Airline\n2) When the question mentions \"airlines\": \"airlines\" actually means \"T1.Airline in schema\"\n3) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T2.Airline).\n4) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline; keep only matching pairs (inner match).\n5) When the question asks for \"at least 10 flights\": ensure the count of flights per airline is greater than 10."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline FROM flights GROUP BY airline HAVING COUNT(*) > 10;",
            "SELECT T1.Airline\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(*) >= 10"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nHAVING COUNT(T2.Airline) >= 10\nORDER BY T1.Airline"
        ]
    },
    "27": {
        "db_id": "concert_singer",
        "question": "What is the year that had the most concerts?",
        "ground_truth": "SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `concert_count`. Do use `count(*)` in the ORDER BY clause instead of selecting it as an alias. Do order by `DESC` instead of `ASC` to find the year with the most concerts. Do reference table `concert` instead of `concerts`. The amended query now correctly identifies the year with the highest number of concerts by counting records per year and ordering descending."
        ],
        "rules": [
            "1) When answering about \"the year that had the most concerts\": make sure the output order: YEAR. 2) When counting concerts: count all rows using count(*) and use this count directly in ordering instead of selecting it as an output column. 3) When finding the year with the most concerts: order the results by concert count in descending order (DESC) instead of ascending order (ASC). 4) When referencing the concerts table: use the exact table name \"concert\" instead of \"concerts\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as concert_count FROM concerts GROUP BY year ORDER BY concert_count ASC LIMIT 1;",
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "964": {
        "db_id": "dog_kennels",
        "question": "What are the arriving date and the departing date of all the dogs?",
        "ground_truth": "SELECT date_arrived ,  date_departed FROM Dogs",
        "amends": [
            "Do reference `date_arrived` and `date_departed` columns instead of `arrival_date` and `departure_date`. Do query from `Dogs` table instead of `cats` table. The amended query now correctly selects the appropriate date columns from the intended table."
        ],
        "rules": [
            "1) When the question asks about \"arriving date\" and \"departing date\" of dogs: use columns \"date_arrived\" and \"date_departed\" from table \"Dogs\". 2) When querying about dogs: use table \"Dogs\" instead of any other table like \"cats\". 3) When selecting date columns for dogs: ensure the output order is \"date_arrived\" followed by \"date_departed\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM cats;",
            "SELECT date_arrived, date_departed FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT date_arrived, date_departed FROM Dogs;"
        ]
    },
    "30": {
        "db_id": "concert_singer",
        "question": "Show countries where a singer above age 40 and a singer below 30 are from.",
        "ground_truth": "SELECT country FROM singer WHERE age  >  40 INTERSECT SELECT country FROM singer WHERE age  <  30",
        "amends": [
            "Do remove `DISTINCT` instead of keeping it, and do use `INTERSECT` with two separate queries instead of `OR` in the `WHERE` clause. Do change the table name from `singers` to `singer` instead of using the plural form. Do split the age conditions into separate queries for `age > 40` and `age < 30` instead of combining them with `OR`, and do use `INTERSECT` to find countries that appear in both result sets instead of finding countries where either condition is true. The amended query now correctly finds countries that have both singers over 40 and singers under 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for countries with both singers above age 40 and singers below age 30: use INTERSECT between two separate queries instead of OR in WHERE clause. 2) When referring to the singers table: use the exact table name \"singer\" instead of the plural form \"singers\". 3) When handling age conditions: split into separate queries for \"age > 40\" and \"age < 30\" instead of combining them with OR. 4) When removing DISTINCT: do not include DISTINCT in the final query as it is not needed with INTERSECT. 5) When finding countries that satisfy both conditions: use INTERSECT to find countries that appear in both the over-40 and under-30 result sets."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM singers \nWHERE age > 40 OR age < 30;",
            "SELECT Country FROM singer WHERE Age > 40 INTERSECT SELECT Country FROM singer WHERE Age < 30"
        ],
        "rule_sql": [
            "SELECT Country FROM singer WHERE Age > 40\nINTERSECT\nSELECT Country FROM singer WHERE Age < 30"
        ]
    },
    "948": {
        "db_id": "dog_kennels",
        "question": "List the cost of each treatment and the corresponding treatment type description.",
        "ground_truth": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
        "amends": [
            "Do specify table aliases `T1.cost_of_treatment` and `T2.treatment_type_description` instead of unqualified column names `cost` and `treatment_type_description`. Do add a `JOIN` with `treatment_types AS T2` instead of querying only the `treatments` table. Do use the join condition `ON T1.treatment_type_code = T2.treatment_type_code` instead of omitting the necessary table relationship. The amended query now correctly retrieves treatment cost and description by properly joining the treatments table with treatment_types using the appropriate foreign key relationship."
        ],
        "rules": [
            "1) When answering about \"cost of each treatment and corresponding treatment type description\": make sure the output order: T1.cost_of_treatment, T2.treatment_type_description. 2) When the question mentions \"cost\": \"cost\" actually means \"T1.cost_of_treatment\" in schema. 3) When the question mentions \"treatment type description\": \"treatment type description\" actually means \"T2.treatment_type_description\" in schema. 4) When combining T1 (treatments) and T2 (treatment_types) for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost, treatment_type_description FROM treatments",
            "SELECT T1.cost_of_treatment, T2.treatment_type_description FROM Treatments AS T1 JOIN Treatment_Types AS T2 ON T1.treatment_type_code = T2.treatment_type_code"
        ],
        "rule_sql": [
            "SELECT T1.cost_of_treatment, T2.treatment_type_description \nFROM Treatments T1\nINNER JOIN Treatment_Types T2 ON T1.treatment_type_code = T2.treatment_type_code\nORDER BY T1.cost_of_treatment, T2.treatment_type_description"
        ]
    },
    "664": {
        "db_id": "poker_player",
        "question": "What are the names of poker players, ordered ascending by the number of final tables they have made?",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made",
        "amends": [
            "Do select `T1.Name` instead of `name, COUNT(final_table)` and remove the aggregate function and alias. Do use `FROM people AS T1 JOIN poker_player AS T2` instead of `FROM poker_players` with a proper join instead of a single table. Do specify the join condition `ON T1.People_ID = T2.People_ID` instead of omitting join predicates. Do remove the `COUNT` aggregation and `GROUP BY` implication instead of including them. Do order by `T2.Final_Table_Made` instead of `final_tables DESC` using the actual column rather than an aggregate result. The amended query now correctly retrieves player names joined with poker player data and orders by final tables made."
        ],
        "rules": [
            "1) When answering about poker players' names ordered by final tables made: make sure the output order includes T1.Name and T2.Final_Table_Made. 2) When the question mentions \"poker players\": use \"people AS T1 JOIN poker_player AS T2\" with join condition T1.People_ID = T2.People_ID instead of a single table. 3) When ordering by number of final tables: use T2.Final_Table_Made column directly instead of counting or aggregating. 4) When selecting player names: use T1.Name instead of generic name column. 5) When the question asks for ascending order: order by T2.Final_Table_Made in ascending direction instead of descending."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(final_table) as final_tables FROM poker_players ORDER BY final_tables DESC;",
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ],
        "rule_sql": [
            "SELECT T1.Name, T2.Final_Table_Made FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made ASC"
        ]
    },
    "233": {
        "db_id": "flight_2",
        "question": "What are airlines that have some flight departing from airport 'AHD'?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do select only `T1.Airline` instead of all columns with `*`. Do join `FLIGHTS AS T2` instead of querying only the `airlines` table. Do use `ON T1.uid = T2.Airline` for the join condition instead of no join. Do filter on `T2.SourceAirport = \"AHD\"` instead of `departure_airport = 'AHD'`. The amended query now correctly joins airlines with flights and filters by source airport instead of using a non-existent departure_airport column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about airlines with flights departing from a specific airport: make sure the output order: T1.Airline\n2) When the question mentions \"departing from airport 'AHD'\": \"AHD\" actually means \"T2.SourceAirport = 'AHD'\" in schema\n3) When combining airlines (T1) and flights (T2) for shared entities: link rows where T1.uid = T2.Airline exactly as shown in the amends; keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation - use 'AHD' exactly as specified"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM airlines WHERE departure_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'"
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nINNER JOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = 'AHD'\nORDER BY T1.Airline"
        ]
    },
    "685": {
        "db_id": "poker_player",
        "question": "How many distinct nationalities are there?",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM people",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do add the `Nationality` column reference instead of omitting it in the aggregate function. The amended query now correctly counts unique nationalities instead of total rows, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"distinct nationalities\": count the number of unique values in the \"Nationality\" column using count(DISTINCT Nationality) instead of counting all rows. 2) When counting distinct values: include the specific column reference \"Nationality\" in the aggregate function rather than omitting it."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people;",
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ]
    },
    "523": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and descriptions of all the sections?",
        "ground_truth": "SELECT section_name ,  section_description FROM Sections",
        "amends": [
            "Do use `section_name` and `section_description` instead of `name` and `description` for column selection. Do reference the table as `Sections` instead of `sections` for proper case sensitivity. Do remove the `WHERE id > 100` filter instead of keeping it, as the right query retrieves all records without filtering. The amended query now correctly selects all section names and descriptions from the Sections table without unnecessary filtering."
        ],
        "rules": [
            "1) When answering about \"names and descriptions of all sections\": make sure the output order: section_name, section_description. 2) When the question mentions \"names\": \"names\" actually means \"section_name in schema\". 3) When the question mentions \"descriptions\": \"descriptions\" actually means \"section_description in schema\". 4) When the question asks for \"all sections\": retrieve all records without any filtering conditions. 5) When referencing the table containing sections: use the exact identifier \"Sections\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, description FROM sections WHERE id > 100;",
            "SELECT section_name, section_description FROM Sections;"
        ],
        "rule_sql": [
            "SELECT section_name, section_description FROM Sections;"
        ]
    },
    "835": {
        "db_id": "orchestra",
        "question": "Count the number of different nationalities of conductors.",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM conductor",
        "amends": [
            "Do `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do reference table `conductor` instead of `conductors` to use the correct table name. Do add the `DISTINCT` modifier instead of omitting it to ensure unique nationality counting. Do remove the asterisk wildcard instead of keeping it to specify the exact column for aggregation. The amended query now correctly counts distinct nationalities from the conductor table."
        ],
        "rules": [
            "1) When counting different nationalities of conductors: count distinct values of the \"Nationality\" column from the \"conductor\" table. 2) When the question asks for \"number of different nationalities\": use the exact column name \"Nationality\" with the DISTINCT modifier to count unique values. 3) When referencing the conductor table: use the exact table name \"conductor\" (not \"conductors\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM conductors;",
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ]
    },
    "770": {
        "db_id": "world_1",
        "question": "What is the total number of unique official languages spoken in the countries that are founded before 1930?",
        "ground_truth": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.Language` instead of `language` in the SELECT clause. Do join on `T1.Code = T2.CountryCode` instead of `countries.country_id = languages.country_id`. Do filter on `IndepYear < 1930` instead of `founded_year < 1930`. Do add the condition `T2.IsOfficial = \"T\"` instead of omitting it. The amended query now correctly counts distinct official languages for countries gaining independence before 1930, matching the intended behavior."
        ],
        "rules": [
            "1) When joining tables for countries and languages: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 2) When filtering for countries founded before 1930: use T1.IndepYear < 1930 instead of founded_year. 3) When counting official languages: only include languages where T2.IsOfficial = \"T\". 4) When counting unique languages: count distinct values of T2.Language. 5) When answering about \"total number of unique official languages\": make sure the output is a single count value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT language) FROM countries JOIN languages ON countries.country_id = languages.country_id WHERE founded_year < 1930;",
            "SELECT COUNT(DISTINCT T2.Language) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.IndepYear < 1930 \nAND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT cl.Language) \nFROM country c\nINNER JOIN countrylanguage cl ON c.Code = cl.CountryCode\nWHERE c.IndepYear < 1930 \nAND cl.IsOfficial = 'T';"
        ]
    },
    "339": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all document names using templates with template type code BK.",
        "ground_truth": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"",
        "amends": [
            "Do join `Templates AS T1` to `Documents AS T2` on `T1.template_id = T2.template_id` instead of querying only the `documents` table without any join. Do reference the column as `T2.document_name` instead of just `document_name` to specify the table source. Do filter on `T1.template_type_code = \"BK\"` instead of `template_type = 'BK'` to use the correct table and column name with proper quoting. The amended query now correctly retrieves document names by joining through the template relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"document names using templates with template type code BK\": make sure the output order: T2.document_name\n2) When combining Templates as T1 and Documents as T2 for shared entities: link rows where T1.template_id = T2.template_id and keep only matching pairs (inner match).\n3) When filtering for template type code BK: use T1.template_type_code = \"BK\" with exact double quotes around the literal value.\n4) When selecting document names: reference the column as T2.document_name to specify the table source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_name FROM documents WHERE template_type = 'BK';",
            "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID WHERE T1.Template_Type_Code = 'BK'"
        ],
        "rule_sql": [
            "SELECT T2.document_name\nFROM Templates AS T1\nINNER JOIN Documents AS T2 ON T1.template_id = T2.template_id\nWHERE T1.template_type_code = \"BK\""
        ]
    },
    "497": {
        "db_id": "battle_death",
        "question": "What are the name and results of the battles when the bulgarian commander is not 'Boril'",
        "ground_truth": "SELECT name ,  RESULT FROM battle WHERE bulgarian_commander != 'Boril'",
        "amends": [
            "Do select `RESULT` instead of `results` and use table `battle` instead of `battles`. Do change the filter to `bulgarian_commander != 'Boril'` instead of `commander = 'Boril' AND nationality = 'Bulgarian'`, removing the nationality condition entirely. The amended query now correctly excludes battles where Boril was the Bulgarian commander rather than selecting only those where he commanded with Bulgarian nationality."
        ],
        "rules": [
            "1) When the question asks for battle results: use the exact column name \"RESULT\" instead of \"results\". 2) When referring to the battles table: use the exact table name \"battle\" instead of \"battles\". 3) When filtering for Bulgarian commander not being 'Boril': use the exact condition \"bulgarian_commander != 'Boril'\" and do not include any nationality condition. 4) When selecting output columns: maintain the order \"name, RESULT\" as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, results FROM battles WHERE commander = 'Boril' AND nationality = 'Bulgarian';",
            "SELECT name, result FROM battle WHERE bulgarian_commander != 'Boril';"
        ],
        "rule_sql": [
            "SELECT name, result FROM battle WHERE bulgarian_commander != 'Boril';"
        ]
    },
    "34": {
        "db_id": "concert_singer",
        "question": "What are the names , themes , and number of singers for every concert ?",
        "ground_truth": "select t2.concert_name ,  t2.theme ,  count(*) from singer_in_concert as t1 join concert as t2 on t1.concert_id  =  t2.concert_id group by t2.concert_id",
        "amends": [
            "Do select `concert_name` and `theme` from the `concert` table instead of `name` and `theme` from an unspecified source. Do join `singer_in_concert` with `concert` on `concert_id` instead of querying only the `concerts` table. Do use `count(*)` to count all rows instead of `COUNT(singer_id)` which might miss null values. Do group by `t2.concert_id` from the joined table instead of grouping by `concert_id` from a single table. The amended query now correctly counts singers per concert by properly joining the relationship tables and grouping on the concert identifier."
        ],
        "rules": [
            "1) When answering about concert names and themes: select \"concert_name\" and \"theme\" from the \"concert\" table (T1). 2) When counting singers per concert: join \"singer_in_concert\" (T2) with \"concert\" (T1) where T1.concert_id = T2.concert_id and count all rows using count(*). 3) When grouping results by concert: group by T2.concert_id to organize results per concert. 4) When producing output columns: present them in the order concert_name, theme, number_of_singers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, theme, COUNT(singer_id) AS number_of_singers FROM concerts GROUP BY concert_id;",
            "SELECT c.concert_Name, c.Theme, COUNT(*) AS number_of_singers\nFROM concert c\nJOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID\nGROUP BY c.concert_ID, c.concert_Name, c.Theme;"
        ],
        "rule_sql": [
            "SELECT c.concert_Name, c.Theme, COUNT(sic.Singer_ID) AS number_of_singers FROM concert c LEFT JOIN singer_in_concert sic ON c.concert_ID = sic.concert_ID GROUP BY c.concert_ID ORDER BY c.concert_Name, c.Theme"
        ]
    },
    "394": {
        "db_id": "course_teach",
        "question": "For each hometown, how many teachers are there?",
        "ground_truth": "SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",
        "amends": [
            "Do reference the `teacher` table instead of `teachers` in the FROM clause. Do group by `Hometown` instead of `teacher_id` to correctly count teachers by their hometowns. Do capitalize `Hometown` in the SELECT list instead of lowercase `hometown` for consistency. The amended query now correctly counts teachers grouped by their hometown locations rather than by individual teacher IDs, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"hometown\": use the exact column token \"Hometown\" from the teacher table. 2) When counting teachers per hometown: group by \"Hometown\" and count using the canonical key for teachers (teacher_id or equivalent). 3) When the question asks \"how many teachers are there\" per group: compute the count of teachers for each hometown group. 4) When choosing table references: use the exact table name \"teacher\" as specified in the schema, not variations like \"teachers\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown, COUNT(*) FROM teachers GROUP BY teacher_id;",
            "SELECT Hometown, COUNT(*) AS teacher_count FROM teacher GROUP BY Hometown"
        ],
        "rule_sql": [
            "SELECT Hometown, COUNT(Teacher_ID) AS teacher_count FROM teacher GROUP BY Hometown"
        ]
    },
    "122": {
        "db_id": "car_1",
        "question": "What are the makers and models?",
        "ground_truth": "SELECT Maker ,  Model FROM MODEL_LIST;",
        "amends": [
            "Do select specific columns `Maker` and `Model` instead of using `*` to select all columns. Do query from table `MODEL_LIST` instead of table `products`. The amended query now correctly retrieves only the maker and model columns from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"makers and models\": make sure the output order: Maker, Model. 2) When the question mentions \"makers\": \"makers\" actually means \"Maker in table MODEL_LIST\". 3) When the question mentions \"models\": \"models\" actually means \"Model in table car_names\". 4) When selecting columns: use specific column names \"Maker\" and \"Model\" instead of using \"*\" to select all columns. 5) When querying for maker and model information: use table \"MODEL_LIST\" instead of table \"products\"."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products;",
            "SELECT Maker, Model FROM model_list"
        ],
        "rule_sql": [
            "SELECT ml.Maker, cn.Model FROM model_list ml JOIN car_names cn ON ml.Model = cn.Model ORDER BY ml.Maker, cn.Model;"
        ]
    },
    "21": {
        "db_id": "concert_singer",
        "question": "How many concerts occurred in 2014 or 2015?",
        "ground_truth": "SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015",
        "amends": [
            "Do reference table `concert` instead of `concerts` in the FROM clause. Do use consistent case for the `YEAR` column instead of lowercase `year`. The amended query now correctly references the intended table and maintains consistent column naming to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about concerts: use the exact table name \"concert\" instead of \"concerts\" as shown in the schema. 2) When referring to the year column: use the exact column name \"YEAR\" with consistent uppercase case instead of lowercase \"year\". 3) When counting concerts that occurred in specific years: count all rows from the \"concert\" table where the \"YEAR\" column equals 2014 or 2015."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE year = 2014 OR year = 2015;",
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM concert WHERE YEAR = '2014' OR YEAR = '2015';"
        ]
    },
    "791": {
        "db_id": "world_1",
        "question": "Give the name, population, and head of state for the country that has the largest area.",
        "ground_truth": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do use column `Name` instead of `name`, `HeadOfState` instead of `head_of_state`, and `SurfaceArea` instead of `area` in the ORDER BY clause, while keeping the same SELECT list structure and LIMIT 1. The amended query now correctly references the proper column names and ordering criteria to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\": use the exact column token \"Name\" from table country. 2) When the question asks for \"head of state\": use the exact column token \"HeadOfState\" from table country. 3) When the question asks for the country with \"largest area\": use the exact column token \"SurfaceArea\" for ordering in descending direction and keep only the first row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"Name\", \"HeadOfState\", and \"SurfaceArea\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, head_of_state FROM country ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \"Name\", \"Population\", \"HeadOfState\" FROM country ORDER BY \"SurfaceArea\" DESC LIMIT 1;"
        ]
    },
    "71": {
        "db_id": "pets_1",
        "question": "Find the average and maximum age for each type of pet.",
        "ground_truth": "SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",
        "amends": [
            "Do use column name `pet_age` instead of `age` in aggregate functions. Do use `max` function instead of `MIN` for maximum age calculation. Do use column name `pettype` instead of `pet_type` in both SELECT list and GROUP BY clause. Do remove the alias `average_age` instead of keeping it. Do remove the alias `max_age` instead of keeping it. The amended query now correctly calculates average and maximum pet ages grouped by pet type using the appropriate column names.",
            "Do use lowercase `avg(pet_age)` and `max(pet_age)` instead of uppercase `AVG(pet_age)` and `MAX(pet_age)`. Do place `pettype` at the end of the SELECT list instead of at the beginning. Do use lowercase `pettype` in GROUP BY instead of uppercase `PetType`. Do use lowercase table name `pets` instead of uppercase `Pets`. The amended query now matches RIGHT_SQL's behavior with identical aggregation logic and grouping."
        ],
        "rules": [
            "1) When the question asks for \"average and maximum age\": use the column name \"pet_age\" for age calculations instead of \"age\". 2) When calculating maximum age: use the max function instead of MIN function. 3) When referring to \"type of pet\" in both SELECT list and GROUP BY clause: use the exact column name \"pettype\" instead of \"pet_type\". 4) When producing output columns: do not use aliases like \"average_age\" or \"max_age\" - return the aggregate functions directly without aliases. 5) When grouping by pet type: organize results by the \"pettype\" column to compute requested aggregates per group.",
            "1) When the question asks for average and maximum age for each type of pet: compute avg(pet_age) and max(pet_age) using lowercase function names. 2) When grouping by pet type: use lowercase pettype as the grouping column. 3) When selecting columns: place pettype at the end of the output columns list after the aggregate functions. 4) When referring to the pets table: use lowercase pets as the table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, AVG(age) as average_age, MIN(age) as max_age FROM pets GROUP BY pet_type;",
            "SELECT PetType, AVG(pet_age) AS average_age, MAX(pet_age) AS max_age FROM Pets GROUP BY PetType;",
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ],
        "rule_sql": [
            "SELECT avg(pet_age), max(pet_age), pettype FROM pets GROUP BY pettype"
        ]
    },
    "317": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many templates do we have?",
        "ground_truth": "SELECT count(*) FROM Templates",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM templates;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Templates;"
        ]
    },
    "481": {
        "db_id": "wta_1",
        "question": "Find the number of matches happened in each year.",
        "ground_truth": "SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",
        "amends": [
            "Do place the aggregate function `count(*)` first in the SELECT list instead of placing `year` first. Do use uppercase `YEAR` for the column reference instead of lowercase `year` in both the SELECT list and GROUP BY clause. The amended query now correctly groups by the year column and counts matches per year, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of matches happened in each year\": make sure the output order: COUNT(*) first, then YEAR. 2) When the question mentions \"year\": \"year\" actually means \"YEAR\" in schema (uppercase). 3) When the question asks for \"count of matches\": compute the number of rows using the canonical key for matches (implied by COUNT(*)). 4) When the question says \"per year\"/\"each year\": organize results by YEAR and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) FROM matches GROUP BY year",
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR"
        ],
        "rule_sql": [
            "SELECT COUNT(*), YEAR FROM matches GROUP BY YEAR ORDER BY COUNT(*) DESC, YEAR;"
        ]
    },
    "491": {
        "db_id": "battle_death",
        "question": "How many ships ended up being 'Captured'?",
        "ground_truth": "SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured'",
        "amends": [
            "Do reference table `ship` instead of `ships` and use filter condition `disposition_of_ship = 'Captured'` instead of `status = 'Sunk'`."
        ],
        "rules": [
            "1) When the question asks about ships: use the exact table name \"ship\" instead of \"ships\". 2) When the question asks about ships that ended up being 'Captured': use the exact column name \"disposition_of_ship\" with the exact literal value 'Captured' instead of using \"status\" with 'Sunk'. 3) When counting ships: count all rows from the \"ship\" table that match the condition disposition_of_ship = 'Captured'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM ships WHERE status = 'Sunk';",
            "SELECT COUNT(*) FROM ship WHERE disposition_of_ship = 'Captured';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM ship WHERE disposition_of_ship = 'Captured';"
        ]
    },
    "282": {
        "db_id": "employee_hire_evaluation",
        "question": "What are the names of the employees who never received any evaluation?",
        "ground_truth": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "amends": [
            "Do select `name` from `employee` instead of `employees` as the table source. Do use `NOT IN` with a subquery checking `Employee_ID` in the `evaluation` table instead of filtering on `evaluation_score IS NULL`. Do remove the direct null check condition and instead implement a correlated exclusion pattern to find employees missing from the evaluation table entirely. The amended query now correctly identifies employees without any evaluation records rather than those with null scores, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for employee names who never received any evaluation: select \"name\" from table \"employee\" (T1) instead of \"employees\". 2) When checking for employees without evaluations: use a NOT IN condition with \"Employee_ID\" compared against a subquery that selects \"Employee_ID\" from table \"evaluation\" (T2). 3) When combining employee and evaluation data: link using the exact key equality \"T1.Employee_ID = T2.Employee_ID\" to find employees missing from the evaluation table entirely. 4) When filtering for employees without evaluations: do not use direct null checks on evaluation_score, instead implement a correlated exclusion pattern to identify employees with no evaluation records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees WHERE evaluation_score IS NULL;",
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ],
        "rule_sql": [
            "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"
        ]
    },
    "87": {
        "db_id": "car_1",
        "question": "How many continents are there?",
        "ground_truth": "SELECT count(*) FROM CONTINENTS;",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM continents;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM continents;"
        ]
    },
    "647": {
        "db_id": "poker_player",
        "question": "How many poker players are there?",
        "ground_truth": "SELECT count(*) FROM poker_player",
        "amends": [
            "Do reference the `poker_player` table instead of the `players` table. Do remove the `WHERE game_type = 'blackjack'` filter instead of keeping it. The amended query now correctly counts all records in the poker_player table without any filtering conditions."
        ],
        "rules": [
            "1) When answering about \"how many poker players\": use the \"poker_player\" table instead of the \"players\" table. 2) When counting poker players: count all records in the \"poker_player\" table without any filtering conditions. 3) When the question asks for count of poker players: remove any WHERE clause that filters by game_type = 'blackjack'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE game_type = 'blackjack';",
            "SELECT COUNT(*) FROM poker_player;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM poker_player;"
        ]
    },
    "926": {
        "db_id": "dog_kennels",
        "question": "Which first names are used for professionals or owners but are not used as dog names?",
        "ground_truth": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name \nFROM professionals \nWHERE first_name NOT IN (SELECT name FROM dogs)\nUNION\nSELECT DISTINCT first_name \nFROM owners \nWHERE first_name NOT IN (SELECT name FROM dogs);"
        ],
        "rule_sql": [
            "SELECT DISTINCT first_name \nFROM (\n    SELECT first_name FROM Professionals\n    UNION \n    SELECT first_name FROM Owners\n) \nWHERE first_name NOT IN (SELECT name FROM Dogs WHERE name IS NOT NULL)"
        ]
    },
    "666": {
        "db_id": "poker_player",
        "question": "Return the birth date of the poker player with the lowest earnings.",
        "ground_truth": "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1",
        "amends": [
            "Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only `poker_players` table. Do select `T1.Birth_Date` from the joined people table instead of `birth_date` from the poker_players table. Do order by `T2.Earnings` from the joined poker_player table instead of `earnings` from the poker_players table. The amended query now correctly retrieves birth dates by joining related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the poker player with the lowest earnings\": join table \"people AS T1\" with table \"poker_player AS T2\" where T1.People_ID equals T2.People_ID to combine player information with earnings data. 2) When selecting the birth date: use T1.Birth_Date from the people table instead of birth_date from poker_players table. 3) When ordering by earnings to find the lowest: use T2.Earnings from the poker_player table in ascending order to identify the player with minimum earnings. 4) When combining tables for shared entities: link rows where T1.People_ID = T2.People_ID exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_date FROM poker_players ORDER BY earnings ASC LIMIT 1;",
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1;"
        ]
    },
    "613": {
        "db_id": "tvshow",
        "question": "List the Episode of all TV series sorted by rating.",
        "ground_truth": "SELECT Episode FROM TV_series ORDER BY rating",
        "amends": [
            "Do select specific column `Episode` instead of all columns `*` from the `TV_series` table instead of the `episodes` table. Do order by `rating` in ascending order instead of descending order. The amended query now correctly retrieves only the Episode column from the TV_series table sorted by rating in ascending order."
        ],
        "rules": [
            "1) When answering about \"List the Episode of all TV series sorted by rating\": make sure the output order: \"Episode\" only. 2) When selecting from the TV series data: use table \"TV_series\" instead of \"episodes\". 3) When ordering by rating: sort in ascending order instead of descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM episodes ORDER BY rating DESC;",
            "SELECT Episode FROM TV_series ORDER BY Rating ASC;"
        ],
        "rule_sql": [
            "SELECT Episode FROM TV_series ORDER BY Rating ASC;"
        ]
    },
    "36": {
        "db_id": "concert_singer",
        "question": "What are the names of the singers and number of concerts for each person?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
        "amends": [
            "Do join `singer_in_concert` and `singer` tables with `JOIN` on `T1.singer_id = T2.singer_id` instead of querying only the `singers` table. Do select from `singer_in_concert AS T1` and `singer AS T2` instead of the single `singers` table. Do group by `T2.singer_id` instead of `name` to ensure proper aggregation. Do reference `T2.name` in the SELECT list instead of just `name` to make the column reference explicit. The amended query now correctly counts concert appearances per singer by joining the relevant tables and grouping by singer ID instead of name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of singers and number of concerts for each person\": make sure the output order: T2.name, COUNT(*) 2) When combining T1 and T2 for shared entities: link rows where T1.singer_id = T2.singer_id exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question asks for \"number of concerts for each person\": compute the count using the canonical key T1.singer_id from the singer_in_concert table. 4) When the question says \"per person\"/\"for each person\": organize results by T2.singer_id and compute requested aggregates per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table names like \"singer_in_concert\" and \"singer\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM singers GROUP BY name;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS Number_of_Concerts\nFROM singer_in_concert AS T1\nJOIN singer AS T2 ON T1.Singer_ID = T2.Singer_ID\nGROUP BY T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT s.\"Name\", COUNT(*) \nFROM \"singer_in_concert\" sic\nJOIN \"singer\" s ON sic.\"Singer_ID\" = s.\"Singer_ID\"\nGROUP BY s.\"Singer_ID\", s.\"Name\"\nORDER BY s.\"Name\", COUNT(*)"
        ]
    },
    "304": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the document id, template id, and description for the document with the name Robbin CV.",
        "ground_truth": "SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  \"Robbin CV\"",
        "amends": [
            "Do reference `Document_Description` instead of `description` in the SELECT list. Do filter on `document_name = \"Robbin CV\"` instead of `name = 'Robbin CV'` in the WHERE clause. Do use table name `Documents` instead of `documents` and double quotes instead of single quotes for the string literal. The amended query now correctly references the actual column names and table name to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for document description: use the exact column name \"Document_Description\" instead of \"description\". 2) When filtering by document name: use the exact column name \"document_name\" and the exact literal value \"Robbin CV\" with double quotes. 3) When referencing the documents table: use the exact table name \"Documents\" with proper capitalization. 4) When answering about document details: make sure the output order is document_id, template_id, Document_Description."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id, template_id, description FROM documents WHERE name = 'Robbin CV';",
            "SELECT Document_ID, Template_ID, Document_Description FROM Documents WHERE Document_Name = \"Robbin CV\""
        ],
        "rule_sql": [
            "SELECT document_id, template_id, Document_Description FROM Documents WHERE document_name = \"Robbin CV\""
        ]
    },
    "376": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id of the document with the fewest paragraphs.",
        "ground_truth": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
        "amends": [
            "Do select `document_id` from the `Paragraphs` table instead of `id` from `documents`. Do use `GROUP BY document_id` with aggregation instead of selecting from a single table. Do order by `count(*) ASC` instead of `paragraphs DESC` to find the document with the fewest paragraphs. Do remove the incorrect column reference `paragraphs` and instead use the proper aggregate function to count paragraphs per document. The amended query now correctly identifies the document with the smallest number of paragraphs by counting and grouping, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the document with the fewest paragraphs\": make sure the output order: document_id. 2) When counting paragraphs per document: group by \"document_id\" and compute count(*) for each group. 3) When finding the document with the fewest paragraphs: order the results by count(*) in ascending order and keep only the first row. 4) When selecting from the Paragraphs table: use \"document_id\" as the output column instead of \"id\" from documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM documents ORDER BY paragraphs DESC LIMIT 1;",
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY COUNT(*) ASC LIMIT 1;"
        ]
    },
    "411": {
        "db_id": "museum_visit",
        "question": "How many visitors below age 30 are there?",
        "ground_truth": "SELECT count(*) FROM visitor WHERE age  <  30",
        "amends": [
            "Do reference table `visitor` instead of `visitors` to use the correct table name. Do use filter `age < 30` instead of `age > 30` to count visitors under 30 rather than over 30. The amended query now correctly counts visitors under age 30 from the proper table."
        ],
        "rules": [
            "1) When the question asks about \"visitors\": use the exact table name \"visitor\" from the schema. 2) When the question asks for visitors \"below age 30\": filter rows where the age column value is less than 30 (age < 30). 3) When the question asks for \"how many visitors\": count the number of rows that satisfy the age condition using the canonical counting method."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM visitors WHERE age > 30;",
            "SELECT COUNT(*) FROM visitor WHERE Age < 30"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM visitor WHERE Age < 30"
        ]
    },
    "575": {
        "db_id": "student_transcripts_tracking",
        "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
        "ground_truth": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "amends": [
            "Do use `DISTINCT T2.semester_id` from `Student_Enrolment` instead of `semester` from `students`. Do join `Degree_Programs AS T1` with `Student_Enrolment AS T2` on `T1.degree_program_id = T2.degree_program_id` instead of querying a single `students` table. Do filter with `degree_summary_name = 'Master'` and `degree_summary_name = 'Bachelor'` in separate queries instead of contradictory `degree = 'Master' AND degree = 'Bachelor'`. Do use `INTERSECT` to find common semesters instead of attempting to find rows that satisfy both degree conditions simultaneously. Do remove the impossible WHERE condition and instead use set intersection to properly identify semesters that contain both Master and Bachelor students. The amended query now correctly identifies semesters where both degree programs are offered by using proper table relationships and set operations."
        ],
        "rules": [
            "1) When answering about semesters where both Master and Bachelor students enrolled: use DISTINCT T2.semester_id from Student_Enrolment table instead of semester from students table. 2) When combining Degree_Programs and Student_Enrolment tables: link rows where T1.degree_program_id = T2.degree_program_id and keep only matching pairs (inner match). 3) When filtering for Master students: use condition degree_summary_name = 'Master' with exact case and spacing. 4) When filtering for Bachelor students: use condition degree_summary_name = 'Bachelor' with exact case and spacing. 5) When finding semesters with both degree programs: use INTERSECT operation between the Master student results and Bachelor student results instead of trying to satisfy both conditions in a single WHERE clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester FROM students WHERE degree = 'Master' AND degree = 'Bachelor';",
            "SELECT DISTINCT T2.semester_id\nFROM Student_Enrolment AS T2\nJOIN Degree_Programs AS T1 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Student_Enrolment AS T2\nJOIN Degree_Programs AS T1 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Master'\nINTERSECT\nSELECT DISTINCT T2.semester_id\nFROM Degree_Programs T1\nINNER JOIN Student_Enrolment T2 ON T1.degree_program_id = T2.degree_program_id\nWHERE T1.degree_summary_name = 'Bachelor'"
        ]
    },
    "51": {
        "db_id": "pets_1",
        "question": "Find number of pets owned by students who are older than 20.",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
        "amends": [
            "Do add `student AS T1 JOIN has_pet AS T2 ON T1.stuid = T2.stuid` as the FROM source instead of just `pets`. Do change the WHERE filter to `T1.age > 20` instead of `student_age > 20` to reference the correct table and column. The amended query now correctly joins the student and has_pet tables and filters on student age, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of pets owned by students who are older than 20\": make sure the output order: COUNT(*) 2) When the question mentions \"students who are older than 20\": \"older than 20\" actually means \"T1.age > 20\" in schema 3) When combining T1 (student) and T2 (has_pet) for shared entities: link rows where T1.stuid = T2.stuid; keep only matching pairs (inner match) 4) When the question asks for \"number of pets\": compute the number of rows using the canonical key token for pets (T2.stuid or T2.petid, though the amends suggest counting all joined rows)"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets WHERE student_age > 20",
            "SELECT COUNT(*) AS number_of_pets\nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student T1\nINNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID\nWHERE T1.Age > 20"
        ]
    },
    "401": {
        "db_id": "course_teach",
        "question": "Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do join `course_arrange AS T1` with `course AS T2` on `T1.Course_ID = T2.Course_ID` and join `teacher AS T3` on `T1.Teacher_ID = T3.Teacher_ID` instead of querying only from `teachers`. Do order by `T3.Name` instead of `course_name`. The amended query now correctly joins multiple tables to retrieve teacher names and course names with proper relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting teacher names and course names: use \"T3.Name\" for teacher names and \"T2.Course\" for course names instead of generic column names. 2) When combining course arrangement, course, and teacher information: link \"course_arrange AS T1\" with \"course AS T2\" where \"T1.Course_ID = T2.Course_ID\" and link with \"teacher AS T3\" where \"T1.Teacher_ID = T3.Teacher_ID\", keeping only matching pairs from all three tables. 3) When ordering results alphabetically by teacher name: sort by \"T3.Name\" in ascending order instead of sorting by course name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers ORDER BY course_name ASC;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC;"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC"
        ]
    },
    "403": {
        "db_id": "course_teach",
        "question": "Show the name of the teacher for the math course.",
        "ground_truth": "SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  \"Math\"",
        "amends": [
            "Do select `T3.Name` from the `teacher` table instead of `teacher_name` from `courses`. Do join three tables using `course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of querying only the `courses` table. Do filter on `T2.Course = \"Math\"` instead of `subject = 'math'` to properly reference the course name field. The amended query now correctly joins the necessary tables to retrieve teacher names for math courses, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"teacher for the math course\": make sure the output order: T3.Name. 2) When the question mentions \"teacher\": \"teacher\" actually means \"T3.Name in schema\". 3) When the question mentions \"math course\": \"math course\" actually means \"T2.Course = 'Math' in schema\". 4) When combining T1, T2, and T3 for shared entities: link rows where T1.Course_ID = T2.Course_ID and T1.Teacher_ID = T3.Teacher_ID; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation - use exact literal 'Math'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name FROM courses WHERE subject = 'math';",
            "SELECT T3.Name \nFROM course_arrange AS T1 \nJOIN course AS T2 ON T1.Course_ID = T2.Course_ID \nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID \nWHERE T2.Course = 'Math'"
        ],
        "rule_sql": [
            "SELECT T3.\"Name\" FROM course_arrange T1 JOIN course T2 ON T1.\"Course_ID\" = T2.\"Course_ID\" JOIN teacher T3 ON T1.\"Teacher_ID\" = T3.\"Teacher_ID\" WHERE T2.\"Course\" = 'Math'"
        ]
    },
    "570": {
        "db_id": "student_transcripts_tracking",
        "question": "When was the last transcript released?",
        "ground_truth": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1",
        "amends": [
            "Do select `transcript_date` instead of `MAX(release_date)` and remove the aggregate function. Do use `FROM Transcripts` instead of `FROM transcripts` with proper table name casing. Do remove the `WHERE release_date > CURRENT_DATE` filter instead of keeping it since it incorrectly excludes all past records. Do add `ORDER BY transcript_date DESC LIMIT 1` instead of omitting ordering and limiting, which provides the most recent transcript date directly rather than attempting to find a maximum future date that doesn't exist. The amended query now correctly retrieves the latest transcript date from the table instead of looking for non-existent future dates."
        ],
        "rules": [
            "1) When answering about \"last transcript released\": make sure the output order: transcript_date. 2) When the question asks for the most recent date: use ORDER BY transcript_date DESC LIMIT 1 to get the single latest date. 3) When selecting from the Transcripts table: use the exact table name \"Transcripts\" with proper casing. 4) When retrieving transcript dates: select the column \"transcript_date\" directly without aggregate functions. 5) When finding the latest transcript: do not apply filters that exclude past records like WHERE release_date > CURRENT_DATE."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(release_date) FROM transcripts WHERE release_date > CURRENT_DATE;",
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1;"
        ]
    },
    "896": {
        "db_id": "network_1",
        "question": "Show names of all high school students who do not have any friends.",
        "ground_truth": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "amends": [
            "Do use `EXCEPT` set operation instead of filtering with `WHERE` conditions. Do change the data source to `Highschooler` instead of `students`. Do remove the `grade` filter condition instead of keeping it. Do remove the `friend_count` filter condition instead of keeping it. Do add a subquery with `JOIN` between `Friend` and `Highschooler` tables instead of omitting the friend relationship check. Do use `ON T1.student_id = T2.id` for the join condition instead of the previous filtering approach. The amended query now correctly identifies high school students without friends by using set operations rather than direct filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"high school students who do not have any friends\": use the table \"Highschooler\" as the main data source instead of \"students\". 2) When checking for students without friends: use an EXCEPT set operation to remove students who have friends rather than filtering with friend_count = 0. 3) When identifying high school students: do not filter by grade condition since the question asks for all high school students. 4) When checking friendship relationships: join the Friend table with Highschooler using the condition T1.student_id = T2.id to identify students who have friends. 5) When producing output: return only the name column from Highschooler for students who remain after excluding those with friends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE grade = 'High School' AND friend_count = 0;",
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT H.name \nFROM Highschooler H\nJOIN Friend F ON H.ID = F.student_id"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler\nEXCEPT\nSELECT H.name FROM Highschooler H\nJOIN Friend F ON H.ID = F.student_id"
        ]
    },
    "204": {
        "db_id": "flight_2",
        "question": "Count the number of flights departing from 'APG'.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference `SourceAirport` column instead of `destination` column in the WHERE filter. Do use double quotes around the literal value \"APG\" instead of single quotes. Do maintain the same aggregate function `count(*)` and table source `FLIGHTS` while correcting the column reference to match the intended logic of counting flights departing from APG rather than arriving at APG, ensuring the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting flights departing from a specific airport: use the \"SourceAirport\" column instead of \"destination\" column to filter for departure airports. 2) When using the literal value \"APG\": use double quotes around the literal value exactly as \"APG\" instead of single quotes. 3) When counting flights: maintain the count(*) aggregate function and table source FLIGHTS while ensuring the column reference matches the intended logic of counting flights departing from rather than arriving at the specified airport."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'APG';",
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ]
    },
    "203": {
        "db_id": "flight_2",
        "question": "How many flights depart from 'APG'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference `SourceAirport` instead of `arrival_airport` in the WHERE filter, and use double quotes instead of single quotes for the string literal value 'APG'. The amended query now correctly counts flights departing from APG airport instead of arriving at APG, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about flights departing from an airport: use the column \"SourceAirport\" from the flights table to identify departure airports. 2) When filtering for a specific airport code like 'APG': use double quotes around the literal value exactly as 'APG' (not single quotes). 3) When counting flights: count the number of rows in the flights table that match the departure condition using the canonical key from the flights table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE arrival_airport = 'APG';",
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights WHERE SourceAirport = 'APG'"
        ]
    },
    "690": {
        "db_id": "voter_1",
        "question": "What are the maximum and minimum values of area codes?",
        "ground_truth": "SELECT max(area_code) ,  min(area_code) FROM area_code_state",
        "amends": [
            "Do reference the `area_code_state` table instead of the `customers` table to ensure the correct data source for area code statistics. The amended query now correctly aggregates area codes from the appropriate table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about maximum and minimum values of area codes: use the \"area_code_state\" table as the data source instead of the \"customers\" table. 2) When computing maximum and minimum values of area codes: aggregate the \"area_code\" column from the \"area_code_state\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(area_code), MIN(area_code) FROM customers;",
            "SELECT MAX(area_code) AS max_area_code, MIN(area_code) AS min_area_code FROM AREA_CODE_STATE"
        ],
        "rule_sql": [
            "SELECT MAX(area_code) AS max_area_code, MIN(area_code) AS min_area_code FROM AREA_CODE_STATE"
        ]
    },
    "473": {
        "db_id": "wta_1",
        "question": "find the number of players for each country.",
        "ground_truth": "SELECT count(*) ,  country_code FROM players GROUP BY country_code",
        "amends": [
            "Do use `country_code` instead of `country` in both the SELECT list and GROUP BY clause. Do place the aggregate function `count(*)` first in the SELECT list instead of second. The amended query now correctly groups by and selects the country_code column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"number of players for each country\": use \"country_code\" instead of \"country\" in both the output and grouping. 2) When counting players: place the count result first in the output order before the country_code. 3) When grouping by country: use the exact column token \"country_code\" for grouping and output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM players GROUP BY country;",
            "SELECT count(*) as player_count, country_code FROM players GROUP BY country_code;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS count, country_code FROM players GROUP BY country_code ORDER BY count DESC;"
        ]
    },
    "904": {
        "db_id": "network_1",
        "question": "Show the names of high schoolers who have likes, and numbers of likes for each.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do use `T2.name` instead of `name` to explicitly reference the joined table's column. Do join `Likes AS T1` to `Highschooler AS T2` instead of joining `Highschooler` to `Likes` to establish the correct table relationship direction. Do use the join condition `T1.student_id = T2.id` instead of `Highschooler.id = Likes.student_id` to properly match the student ID from Likes to the ID in Highschooler. Do group by `T1.student_id` instead of `name` to ensure accurate count aggregation per student rather than potentially grouping by duplicate names. The amended query now correctly counts likes per student while properly handling the table relationships."
        ],
        "rules": [
            "1) When joining tables for high schoolers who have likes: link rows where T1.student_id = T2.id to match student IDs from Likes to IDs in Highschooler, keeping only matching pairs (inner match). 2) When counting likes per student: group by T1.student_id to ensure accurate count aggregation per individual student rather than by potentially duplicate names. 3) When selecting student names: use T2.name to explicitly reference the name column from the Highschooler table. 4) When the question asks for numbers of likes for each high schooler: count the number of likes using the student_id from the Likes table as the counting key."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM Highschooler JOIN Likes ON Highschooler.id = Likes.student_id GROUP BY name",
            "SELECT T2.name, COUNT(*) AS number_of_likes\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(T1.student_id) AS number_of_likes\nFROM Likes T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ]
    },
    "871": {
        "db_id": "network_1",
        "question": "What are the names of all high schoolers in grade 10?",
        "ground_truth": "SELECT name FROM Highschooler WHERE grade  =  10",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table. Do remove the `school_type = 'college'` filter instead of keeping it, as high school students should not be filtered by college type. The amended query now correctly selects names from the Highschooler table for 10th grade students without the inappropriate college filter."
        ],
        "rules": [
            "1) When answering about high schoolers in grade 10: use the \"Highschooler\" table instead of the \"students\" table. 2) When filtering for grade 10: use the condition grade = 10. 3) When the question asks for high schoolers: do not apply any school_type filter, especially not school_type = 'college'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students WHERE grade = 10 AND school_type = 'college';",
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ],
        "rule_sql": [
            "SELECT name FROM Highschooler WHERE grade = 10;"
        ]
    },
    "238": {
        "db_id": "flight_2",
        "question": "Which airlines have departing flights from both APG and CVO airports?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "amends": [
            "Do use `INTERSECT` to find airlines serving both airports instead of joining the same table twice with different conditions. Do select `T1.Airline` instead of `a.name` and use proper table aliases `T1` and `T2` instead of `a`, `f1`, and `f2`. Do join on `T1.uid = T2.Airline` instead of `a.id = f1.airline_id` and use `T2.SourceAirport` instead of `f1.departure_airport`. Do remove the `DISTINCT` modifier since `INTERSECT` inherently returns unique results instead of keeping it. Do use double quotes around airport codes \"APG\" and \"CVO\" instead of single quotes. The amended query now correctly identifies airlines that serve both specified airports using set intersection logic."
        ],
        "rules": [
            "1) When answering about airlines with departing flights from both APG and CVO airports: use INTERSECT logic to find airlines serving both airports instead of joining the same table twice. 2) When selecting airline names: use T1.Airline instead of a.name. 3) When combining airline and flight information: link rows where T1.uid = T2.Airline. 4) When filtering by departure airport: use T2.SourceAirport instead of departure_airport. 5) When specifying airport codes: use double quotes around \"APG\" and \"CVO\" instead of single quotes. 6) When returning unique results: remove DISTINCT modifier since INTERSECT inherently returns unique results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM airlines a \nJOIN flights f1 ON a.id = f1.airline_id \nJOIN flights f2 ON a.id = f2.airline_id \nWHERE f1.departure_airport = 'APG' AND f2.departure_airport = 'CVO';",
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"APG\" INTERSECT SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"CVO\""
        ],
        "rule_sql": [
            "SELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"APG\"\nINTERSECT\nSELECT T1.Airline\nFROM airlines T1\nJOIN flights T2 ON T1.uid = T2.Airline\nWHERE T2.SourceAirport = \"CVO\""
        ]
    },
    "884": {
        "db_id": "network_1",
        "question": "Show the names of high school students and their corresponding number of friends.",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do select `T2.name` instead of `name` and maintain `count(*)` without change. Do use `FROM Friend AS T1 JOIN Highschooler AS T2` instead of `FROM students` with a single table. Do apply join condition `ON T1.student_id = T2.id` instead of a simple `WHERE grade = 'High School'` filter. Do group by `T1.student_id` instead of `name` to ensure proper aggregation. The amended query now correctly joins the Friend and Highschooler tables to count friends per student while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"high school students\": use the \"Highschooler\" table (aliased as T2) to get student information. 2) When combining Friend and Highschooler tables: link rows where T1.student_id = T2.id and keep only matching pairs (inner match). 3) When counting \"number of friends\": count all rows per student using T1.student_id as the grouping key. 4) When selecting output columns: include T2.name and the count of friends, maintaining this exact output order. 5) When grouping for aggregation: group by T1.student_id to ensure proper counting of friends per student."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM students WHERE grade = 'High School' GROUP BY name;",
            "SELECT T2.name, COUNT(*) \nFROM Friend AS T1 \nJOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) AS number_of_friends\nFROM Friend T1\nINNER JOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY T1.student_id;"
        ]
    },
    "98": {
        "db_id": "car_1",
        "question": "What is the model for the car with a weight smaller than the average?",
        "ground_truth": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)",
        "amends": [
            "Do select `T1.model` from the `CAR_NAMES` table instead of `model` from the `cars` table. Do join `CARS_DATA AS T2` with `T1.MakeId = T2.Id` instead of querying a single table. Do use `T2.Weight <` instead of `weight >` for the comparison. Do reference `CARS_DATA` in the subquery instead of `cars`. Do add proper table aliases and join conditions instead of assuming a single table structure. The amended query now correctly joins the car names with car data and uses the proper comparison logic to find models with below-average weight."
        ],
        "rules": [
            "1) When selecting car model information: use \"T1.model\" from the \"CAR_NAMES\" table instead of \"model\" from a generic \"cars\" table. 2) When combining car name and car data information: join \"CAR_NAMES\" as T1 with \"CARS_DATA\" as T2 using the condition T1.MakeId = T2.Id to link the tables correctly. 3) When comparing car weight to average weight: use T2.Weight < (subquery result) instead of weight > to find cars with below-average weight. 4) When computing average weight in a subquery: reference the \"CARS_DATA\" table instead of a generic \"cars\" table to ensure proper data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE weight > (SELECT AVG(weight) FROM cars);",
            "SELECT T1.Model \nFROM car_names AS T1\nJOIN cars_data AS T2 ON T1.MakeId = T2.Id\nWHERE T2.Weight < (SELECT AVG(Weight) FROM cars_data)"
        ],
        "rule_sql": [
            "SELECT T1.Model FROM CAR_NAMES T1 JOIN CARS_DATA T2 ON T1.MakeId = T2.Id WHERE T2.Weight < (SELECT AVG(Weight) FROM CARS_DATA)"
        ]
    }
}