{
    "355": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the template ids with template type description \"Presentation\".",
        "ground_truth": "SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  \"Presentation\"",
        "amends": [
            "Do join `Ref_template_types AS T1` and `Templates AS T2` instead of querying only `templates` table. Do use `T1.template_type_code = T2.template_type_code` join condition instead of no join. Do filter on `T1.template_type_description = \"Presentation\"` instead of `template_type = 'Presentation'`. Do select `T2.template_id` with table alias instead of just `template_id`. The amended query now correctly joins reference tables to resolve template types by description rather than relying on direct column matching."
        ],
        "rules": [
            "1) When the question asks for template ids with template type description \"Presentation\": join Ref_template_types AS T1 and Templates AS T2 using T1.template_type_code = T2.template_type_code. 2) When filtering for template type description: use T1.template_type_description = \"Presentation\" exactly as specified. 3) When selecting template ids: use T2.template_id with the table alias to specify the source table. 4) When combining T1 and T2: perform an inner match where T1.template_type_code equals T2.template_type_code to link template types with their corresponding templates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id FROM templates WHERE template_type = 'Presentation'",
            "SELECT T2.Template_ID \nFROM Ref_Template_Types AS T1 \nJOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code \nWHERE T1.Template_Type_Description = 'Presentation'"
        ],
        "rule_sql": [
            "SELECT T2.Template_ID\nFROM Ref_Template_Types AS T1\nINNER JOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code\nWHERE T1.Template_Type_Description = \"Presentation\""
        ]
    },
    "2": {
        "db_id": "concert_singer",
        "question": "Show name, country, age for all singers ordered by age from the oldest to the youngest.",
        "ground_truth": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use `ORDER BY age DESC` instead of `ORDER BY age ASC` to sort in descending order rather than ascending. The amended query now correctly references the intended table and sorts the results by age in descending order as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks about singers: use the exact table name \"singer\" instead of \"singers\". 2) When ordering by age from oldest to youngest: sort by \"age\" in descending order (DESC) instead of ascending order (ASC)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country, age FROM singers ORDER BY age ASC;",
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ]
    },
    "723": {
        "db_id": "world_1",
        "question": "How many people live in Asia, and what is the largest GNP among them?",
        "ground_truth": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
        "amends": [
            "Do use `sum(Population)` instead of `COUNT(*)` to calculate total population instead of counting rows. Do reference `Continent` instead of `continent` for case-sensitive column name matching. Do use double quotes `\"Asia\"` instead of single quotes `'Asia'` for string literal syntax. Do remove the `AS population` and `AS largest_gnp` aliases instead of keeping them. The amended query now correctly sums population values and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When calculating total population: use sum(Population) instead of counting rows with COUNT(*). 2) When referencing the continent column: use exact case-sensitive identifier \"Continent\" instead of \"continent\". 3) When using string literals for continent values: use double quotes \"Asia\" instead of single quotes 'Asia'. 4) When producing output columns: do not include AS aliases like \"AS population\" or \"AS largest_gnp\" in the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS population, MAX(GNP) AS largest_gnp FROM country WHERE continent = 'Asia';",
            "SELECT SUM(country.Population), MAX(country.GNP) FROM country WHERE country.Continent = \"Asia\""
        ],
        "rule_sql": [
            "SELECT SUM(country.Population), MAX(country.GNP) FROM country WHERE country.Continent = \"Asia\";"
        ]
    },
    "672": {
        "db_id": "poker_player",
        "question": "Return the names of poker players sorted by their earnings descending.",
        "ground_truth": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC",
        "amends": [
            "Do select `T1.Name` from the `people` table instead of `name` from `poker_players`. Do join `people AS T1` with `poker_player AS T2` on `T1.People_ID = T2.People_ID` instead of querying only the `poker_players` table. Do order by `T2.Earnings DESC` instead of `earnings ASC` to sort in descending order. The amended query now correctly retrieves player names from the people table joined with poker player data and sorts by earnings in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about poker player names: select \"T1.Name\" from the \"people\" table instead of \"name\" from \"poker_players\". 2) When combining people and poker player data: join \"people AS T1\" with \"poker_player AS T2\" on \"T1.People_ID = T2.People_ID\" using exact key equality and keep only matching pairs. 3) When sorting by earnings: order by \"T2.Earnings DESC\" instead of ascending to sort in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM poker_players ORDER BY earnings ASC;",
            "SELECT T1.Name \nFROM people AS T1\nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID\nORDER BY T2.Earnings DESC"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
        ]
    },
    "319": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show template ids, version numbers, and template type codes for all templates.",
        "ground_truth": "SELECT template_id ,  version_number ,  template_type_code FROM Templates",
        "amends": [
            "Do add `template_type_code` to the SELECT list instead of omitting it. Do capitalize the table name `Templates` instead of using lowercase `templates`. The amended query now correctly includes all required columns and uses proper table naming conventions."
        ],
        "rules": [
            "1) When the question asks for template ids, version numbers, and template type codes: include \"template_id\", \"version_number\", and \"template_type_code\" in the output columns. 2) When referring to the templates table: use the exact table name \"Templates\" with capital T instead of lowercase \"templates\". 3) When answering about all templates: make sure the output order includes template_id, version_number, and template_type_code as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id, version_number FROM templates;",
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT Template_ID, Version_Number, Template_Type_Code FROM Templates ORDER BY Template_ID, Version_Number, Template_Type_Code;"
        ]
    },
    "508": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first and second line for all addresses?",
        "ground_truth": "SELECT line_1 ,  line_2 FROM addresses",
        "amends": [
            "Do select `line_1` and `line_2` instead of `first_line` and `second_line` to use the correct column names from the addresses table schema. Do maintain the same WHERE filter condition `id = 1 OR id = 2` to retrieve the specific address records. The amended query now correctly references the actual column names while preserving the same record selection behavior.",
            "Do use lowercase `addresses` instead of uppercase `Addresses` for the table name. Do remove the `WHERE address_id = 1 OR address_id = 2` filter instead of keeping it, as the right query selects all records from the addresses table without any filtering conditions. The amended query now matches RIGHT_SQL's behavior by returning all address lines without restrictions."
        ],
        "rules": [
            "1) When the question mentions \"first line\" for addresses: use the exact column name \"line_1\" from the addresses table. 2) When the question mentions \"second line\" for addresses: use the exact column name \"line_2\" from the addresses table. 3) When the question asks for specific address records with IDs 1 and 2: maintain the filter condition id = 1 OR id = 2 to retrieve only those specific records.",
            "1) When referring to the addresses table: use lowercase \"addresses\" instead of uppercase \"Addresses\" for the table name. 2) When the question asks for all addresses without filtering conditions: do not apply any WHERE clause filters like \"address_id = 1 OR address_id = 2\" and return all records from the addresses table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_line, second_line FROM addresses WHERE id = 1 OR id = 2;",
            "SELECT line_1, line_2 FROM Addresses WHERE address_id = 1 OR address_id = 2",
            "SELECT line_1, line_2 FROM addresses"
        ],
        "rule_sql": [
            "SELECT line_1, line_2 FROM addresses;"
        ]
    },
    "494": {
        "db_id": "battle_death",
        "question": "What is maximum and minimum death toll caused each time?",
        "ground_truth": "SELECT max(killed) ,  min(killed) FROM death",
        "amends": [
            "Do reference `max(killed)` and `min(killed)` instead of `MAX(death_toll)` and `MIN(death_toll)` for the aggregate functions. Do query from table `death` instead of table `events` as the data source. Do remove the `GROUP BY event_id` clause instead of including it, as the query should return overall maximum and minimum values rather than per-event aggregates. The amended query now correctly calculates the global maximum and minimum killed values from the death table without unnecessary grouping."
        ],
        "rules": [
            "1) When the question asks for maximum and minimum death toll: use \"max(killed)\" and \"min(killed)\" as the aggregate functions instead of \"MAX(death_toll)\" and \"MIN(death_toll)\". 2) When querying for death toll information: use the \"death\" table as the data source instead of the \"events\" table. 3) When calculating overall maximum and minimum values: do not include any GROUP BY clause, as the aggregates should be computed across all rows rather than per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(death_toll), MIN(death_toll) FROM events GROUP BY event_id;",
            "SELECT MAX(killed) AS max_death_toll, MIN(killed) AS min_death_toll FROM death;"
        ],
        "rule_sql": [
            "SELECT MAX(killed) AS max_death_toll, MIN(killed) AS min_death_toll FROM death;"
        ]
    },
    "747": {
        "db_id": "world_1",
        "question": "Give the names of nations that speak both English and French.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "amends": [
            "Do use `INTERSECT` to find countries that speak both English and French instead of using `OR` which finds countries that speak either language. Do join `country` table as `T1` with `countrylanguage` as `T2` on `T1.Code = T2.CountryCode` instead of joining `nations` with `languages` twice on `n.id = l1.nation_id` and `n.id = l2.nation_id`. Do filter for `T2.Language = \"English\"` in the first branch and `T2.Language = \"French\"` in the second branch instead of using `WHERE l1.language = 'English' OR l2.language = 'French'`. Do select `T1.Name` from the `country` table instead of `n.name` from `nations`. The amended query now correctly identifies countries that speak both English and French by using intersection logic instead of union logic."
        ],
        "rules": [
            "1) When answering about \"nations that speak both English and French\": use the INTERSECT operation to find countries that speak both languages instead of using OR which finds countries that speak either language. 2) When combining country and countrylanguage tables: join T1 (country) with T2 (countrylanguage) on T1.Code = T2.CountryCode. 3) When filtering for English language: use T2.Language = \"English\" exactly as specified. 4) When filtering for French language: use T2.Language = \"French\" exactly as specified. 5) When selecting output: use T1.Name from the country table instead of n.name from nations. 6) When finding countries that speak both languages: use intersection logic with two separate queries - one for English speakers and one for French speakers - then intersect the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT n.name \nFROM nations n\nJOIN languages l1 ON n.id = l1.nation_id\nJOIN languages l2 ON n.id = l2.nation_id\nWHERE l1.language = 'English' OR l2.language = 'French';",
            "SELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French'"
        ]
    },
    "544": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name of the semester with no students enrolled?",
        "ground_truth": "SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )",
        "amends": [
            "Do select `semester_name` instead of `name` and change the table reference to `Semesters` instead of `semesters`. Do use a `NOT IN` subquery condition with `semester_id` instead of a direct `student_count = 0` filter. Do add a subquery that references `Student_Enrolment` table to check for enrollment existence instead of relying on a potentially incorrect count column. The amended query now correctly identifies semesters without any student enrollments by checking against the enrollment records rather than using a count that may not be properly maintained."
        ],
        "rules": [
            "1) When the question asks for the name of a semester: select \"semester_name\" from the \"Semesters\" table instead of \"name\". 2) When identifying semesters with no students enrolled: use a NOT IN condition with \"semester_id\" against the \"Student_Enrolment\" table rather than checking a student_count column. 3) When checking for enrollment existence: reference the \"Student_Enrolment\" table to verify that no records exist for a given semester_id, ensuring accurate identification of semesters without enrollments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM semesters WHERE student_count = 0;",
            "SELECT semester_name \nFROM Semesters \nWHERE semester_id NOT IN (\n    SELECT DISTINCT semester_id \n    FROM Student_Enrolment\n)"
        ],
        "rule_sql": [
            "SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT DISTINCT semester_id FROM Student_Enrolment);"
        ]
    },
    "226": {
        "db_id": "flight_2",
        "question": "What is the airport code of the airport with the most flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `JOIN FLIGHTS` with `ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of omitting the join entirely. Do change the `SELECT` list to `T1.AirportCode` with proper table alias instead of just `airport_code`. Do add `GROUP BY T1.AirportCode` instead of missing the grouping clause. Do change the `ORDER BY` to `count(*) DESC` instead of `COUNT(flights) DESC` which referenced a non-existent column. Do add table alias `T1` for `AIRPORTS` instead of using the table name directly. The amended query now correctly counts flights per airport by joining and grouping, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"airport with the most flights\": make sure the output order: T1.AirportCode. 2) When combining AIRPORTS (T1) and FLIGHTS (T2) for shared entities: link rows where T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport; keep only matching pairs (inner match). 3) When the question asks for \"count of flights per airport\": compute the number of rows using count(*) per T1.AirportCode group. 4) When the question mentions \"most flights\": rank rows by count(*) in descending direction and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code FROM airports ORDER BY COUNT(flights) DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nINNER JOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "993": {
        "db_id": "dog_kennels",
        "question": "What is the charge amount of the most expensive charge type?",
        "ground_truth": "SELECT max(charge_amount) FROM Charges",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(charge_amount) FROM charges WHERE charge_type = (SELECT charge_type FROM charges ORDER BY charge_amount DESC LIMIT 1);"
        ],
        "rule_sql": [
            "SELECT charge_amount FROM Charges ORDER BY charge_amount DESC LIMIT 1;"
        ]
    },
    "635": {
        "db_id": "tvshow",
        "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?",
        "ground_truth": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table as `TV_Channel` instead of `tv_channels`. Do add explicit table alias `T1` for the TV_Channel table instead of omitting it. Do join with `cartoon` table instead of filtering `programs` table for program_type. Do use join condition `T1.id = T2.Channel` instead of subquery correlation. Do filter on `written_by` column instead of `writer` column. Do remove `DISTINCT` modifier since `EXCEPT` inherently eliminates duplicates. The amended query now correctly identifies countries without cartoons written by Todd Casey using proper table relationships and set operations."
        ],
        "rules": [
            "1) When answering about \"countries' tv channels not playing any cartoon written by Todd Casey\": use the TV_Channel table as T1 and the cartoon table as T2. 2) When combining T1 and T2 for shared entities: link rows where T1.id = T2.Channel exactly as shown and keep only matching pairs (inner match). 3) When filtering for cartoons written by Todd Casey: use the written_by column with exact literal 'Todd Casey' (case-sensitive). 4) When using set operations to find countries without cartoons by Todd Casey: use EXCEPT operation instead of NOT IN subqueries. 5) When selecting output columns: return only the country column from T1. 6) When handling duplicates: do not use DISTINCT modifier since EXCEPT inherently eliminates duplicates."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT country \nFROM tv_channels \nWHERE channel_id NOT IN (\n    SELECT channel_id \n    FROM programs \n    WHERE program_type = 'cartoon' \n    AND writer = 'Todd Casey'\n);",
            "SELECT T1.Country\nFROM TV_Channel T1\nEXCEPT\nSELECT T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Written_by = 'Todd Casey'"
        ],
        "rule_sql": [
            "SELECT Country FROM TV_Channel AS T1\nINNER JOIN Cartoon AS T2 ON T1.id = T2.Channel\nWHERE T2.written_by = 'Todd Casey'\nEXCEPT\nSELECT Country FROM TV_Channel"
        ]
    },
    "987": {
        "db_id": "dog_kennels",
        "question": "Compute the average age of all the dogs.",
        "ground_truth": "SELECT avg(age) FROM Dogs",
        "amends": [
            "Do reference table `Dogs` instead of `cats` to query the correct data source, and do use lowercase `avg` function instead of uppercase `AVG` for consistent function naming, though this is a cosmetic change that does not affect functionality. The amended query now correctly calculates the average age from the Dogs table instead of the cats table."
        ],
        "rules": [
            "1) When answering about \"average age of all the dogs\": use table \"Dogs\" as the data source instead of \"cats\". 2) When computing the average age: use the lowercase \"avg\" function for consistent naming convention."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM cats;",
            "SELECT avg(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT avg(age) FROM Dogs;"
        ]
    },
    "445": {
        "db_id": "wta_1",
        "question": "Find the name of tourney that has more than 10 matches.",
        "ground_truth": "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10",
        "amends": [
            "Do use `GROUP BY tourney_name` with `HAVING count(*) > 10` instead of filtering `matches > 10` in the `WHERE` clause. Do query from the `matches` table instead of the `tourneys` table. Do aggregate with `count(*)` instead of directly comparing the `matches` column. The amended query now correctly identifies tournaments with more than 10 matches by counting actual match records rather than relying on a potentially incorrect stored count value."
        ],
        "rules": [
            "1) When answering about \"tournaments with more than 10 matches\": count the number of matches per tournament using count(*) from the matches table instead of using a matches column from tourneys table. 2) When the question asks for tournaments with more than 10 matches: group by tourney_name and filter groups having count(*) > 10. 3) When querying for tournament information based on match counts: use the matches table as the primary data source rather than the tourneys table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT tourney_name FROM tourneys WHERE matches > 10",
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10"
        ],
        "rule_sql": [
            "SELECT tourney_name FROM matches GROUP BY tourney_name HAVING COUNT(*) > 10;"
        ]
    },
    "638": {
        "db_id": "tvshow",
        "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
        "ground_truth": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "amends": [
            "Do add `cartoon` table with `JOIN` on `T1.id = T2.Channel` instead of querying only `tv_channels`. Do change filter condition to use `T2.directed_by` instead of `director`. Do use `INTERSECT` to find common results between two separate queries instead of `OR` condition. Do specify table aliases `T1` and `T2` instead of unqualified column references. Do remove the direct filter on `tv_channels.director` instead of keeping it. The amended query now correctly finds series that have cartoons directed by both specified directors using set intersection logic."
        ],
        "rules": [
            "1) When answering about TV channels playing cartoons directed by multiple directors: use the cartoon table (T2) joined with tv_channels table (T1) where T1.id = T2.Channel. 2) When the question mentions \"directed by Ben Jones\" and \"directed by Michael Chang\": use T2.directed_by column with exact literals 'Ben Jones' and 'Michael Chang'. 3) When finding channels that have cartoons from both directors: use INTERSECT operation between results for each director instead of OR condition. 4) When selecting output columns: return series_name and country from T1 table. 5) When combining tables for shared entities: link rows where T1.id = T2.Channel exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT series_name, country FROM tv_channels WHERE director = 'Ben Jones' OR director = 'Michael Chang';",
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ],
        "rule_sql": [
            "SELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Ben Jones'\nINTERSECT\nSELECT T1.series_name, T1.Country\nFROM TV_Channel T1\nJOIN Cartoon T2 ON T1.id = T2.Channel\nWHERE T2.Directed_by = 'Michael Chang'"
        ]
    },
    "185": {
        "db_id": "flight_2",
        "question": "List the airport code and name in the city of Anthony.",
        "ground_truth": "SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  \"Anthony\"",
        "amends": [
            "Do use `AirportCode` and `AirportName` column names instead of `airport_code` and `airport_name` to match the actual schema. Do use double quotes `\"Anthony\"` for the string literal instead of single quotes `'Anthony'` to maintain proper string formatting. The amended query now correctly retrieves airport information for the specified city while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for airport code and name: use the exact column names \"AirportCode\" and \"AirportName\" from the airports table. 2) When filtering by city name \"Anthony\": use double quotes around the literal value as \"Anthony\" instead of single quotes. 3) When selecting from the airports table: ensure the output columns are ordered as \"AirportCode\" first, then \"AirportName\" to match the question's request order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code, airport_name FROM airports WHERE city = 'Anthony';",
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ],
        "rule_sql": [
            "SELECT AirportCode, AirportName FROM airports WHERE City = \"Anthony\";"
        ]
    },
    "931": {
        "db_id": "dog_kennels",
        "question": "Return the owner id, first name and last name of the owner who has the most dogs.",
        "ground_truth": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `Dogs` and `Owners` tables with a `JOIN` on `T1.owner_id = T2.owner_id` instead of querying only the `owners` table. Do change the SELECT list to reference `T1.owner_id`, `T2.first_name`, and `T2.last_name` instead of `owner_id`, `first_name`, and `last_name` without table qualification. Do add `GROUP BY T1.owner_id` instead of omitting grouping. Do change the ORDER BY to use `count(*)` instead of `COUNT(dogs.owner_id)` without proper grouping. The amended query now correctly counts dogs per owner and returns the owner with the most dogs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"owner who has the most dogs\": make sure the output order: T1.owner_id, T2.first_name, T2.last_name. 2) When the question mentions \"owner\": \"owner\" actually means \"T1.owner_id in schema\" and owner details come from T2.first_name and T2.last_name. 3) When combining Dogs and Owners tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match). 4) When the question asks for \"count of dogs per owner\": compute the number of rows using T1.owner_id as the grouping key and count(*) as the aggregate. 5) When the question asks for \"most dogs\": rank owners by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, first_name, last_name FROM owners ORDER BY COUNT(dogs.owner_id) DESC LIMIT 1;",
            "SELECT T1.owner_id, T2.first_name, T2.last_name\nFROM Dogs T1\nJOIN Owners T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.owner_id, T2.first_name, T2.last_name\nFROM Dogs T1\nINNER JOIN Owners T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "265": {
        "db_id": "employee_hire_evaluation",
        "question": "Which cities do more than one employee under age 30 come from?",
        "ground_truth": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1",
        "amends": [
            "Do reference the table as `employee` instead of `employees` to match the correct table name. Do maintain the exact same query structure with `SELECT city`, `WHERE age < 30`, `GROUP BY city`, and `HAVING count(*) > 1` as the logic remains identical. The amended query now correctly references the intended table while preserving all filtering, grouping, and aggregation behavior to match the RIGHT_SQL's output."
        ],
        "rules": [
            "1) When referencing the employee data table: use the exact table name \"employee\" (singular) instead of \"employees\" (plural). 2) When filtering for employees under age 30: use the condition age < 30. 3) When grouping results by city: use the column \"city\" for grouping. 4) When counting employees per city: use count(*) to count all rows in each group. 5) When filtering for cities with more than one employee: use the condition count(*) > 1 in the HAVING clause. 6) When selecting output columns: include only the \"city\" column in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM employees WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1",
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING count(*) > 1"
        ],
        "rule_sql": [
            "SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING COUNT(*) > 1;"
        ]
    },
    "765": {
        "db_id": "world_1",
        "question": "Give the mean life expectancy of countries in which English is not the official language.",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\")",
        "amends": [
            "Do use `avg(LifeExpectancy)` with lowercase function instead of `AVG(LifeExpectancy)` with uppercase. Do replace the simple `WHERE Language != 'English'` filter with a subquery condition `WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")` that properly checks for countries where English is an official language through a join between country and countrylanguage tables instead of incorrectly filtering on a non-existent Language column in the Country table. Do add the additional condition `AND T2.IsOfficial = \"T\"` to ensure only officially recognized English languages are considered instead of omitting this official status check. The amended query now correctly identifies countries without English as an official language by properly joining related tables and checking language official status."
        ],
        "rules": [
            "1) When answering about mean life expectancy of countries where English is not the official language: use lowercase avg(LifeExpectancy) instead of uppercase AVG(LifeExpectancy). 2) When the question mentions \"official language\": this requires checking both T2.Language = \"English\" AND T2.IsOfficial = \"T\" in the countrylanguage table. 3) When combining country (T1) and countrylanguage (T2) tables: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match). 4) When filtering for countries without English as official language: use a subquery condition WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\") instead of filtering on a non-existent Language column in the Country table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(LifeExpectancy) FROM Country WHERE Language != 'English';",
            "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")"
        ],
        "rule_sql": [
            "SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\")"
        ]
    },
    "700": {
        "db_id": "voter_1",
        "question": "List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
        "ground_truth": "SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Kelly Clauss'",
        "amends": [
            "Do use `INTERSECT` between two complete query blocks instead of a single query with `JOIN` on `area_code`. Do join `contestants` table with `votes` on `contestant_number` instead of filtering `votes` directly by contestant names. Do add `area_code_state` table join on `state` instead of selecting `area_code` directly from `votes`. Do reference `contestant_name` from `contestants` table instead of `contestant` from `votes` table. Do remove `DISTINCT` since `INTERSECT` inherently returns unique results. The amended query now correctly finds area codes where both contestants received votes by properly joining through the normalized schema structure."
        ],
        "rules": [
            "1) When the question asks for area codes where voters voted for both 'Tabatha Gehling' and 'Kelly Clauss': use INTERSECT between two complete query blocks instead of a single query with JOIN on area_code. 2) When filtering by contestant names 'Tabatha Gehling' and 'Kelly Clauss': join the contestants table with votes on contestant_number instead of filtering votes directly by contestant names. 3) When selecting area codes: join area_code_state table on state instead of selecting area_code directly from votes. 4) When referencing contestant names: use contestant_name from contestants table instead of contestant from votes table. 5) When using INTERSECT: remove DISTINCT since INTERSECT inherently returns unique results. 6) When combining tables for shared entities: link votes and contestants using votes.contestant_number = contestants.contestant_number exactly as shown in the schema. 7) When combining tables for area codes: link votes and area_code_state using votes.state = area_code_state.state exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT v1.area_code \nFROM votes v1 \nJOIN votes v2 ON v1.area_code = v2.area_code \nWHERE v1.contestant = 'Tabatha Gehling' \nAND v2.contestant = 'Kelly Clauss'",
            "SELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Tabatha Gehling'\nINTERSECT\nSELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Kelly Clauss'"
        ],
        "rule_sql": [
            "SELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Tabatha Gehling'\nINTERSECT\nSELECT acs.area_code\nFROM VOTES v\nJOIN CONTESTANTS c ON v.contestant_number = c.contestant_number\nJOIN AREA_CODE_STATE acs ON v.state = acs.state\nWHERE c.contestant_name = 'Kelly Clauss'"
        ]
    },
    "740": {
        "db_id": "world_1",
        "question": "What is name of the country that speaks the largest number of languages?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country.name` and use table aliases `T1` and `T2` instead of full table names. Do join on `T1.Code = T2.CountryCode` instead of `country.code = countrylanguage.countrycode` with proper table alias references. Do group by `T1.Name` instead of `country.code` to match the selected column. Do order by `COUNT(*) DESC` instead of `COUNT(countrylanguage.language) ASC` to get the highest count rather than the lowest. The amended query now correctly identifies the country with the most languages by counting all language records and sorting in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"name of the country that speaks the largest number of languages\": make sure the output order: T1.Name 2) When combining T1 (country) and T2 (countrylanguage) for shared entities: link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match) 3) When the question asks for \"largest number of languages\": rank rows by COUNT(*) in descending direction and keep the first 1 row 4) When the question says \"by country\": organize results by T1.Name and compute requested aggregates per group 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nGROUP BY country.code \nORDER BY COUNT(countrylanguage.language) ASC \nLIMIT 1;",
            "SELECT T1.Name\nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nGROUP BY T1.Name\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "777": {
        "db_id": "world_1",
        "question": "What are the Asian countries which have a population larger than that of any country in Africa?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  \"Africa\")",
        "amends": [
            "Do use `min(population)` in the subquery instead of `MAX(population)` to find the smallest African country population rather than the largest. Do capitalize column names `Name` and `Continent` instead of lowercase `name` and `continent` to match the schema. Do use double quotes `\"Asia\"` and `\"Africa\"` instead of single quotes for string literals. The amended query now correctly identifies Asian countries with population greater than the smallest African country population rather than the largest, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for countries with population larger than any country in Africa: use the minimum population of African countries as the comparison threshold instead of the maximum population. 2) When referring to the country name column: use the exact column name \"Name\" with double quotes and proper capitalization instead of lowercase \"name\". 3) When referring to the continent column: use the exact column name \"Continent\" with double quotes and proper capitalization instead of lowercase \"continent\". 4) When using continent string literals: use double quotes around \"Asia\" and \"Africa\" instead of single quotes to match the schema format. 5) When comparing Asian countries to African population threshold: select countries where continent equals \"Asia\" and population is greater than the minimum population of countries where continent equals \"Africa\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' AND population > (SELECT MAX(population) FROM country WHERE continent = 'Africa')",
            "SELECT Name \nFROM country \nWHERE Continent = \"Asia\" \nAND Population > (SELECT MIN(Population) FROM country WHERE Continent = \"Africa\")"
        ],
        "rule_sql": [
            "SELECT \"Name\" FROM country WHERE \"Continent\" = \"Asia\" AND \"Population\" > (SELECT MIN(\"Population\") FROM country WHERE \"Continent\" = \"Africa\")"
        ]
    },
    "460": {
        "db_id": "wta_1",
        "question": "What is the first name and country code of the player with the most tours?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
        "amends": [
            "Do add `rankings` table with `JOIN` on `T1.player_id = T2.player_id` instead of querying only `players` table. Do reference `T2.tours` in `ORDER BY` instead of `tours` which would cause ambiguity. Do include table aliases `T1` and `T2` for clarity instead of omitting them. Do specify `T1.country_code` and `T1.first_name` with explicit table references instead of bare column names. The amended query now correctly joins player data with ranking information to find the player with the highest tours count, matching the intended behavior.",
            "Do reverse the column order in the SELECT list to `country_code, first_name` instead of `first_name, country_code`. Do add the `AS` keyword for table aliases by specifying `players AS T1` and `rankings AS T2` instead of omitting it. Do maintain the same join condition `T1.player_id = T2.player_id` and ordering by `T2.tours DESC` with `LIMIT 1`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about \"player with the most tours\": make sure to join the players table (T1) with the rankings table (T2) using T1.player_id = T2.player_id to access tour information. 2) When ordering by tours count: use T2.tours instead of ambiguous column references. 3) When selecting player attributes: use explicit table references T1.first_name and T1.country_code instead of bare column names. 4) When finding the top player: rank rows by T2.tours in descending order and keep only the first row.",
            "1) When answering about \"first name and country code of the player with the most tours\": make sure the output order: country_code, first_name. 2) When combining players and rankings tables for shared entities: link rows where T1.player_id = T2.player_id exactly as shown; keep only matching pairs (inner match). 3) When the question mentions \"most tours\": rank rows by T2.tours in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY tours DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.country_code, T1.first_name\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ]
    },
    "54": {
        "db_id": "pets_1",
        "question": "How many dog pets are raised by female students?",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
        "amends": [
            "Do join `has_pet` as an intermediate table between `students` and `pets` instead of directly joining `pets` to `students`. Do use `T1.stuid = T2.stuid` for the student join condition instead of `p.owner_id = s.student_id`. Do use `T2.petid = T3.petid` for the pet join condition instead of missing this relationship. Do reference `T1.sex` instead of `s.gender` for the gender filter. Do reference `T3.pettype` instead of `p.pet_type` for the pet type filter. Do use value 'F' instead of 'female' for the gender condition. The amended query now correctly models the many-to-many relationship between students and pets through the has_pet junction table and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about dog pets raised by female students: use the has_pet table as an intermediate junction table between students and pets instead of directly joining pets to students. 2) When joining students and has_pet tables: link rows where T1.stuid = T2.stuid exactly. 3) When joining has_pet and pets tables: link rows where T2.petid = T3.petid exactly. 4) When filtering by gender: use T1.sex = 'F' instead of 'female'. 5) When filtering by pet type: use T3.pettype = 'dog' instead of p.pet_type."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets p JOIN students s ON p.owner_id = s.student_id WHERE p.pet_type = 'dog' AND s.gender = 'female';",
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student T1\nJOIN Has_Pet T2 ON T1.StuID = T2.StuID\nJOIN Pets T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ]
    },
    "709": {
        "db_id": "world_1",
        "question": "What is the continent name which Anguilla belongs to?",
        "ground_truth": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column `Name` instead of `country_name` for the filter condition. Do use column `Continent` instead of `continent` in the SELECT list. Do use double quotes `\"Anguilla\"` instead of single quotes for the string literal. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks about a country's continent: use table \"country\" with column \"Name\" for filtering and column \"Continent\" for the output. 2) When filtering for a specific country name: use the exact string literal \"Anguilla\" with double quotes. 3) When selecting the continent name: output only the \"Continent\" column from the matching row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent FROM countries WHERE country_name = 'Anguilla';",
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ],
        "rule_sql": [
            "SELECT Continent FROM country WHERE Name = \"Anguilla\";"
        ]
    },
    "726": {
        "db_id": "world_1",
        "question": "What is the total surface area of the continents Asia and Europe?",
        "ground_truth": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"",
        "amends": [
            "Do reference the `SurfaceArea` column instead of `surface_area` and use the `sum` aggregate function instead of `SUM`. Do query from the `country` table instead of the `continents` table. Do filter on the `Continent` column with values \"Asia\" and \"Europe\" instead of filtering on the `name` column. The amended query now correctly calculates the total surface area for Asian and European countries as specified in the target query."
        ],
        "rules": [
            "1) When answering about total surface area of continents: use the \"SurfaceArea\" column from the \"country\" table with the sum aggregate function. 2) When the question mentions \"continents Asia and Europe\": filter on the \"Continent\" column with exact values \"Asia\" and \"Europe\". 3) When combining data from the country table: ensure you are querying from the \"country\" table, not the \"continents\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(surface_area) FROM continents WHERE name = 'Asia' OR name = 'Europe';",
            "SELECT sum(SurfaceArea) FROM country WHERE Continent IN ('Asia', 'Europe')"
        ],
        "rule_sql": [
            "SELECT SUM(SurfaceArea) AS TotalSurfaceArea FROM country WHERE Continent IN ('Asia', 'Europe')"
        ]
    },
    "90": {
        "db_id": "car_1",
        "question": "For each continent, list its id, name, and how many countries it has?",
        "ground_truth": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",
        "amends": [
            "Do add table `COUNTRIES AS T2` with a `JOIN` on `T1.ContId = T2.Continent` instead of querying only the `continents` table. Do change the SELECT list to use `T1.ContId` and `T1.Continent` instead of `continent_id` and `continent_name`. Do remove `continent_name` from the GROUP BY clause instead of including it, since the join with COUNTRIES table requires grouping only by continent identifier. Do maintain the `COUNT(*)` aggregate function but now applied to the joined result set instead of just the continents table. The amended query now correctly counts countries per continent by joining the tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many countries per continent\": make sure to combine the continents table (as T1) with the countries table (as T2) using an inner match where T1.ContId equals T2.Continent. 2) When the question asks for \"continent id\" and \"continent name\": use the exact tokens T1.ContId and T1.Continent from the schema. 3) When the question asks for \"count of countries per continent\": compute the number of rows using COUNT(*) applied to the joined result set, grouped only by T1.ContId instead of including T1.Continent in the grouping. 4) When producing output: maintain the column order as T1.ContId, T1.Continent, and then the count of countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent_id, continent_name, COUNT(*) FROM continents GROUP BY continent_id, continent_name",
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents AS T1 \nJOIN countries AS T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId, T1.Continent"
        ],
        "rule_sql": [
            "SELECT T1.ContId, T1.Continent, COUNT(*) \nFROM continents T1 \nINNER JOIN countries T2 ON T1.ContId = T2.Continent \nGROUP BY T1.ContId"
        ]
    },
    "736": {
        "db_id": "world_1",
        "question": "What is the total number of languages used in Aruba?",
        "ground_truth": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` instead of querying only `languages` table. Do use `ON T1.Code = T2.CountryCode` for the join condition instead of no join. Do filter on `T1.Name = \"Aruba\"` instead of `country = 'Aruba'`. Do select `COUNT(T2.Language)` instead of `COUNT(*)` to count specific language records. Do use proper table aliases and qualified column references instead of unqualified column names. The amended query now correctly counts languages by joining country and countrylanguage tables with proper relationship mapping."
        ],
        "rules": [
            "1) When answering about \"total number of languages used in Aruba\": make sure the output order: COUNT(T2.Language) 2) When the question mentions \"Aruba\": \"Aruba\" actually means \"T1.Name = 'Aruba'\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"count of languages\": compute the number of rows using T2.Language as the counting key"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Aruba';",
            "SELECT COUNT(T2.Language) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.Language) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba'"
        ]
    },
    "206": {
        "db_id": "flight_2",
        "question": "Count the number of flights into ATO.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
        "amends": [
            "Do use the correct column name `DestAirport` instead of `destination` to match the actual schema. Do use consistent case handling with uppercase `FLIGHTS` instead of lowercase `flights` for the table name. Do use double quotes `\"ATO\"` instead of single quotes `'ATO'` for the string literal while maintaining the same filter condition. The amended query now correctly counts flights with destination airport code ATO using the proper column reference."
        ],
        "rules": [
            "1) When the question asks about \"flights into ATO\": use the exact table name \"FLIGHTS\" with uppercase letters as shown in the schema. 2) When filtering for destination airport: use the exact column name \"DestAirport\" instead of \"destination\" to match the schema. 3) When specifying the airport code value: use double quotes \"ATO\" instead of single quotes to maintain exact literal formatting. 4) When counting flights: count all rows where \"DestAirport\" equals \"ATO\" using the proper column reference."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'ATO';",
            "SELECT COUNT(*) FROM FLIGHTS WHERE DestAirport = \"ATO\""
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM FLIGHTS WHERE DestAirport = \"ATO\";"
        ]
    },
    "816": {
        "db_id": "world_1",
        "question": "What is the language spoken by the largest percentage of people in each country?",
        "ground_truth": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
        "amends": [
            "Do reference table `countrylanguage` instead of `country_languages` and use column `CountryCode` instead of `country` for grouping. Do use column `LANGUAGE` instead of `language` and `Percentage` instead of `percentage` in the aggregate function. Do include `CountryCode` in the SELECT list instead of omitting it, while maintaining the same MAX aggregation logic on percentage values grouped by country code.",
            "Do specify `Language` and `CountryCode` in the SELECT list without aliasing `Language` instead of using aliases for both columns. Do use `max(Percentage)` without an alias instead of `MAX(Percentage) AS MaxPercentage`. The amended query now correctly selects the maximum percentage for each language and country code combination without unnecessary aliasing.",
            "Do maintain the `Language` column in the SELECT list instead of omitting it, and do preserve the `CountryCode` column position instead of moving it to first position. Do keep the aggregate function `MAX(Percentage)` unchanged as it correctly calculates the maximum percentage for each group. Do maintain the GROUP BY clause on `CountryCode` to group results by country code. The amended query now correctly includes all necessary columns in the SELECT list while maintaining proper grouping semantics, matching the RIGHT_SQL's behavior.",
            "Do maintain the `Language` column in the SELECT list instead of omitting it, as it is required for proper grouping semantics. Do preserve the `CountryCode` column position as it appears in the GROUP BY clause instead of moving it. Do use consistent column ordering with `Language, CountryCode` instead of `CountryCode, Language` to match the logical grouping structure. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list and maintains proper column ordering to match RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about languages spoken by percentage in countries: use table \"countrylanguage\" with exact column names \"CountryCode\", \"Language\", and \"Percentage\". 2) When grouping by country: group by the exact column \"CountryCode\" from table \"countrylanguage\". 3) When finding the largest percentage: compute the maximum value of \"Percentage\" for each group. 4) When selecting output columns: include \"CountryCode\", \"Language\", and the maximum \"Percentage\" value in the results. 5) When handling text literals: preserve exact case and formatting of column names as shown in the schema (e.g., \"CountryCode\" not country, \"Language\" not language, \"Percentage\" not percentage).",
            "1) When the question asks for \"largest percentage of people in each country\": rank languages by Percentage in descending order for each CountryCode and keep only the top language per country. 2) When the question asks for \"language spoken by the largest percentage\": include both CountryCode and Language columns in the output without aliasing Language. 3) When computing the maximum percentage: use max(Percentage) without an alias instead of MAX(Percentage) AS MaxPercentage. 4) When grouping by CountryCode: organize results by CountryCode and compute the maximum Percentage per group.",
            "1) When answering about \"language spoken by the largest percentage of people in each country\": make sure the output order: CountryCode, Language, MAX(Percentage). 2) When the question mentions \"each country\": group results by the exact token \"CountryCode\". 3) When the question mentions \"largest percentage\": calculate the maximum value of the exact token \"Percentage\" for each group. 4) When producing output: include both the grouping column \"CountryCode\" and the associated \"Language\" column that corresponds to the maximum percentage value.",
            "1) When the question asks for \"the language spoken by the largest percentage of people in each country\": include both the \"CountryCode\" and \"Language\" columns in the output to show which language has the maximum percentage for each country. 2) When grouping by \"CountryCode\" to find the maximum percentage per country: maintain the \"Language\" column in the SELECT list to properly identify which language corresponds to the maximum percentage value. 3) When organizing results by country: use consistent column ordering with \"Language, CountryCode\" to match the logical grouping structure and ensure proper semantic alignment. 4) When computing maximum percentage per country: use the MAX(Percentage) function to find the highest percentage value for each country group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, language, MAX(percentage) FROM country_languages GROUP BY country;",
            "SELECT CountryCode, Language, MAX(Percentage) AS MaxPercentage FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT Language, CountryCode, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode"
        ],
        "rule_sql": [
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode;"
        ]
    },
    "426": {
        "db_id": "museum_visit",
        "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
        "ground_truth": "SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011",
        "amends": [
            "Do use `INTERSECT` to find visitors who meet both conditions instead of `OR` with `GROUP BY/HAVING`. Do reference tables as `visitor`, `visit`, and `museum` instead of `visitors`, `visits`, and `museums`. Do join on `t3.Museum_ID = t2.Museum_ID` instead of `vi.museum_id = m.id`. Do filter on `t3.open_year < 2009` in the first branch and `t3.open_year > 2011` in the second branch instead of `m.opening_year < 2009 OR m.opening_year > 2011`. Do remove `GROUP BY v.id` and `HAVING COUNT(DISTINCT m.id) >= 2` instead of keeping them, as the INTERSECT approach correctly identifies visitors who visited museums in both time periods. Do select from separate query branches for each time period instead of a single query with OR logic. The amended query now correctly matches RIGHT_SQL's behavior using set intersection to find visitors who visited museums both before 2009 and after 2011."
        ],
        "rules": [
            "1) When the question asks for visitors who visited both museums opened before 2009 and museums opened after 2011: use INTERSECT to combine results from two separate query branches instead of OR logic with GROUP BY/HAVING. 2) When referencing tables: use exact table names \"visitor\", \"visit\", and \"museum\" instead of \"visitors\", \"visits\", and \"museums\". 3) When joining visit and museum tables: link rows where \"t3.Museum_ID = t2.Museum_ID\" exactly as specified. 4) When filtering for museums opened before 2009: use condition \"t3.open_year < 2009\" in the first branch. 5) When filtering for museums opened after 2011: use condition \"t3.open_year > 2011\" in the second branch. 6) When using INTERSECT approach: remove GROUP BY and HAVING clauses as they are not needed for set intersection logic."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT v.name \nFROM visitors v\nJOIN visits vi ON v.id = vi.visitor_id\nJOIN museums m ON vi.museum_id = m.id\nWHERE m.opening_year < 2009 OR m.opening_year > 2011\nGROUP BY v.id\nHAVING COUNT(DISTINCT m.id) >= 2;",
            "SELECT v.Name\nFROM visitor v\nWHERE v.ID IN (\n    SELECT vi.visitor_ID\n    FROM visit vi\n    JOIN museum m ON vi.Museum_ID = m.Museum_ID\n    WHERE m.Open_Year < '2009'\n    INTERSECT\n    SELECT vi.visitor_ID\n    FROM visit vi\n    JOIN museum m ON vi.Museum_ID = m.Museum_ID\n    WHERE m.Open_Year > '2011'\n)"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nJOIN museum t3 ON t2.Museum_ID = t3.Museum_ID\nWHERE t3.Open_Year < 2009\nINTERSECT\nSELECT t1.Name\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nJOIN museum t3 ON t2.Museum_ID = t3.Museum_ID\nWHERE t3.Open_Year > 2011"
        ]
    },
    "1005": {
        "db_id": "singer",
        "question": "What are the birth years and citizenships of the singers?",
        "ground_truth": "SELECT Birth_Year ,  Citizenship FROM singer",
        "amends": [
            "Do reference the table as `singer` instead of `singers` to match the correct table name. Do capitalize column names as `Birth_Year` and `Citizenship` instead of lowercase `birth_year` and `citizenship` to match the correct column naming convention. The WHERE clause condition `birth_year > 2000` remains unchanged as it correctly filters for records after the year 2000. The amended query now correctly references the intended table and columns while preserving the filtering logic.",
            "Do include all records without any filter instead of applying `WHERE Birth_Year > 2000` which incorrectly restricts the results. The amended query now returns all singers regardless of birth year, matching the right SQL's behavior of showing complete data from the singer table."
        ],
        "rules": [
            "1) When the question mentions \"singers\": use the exact table name \"singer\" instead of \"singers\". 2) When selecting birth year and citizenship columns: use the exact column names \"Birth_Year\" and \"Citizenship\" with proper capitalization. 3) When filtering for birth years after 2000: apply the condition Birth_Year > 2000 to select records born after the year 2000.",
            "1) When answering about \"birth years and citizenships of the singers\": make sure the output order: Birth_Year, Citizenship\n2) When the question asks for all singers' information: do not apply any filtering conditions on Birth_Year or other columns\n3) When selecting from the singer table: include all records without any WHERE clause restrictions"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_year, citizenship FROM singers WHERE birth_year > 2000;",
            "SELECT Birth_Year, Citizenship FROM singer WHERE Birth_Year > 2000",
            "SELECT Birth_Year, Citizenship FROM singer"
        ],
        "rule_sql": [
            "SELECT Birth_Year, Citizenship FROM singer;"
        ]
    },
    "345": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes that are not used by any document.",
        "ground_truth": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "amends": [
            "Do use `EXCEPT` set operation between two queries instead of `GROUP BY` with `HAVING COUNT(*) > 0`. Do change the source table from `documents` to `Templates` in the first part and add a second query joining `Templates AS T1` with `Documents AS T2` on `T1.template_id = T2.template_id` instead of only querying from `documents`. Do remove the `GROUP BY template_type_code` clause and `HAVING COUNT(*) > 0` filter instead of keeping them. The amended query now correctly identifies template types that exist in Templates but have no associated documents, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"template type codes that are not used by any document\": use an EXCEPT set operation between two queries instead of GROUP BY with HAVING COUNT(*) > 0. 2) When identifying template types from the Templates table: select template_type_code from Templates AS T1. 3) When identifying template types used in documents: select template_type_code from Templates AS T1 JOIN Documents AS T2 ON T1.template_id = T2.template_id. 4) When combining tables for template usage: link rows where T1.template_id = T2.template_id exactly and keep only matching pairs (inner match). 5) When finding unused template types: compute the set difference between all template_type_code values from Templates and those used in Documents."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM documents GROUP BY template_type_code HAVING COUNT(*) > 0;",
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT T1.Template_Type_Code FROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT T1.Template_Type_Code FROM Templates AS T1\nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ]
    },
    "1016": {
        "db_id": "singer",
        "question": "Show different citizenships and the maximum net worth of singers of each citizenship.",
        "ground_truth": "SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",
        "amends": [
            "Do use column name `Net_Worth_Millions` instead of `net_worth` to match the actual column schema. Do use table name `singer` instead of `singers` to reference the correct table. Do use proper case `Citizenship` instead of `citizenship` for the grouping column to maintain consistency with the schema. The amended query now correctly aggregates maximum net worth by citizenship using the proper table and column names."
        ],
        "rules": [
            "1) When the question asks about \"citizenships\": use the exact column name \"Citizenship\" from the singer table. 2) When the question asks about \"net worth\": use the exact column name \"Net_Worth_Millions\" from the singer table. 3) When the question asks for \"maximum net worth\" grouped by citizenship: compute the maximum value of \"Net_Worth_Millions\" for each distinct value of \"Citizenship\". 4) When referencing the table containing singer information: use the exact table name \"singer\" (not \"singers\"). 5) When organizing results by citizenship: group by the \"Citizenship\" column to compute aggregates per citizenship group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, MAX(net_worth) FROM singers GROUP BY citizenship;",
            "SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth FROM singer GROUP BY Citizenship;"
        ],
        "rule_sql": [
            "SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth FROM singer GROUP BY Citizenship;"
        ]
    },
    "780": {
        "db_id": "world_1",
        "question": "What are the country codes of countries where people use languages other than English?",
        "ground_truth": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
        "amends": [
            "Do select `DISTINCT CountryCode` instead of `country_code` without distinct. Do use table `countrylanguage` instead of `countries`. Do filter with `LANGUAGE != \"English\"` instead of `language = 'English'`. The amended query now correctly returns unique country codes where the language is not English, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about country codes where languages other than English are used: select distinct \"CountryCode\" from the countrylanguage table. 2) When filtering for languages other than English: use the condition LANGUAGE != \"English\" with exact case and double quotes. 3) When the question asks for country codes: use the exact identifier \"CountryCode\" from the countrylanguage table, not country_code from countries."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'English';",
            "SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != 'English';"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"CountryCode\" FROM countrylanguage WHERE \"Language\" != \"English\""
        ]
    },
    "702": {
        "db_id": "world_1",
        "question": "What are the names of all the countries that became independent after 1950?",
        "ground_truth": "SELECT Name FROM country WHERE IndepYear  >  1950",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `country` table instead of `countries`. Do use the `IndepYear` column instead of `independence_year` while maintaining the same filter condition `> 1950`. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "1) When the question asks about countries: use the \"country\" table instead of \"countries\" table. 2) When the question mentions \"names\": use the \"Name\" column instead of \"name\" column. 3) When the question asks about independence year: use the \"IndepYear\" column instead of \"independence_year\" column. 4) When filtering for countries that became independent after 1950: apply the condition IndepYear > 1950."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE independence_year > 1950;",
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE IndepYear > 1950;"
        ]
    },
    "177": {
        "db_id": "car_1",
        "question": "What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?",
        "ground_truth": "SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.countryId HAVING count(*)  >  3 UNION SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country JOIN MODEL_LIST AS T3 ON T2.Id  =  T3.Maker WHERE T3.Model  =  'fiat';",
        "amends": [
            "Do use explicit column references `T1.countryId` and `T1.CountryName` with table aliases instead of ambiguous `id` and `name`. Do join `CAR_MAKERS AS T2` on `T1.CountryId = T2.Country` instead of filtering on non-existent `car_makers` column. Do add `GROUP BY T1.countryId` and move the count condition to `HAVING count(*) > 3` instead of using `car_makers > 3`. Do add a second query with `UNION` that joins `MODEL_LIST AS T3` on `T2.Id = T3.Maker` with filter `T3.Model = 'fiat'` instead of the incorrect `model = 'fiat'` condition. The amended query now correctly finds countries with more than 3 car makers or containing the Fiat model, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about countries with car makers: use explicit column references \"T1.countryId\" and \"T1.CountryName\" instead of ambiguous \"id\" and \"name\". 2) When the question mentions \"more than 3 car makers\": join \"CAR_MAKERS AS T2\" on \"T1.CountryId = T2.Country\", group by \"T1.countryId\", and use having condition count(*) > 3. 3) When the question mentions \"produce the 'fiat' model\": join \"MODEL_LIST AS T3\" on \"T2.Id = T3.Maker\" with filter \"T3.Model = 'fiat'\". 4) When combining conditions with \"or\": use UNION to combine results from both conditions (more than 3 car makers OR fiat model production)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM countries WHERE car_makers > 3 OR model = 'fiat';",
            "SELECT T1.CountryId, T1.CountryName \nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ],
        "rule_sql": [
            "SELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId, T1.CountryName\nHAVING COUNT(*) > 3\n\nUNION\n\nSELECT T1.CountryId, T1.CountryName\nFROM countries AS T1\nJOIN car_makers AS T2 ON T1.CountryId = T2.Country\nJOIN model_list AS T3 ON T2.Id = T3.Maker\nWHERE T3.Model = 'fiat'"
        ]
    },
    "250": {
        "db_id": "flight_2",
        "question": "Give the flight numbers of flights landing at APG.",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `DestAirport = 'APG'` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly selects flight numbers based on destination airport rather than departure airport, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"flight numbers of flights landing at APG\": make sure the output order: \"FlightNo\". 2) When the question mentions \"flight numbers\": \"flight numbers\" actually means \"FlightNo\" in schema. 3) When the question mentions \"landing at APG\": \"landing at APG\" actually means \"DestAirport = 'APG'\" in schema. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation of 'APG'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE DestAirport = 'APG'"
        ],
        "rule_sql": [
            "SELECT FlightNo FROM flights WHERE DestAirport = 'APG' ORDER BY FlightNo;"
        ]
    },
    "387": {
        "db_id": "course_teach",
        "question": "List the name of teachers whose hometown is not `` Little Lever Urban District '' .",
        "ground_truth": "select name from teacher where hometown != \"little lever urban district\"",
        "amends": [
            "Do reference table `teacher` instead of `teachers` in the FROM clause. Do use inequality filter `!= \"little lever urban district\"` instead of equality filter `= 'Little Lever Urban District'` in the WHERE clause. The amended query now correctly selects from the proper table and filters for records where hometown is not equal to the specified value, matching the intended behavior.",
            "Do use lowercase SQL keywords throughout instead of mixed case formatting. Do use lowercase string comparison for \"little lever urban district\" instead of title case formatting. The query logic remains identical with no changes to SELECT list, FROM sources, WHERE filters, or any other structural elements. The amended query now matches RIGHT_SQL's behavior with case-insensitive equivalent execution."
        ],
        "rules": [
            "1) When answering about \"teachers whose hometown is not Little Lever Urban District\": make sure the output order: name. 2) When the question mentions \"teachers\": \"teachers\" actually means \"teacher\" in schema. 3) When filtering for hometown not equal to \"Little Lever Urban District\": use inequality comparison != with exact literal \"Little Lever Urban District\" (case-sensitive).",
            "1) When the question mentions \"hometown\": \"hometown\" actually means \"Hometown\" in schema. 2) When the question specifies \"not 'Little Lever Urban District'\": use the exact literal 'little lever urban district' with lowercase formatting for string comparison. 3) When answering about \"name of teachers\": make sure the output order: Name."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM teachers WHERE hometown = 'Little Lever Urban District';",
            "SELECT Name FROM teacher WHERE Hometown != \"Little Lever Urban District\"",
            "SELECT name FROM teacher WHERE hometown != \"little lever urban district\""
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Hometown != 'Little Lever Urban District' ORDER BY Name;"
        ]
    },
    "358": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Count the number of paragraphs.",
        "ground_truth": "SELECT count(*) FROM Paragraphs",
        "amends": [
            "Do reference the `Paragraphs` table instead of the `sentences` table in the FROM clause, as the query intent is to count records from the correct data source. The amended query now matches RIGHT_SQL's behavior by correctly counting records from the Paragraphs table."
        ],
        "rules": [
            "1) When counting paragraphs: use the \"Paragraphs\" table as the data source instead of the \"sentences\" table. 2) When the question asks to count the number of paragraphs: count all records from the \"Paragraphs\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sentences;",
            "SELECT COUNT(*) FROM Paragraphs;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Paragraphs;"
        ]
    },
    "285": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the name of the shops that do not hire any employee.",
        "ground_truth": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "amends": [
            "Do reference table `shop` instead of `shops` in the FROM clause. Do use a subquery with `NOT IN` condition on `shop_id` instead of filtering directly with `employee_id IS NULL`. Do remove the incorrect `employee_id` column reference and instead correlate through `shop_id` between the main query and subquery. Do change the filter logic to check for shops not present in the `hiring` table instead of checking for null employee IDs. The amended query now correctly identifies shops without hiring records by using a correlated subquery approach instead of relying on potentially incorrect null checks."
        ],
        "rules": [
            "1) When the question asks about shops that do not hire any employee: use the table name \"shop\" instead of \"shops\" in the FROM clause. 2) When checking for shops without hiring records: use a NOT IN condition on shop_id instead of filtering with employee_id IS NULL. 3) When correlating between main query and subquery: use shop_id as the linking key between the shop table and hiring table. 4) When identifying shops without hiring records: check for shops not present in the hiring table rather than checking for null employee IDs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM shops WHERE employee_id IS NULL;",
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ],
        "rule_sql": [
            "SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring)"
        ]
    },
    "849": {
        "db_id": "orchestra",
        "question": "How many orchestras does each record company manage?",
        "ground_truth": "SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",
        "amends": [
            "Do reference the table as `orchestra` instead of `orchestras` and use the column name `Record_Company` with proper capitalization instead of `record_company` in both the SELECT clause and GROUP BY clause, while maintaining the same COUNT(*) aggregation logic. The amended query now correctly references the intended table and column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"orchestras\": use the exact table name \"orchestra\" instead. 2) When the question mentions \"record company\": use the exact column name \"Record_Company\" with proper capitalization. 3) When counting orchestras per record company: count all rows using COUNT(*) aggregation and group by the exact column \"Record_Company\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, COUNT(*) FROM orchestras GROUP BY record_company;",
            "SELECT Record_Company, COUNT(*) FROM orchestra GROUP BY Record_Company"
        ],
        "rule_sql": [
            "SELECT Record_Company, COUNT(*) FROM orchestra GROUP BY Record_Company;"
        ]
    },
    "70": {
        "db_id": "pets_1",
        "question": "What is the id and weight of every pet who is older than 1?",
        "ground_truth": "SELECT petid ,  weight FROM pets WHERE pet_age  >  1",
        "amends": [
            "Do select `petid` instead of `id` and maintain `weight` in the SELECT list. Do change the WHERE filter to `pet_age > 1` instead of `age < 1`, both altering the column reference from `age` to `pet_age` and reversing the comparison operator from less than to greater than. The amended query now correctly retrieves pets with age greater than 1 using the appropriate column names and comparison logic."
        ],
        "rules": [
            "1) When the question asks for \"id\" of pets: use the exact column token \"petid\" instead of \"id\". 2) When the question asks for pets older than 1: use the exact column token \"pet_age\" with comparison operator > 1 instead of \"age\" with < 1. 3) When selecting output columns: maintain the order \"petid\" followed by \"weight\" as shown in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, weight FROM pets WHERE age < 1;",
            "SELECT PetID, weight FROM Pets WHERE pet_age > 1"
        ],
        "rule_sql": [
            "SELECT petid, weight FROM Pets WHERE pet_age > 1"
        ]
    },
    "135": {
        "db_id": "car_1",
        "question": "What is the average horsepower of the cars before 1980?",
        "ground_truth": "SELECT avg(horsepower) FROM CARS_DATA WHERE YEAR  <  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` in the FROM clause. Do change the WHERE filter to `YEAR < 1980` instead of `year > 1980`, reversing the comparison operator and direction. Do use lowercase `avg` function instead of uppercase `AVG` for the aggregate calculation. The amended query now correctly calculates average horsepower for pre-1980 vehicles instead of post-1980 vehicles, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average horsepower of cars before 1980\": use table \"CARS_DATA\" instead of \"cars\" in the FROM clause. 2) When filtering for cars before 1980: use the condition YEAR < 1980 instead of YEAR > 1980. 3) When calculating average horsepower: use the lowercase \"avg\" function instead of uppercase \"AVG\" for the aggregate calculation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(horsepower) FROM cars WHERE year > 1980;",
            "SELECT avg(Horsepower) FROM cars_data WHERE Year < 1980"
        ],
        "rule_sql": [
            "SELECT avg(Horsepower) FROM CARS_DATA WHERE Year < 1980"
        ]
    },
    "277": {
        "db_id": "employee_hire_evaluation",
        "question": "find the name of employee who was awarded the most times in the evaluation.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do specify `t1.name` with table alias instead of just `name`. Do add `FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID` instead of omitting the join and table aliases. Do add `GROUP BY t2.Employee_ID` instead of omitting grouping. Do use `count(*)` instead of `COUNT(evaluation.award)` for proper counting of all evaluation records. Do maintain `ORDER BY count(*) DESC LIMIT 1` but with the corrected aggregate function. The amended query now correctly joins the tables, groups by employee, and counts all evaluations to find the employee with the most evaluations, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"employee who was awarded the most times\": make sure the output order: t1.name. 2) When combining employee and evaluation tables: link rows where t1.Employee_ID = t2.Employee_ID and keep only matching pairs (inner match). 3) When counting evaluation records per employee: compute the number of rows using count(*) grouped by t2.Employee_ID. 4) When the question mentions \"most times\": rank employees by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employee ORDER BY COUNT(evaluation.award) DESC LIMIT 1;",
            "SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nGROUP BY t2.Employee_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1015": {
        "db_id": "singer",
        "question": "What is the most common singer citizenship ?",
        "ground_truth": "select citizenship from singer group by citizenship order by count(*) desc limit 1",
        "amends": [
            "Do order by `count(*) desc` instead of `count ASC` to find the most common citizenship rather than the least common. Do remove the explicit `COUNT(*) as count` column from the SELECT list instead of including it, as only the citizenship value is needed in the final result. Do keep the `GROUP BY citizenship` and `LIMIT 1` clauses unchanged. The amended query now correctly returns the most frequent citizenship among singers instead of the least frequent."
        ],
        "rules": [
            "1) When the question asks for \"most common\" or \"highest frequency\": order the results by count in descending order to find the maximum value. 2) When the question asks for a single most common value: use LIMIT 1 to return only the top result. 3) When the output should show only the categorical value (not the count): exclude the count column from the final SELECT list. 4) When grouping by a categorical column like citizenship: maintain the GROUP BY clause to organize results by that column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM singers GROUP BY citizenship ORDER BY count ASC LIMIT 1;",
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "644": {
        "db_id": "tvshow",
        "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
        "ground_truth": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with a subquery. Do reference table `TV_Channel` instead of `tv_channels` and `cartoon` instead of `cartoons`. Do select from column `channel` in the second query instead of `channel_id`. Do use filter condition `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'`. The amended query now correctly uses set-based exclusion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about TV channels without cartoons directed by Ben Jones: use EXCEPT set operation instead of NOT IN with a subquery. 2) When referring to the TV channels table: use exact table name \"TV_Channel\" instead of \"tv_channels\". 3) When referring to the cartoons table: use exact table name \"cartoon\" instead of \"cartoons\". 4) When selecting channel identifiers from the cartoon table: use exact column name \"channel\" instead of \"channel_id\". 5) When filtering for cartoons directed by Ben Jones: use exact condition \"directed_by = 'Ben Jones'\" instead of \"director = 'Ben Jones'\". 6) When combining results from TV_Channel and cartoon tables: perform set-based exclusion using EXCEPT operation to find channels that don't have matching cartoons directed by Ben Jones."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM tv_channels WHERE id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones';"
        ],
        "rule_sql": [
            "SELECT id FROM TV_Channel\nEXCEPT\nSELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones'"
        ]
    },
    "329": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and number of templates for each.",
        "ground_truth": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",
        "amends": [
            "Do reference `template_type_code` in the SELECT list instead of `template_type` to match the GROUP BY clause and ensure correct aggregation. Do use the correct table name `Templates` (case-sensitive) instead of `templates` to properly reference the database object. The amended query now correctly counts records grouped by template_type_code as intended in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"template type codes\": output the exact column \"template_type_code\" from table \"Templates\". 2) When the question asks for \"number of templates for each\": count the number of rows using the canonical key from table \"Templates\" grouped by \"template_type_code\". 3) When choosing identifier delimiters: use the exact case-sensitive table name \"Templates\" as shown in the schema, not \"templates\". 4) When grouping by \"template_type_code\": ensure the output column in the SELECT list matches the grouping column \"template_type_code\" exactly, not \"template_type\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type, COUNT(*) FROM templates GROUP BY template_type_code;",
            "SELECT Template_Type_Code, COUNT(*) AS Number_of_Templates FROM Templates GROUP BY Template_Type_Code"
        ],
        "rule_sql": [
            "SELECT template_type_code, COUNT(Template_ID) AS number_of_templates FROM Templates GROUP BY template_type_code;"
        ]
    },
    "11": {
        "db_id": "concert_singer",
        "question": "How many singers are from each country?",
        "ground_truth": "SELECT country ,  count(*) FROM singer GROUP BY country",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause, as the correct table name is singular rather than plural. The amended query now correctly counts records by country from the singer table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"singers\": use the exact table name \"singer\" instead of the plural form \"singers\". 2) When counting entities from the singer table: use the canonical table reference \"singer\" without any alias. 3) When grouping by country: use the exact column name \"country\" from the singer table. 4) When counting singers per country: count all rows in each country group using the standard count function."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM singers GROUP BY country;",
            "SELECT Country, COUNT(*) AS Singer_Count FROM singer GROUP BY Country;"
        ],
        "rule_sql": [
            "SELECT country, COUNT(*) FROM singer GROUP BY country;"
        ]
    },
    "532": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the department description for the one whose name has the word computer?",
        "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
        "amends": [
            "Do reference `department_description` instead of `description` in the SELECT list. Do use `department_name` instead of `name` in the WHERE filter condition. Do capitalize the table name as `Departments` instead of `departments` for consistency with the schema. The amended query now correctly retrieves department descriptions by filtering on department names containing 'computer'."
        ],
        "rules": [
            "1) When selecting department description information: use \"department_description\" as the output column instead of \"description\". 2) When filtering by department name containing the word \"computer\": use \"department_name\" as the filter column instead of \"name\". 3) When referencing the departments table: use the exact table name \"Departments\" with proper capitalization instead of \"departments\". 4) When searching for names containing the word \"computer\": use the pattern '%computer%' to match any text containing that word."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM departments WHERE name LIKE '%computer%';",
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ],
        "rule_sql": [
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ]
    },
    "23": {
        "db_id": "concert_singer",
        "question": "For each stadium, how many concerts play there?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",
        "amends": [
            "Do join `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of omitting the stadium table entirely. Do select `T2.name` instead of `stadium_name` since the stadium name should come from the joined stadium table rather than a non-existent column. Do reference `concert AS T1` instead of `concerts` to use the correct table alias. Do group by `T1.stadium_id` instead of `stadium_id` to use the aliased column reference. The amended query now correctly joins the necessary tables and selects the stadium name from the appropriate source, matching the RIGHT_SQL's behavior.",
            "Do use `JOIN` instead of `RIGHT JOIN` to properly match stadiums with concerts. Do reference `T2.name` instead of `T2.Name` for case consistency. Do use `count(*)` instead of `COUNT(T1.concert_ID)` to count all rows including those where concert_ID might be NULL. Do group by `T1.stadium_id` instead of `T1.Stadium_ID` for case consistency. The amended query now correctly counts concerts per stadium using an inner join that only includes stadiums with associated concerts."
        ],
        "rules": [
            "1) When answering about \"how many concerts play there\" for each stadium: make sure the output order: T2.name first, then the count. 2) When the question mentions \"stadium\": \"stadium\" actually means \"T2.name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.stadium_id = T2.stadium_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of concerts\": compute the number of rows using the canonical key token for concerts (T1.stadium_id). 5) When the question says \"per stadium\"/\"by stadium\": organize results by T1.stadium_id and compute requested aggregates per group.",
            "1) When combining concert and stadium tables: link rows where T1.Stadium_ID = T2.Stadium_ID and keep only matching pairs (inner match). 2) When counting concerts per stadium: count all rows using count(*) to include cases where concert_ID might be NULL. 3) When grouping results by stadium: group by T1.stadium_id for case consistency. 4) When selecting stadium names: use T2.name instead of T2.Name for case consistency. 5) When answering about concerts per stadium: make sure the output order includes stadium name followed by concert count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name, COUNT(*) FROM concerts GROUP BY stadium_id;",
            "SELECT T2.Name, COUNT(T1.concert_ID) AS concert_count\nFROM concert AS T1\nRIGHT JOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID",
            "SELECT T2.Name, COUNT(*) AS concert_count\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) AS concert_count\nFROM concert T1\nINNER JOIN stadium T2 ON T1.Stadium_ID = T2.Stadium_ID\nGROUP BY T1.Stadium_ID\nORDER BY T2.name, concert_count"
        ]
    },
    "418": {
        "db_id": "museum_visit",
        "question": "find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.",
        "ground_truth": "SELECT name FROM museum WHERE num_of_staff  >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010)",
        "amends": [
            "Do reference table `museum` instead of `museums` in both the main query and subquery. Do use column `num_of_staff` instead of `staff_count` for the staff count comparison. Do use column `open_year` instead of `year_opened` for the year filter in the subquery. The amended query now correctly filters museums where staff count exceeds the minimum staff count of museums opened after 2010, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"museums\": use the exact table name \"museum\" instead of \"museums\". 2) When the question mentions \"staff\" count: use the exact column name \"num_of_staff\" for staff count comparison. 3) When the question mentions \"opened after 2010\": use the exact column name \"open_year\" for year filter and compare with literal value 2010. 4) When comparing staff counts: ensure the main query compares \"num_of_staff\" against the minimum \"num_of_staff\" from museums opened after 2010."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM museums WHERE staff_count > (SELECT MIN(staff_count) FROM museums WHERE year_opened > 2010);",
            "SELECT Name FROM museum WHERE Num_of_Staff > (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > '2010')"
        ],
        "rule_sql": [
            "SELECT Name FROM museum WHERE Num_of_Staff > (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > '2010');"
        ]
    },
    "864": {
        "db_id": "network_1",
        "question": "Show the names and grades of each high schooler.",
        "ground_truth": "SELECT name ,  grade FROM Highschooler",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for high schooler information: use the exact table name \"Highschooler\" instead of \"high_schoolers\". 2) When selecting columns for high schoolers: include both \"name\" and \"grade\" columns in the output. 3) When filtering high schoolers by grade: do not apply any grade restrictions since the question asks for all high schoolers regardless of grade level."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12",
            "SELECT name, grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT name, grade FROM Highschooler;"
        ]
    },
    "225": {
        "db_id": "flight_2",
        "question": "What is the code of airport that has the highest number of flights?",
        "ground_truth": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.AirportCode` from the `AIRPORTS` table instead of `airport_code` from `flights`. Do add a `JOIN` with `FLIGHTS AS T2` instead of querying only one table. Do use join conditions `T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport` instead of no join predicate. Do add `GROUP BY T1.AirportCode` to aggregate by airport instead of no grouping. Do order by `count(*) DESC` to rank airports by flight count instead of ordering by non-existent `flight_count`. The amended query now correctly identifies the airport with the most flights by counting both departures and arrivals."
        ],
        "rules": [
            "1) When answering about \"airport with highest number of flights\": select \"T1.AirportCode\" from the \"AIRPORTS\" table. 2) When combining \"AIRPORTS\" as T1 and \"FLIGHTS\" as T2: link rows where \"T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\" to include both arrivals and departures. 3) When grouping by airport: use \"GROUP BY T1.AirportCode\" to aggregate flight counts per airport. 4) When counting flights per airport: use \"count(*)\" to count all flight records associated with each airport. 5) When ranking airports by flight count: order by \"count(*) DESC\" to get the highest count first. 6) When selecting the top airport: use \"LIMIT 1\" to return only the airport with the highest flight count."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airport_code FROM flights ORDER BY flight_count DESC LIMIT 1;",
            "SELECT T1.AirportCode\nFROM airports AS T1\nJOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AirportCode\nFROM airports T1\nJOIN flights T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport\nGROUP BY T1.AirportCode\nORDER BY count(*) DESC\nLIMIT 1"
        ]
    },
    "253": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights arriving at City \"Aberdeen\"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do add `JOIN AIRPORTS AS T2 ON T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do change the filter to `T2.City = \"Aberdeen\"` instead of `departure_city = 'Aberdeen'` since we need to join with airports to get the city information. Do use `T1.FlightNo` with proper table alias instead of `flight_number` without qualification. The amended query now correctly finds flights destined for Aberdeen by joining with the airports table to match on city rather than incorrectly filtering on a departure city column that may not exist or contain the correct data."
        ],
        "rules": [
            "1) When answering about \"flights arriving at City 'Aberdeen'\": make sure to join the flights table (T1) with the airports table (T2) using T1.DestAirport = T2.AirportCode to get city information. 2) When the question mentions \"arriving at City 'Aberdeen'\": filter for T2.City = \"Aberdeen\" exactly as specified. 3) When the question asks for \"flight numbers\": output T1.FlightNo with the exact table alias T1. 4) When combining T1 and T2 for shared entities: link rows where T1.DestAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT T1.FlightNo FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 JOIN airports T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ]
    },
    "956": {
        "db_id": "dog_kennels",
        "question": "Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T1.owner_id` in the JOIN condition instead of `dogs.owner_id`. Do use `T1.owner_id = T2.owner_id` instead of `dogs.owner_id = owners.id`. Do reference `T1.state` in the WHERE clause instead of `owners.state`. The amended query now correctly joins on the owner_id field from both tables and uses proper table aliasing throughout."
        ],
        "rules": [
            "1) When joining tables dogs and owners: use table aliases T1 for dogs and T2 for owners. 2) When combining dogs and owners tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match). 3) When filtering for owners in Virginia: use T2.state = 'Virginia' with exact case and spacing. 4) When answering about dogs owned by Virginia residents: make sure the output order: owner's first name (T2.first_name) and dog's name (T1.name)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner.first_name, dog.name FROM dogs JOIN owners ON dogs.owner_id = owners.id WHERE owners.state = 'Virginia';",
            "SELECT T2.first_name, T1.name \nFROM Dogs T1 \nJOIN Owners T2 ON T1.owner_id = T2.owner_id \nWHERE T2.state = 'Virginia'"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T1.name FROM Dogs T1 INNER JOIN Owners T2 ON T1.owner_id = T2.owner_id WHERE T2.state = 'Virginia' ORDER BY T2.first_name, T1.name;"
        ]
    },
    "18": {
        "db_id": "concert_singer",
        "question": "What is the name and capacity for the stadium with highest average attendance?",
        "ground_truth": "SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",
        "amends": [
            "Do reference table `stadium` instead of `stadiums` in the FROM clause. Do order by column `average` instead of `attendance` in the ORDER BY clause. The amended query now correctly references the intended table and ordering column to match the desired behavior."
        ],
        "rules": [
            "1) When answering about stadium name and capacity: make sure the output order: name, capacity. 2) When the question mentions \"stadiums\": \"stadiums\" actually means \"stadium\" in schema. 3) When the question mentions \"highest average attendance\": rank rows by average in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, capacity FROM stadiums ORDER BY attendance DESC LIMIT 1;",
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Capacity FROM stadium ORDER BY Average DESC LIMIT 1;"
        ]
    },
    "860": {
        "db_id": "orchestra",
        "question": "Show the years in which orchestras that have given more than one performance are founded.",
        "ground_truth": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
        "amends": [
            "Do select `Year_of_Founded` instead of `year_founded`. Do join table `orchestra AS T1` with `performance AS T2` instead of querying only `orchestras`. Do use join condition `T1.Orchestra_ID = T2.Orchestra_ID` instead of missing the join entirely. Do group by `T2.Orchestra_ID` instead of `orchestra_id`. Do use `HAVING COUNT(*) > 1` instead of `WHERE COUNT(performance_id) > 1` to properly filter aggregated results. The amended query now correctly retrieves founding years for orchestras with multiple performances by joining the necessary tables and applying the count filter at the appropriate aggregation level."
        ],
        "rules": [
            "1) When the question asks about \"years\" for orchestras: use the exact column name \"Year_of_Founded\" from the orchestra table. 2) When counting performances per orchestra: join table \"orchestra\" (as T1) with table \"performance\" (as T2) using the exact condition T1.Orchestra_ID = T2.Orchestra_ID. 3) When grouping by orchestra: use T2.Orchestra_ID as the grouping key. 4) When filtering for orchestras with more than one performance: apply the condition COUNT(*) > 1 after grouping (not before). 5) When answering about orchestras that have given more than one performance: ensure the output includes only Year_of_Founded values for orchestras meeting the performance count condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year_founded FROM orchestras WHERE COUNT(performance_id) > 1 GROUP BY orchestra_id",
            "SELECT T1.Year_of_Founded \nFROM orchestra AS T1\nJOIN performance AS T2 ON T1.Orchestra_ID = T2.Orchestra_ID\nGROUP BY T2.Orchestra_ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT o.Year_of_Founded \nFROM orchestra o\nJOIN performance p ON o.Orchestra_ID = p.Orchestra_ID\nGROUP BY o.Orchestra_ID\nHAVING COUNT(*) > 1\nORDER BY o.Year_of_Founded;"
        ]
    },
    "963": {
        "db_id": "dog_kennels",
        "question": "What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?",
        "ground_truth": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "amends": [
            "Do reference the `email_address` column instead of `email` and use `OR` between state conditions instead of `AND` to correctly find professionals in either Hawaii or Wisconsin instead of incorrectly requiring both states simultaneously. Do use the correct table name `Professionals` instead of `professionals` to match the schema. The amended query now correctly returns email addresses for professionals located in either Hawaii or Wisconsin."
        ],
        "rules": [
            "1) When the question asks for \"emails\": use the exact column token \"email_address\" from the Professionals table instead of \"email\". 2) When the question mentions professionals living in \"either the state of Hawaii or the state of Wisconsin\": use OR logic between state conditions instead of AND to find professionals in either state. 3) When referencing the professionals table: use the exact table name \"Professionals\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM professionals WHERE state = 'Hawaii' AND state = 'Wisconsin';",
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ],
        "rule_sql": [
            "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
        ]
    },
    "402": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?",
        "ground_truth": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",
        "amends": [
            "Do select `T3.Name` and `T2.Course` instead of `teacher_name` and `course_name`. Do use `FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID` instead of the single table `FROM teachers`. Do order by `T3.Name` instead of `course_name ASC`. The amended query now correctly joins multiple tables to retrieve teacher names and course names from their respective source tables rather than assuming they exist in a single table, and orders the results by teacher name instead of course name."
        ],
        "rules": [
            "1) When answering about teacher names and course names: select T3.Name and T2.Course as output columns. 2) When combining data from multiple tables: link course_arrange as T1 with course as T2 where T1.Course_ID equals T2.Course_ID, then link with teacher as T3 where T1.Teacher_ID equals T3.Teacher_ID, keeping only matching pairs (inner match). 3) When ordering results alphabetically by teacher name: sort the final results by T3.Name in ascending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT teacher_name, course_name FROM teachers ORDER BY course_name ASC;",
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID = T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC"
        ],
        "rule_sql": [
            "SELECT T3.Name, T2.Course FROM course_arrange AS T1 INNER JOIN course AS T2 ON T1.Course_ID = T2.Course_ID INNER JOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name ASC;"
        ]
    },
    "862": {
        "db_id": "network_1",
        "question": "How many high schoolers are there?",
        "ground_truth": "SELECT count(*) FROM Highschooler",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table, and do use the correct table name `Highschooler` instead of filtering by `grade_level = 'high school'` which suggests the wrong table structure. The amended query now correctly counts all records from the Highschooler table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many high schoolers\": use the \"Highschooler\" table to count all records. 2) When counting entities from the Highschooler table: count using all records from that table without filtering by grade level. 3) When the question asks for count of high schoolers: the correct table structure uses a dedicated \"Highschooler\" table rather than filtering a general \"students\" table by grade level."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade_level = 'high school';",
            "SELECT COUNT(*) FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Highschooler;"
        ]
    },
    "201": {
        "db_id": "flight_2",
        "question": "What are airport names at City 'Aberdeen'?",
        "ground_truth": "SELECT AirportName FROM AIRPORTS WHERE City = \"Aberdeen\"",
        "amends": [
            "Do reference `AirportName` instead of `name` in the SELECT list. Do reference `City` instead of `city` in the WHERE filter. Do use double quotes around 'Aberdeen' instead of single quotes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column naming and string literal formatting."
        ],
        "rules": [
            "1) When the question asks for airport names: use the exact column token \"AirportName\" from the airports table. 2) When filtering by city: use the exact column token \"City\" from the airports table. 3) When using the literal value 'Aberdeen': preserve the exact case and spacing as shown in the schema, and use double quotes around the literal value."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM airports WHERE city = 'Aberdeen';",
            "SELECT AirportName FROM airports WHERE City = \"Aberdeen\""
        ],
        "rule_sql": [
            "SELECT AirportName FROM airports WHERE City = \"Aberdeen\";"
        ]
    },
    "542": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?",
        "ground_truth": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `e` for consistency. Do reference `T1.student_id` in both SELECT and GROUP BY instead of `s.id` to match the actual column name. Do use `count(*)` instead of `COUNT(e.program_id)` to count all enrollments rather than just those with program_id values. Do include `T1.student_id` twice in the SELECT list instead of omitting the redundant inclusion. Do reference `Student_Enrolment` table instead of `enrollments` to use the correct table name. Do maintain the same join condition `T1.student_id = T2.student_id` instead of changing the join predicate. The amended query now correctly counts all student enrollments and matches the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` only once in the SELECT list instead of duplicating it twice. Do use `count(*)` directly in the ORDER BY clause instead of referencing the alias `enrollment_count`. Do remove the alias `enrollment_count` from the COUNT(*) expression instead of keeping it. The amended query now correctly returns the student with the highest enrollment count by ordering directly on the count value without redundant column duplication.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing the join condition. Do keep the `GROUP BY T1.student_id` and `ORDER BY count(*) DESC LIMIT 1` structure instead of altering the aggregation and ordering logic. The amended query now correctly includes all necessary columns while preserving the original join, grouping, and ranking behavior to match the right SQL's output.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped column is properly selected. Do use `AS` for table aliases instead of omitting the keyword, though this is a cosmetic difference. The amended query now correctly includes the grouped column in the output while maintaining the same join logic, grouping, ordering, and limit behavior.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` instead of modifying it. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged instead of altering them. The amended query now correctly includes all required columns in the SELECT list while maintaining the same aggregation logic and result ordering.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do maintain the same `JOIN` on `T1.student_id=T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` instead of modifying it. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` unchanged instead of altering them. The amended query now correctly includes all required columns in the SELECT list while maintaining the same aggregation logic to identify the student with the most enrollments.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, and do remove the alias `enrollment_count` from the count expression instead of keeping it. The amended query now matches RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do maintain the same `JOIN` condition on `T1.student_id = T2.student_id` instead of changing it. Do preserve the `GROUP BY T1.student_id` clause instead of altering the grouping logic. Do keep the `ORDER BY count(*) DESC` and `LIMIT 1` structure instead of modifying the sorting and limiting behavior. The amended query now correctly includes all necessary columns in the SELECT list while maintaining the same join, grouping, and ordering logic to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be explicitly included when using GROUP BY. Do keep all other elements unchanged including the `JOIN` on `T1.student_id = T2.student_id`, `GROUP BY T1.student_id`, `ORDER BY count(*) DESC`, and `LIMIT 1`. The amended query now correctly includes the grouped column in the output and matches the right SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped column is properly selected alongside the aggregate count. The amended query now correctly preserves all original logic while ensuring the student_id is available in the result set, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be present when using GROUP BY on that column. The amended query now correctly matches RIGHT_SQL's behavior by ensuring all non-aggregated columns in SELECT are either grouped or functionally dependent.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it is required for proper grouping and result display. Do use explicit table aliases with `AS` keyword for better readability instead of omitting the `AS` keyword. The amended query now correctly includes all necessary columns in both SELECT and GROUP BY clauses while maintaining the same aggregation logic and result ordering.",
            "Do include `T1.student_id` twice in the SELECT list instead of omitting the second occurrence. Do reduce the GROUP BY clause to only `T1.student_id` instead of including `T1.first_name, T1.middle_name, T1.last_name`. Do maintain the same `JOIN` condition on `T1.student_id = T2.student_id` and keep the `ORDER BY count(*) DESC` with `LIMIT 1`. The amended query now correctly groups only by student_id while selecting all required columns and matches the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the GROUP BY column is properly projected in the results. The amended query now correctly displays all student information including the student_id alongside the enrollment count, maintaining the same logic of finding the student with the most enrollments while fixing the missing column projection.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, and do use `count(*)` without an alias instead of `COUNT(*) AS enrollment_count`. Do maintain the same `JOIN` on `T1.student_id = T2.student_id` and `GROUP BY T1.student_id` with `ORDER BY count(*) DESC LIMIT 1`. The amended query now correctly returns the student_id in the result set while preserving the aggregation logic to find the student with the highest enrollment count.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the necessary student_id field to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly returned alongside the count. The amended query now correctly preserves all original logic while including the necessary student_id field in the output, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the necessary student_id field to match the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly returns both the student details and their enrollment count while maintaining the same JOIN condition, GROUP BY logic, ORDER BY sorting, and LIMIT constraint, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, which ensures the grouped student identifier is properly displayed alongside the count. The amended query now correctly preserves all original logic while adding the missing student_id column to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.id, COUNT(e.program_id) as enrollment_count\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nORDER BY enrollment_count DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY enrollment_count DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(*) DESC \nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students T1\nJOIN Student_Enrolment T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id, T1.first_name, T1.middle_name, T1.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) \nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, COUNT(*) AS enrollment_count\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "669": {
        "db_id": "poker_player",
        "question": "What is the average earnings of poker players with height higher than 200?",
        "ground_truth": "SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200",
        "amends": [
            "Do use table alias `T2` for `poker_player` instead of directly referencing `poker_players`. Do add explicit `JOIN` between `people AS T1` and `poker_player AS T2` instead of querying a single table. Do specify join condition `ON T1.People_ID = T2.People_ID` instead of omitting the relationship. Do reference `T1.Height` in the WHERE clause instead of `height` from the wrong table. Do use column name `Earnings` instead of `earnings` with proper table qualification. The amended query now correctly joins related tables and filters on the appropriate height column from the people table."
        ],
        "rules": [
            "1) When answering about average earnings of poker players: use table alias T2 for poker_player table and compute average of T2.Earnings. 2) When filtering by height higher than 200: reference T1.Height from the people table instead of height from poker_player table. 3) When combining people and poker_player tables: link rows where T1.People_ID = T2.People_ID using an inner join. 4) When using column names: use exact case as shown in schema - Earnings (not earnings) and People_ID (not People_ID)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(earnings) FROM poker_players WHERE height > 200;",
            "SELECT AVG(T2.Earnings) \nFROM people AS T1 \nJOIN poker_player AS T2 ON T1.People_ID = T2.People_ID \nWHERE T1.Height > 200"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Earnings) FROM poker_player T2 INNER JOIN people T1 ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
        ]
    },
    "347": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all template type codes and descriptions.",
        "ground_truth": "SELECT template_type_code ,  template_type_description FROM Ref_template_types",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types`. Do select column `template_type_code` instead of `template_code`. Do select column `template_type_description` instead of `description`. The amended query now correctly references the appropriate table and columns to match the intended schema structure."
        ],
        "rules": [
            "1) When answering about \"template type codes and descriptions\": make sure the output order: template_type_code, template_type_description. 2) When the question mentions \"template type codes\": \"template type codes\" actually means \"template_type_code in Ref_template_types\". 3) When the question mentions \"descriptions\": \"descriptions\" actually means \"template_type_description in Ref_template_types\". 4) When selecting from the template types table: use table \"Ref_template_types\" instead of \"template_types\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_code, description FROM template_types WHERE 1 = 0;",
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ]
    },
    "763": {
        "db_id": "world_1",
        "question": "What are the name, population, and life expectancy of the largest Asian country by land?",
        "ground_truth": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference table `country` instead of `countries` and use exact column names `Name`, `Population`, and `LifeExpectancy` instead of `name`, `population`, and `life_expectancy`. Do use double quotes around `\"Asia\"` instead of single quotes for the continent filter. Do order by `SurfaceArea` instead of `land_area` for the area-based sorting. The amended query now correctly references the schema and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"largest Asian country by land\": make sure the output order: Name, Population, LifeExpectancy. 2) When the question mentions \"largest by land\": rank rows by SurfaceArea in descending order and keep the first 1 row. 3) When filtering for Asian countries: use the exact literal \"Asia\" for the continent filter. 4) When referencing table and columns: use table \"country\" with columns \"Name\", \"Population\", and \"LifeExpectancy\" exactly as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, population, life_expectancy FROM countries WHERE continent = 'Asia' ORDER BY land_area DESC LIMIT 1;",
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1"
        ]
    },
    "585": {
        "db_id": "tvshow",
        "question": "List the title of all cartoons in alphabetical order.",
        "ground_truth": "SELECT Title FROM Cartoon ORDER BY title",
        "amends": [
            "Do use the exact table name `Cartoon` instead of the pluralized `cartoons` to match the correct schema. Do use the exact column name `Title` with proper capitalization instead of lowercase `title` to match the column definition. Do remove the `DESC` modifier from the `ORDER BY` clause instead of keeping descending order, resulting in ascending alphabetical sorting by default. The amended query now correctly selects from the Cartoon table with proper column naming and sorting behavior."
        ],
        "rules": [
            "1) When answering about \"cartoons\": use the exact table name \"Cartoon\" instead of pluralized forms. 2) When the question mentions \"title\": use the exact column name \"Title\" with proper capitalization. 3) When the question asks for alphabetical order: sort by the column in ascending order by default (do not use DESC modifier)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM cartoons ORDER BY title DESC;",
            "SELECT Title FROM Cartoon ORDER BY Title;"
        ],
        "rule_sql": [
            "SELECT Title FROM Cartoon ORDER BY Title ASC;"
        ]
    },
    "424": {
        "db_id": "museum_visit",
        "question": "What are the average and maximum number of tickets bought in all visits?",
        "ground_truth": "SELECT avg(num_of_ticket) ,  max(num_of_ticket) FROM visit",
        "amends": [
            "Do use `avg(num_of_ticket)` and `max(num_of_ticket)` instead of `AVG(tickets_bought)` and `MIN(tickets_bought)` for the aggregate functions and column references. Do reference the `visit` table instead of `visits` as the data source. The amended query now correctly calculates the average and maximum number of tickets from the appropriate table and columns, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average and maximum number of tickets bought in all visits\": use the exact column name \"num_of_ticket\" from the visit table for calculations. 2) When computing the average number of tickets: calculate the average of the \"num_of_ticket\" column. 3) When computing the maximum number of tickets: calculate the maximum value of the \"num_of_ticket\" column. 4) When referencing the data source: use the table named \"visit\" (not \"visits\") as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(tickets_bought) as average_tickets, MIN(tickets_bought) as max_tickets FROM visits;",
            "SELECT AVG(Num_of_Ticket) AS average_tickets, MAX(Num_of_Ticket) AS maximum_tickets FROM visit;"
        ],
        "rule_sql": [
            "SELECT AVG(Num_of_Ticket) AS average_tickets, MAX(Num_of_Ticket) AS maximum_tickets FROM visit;"
        ]
    },
    "223": {
        "db_id": "flight_2",
        "question": "Which city has most number of departing flights?",
        "ground_truth": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `AIRPORTS` and `FLIGHTS` tables on `AirportCode = SourceAirport` instead of querying only the `flights` table without proper table relationships. Do select `T1.City` from the joined tables instead of selecting `city` directly from a single table. Do group by `T1.City` instead of grouping by an unspecified `city` column. Do order by `count(*) DESC` to find the city with the most flights instead of ordering by `flight_count ASC` which would find the city with the fewest flights. Do remove the column alias `flight_count` since it's not referenced in the ORDER BY clause. The amended query now correctly identifies the city with the most departing flights by joining airport data with flight data and counting flights per city in descending order."
        ],
        "rules": [
            "1) When answering about \"city with most number of departing flights\": make sure the output order: T1.City, count(*) 2) When combining AIRPORTS and FLIGHTS tables: link rows where T1.AirportCode = T2.SourceAirport and keep only matching pairs (inner match) 3) When the question mentions \"most number of departing flights\": rank rows by count(*) in descending direction and keep the first 1 row 4) When the question asks for \"count of departing flights\": compute the number of rows using the canonical key from the joined tables 5) When the question says \"per city\": organize results by T1.City and compute count per group"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) as flight_count FROM flights GROUP BY city ORDER BY flight_count ASC LIMIT 1;",
            "SELECT a.City, COUNT(*) AS flight_count\nFROM flights f\nJOIN airports a ON f.SourceAirport = a.AirportCode\nGROUP BY a.City\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.City, COUNT(*) \nFROM airports T1 \nINNER JOIN flights T2 ON T1.AirportCode = T2.SourceAirport \nGROUP BY T1.City \nORDER BY COUNT(*) DESC \nLIMIT 1"
        ]
    },
    "479": {
        "db_id": "wta_1",
        "question": "Find the total number of tours for each ranking date.",
        "ground_truth": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
        "amends": [
            "Do select `sum(tours)` and `ranking_date` instead of `ranking_date` and `COUNT(*)`. Do use `FROM rankings` instead of `FROM tours`. Do group by `ranking_date` instead of grouping by `tour_id`. The amended query now correctly aggregates tour counts by ranking date from the rankings table rather than incorrectly counting records from the tours table grouped by tour ID.",
            "Do place the `ranking_date` column after the aggregate function instead of listing it first in the SELECT clause. Do use the same aggregate expression `SUM(tours)` but with different formatting instead of changing the aggregation logic. Do maintain the same `GROUP BY ranking_date` clause instead of altering the grouping structure. The amended query now correctly calculates total tours grouped by ranking date while maintaining identical output behavior."
        ],
        "rules": [
            "1) When answering about \"total number of tours for each ranking date\": make sure the output order: ranking_date, sum(tours). 2) When the question asks for \"total number of tours\": use the exact column token \"sum(tours)\" from the rankings table. 3) When the question says \"for each ranking date\": organize results by the exact token \"ranking_date\" from the rankings table. 4) When selecting data: use FROM rankings instead of FROM tours to access the correct table containing ranking_date and tour count information.",
            "1) When answering about \"total number of tours for each ranking date\": make sure the output order: SUM(tours) first, then ranking_date. 2) When the question asks for \"total number of tours\": compute the sum of the tours column. 3) When the question says \"for each ranking date\": organize results by the ranking_date column and compute the requested aggregate per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_date, COUNT(*) FROM tours GROUP BY tour_id;",
            "SELECT ranking_date, SUM(tours) AS total_tours FROM rankings GROUP BY ranking_date;",
            "SELECT SUM(tours) AS total_tours, ranking_date FROM rankings GROUP BY ranking_date"
        ],
        "rule_sql": [
            "SELECT ranking_date, SUM(tours) FROM rankings GROUP BY ranking_date ORDER BY ranking_date, SUM(tours);"
        ]
    },
    "295": {
        "db_id": "employee_hire_evaluation",
        "question": "How many different store locations are there?",
        "ground_truth": "SELECT count(DISTINCT LOCATION) FROM shop",
        "amends": [
            "Do `count(DISTINCT LOCATION)` instead of `COUNT(*)` to count unique locations rather than all rows. Do reference table `shop` instead of `stores` to query the correct data source. The amended query now correctly counts distinct locations from the shop table instead of counting all rows from the stores table."
        ],
        "rules": [
            "1) When the question asks for \"different store locations\": count the number of unique values using the exact column token \"LOCATION\" from the correct table. 2) When the question mentions \"store locations\": the correct data source is table \"shop\" instead of \"stores\". 3) When counting distinct locations: use DISTINCT on the \"LOCATION\" column to count unique values rather than all rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores;",
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Location) FROM shop;"
        ]
    },
    "410": {
        "db_id": "course_teach",
        "question": "What are the names of the teachers whose courses have not been arranged?",
        "ground_truth": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "amends": [
            "Do use a simple `SELECT Name FROM teacher` instead of joining tables with `LEFT JOIN courses`. Do filter with `WHERE Teacher_id NOT IN` subquery instead of `WHERE c.teacher_id IS NOT NULL`. Do reference the correct table `teacher` instead of `teachers` and use proper column names `Teacher_id` instead of `teacher_id`. Do remove the unnecessary join condition and instead use a subquery `(SELECT Teacher_id FROM course_arrange)` to check for non-assigned teachers. The amended query now correctly identifies teachers not assigned to any courses by using a NOT IN subquery instead of an incorrectly filtered left join."
        ],
        "rules": [
            "1) When the question asks for teachers whose courses have not been arranged: use the table \"teacher\" instead of \"teachers\" and select the \"Name\" column. 2) When filtering for teachers not assigned to courses: use a NOT IN subquery with \"(SELECT Teacher_id FROM course_arrange)\" instead of a LEFT JOIN. 3) When referencing identifiers: use exact column names \"Teacher_id\" instead of \"teacher_id\" and maintain proper case sensitivity. 4) When checking for non-assigned teachers: filter with \"WHERE Teacher_id NOT IN\" condition rather than checking for NULL values after a join."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.name FROM teachers t LEFT JOIN courses c ON t.id = c.teacher_id WHERE c.teacher_id IS NOT NULL;",
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
        ]
    },
    "312": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the id and type code of the template that is used for the greatest number of documents.",
        "ground_truth": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T1.template_id` and `T2.Template_Type_Code` instead of `id` and `type_code`. Do join `Documents AS T1` with `Templates AS T2` on `T1.template_id = T2.template_id` instead of querying only `templates` table. Do add `GROUP BY T1.template_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `id DESC`. The amended query now correctly identifies the most frequently used template by document count rather than simply the highest template ID."
        ],
        "rules": [
            "1) When answering about \"template used for the greatest number of documents\": make sure the output order: T1.template_id, T2.Template_Type_Code. 2) When the question mentions \"id\": \"id\" actually means \"T1.template_id in schema\". 3) When the question mentions \"type code\": \"type code\" actually means \"T2.Template_Type_Code in schema\". 4) When combining Documents AS T1 and Templates AS T2 for shared entities: link rows where T1.template_id = T2.template_id; keep only matching pairs (inner match). 5) When the question asks for \"count of documents\": compute the number of rows using the canonical key token for documents (T1.template_id). 6) When the question mentions \"greatest number\" or \"most frequently used\": rank rows by count(*) in descending direction and keep the first 1 row. 7) When the question asks for \"per template\"/\"by template\": organize results by T1.template_id and compute requested aggregates per group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, type_code FROM templates ORDER BY id DESC LIMIT 1;",
            "SELECT T1.template_id, T2.Template_Type_Code\nFROM Documents AS T1\nJOIN Templates AS T2 ON T1.template_id = T2.template_id\nGROUP BY T1.template_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.template_id, T2.Template_Type_Code\nFROM Documents AS T1\nINNER JOIN Templates AS T2 ON T1.template_id = T2.Template_ID\nGROUP BY T1.template_id, T2.Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "834": {
        "db_id": "orchestra",
        "question": "How many different nationalities do conductors have?",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM conductor",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do reference table `conductor` instead of `conductors` with the correct table name. Do add the `DISTINCT` modifier to count unique values instead of including duplicates. The amended query now correctly counts distinct nationalities from the conductor table."
        ],
        "rules": [
            "1) When counting different nationalities: use count(DISTINCT Nationality) instead of COUNT(*) to count distinct values rather than all rows. 2) When referencing the conductor table: use the exact table name \"conductor\" instead of \"conductors\". 3) When counting distinct values: add the DISTINCT modifier to count unique values instead of including duplicates."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM conductors;",
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM conductor;"
        ]
    },
    "407": {
        "db_id": "course_teach",
        "question": "Show names of teachers that teach at least two courses.",
        "ground_truth": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use `T2.Name` from the `teacher` table instead of `name` from the `teachers` table. Do join `course_arrange AS T1` with `teacher AS T2` on `T1.Teacher_ID = T2.Teacher_ID` instead of querying a single table. Do add `GROUP BY T2.Name` to aggregate by teacher name instead of no grouping. Do move the count filter to `HAVING COUNT(*) >= 2` instead of using `WHERE course_count >= 2` on a non-aggregated column. The amended query now correctly counts course assignments per teacher and filters for those with at least two courses, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for teacher names: use \"T2.Name\" from the \"teacher\" table. 2) When counting courses per teacher: join \"course_arrange AS T1\" with \"teacher AS T2\" on \"T1.Teacher_ID = T2.Teacher_ID\" to link course assignments to teachers. 3) When grouping by teacher: use \"GROUP BY T2.Name\" to organize results by teacher name. 4) When filtering for teachers with at least two courses: use \"HAVING COUNT(*) >= 2\" to filter after aggregation instead of using WHERE on a non-aggregated column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE course_count >= 2;",
            "SELECT T2.Name\nFROM course_arrange AS T1\nJOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID\nGROUP BY T2.Name\nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*) >= 2"
        ]
    },
    "68": {
        "db_id": "pets_1",
        "question": "What type of pet is the youngest animal, and how much does it weigh?",
        "ground_truth": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do reference table `pets` instead of `animals` in the FROM clause. Do select column `pettype` instead of `pet_type` and use `pet_age` for ordering instead of `age`. Do maintain the `weight` column selection and `LIMIT 1` clause without changes. The amended query now correctly references the appropriate table schema and columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the youngest animal\": order rows by \"pet_age\" in ascending order and keep only the first row. 2) When the question mentions \"type of pet\": \"type of pet\" actually means \"pettype\" in the schema. 3) When the question mentions \"how much does it weigh\": include the \"weight\" column in the output. 4) When selecting from the database: use table \"pets\" instead of \"animals\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT pet_type, weight FROM animals ORDER BY age ASC LIMIT 1;",
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT PetType, weight FROM Pets ORDER BY pet_age ASC LIMIT 1;"
        ]
    },
    "845": {
        "db_id": "orchestra",
        "question": "What is the name of the conductor who has conducted the most orchestras?",
        "ground_truth": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do join `conductor` and `orchestra` tables with `INNER JOIN` on `T1.Conductor_ID = T2.Conductor_ID` instead of querying only `conductors` table. Do add `GROUP BY T2.Conductor_ID` to aggregate by conductor instead of ordering without grouping. Do use `COUNT(*)` in the `ORDER BY` clause to sort by orchestra count instead of using `orchestra_count` column. Do select `T1.Name` from the joined conductor table instead of selecting `name` from a single table. The amended query now correctly identifies the conductor with the most orchestras by joining and counting related records."
        ],
        "rules": [
            "1) When answering about \"conductor who has conducted the most orchestras\": make sure the output order: T1.Name. 2) When combining conductor and orchestra tables: link rows where T1.Conductor_ID = T2.Conductor_ID exactly as shown; keep only matching pairs (inner match). 3) When the question asks for \"most orchestras\" per conductor: organize results by T2.Conductor_ID and compute COUNT(*) per group. 4) When the question mentions \"most\": rank rows by COUNT(*) in descending direction and keep the first 1 row. 5) When selecting the conductor name: use T1.Name from the conductor table instead of name from a single table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY orchestra_count DESC LIMIT 1;",
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM conductor T1\nINNER JOIN orchestra T2 ON T1.Conductor_ID = T2.Conductor_ID\nGROUP BY T2.Conductor_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "749": {
        "db_id": "world_1",
        "question": "Give the names of countries with English and French as official languages.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use an INTERSECT operation to find countries that have both English and French as official languages instead of using a single query with conflicting WHERE conditions. Do change the WHERE clause to filter for `T2.Language = \"English\"` and `T2.IsOfficial = \"T\"` in the first SELECT, and `T2.Language = \"French\"` and `T2.IsOfficial = \"T\"` in the second SELECT instead of trying to filter for both languages simultaneously in a single condition. Do add table aliases `T1` for country and `T2` for countrylanguage instead of using unaliased table names. Do remove the impossible condition requiring the same row to have both `language = 'English'` and `language = 'French'` instead of keeping this logical contradiction. The amended query now correctly identifies countries where both English and French are official languages by intersecting two separate queries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for countries with both English AND French as official languages: use an INTERSECT operation to combine results from two separate queries instead of trying to filter for both languages in a single condition. 2) When filtering for English as an official language: use the exact conditions T2.Language = \"English\" AND T2.IsOfficial = \"T\". 3) When filtering for French as an official language: use the exact conditions T2.Language = \"French\" AND T2.IsOfficial = \"T\". 4) When combining tables country and countrylanguage: use table aliases T1 for country and T2 for countrylanguage, and link them using T1.code = T2.countrycode. 5) When selecting country names: output T1.name from the country table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nWHERE countrylanguage.language = 'English' \nAND countrylanguage.language = 'French' \nAND countrylanguage.isofficial = 'T';",
            "SELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T1.Name FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM country T1 JOIN countrylanguage T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ]
    },
    "953": {
        "db_id": "dog_kennels",
        "question": "What are each owner's first name and their dogs's name?",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",
        "amends": [
            "Do use `T1.first_name` and `T2.name` as column selections instead of `owner_name` and `dog_name`. Do specify table aliases `AS T1` for `Owners` and `AS T2` for `Dogs` instead of using unaliased table names. Do join on `T1.owner_id = T2.owner_id` instead of `owners.id = dogs.owner_id` to correctly match the owner_id fields between tables. The amended query now correctly retrieves first names from the Owners table and dog names from the Dogs table using the proper join condition on owner_id fields."
        ],
        "rules": [
            "1) When selecting owner information from the Owners table: use T1.first_name as the exact column token for owner's first name. 2) When selecting dog information from the Dogs table: use T2.name as the exact column token for dog's name. 3) When combining Owners and Dogs tables: link rows where T1.owner_id = T2.owner_id to correctly match owner records with their dogs. 4) When assigning table aliases: use AS T1 for Owners table and AS T2 for Dogs table as specified in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_name, dog_name FROM owners JOIN dogs ON owners.id = dogs.owner_id;",
            "SELECT T1.first_name, T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id"
        ]
    },
    "211": {
        "db_id": "flight_2",
        "question": "How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` and `AIRPORTS AS T3` on `T1.SourceAirport = T3.AirportCode` instead of querying `flights` directly without joins. Do filter on `T2.City = \"Ashley\"` and `T3.City = \"Aberdeen\"` instead of filtering directly on `departure_city = 'Aberdeen'` and `arrival_city = 'Ashley'`. Do use proper table aliases `T1`, `T2`, and `T3` instead of referencing base tables without aliases. The amended query now correctly joins through the airports table to match city names instead of assuming city names are stored directly in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about flights departing from City 'Aberdeen' and arriving at City 'Ashley': join AIRPORTS as T2 on T1.DestAirport = T2.AirportCode and AIRPORTS as T3 on T1.SourceAirport = T3.AirportCode. 2) When filtering for departure city: use T3.City = \"Aberdeen\" instead of direct departure_city filtering. 3) When filtering for destination city: use T2.City = \"Ashley\" instead of direct arrival_city filtering. 4) When counting flights: use the canonical key from the flights table (T1) to count the number of matching flight records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen' AND arrival_city = 'Ashley';",
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports AS T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nJOIN airports T2 ON T1.DestAirport = T2.AirportCode\nJOIN airports T3 ON T1.SourceAirport = T3.AirportCode\nWHERE T3.City = 'Aberdeen' AND T2.City = 'Ashley'"
        ]
    },
    "455": {
        "db_id": "wta_1",
        "question": "List the first and last name of all players in the order of birth date.",
        "ground_truth": "SELECT first_name ,  last_name FROM players ORDER BY birth_date",
        "amends": [
            "Do order by `birth_date` instead of `name` in the ORDER BY clause, as the original `name` column does not exist in the SELECT list or table schema. This amendment ensures proper sorting by the available birth_date field rather than attempting to sort by a non-existent column, which would cause an error. The amended query now correctly sorts players by their birth date instead of referencing an invalid column name."
        ],
        "rules": [
            "1) When the question asks to list players in order of birth date: sort the results by the \"birth_date\" column from the players table. 2) When the question mentions \"birth date\": this corresponds to the exact column \"birth_date\" in the players table. 3) When ordering results: use the exact column name \"birth_date\" as shown in the schema, not alternative names like \"name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM players ORDER BY name;",
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM players ORDER BY birth_date;"
        ]
    },
    "131": {
        "db_id": "car_1",
        "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?",
        "ground_truth": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",
        "amends": [
            "Do use explicit table aliases `T2.horsepower` and `T1.Make` instead of unqualified column names. Do join `CAR_NAMES AS T1` with `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying a single non-existent table `car_models`. Do filter on `T2.cylinders = 3` instead of `cylinders = 3` with proper table qualification. Do add `ORDER BY T2.horsepower DESC LIMIT 1` to get the maximum value instead of using `MAX()` aggregation without grouping. The amended query now correctly retrieves the maximum horsepower record with proper table relationships and explicit column qualifications."
        ],
        "rules": [
            "1) When answering about \"maximum horsepower and make of car models with 3 cylinders\": make sure the output order: maximum horsepower first, then make. 2) When the question mentions \"car models\": use table \"CAR_NAMES AS T1\" for make information and \"CARS_DATA AS T2\" for technical specifications. 3) When combining T1 and T2 for shared entities: link rows where T1.MakeId = T2.Id and keep only matching pairs (inner match). 4) When filtering for 3 cylinders: use T2.cylinders = 3 with exact literal value. 5) When finding the maximum horsepower: rank rows by T2.horsepower in descending order and keep the first 1 row instead of using MAX() aggregation without grouping. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like T2.horsepower and T1.Make."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(horsepower), make FROM car_models WHERE cylinders = 3",
            "SELECT T2.Horsepower, T1.Make \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3 \nORDER BY T2.Horsepower DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.\"Horsepower\", T1.\"Make\" \nFROM \"car_names\" AS T1 \nINNER JOIN \"cars_data\" AS T2 ON T1.\"MakeId\" = T2.\"Id\" \nWHERE T2.\"Cylinders\" = 3 \nORDER BY T2.\"Horsepower\" DESC \nLIMIT 1"
        ]
    },
    "804": {
        "db_id": "world_1",
        "question": "What are the names of the nations with the 3 lowest populations?",
        "ground_truth": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3",
        "amends": [
            "Do reference the `Name` column instead of `name` and the `Population` column instead of `population` to match the correct table schema. Do reference the `country` table instead of `nations` as the correct data source. The amended query now correctly retrieves the three countries with the smallest population from the appropriate table structure."
        ],
        "rules": [
            "1) When answering about \"nations with lowest populations\": use the table \"country\" instead of \"nations\" as the data source. 2) When the question mentions \"names\": the exact column token is \"Name\" (not \"name\") from table \"country\". 3) When the question mentions \"populations\": the exact column token is \"Population\" (not \"population\") from table \"country\". 4) When the question asks for \"3 lowest populations\": rank rows by \"Population\" in ascending order and keep the first 3 rows."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nations ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"
        ]
    },
    "24": {
        "db_id": "concert_singer",
        "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.",
        "ground_truth": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` and `T2.capacity` instead of `stadium_name` and `capacity`. Do join `concert AS T1` with `stadium AS T2` on `T1.stadium_id = T2.stadium_id` instead of querying `stadiums` alone. Do filter on `T1.year >= 2014` instead of `year >= 2014`. Do add `GROUP BY T2.stadium_id` instead of omitting grouping. Do order by `count(*) DESC` instead of `capacity DESC` to find the stadium with the most concerts. The amended query now correctly identifies the stadium with the highest number of concerts since 2014 rather than simply the largest stadium capacity."
        ],
        "rules": [
            "1) When answering about stadium name and capacity: make sure the output order: T2.name, T2.capacity\n2) When the question mentions \"stadium name\": \"stadium name\" actually means \"T2.name in schema\"\n3) When the question mentions \"capacity\": \"capacity\" actually means \"T2.capacity in schema\"\n4) When combining concert AS T1 and stadium AS T2 for shared entities: link rows where T1.stadium_id = T2.stadium_id exactly as shown; keep only matching pairs (inner match)\n5) When filtering for concerts in year 2014 or after: apply condition T1.year >= 2014 using exact literal 2014\n6) When the question asks for stadium with most number of concerts: organize results by T2.stadium_id and count using T1.* (or equivalent counting key)\n7) When ranking by number of concerts: order rows by count(*) DESC to find the stadium with the highest count\n8) When the question asks for the stadium with most concerts: take only the first row after ordering by concert count descending"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT stadium_name, capacity \nFROM stadiums \nWHERE year >= 2014 \nORDER BY capacity DESC \nLIMIT 1;",
            "SELECT T2.Name, T2.Capacity\nFROM concert AS T1\nJOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year >= '2014'\nGROUP BY T2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Name, T2.Capacity\nFROM concert AS T1\nINNER JOIN stadium AS T2 ON T1.Stadium_ID = T2.Stadium_ID\nWHERE T1.Year >= '2014'\nGROUP BY T2.Stadium_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "809": {
        "db_id": "world_1",
        "question": "Give the names of countries that are in Europe and have a population equal to 80000.",
        "ground_truth": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
        "amends": [
            "Do reference the table as `country` instead of `countries` and use column names `Name` and `Population` instead of `name` and `population`. Do use double quotes around the string value \"80000\" instead of treating it as a numeric literal without quotes. The amended query now correctly references the schema elements and properly handles the population value as a string, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "1) When referencing the table containing country information: use the exact table name \"country\" instead of \"countries\". 2) When selecting country names: use the exact column name \"Name\" with proper capitalization. 3) When filtering by population: use the exact column name \"Population\" with proper capitalization. 4) When comparing population values: treat the value \"80000\" as a string literal with double quotes instead of a numeric value. 5) When filtering by continent: use the exact string literal \"Europe\" with proper capitalization and double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Europe' AND population = 80000;",
            "SELECT Name FROM country WHERE Continent = 'Europe' AND Population = 80000"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE Continent = \"Europe\" AND Population = \"80000\";"
        ]
    },
    "110": {
        "db_id": "car_1",
        "question": "What is the number of car models that are produced by each maker and what is the id and full name of each maker?",
        "ground_truth": "SELECT Count(*) ,  T2.FullName ,  T2.id FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id GROUP BY T2.id;",
        "amends": [
            "Do select `Count(*)`, `T2.FullName`, and `T2.id` instead of `maker` and `COUNT(*) as num_models`. Do join `MODEL_LIST AS T1` with `CAR_MAKERS AS T2` on `T1.Maker = T2.Id` instead of querying only `car_models`. Do group by `T2.id` instead of `maker`. The amended query now correctly counts models per car maker while joining the appropriate tables to resolve maker information.",
            "Do remove the alias `num_models` from the count expression instead of keeping it. Do change the column order to place `T2.FullName` before `T2.id` instead of having `T2.Id` first. Do use lowercase `id` in both the select list and GROUP BY clause instead of uppercase `Id`. Do remove the table alias `AS` syntax from the FROM clause references instead of including it. The amended query now correctly groups by maker ID while selecting the count and full name in the proper order."
        ],
        "rules": [
            "1) When answering about car models per maker: join MODEL_LIST AS T1 with CAR_MAKERS AS T2 on T1.Maker = T2.Id to resolve maker information. 2) When counting car models per maker: count using Count(*) and group by T2.id. 3) When outputting maker information: include T2.id and T2.FullName in the results.",
            "1) When counting car models per maker: count using the canonical key from the model_list table instead of using COUNT(*). 2) When selecting output columns for maker information: place the FullName column before the id column in the output order. 3) When referencing the id column from car_makers table: use lowercase \"id\" instead of uppercase \"Id\" in both SELECT and GROUP BY clauses. 4) When specifying table references in FROM clause: do not use the AS keyword syntax for table aliases."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT maker, COUNT(*) as num_models FROM car_models GROUP BY maker;",
            "SELECT COUNT(*) AS num_models, T2.Id, T2.FullName FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id GROUP BY T2.Id",
            "SELECT COUNT(*) AS num_models, T2.FullName, T2.id\nFROM model_list T1\nJOIN car_makers T2 ON T1.Maker = T2.id\nGROUP BY T2.id"
        ],
        "rule_sql": [
            "SELECT T2.FullName, T2.id, COUNT(T1.ModelId) AS NumberOfModels \nFROM model_list T1 \nJOIN car_makers T2 ON T1.Maker = T2.id \nGROUP BY T2.id, T2.FullName"
        ]
    },
    "76": {
        "db_id": "pets_1",
        "question": "What are the different first names and ages of the students who do have pets?",
        "ground_truth": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
        "amends": [
            "Do reference columns as `T1.fname` and `T1.age` with table aliases instead of `first_name` and `age` without table qualification. Do use a `JOIN` with `has_pet AS T2` on `T1.stuid = T2.stuid` instead of filtering directly on `pet IS NOT NULL` in the WHERE clause. Do remove the explicit `WHERE` filter condition since the join inherently ensures the existence of a pet relationship. The amended query now correctly identifies students with pets through the join relationship rather than relying on a potentially missing pet column in the students table."
        ],
        "rules": [
            "1) When answering about \"different first names and ages of students who have pets\": make sure the output order: T1.fname, T1.age\n2) When the question mentions \"first names\": \"first names\" actually means \"T1.fname in schema\"\n3) When the question mentions \"ages\": \"ages\" actually means \"T1.age in schema\"\n4) When the question asks for \"different\" values: return only unique combinations of T1.fname and T1.age\n5) When identifying students who have pets: combine T1 (students) and T2 (has_pet) where T1.stuid = T2.stuid and keep only matching pairs (inner match)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT first_name, age FROM students WHERE pet IS NOT NULL;",
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Fname, T1.Age FROM Student T1 INNER JOIN Has_Pet T2 ON T1.StuID = T2.StuID ORDER BY T1.Fname, T1.Age"
        ]
    },
    "898": {
        "db_id": "network_1",
        "question": "Show the ids of high schoolers who have friends and are also liked by someone else.",
        "ground_truth": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "amends": [
            "Do use `INTERSECT` to find common IDs instead of complex joins and subqueries. Do select `student_id` from `Friend` instead of `h1.id` from multiple joined tables. Do select `liked_id` from `Likes` instead of filtering with `WHERE h1.id IN` subqueries. Do remove the `DISTINCT` keyword instead of keeping it since `INTERSECT` inherently returns unique values. Do eliminate the `Highschooler` table join instead of including unnecessary table relationships. Do remove the join conditions `h1.id = f.id1` and `h1.id = l.id2` instead of maintaining incorrect join logic. The amended query now correctly identifies students who are both friends and liked by someone, matching the RIGHT_SQL's behavior through set intersection rather than complex filtering."
        ],
        "rules": [
            "1) When answering about high schoolers who have friends and are also liked by someone else: use INTERSECT to find common IDs between the two conditions instead of complex joins and subqueries. 2) When selecting students who have friends: select \"student_id\" from \"Friend\" table instead of using joined tables. 3) When selecting students who are liked by someone: select \"liked_id\" from \"Likes\" table instead of filtering with WHERE subqueries. 4) When using INTERSECT operation: do not use DISTINCT keyword since INTERSECT inherently returns unique values. 5) When identifying students: eliminate unnecessary joins to the \"Highschooler\" table instead of including table relationships not needed for the intersection. 6) When combining results from \"Friend\" and \"Likes\" tables: do not use join conditions like \"h1.id = f.id1\" and \"h1.id = l.id2\" since INTERSECT handles the set operation without explicit joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT h1.id\nFROM Highschooler h1\nJOIN Friend f ON h1.id = f.id1\nJOIN Likes l ON h1.id = l.id2\nWHERE h1.id IN (SELECT id2 FROM Likes)\nAND h1.id IN (SELECT id1 FROM Friend);",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ],
        "rule_sql": [
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ]
    },
    "970": {
        "db_id": "dog_kennels",
        "question": "Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.",
        "ground_truth": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
        "amends": [
            "Do use `role_code` instead of `role` in the SELECT list to reference the correct column name. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate column while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When the question asks for \"role\" from the Professionals table: use the exact column name \"role_code\" instead of \"role\" in the output. 2) When filtering for cities containing the substring 'West': use the exact literal 'West' with case sensitivity and the LIKE operator pattern '%West%' to match any city containing this substring. 3) When selecting output columns for professionals: maintain the order role_code, street, city, state as specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT role, street, city, state FROM professionals WHERE city LIKE '%West%';",
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ],
        "rule_sql": [
            "SELECT role_code, street, city, state FROM Professionals WHERE city LIKE '%West%';"
        ]
    },
    "119": {
        "db_id": "car_1",
        "question": "What is the smallest weight of the car produced with 8 cylinders on 1974 ?",
        "ground_truth": "select min(weight) from cars_data where cylinders  =  8 and year  =  1974",
        "amends": [
            "Do use `MIN(weight)` instead of `MAX(weight)` for the aggregate function. Do reference table `cars_data` instead of `cars` as the data source. The amended query now correctly finds the minimum weight of 8-cylinder cars from 1974 rather than the maximum weight."
        ],
        "rules": [
            "1) When answering about \"smallest weight of the car produced with 8 cylinders on 1974\": use MIN(weight) instead of MAX(weight) for the aggregate function. 2) When referencing the data source: use table \"cars_data\" instead of \"cars\" as the data source. 3) When filtering for specific car characteristics: apply conditions where cylinders = 8 AND year = 1974 using exact numerical values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(weight) FROM cars WHERE cylinders = 8 AND year = 1974;",
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ],
        "rule_sql": [
            "SELECT MIN(Weight) FROM cars_data WHERE Cylinders = 8 AND Year = 1974;"
        ]
    },
    "234": {
        "db_id": "flight_2",
        "question": "Which airlines have a flight with source airport AHD?",
        "ground_truth": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
        "amends": [
            "Do add `JOIN FLIGHTS AS T2 ON T1.uid = T2.Airline` instead of querying only the airlines table. Do change the column selection to `T1.Airline` instead of `airline_name`. Do move the filter condition to `T2.SourceAirport = \"AHD\"` instead of `source_airport = 'AHD'` and use double quotes instead of single quotes for the string literal. Do add table alias `T1` for the airlines table instead of using it directly. The amended query now correctly joins the airlines and flights tables to find airlines operating from the specified source airport, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about airlines with flights from a specific source airport: join the airlines table (as T1) with the flights table (as T2) using the key relationship T1.uid = T2.Airline. 2) When the question mentions \"airlines\": select T1.Airline instead of airline_name. 3) When the question specifies source airport \"AHD\": filter using T2.SourceAirport = \"AHD\" with double quotes around the literal. 4) When combining T1 and T2 for shared entities: link rows where T1.uid = T2.Airline exactly and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name FROM airlines WHERE source_airport = 'AHD';",
            "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"AHD\""
        ],
        "rule_sql": [
            "SELECT T1.Airline FROM airlines T1 JOIN flights T2 ON T1.uid = T2.Airline WHERE T2.SourceAirport = \"AHD\""
        ]
    },
    "629": {
        "db_id": "tvshow",
        "question": "Find the production code and channel of the most recently aired cartoon .",
        "ground_truth": "select production_code ,  channel from cartoon order by original_air_date desc limit 1",
        "amends": [
            "Do reference the `cartoon` table instead of the `cartoons` table. Do use the `original_air_date` column for ordering instead of `air_date`. The amended query now correctly references the proper table name and date column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the most recently aired cartoon\": use the \"cartoon\" table instead of \"cartoons\" table. 2) When ordering by air date to find the most recent: use the \"original_air_date\" column for ordering instead of \"air_date\" column. 3) When finding the most recent record: order by date in descending order and keep only the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT production_code, channel FROM cartoons ORDER BY air_date DESC LIMIT 1;",
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ]
    },
    "468": {
        "db_id": "wta_1",
        "question": "What are the names of the winner and loser who played in the longest match?",
        "ground_truth": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
        "amends": [
            "Do reference the `minutes` column instead of `duration` in the ORDER BY clause. The amended query now correctly sorts by match length using the appropriate column name and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks about the \"longest match\": use the \"minutes\" column from the matches table to determine match length and sort in descending order. 2) When answering about names of winner and loser in the longest match: make sure the output order includes \"winner_name\" and \"loser_name\" columns. 3) When ranking to find the single longest match: take only the first row after sorting by \"minutes\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name, loser_name \nFROM matches \nORDER BY duration DESC \nLIMIT 1;",
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name, loser_name FROM matches ORDER BY minutes DESC LIMIT 1;"
        ]
    },
    "713": {
        "db_id": "world_1",
        "question": "What language is predominantly spoken in Aruba?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T2.Language` from the joined table instead of `language` from a single table. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do add a filter on `T1.Name = \"Aruba\"` instead of `name = 'Aruba'` with proper table qualification. Do add `ORDER BY Percentage DESC` and `LIMIT 1` to get the highest percentage language instead of returning all matching records without ordering or limiting. The amended query now correctly retrieves the most spoken language in Aruba by joining the country and countrylanguage tables and selecting the top result by percentage."
        ],
        "rules": [
            "1) When answering about \"predominantly spoken language\": make sure the output order: T2.Language. 2) When the question mentions \"Aruba\": \"Aruba\" actually means T1.Name = \"Aruba\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question mentions \"predominantly\" or asks for the most spoken language: rank rows by T2.Percentage in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM countries WHERE name = 'Aruba';",
            "SELECT T2.Language \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Language \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Aruba' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ]
    },
    "959": {
        "db_id": "dog_kennels",
        "question": "Find the arriving date and the departing date of the dogs that received a treatment.",
        "ground_truth": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and use `date_arrived` and `date_departed` instead of `arrival_date` and `departure_date`. Do join `Treatments` table on `dog_id` instead of filtering only by `treatment_received = 'yes'`, and reference the table as `Dogs AS T1` instead of just `dogs`. Do remove the `WHERE` clause filter entirely instead of keeping it, as the join condition now properly identifies dogs that have received treatments. The amended query now correctly returns distinct arrival and departure dates for dogs that have treatment records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"arriving date and departing date of dogs that received a treatment\": use \"date_arrived\" and \"date_departed\" columns from table \"Dogs\" instead of \"arrival_date\" and \"departure_date\". 2) When identifying dogs that received treatments: join \"Treatments\" table with \"Dogs AS T1\" using \"dog_id\" column instead of filtering by \"treatment_received = 'yes'\". 3) When returning results for dogs with treatments: ensure distinct arrival and departure dates by removing duplicate combinations of date_arrived and date_departed. 4) When combining Dogs and Treatments tables: link rows where T1.dog_id equals Treatments.dog_id and keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT arrival_date, departure_date FROM dogs WHERE treatment_received = 'yes';",
            "SELECT DISTINCT T1.date_arrived, T1.date_departed\nFROM Dogs AS T1\nJOIN Treatments ON T1.dog_id = Treatments.dog_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT d.date_arrived, d.date_departed\nFROM Dogs d\nINNER JOIN Treatments t ON d.dog_id = t.dog_id;"
        ]
    },
    "175": {
        "db_id": "car_1",
        "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .",
        "ground_truth": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;",
        "amends": [
            "Do add `JOIN model_list as t2 on t1.id = t2.maker` instead of querying `car_makers` alone. Do change the filter to use `GROUP BY t1.id HAVING count(*) >= 2` instead of `WHERE models >= 2`. Do add a second query with `INTERSECT` that includes `JOIN car_names as t3 on t2.model = t3.model` and `HAVING count(*) > 3` instead of the incorrect `car_makers > 3` condition. Do use proper table aliases `t1` for `car_makers` instead of direct table references. The amended query now correctly finds car makers with at least 2 models and more than 3 car names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about car makers with models and car names: combine car_makers as T1 with model_list as T2 where T1.id equals T2.maker, then combine with car_names as T3 where T2.model equals T3.model. 2) When counting models per car maker: group by T1.id and count using T2.model to find makers with at least 2 models. 3) When counting car names per car maker: group by T1.id and count using T3.model to find makers with more than 3 car names. 4) When combining both conditions: use INTERSECT to find car makers that satisfy both the model count and car name count requirements. 5) When selecting output: include T1.id and T1.maker for the final result."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, maker FROM car_makers WHERE models >= 2 AND car_makers > 3;",
            "SELECT t1.Id, t1.Maker\nFROM car_makers t1\nJOIN model_list t2 ON t1.Id = t2.Maker\nGROUP BY t1.Id\nHAVING COUNT(*) >= 2\nINTERSECT\nSELECT t1.Id, t1.Maker\nFROM car_makers t1\nJOIN model_list t2 ON t1.Id = t2.Maker\nJOIN car_names t3 ON t2.Model = t3.Model\nGROUP BY t1.Id\nHAVING COUNT(*) > 3"
        ],
        "rule_sql": [
            "SELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nGROUP BY T1.Id, T1.Maker\nHAVING COUNT(T2.Model) >= 2\nINTERSECT\nSELECT T1.Id, T1.Maker\nFROM car_makers T1\nJOIN model_list T2 ON T1.Id = T2.Maker\nJOIN car_names T3 ON T2.Model = T3.Model\nGROUP BY T1.Id, T1.Maker\nHAVING COUNT(T3.Model) > 3;"
        ]
    },
    "160": {
        "db_id": "car_1",
        "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?",
        "ground_truth": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );",
        "amends": [
            "Do reference the correct table name `CARS_DATA` instead of `cars`. Do use the column `Accelerate` in the outer query filter instead of `accelerate`. Do change the subquery to select `Accelerate` instead of `MAX(horsepower)` and use `ORDER BY Horsepower DESC LIMIT 1` instead of an aggregate function to find the maximum value. The amended query now correctly counts records where acceleration exceeds the acceleration value from the car with the highest horsepower, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When referencing the cars data table: use the exact table name \"CARS_DATA\" instead of \"cars\". 2) When filtering by acceleration: use the exact column name \"Accelerate\" with proper case. 3) When finding the car with the most horsepower: use \"ORDER BY Horsepower DESC LIMIT 1\" to get the single row with maximum horsepower rather than an aggregate function. 4) When comparing acceleration values: compare the \"Accelerate\" column value against the \"Accelerate\" value from the car with highest horsepower. 5) When counting cars: count all rows from \"CARS_DATA\" where the acceleration condition is satisfied."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cars \nWHERE accelerate > (SELECT MAX(horsepower) FROM cars)",
            "SELECT COUNT(*) \nFROM CARS_DATA \nWHERE Accelerate > (\n    SELECT Accelerate \n    FROM CARS_DATA \n    ORDER BY Horsepower DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate > (SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1);"
        ]
    },
    "3": {
        "db_id": "concert_singer",
        "question": "What are the names, countries, and ages for every singer in descending order of age?",
        "ground_truth": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do use `ORDER BY age DESC` instead of `ORDER BY age ASC` to sort in descending order rather than ascending order. The amended query now correctly references the intended table and produces the desired descending age ordering."
        ],
        "rules": [
            "1) When the question asks about singers: use the exact table name \"singer\" instead of \"singers\". 2) When ordering by age in descending order: sort by \"age\" column in descending direction (highest to lowest). 3) When selecting output columns: include \"name\", \"country\", and \"age\" in that exact order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country, age FROM singers ORDER BY age ASC;",
            "SELECT Name, Country, Age FROM singer ORDER BY Age DESC;"
        ],
        "rule_sql": [
            "SELECT name, country, age FROM singer ORDER BY age DESC;"
        ]
    },
    "105": {
        "db_id": "car_1",
        "question": "How many car makers are there in each continents? List the continent name and the count.",
        "ground_truth": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",
        "amends": [
            "Do add `CONTINENTS AS T1` and `COUNTRIES AS T2` tables with proper joins instead of querying only `car_makers`. Do use `JOIN COUNTRIES AS T2 ON T1.ContId = T2.continent` to connect continents to countries instead of missing this relationship. Do add `JOIN car_makers AS T3 ON T2.CountryId = T3.Country` to properly associate car makers with countries instead of directly grouping by continent from car_makers. Do select `T1.Continent` from the continents table instead of the potentially incorrect `continent` column from car_makers. The amended query now correctly handles the hierarchical relationship between continents, countries, and car makers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"car makers in each continent\": make sure to use the hierarchical relationship between continents, countries, and car makers instead of querying only the car_makers table. 2) When combining continents and countries: link rows where T1.ContId = T2.continent to connect continents to countries. 3) When combining countries and car makers: link rows where T2.CountryId = T3.Country to associate car makers with countries. 4) When selecting the continent name: use T1.Continent from the continents table instead of any other continent column. 5) When counting car makers per continent: count the number of car makers using the proper hierarchical relationship through countries rather than direct grouping by continent from car_makers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT continent, COUNT(*) FROM car_makers GROUP BY continent;",
            "SELECT T1.Continent, COUNT(T3.Id) AS CountOfCarMakers\nFROM continents AS T1\nJOIN countries AS T2 ON T1.ContId = T2.Continent\nJOIN car_makers AS T3 ON T2.CountryId = T3.Country\nGROUP BY T1.Continent"
        ],
        "rule_sql": [
            "SELECT c.Continent, COUNT(DISTINCT cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent\nORDER BY CarMakerCount DESC;"
        ]
    },
    "830": {
        "db_id": "orchestra",
        "question": "What is the average attendance of shows?",
        "ground_truth": "SELECT avg(Attendance) FROM SHOW",
        "amends": [
            "Do use the correct column name `Attendance` instead of the incorrect `show_name` column. Do reference the correct table name `SHOW` instead of the incorrect `shows` table. Do use lowercase `avg` function instead of uppercase `AVG` for consistency with the target query format. The amended query now correctly calculates the average attendance from the SHOW table instead of attempting to average an incorrect column name."
        ],
        "rules": [
            "1) When answering about \"average attendance of shows\": use the exact column name \"Attendance\" from the \"SHOW\" table. 2) When computing the average: use the lowercase \"avg\" function for consistency with the target query format. 3) When referencing the table containing attendance data: use the exact table name \"SHOW\" instead of any variations like \"shows\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(show_name) FROM shows;",
            "SELECT avg(Attendance) FROM show;"
        ],
        "rule_sql": [
            "SELECT avg(Attendance) FROM show"
        ]
    },
    "917": {
        "db_id": "network_1",
        "question": "What is the lowest grade of students who do not have any friends?",
        "ground_truth": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do reference table `Highschooler` instead of `students` in the FROM clause. Do use the correct subquery structure with `Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of `SELECT DISTINCT student_id FROM friends`. Do remove the WHERE clause filter entirely instead of keeping it, as the filtering logic is now handled within the subquery. The amended query now correctly identifies minimum grades from Highschooler where IDs are not found in the Friend relationship table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"lowest grade of students who do not have any friends\": make sure the output order: MIN(grade). 2) When the question mentions \"students\": \"students\" actually means \"Highschooler\" in schema. 3) When the question mentions \"friends\": \"friends\" actually means \"Friend\" in schema. 4) When combining Highschooler and Friend for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.student_id = T2.id); keep only matching pairs (inner match). 5) When identifying students without friends: find Highschooler rows where id values are not present in the Friend relationship table through the join condition T1.student_id = T2.id."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(grade) FROM students WHERE id NOT IN (SELECT DISTINCT student_id FROM friends);",
            "SELECT MIN(grade) FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend)"
        ],
        "rule_sql": [
            "SELECT MIN(grade) \nFROM Highschooler \nWHERE ID NOT IN (SELECT student_id FROM Friend)"
        ]
    },
    "436": {
        "db_id": "wta_1",
        "question": "What are the average ages of losers and winners across matches?",
        "ground_truth": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
        "amends": [
            "Do use direct column references `avg(loser_age)` and `avg(winner_age)` instead of calculating averages with `CASE` statements that check `m.winner_id = p.player_id` and `m.loser_id = p.player_id`. Do remove the `JOIN players p` clause entirely instead of joining on `m.winner_id = p.player_id OR m.loser_id = p.player_id` since the right query operates solely on the matches table without player data. Do query from only the `matches` table instead of joining with the `players` table, indicating the original query incorrectly attempted to access player age data that isn't needed for this aggregation. The amended query now correctly calculates averages from existing match data columns rather than attempting to join with unrelated player information."
        ],
        "rules": [
            "1) When calculating average ages of losers and winners across matches: use direct column references \"avg(loser_age)\" and \"avg(winner_age)\" instead of CASE statements that check player IDs. 2) When the question asks for average ages from match data: operate solely on the \"matches\" table without joining to the \"players\" table. 3) When aggregating match statistics: use the existing \"loser_age\" and \"winner_age\" columns in the \"matches\" table rather than attempting to access player age data through joins."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    AVG(CASE WHEN m.winner_id = p.player_id THEN p.age ELSE NULL END) AS avg_winner_age,\n    AVG(CASE WHEN m.loser_id = p.player_id THEN p.age ELSE NULL END) AS avg_loser_age\nFROM matches m\nJOIN players p ON m.winner_id = p.player_id OR m.loser_id = p.player_id",
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ],
        "rule_sql": [
            "SELECT AVG(loser_age) AS avg_loser_age, AVG(winner_age) AS avg_winner_age FROM matches;"
        ]
    },
    "1033": {
        "db_id": "real_estate_properties",
        "question": "What are the names of properties that are either houses or apartments with more than 1 room?",
        "ground_truth": "SELECT property_name FROM Properties WHERE property_type_code  =  \"House\" UNION SELECT property_name FROM Properties WHERE property_type_code  =  \"Apartment\" AND room_count  >  1",
        "amends": [
            "Do select `property_name` instead of `name` and use `UNION` to combine results instead of `OR` logic. Do reference table `Properties` instead of `properties` and use column `property_type_code` instead of `type`. Do use exact string values `\"House\"` and `\"Apartment\"` instead of `'house'` and `'apartment'`. Do use column `room_count` instead of `rooms` and apply the `room_count > 1` filter only to the apartment condition instead of applying it to both house and apartment conditions. The amended query now correctly separates the house selection (without room count restriction) from the apartment selection (with room count requirement) using UNION, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting property names: use \"property_name\" instead of \"name\" as the output column. 2) When the question mentions \"houses\" or \"apartments\": these correspond to exact string values \"House\" and \"Apartment\" in column \"property_type_code\". 3) When combining results for different property types: use UNION to separate house selection (without room count restriction) from apartment selection (with room count requirement). 4) When filtering apartments: apply room_count > 1 condition only to apartments, not to houses. 5) When referring to the table: use \"Properties\" (exact case) instead of \"properties\". 6) When counting rooms: use column \"room_count\" instead of \"rooms\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM properties WHERE type = 'house' OR type = 'apartment' AND rooms > 1;",
            "SELECT property_name FROM Properties WHERE property_type_code = 'House' UNION SELECT property_name FROM Properties WHERE property_type_code = 'Apartment' AND room_count > 1"
        ],
        "rule_sql": [
            "SELECT property_name FROM Properties WHERE property_type_code = 'House' \nUNION \nSELECT property_name FROM Properties WHERE property_type_code = 'Apartment' AND room_count > 1"
        ]
    },
    "8": {
        "db_id": "concert_singer",
        "question": "What are all distinct countries where singers above age 20 are from?",
        "ground_truth": "SELECT DISTINCT country FROM singer WHERE age  >  20",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause while keeping the same SELECT list with `DISTINCT country` and WHERE filter `age > 20` unchanged. The amended query now correctly references the singular table name and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks about singers: use the table \"singer\" instead of \"singers\" 2) When the question asks for distinct countries where singers above age 20 are from: select distinct values of the \"country\" column from the \"singer\" table where the \"age\" column is greater than 20"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM singers WHERE age > 20;",
            "SELECT DISTINCT country FROM singer WHERE age > 20"
        ],
        "rule_sql": [
            "SELECT DISTINCT Country FROM singer WHERE Age > 20"
        ]
    },
    "781": {
        "db_id": "world_1",
        "question": "Give the country codes for countries in which people speak langauges that are not English.",
        "ground_truth": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
        "amends": [
            "Do select `DISTINCT CountryCode` instead of `country_code` without distinct. Do query from `countrylanguage` table instead of `countries` table. Do filter with `LANGUAGE != \"English\"` instead of `language = 'English'`. Do use double quotes around string literal instead of single quotes. The amended query now correctly selects distinct country codes from the countrylanguage table where the language is not English, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting country codes from the countrylanguage table: use DISTINCT \"CountryCode\" to get unique values. 2) When filtering for languages that are not English: use LANGUAGE != \"English\" with double quotes around the literal. 3) When the question asks for countries where people speak languages that are not English: query from the countrylanguage table instead of the countries table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE language = 'English';",
            "SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != \"English\""
        ],
        "rule_sql": [
            "SELECT DISTINCT \"CountryCode\" FROM countrylanguage WHERE \"Language\" != \"English\""
        ]
    },
    "954": {
        "db_id": "dog_kennels",
        "question": "List the names of the dogs of the rarest breed and the treatment dates of them.",
        "ground_truth": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",
        "amends": [
            "Do use `T1.name` and `T2.date_of_treatment` as column aliases instead of `d.name` and `t.treatment_date`. Do reference table aliases `Dogs AS T1` and `Treatments AS T2` instead of `dogs d` and `treatments t`. Do join on `T1.dog_id = T2.dog_id` instead of `d.dog_id = t.dog_id`. Do filter on `T1.breed_code` instead of `d.breed`. Do use `breed_code` in the subquery instead of `breed` for both the selection and grouping. The amended query now correctly matches the RIGHT_SQL's behavior with proper column references and table aliasing."
        ],
        "rules": [
            "1) When answering about \"names of dogs and treatment dates\": make sure the output order: T1.name, T2.date_of_treatment\n2) When the question mentions \"breed\": \"breed\" actually means \"breed_code in schema\"\n3) When the question asks for \"rarest breed\": find the breed_code with the smallest count of dogs and use that value for filtering\n4) When combining T1 (Dogs) and T2 (Treatments) for shared entities: link rows where T1.dog_id = T2.dog_id; keep only matching pairs (inner match)\n5) When filtering for the rarest breed: use the exact breed_code value that has the minimum count from the Dogs table"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name, t.treatment_date \nFROM dogs d \nJOIN treatments t ON d.dog_id = t.dog_id \nWHERE d.breed = (SELECT breed FROM dogs GROUP BY breed ORDER BY COUNT(*) ASC LIMIT 1)",
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs AS T1\nJOIN Treatments AS T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T2.date_of_treatment;"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.date_of_treatment\nFROM Dogs T1\nINNER JOIN Treatments T2 ON T1.dog_id = T2.dog_id\nWHERE T1.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)\nORDER BY T1.name, T2.date_of_treatment;"
        ]
    },
    "560": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first name of the student whose permanent address is different from his or her current one?",
        "ground_truth": "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id",
        "amends": [
            "Do reference the correct table name `Students` instead of `students` to match the actual schema. Do compare the correct column identifiers `current_address_id` and `permanent_address_id` instead of `permanent_address` and `current_address` to properly evaluate address inequality using ID values rather than address text. The amended query now correctly filters students based on address ID mismatch and matches the intended behavior."
        ],
        "rules": [
            "1) When referencing table names from the schema: use exact case-sensitive identifier \"Students\" instead of lowercase \"students\". 2) When comparing permanent and current addresses: use column identifiers \"permanent_address_id\" and \"current_address_id\" instead of \"permanent_address\" and \"current_address\" to properly evaluate address inequality using ID values. 3) When filtering for students with different permanent and current addresses: compare \"Students\".\"permanent_address_id\" != \"Students\".\"current_address_id\" to identify address ID mismatches."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE permanent_address != current_address LIMIT 1;",
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ],
        "rule_sql": [
            "SELECT first_name FROM Students WHERE permanent_address_id != current_address_id;"
        ]
    },
    "340": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the names of documents that use templates with the code BK?",
        "ground_truth": "SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  \"BK\"",
        "amends": [
            "Do select `T2.document_name` instead of `d.name` for the column name. Do use `Templates AS T1` and `Documents AS T2` as table aliases instead of `documents d` and `templates t`. Do join on `T1.template_id = T2.template_id` instead of `d.template_id = t.id` for the join condition. Do filter on `T1.template_type_code = \"BK\"` instead of `t.code = 'BK'` for the WHERE condition. The amended query now correctly retrieves document names by joining on template_id and filtering by template_type_code instead of code, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of documents that use templates with code BK\": make sure the output order: T2.document_name. 2) When the question mentions \"documents\": use table \"Documents AS T2\" with exact alias T2. 3) When the question mentions \"templates with code BK\": use table \"Templates AS T1\" with exact alias T1 and filter on T1.template_type_code = \"BK\" with exact literal \"BK\". 4) When combining T1 and T2 for shared template relationships: link rows where T1.template_id = T2.template_id exactly as shown; keep only matching pairs (inner match)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.name FROM documents d JOIN templates t ON d.template_id = t.id WHERE t.code = 'BK';",
            "SELECT T2.Document_Name \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nWHERE T1.Template_Type_Code = 'BK'"
        ],
        "rule_sql": [
            "SELECT T2.Document_Name FROM Templates AS T1 INNER JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID WHERE T1.Template_Type_Code = 'BK'"
        ]
    },
    "183": {
        "db_id": "flight_2",
        "question": "List all airline names and their abbreviations in \"USA\".",
        "ground_truth": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use column aliases `Airline` and `Abbreviation` instead of the original column names `name` and `abbreviation`. Do reference the table name `AIRLINES` in uppercase instead of lowercase `airlines`. Do use double quotes `\"USA\"` for the string literal instead of single quotes `'USA'`. The amended query now correctly matches the RIGHT_SQL's behavior while maintaining the same logical result."
        ],
        "rules": [
            "1) When the question asks for airline names and abbreviations: use column aliases \"Airline\" and \"Abbreviation\" for the output columns. 2) When referencing the airlines table: use the exact table name \"AIRLINES\" in uppercase. 3) When filtering for country \"USA\": use double quotes around the literal value as \"USA\". 4) When the question specifies \"in USA\": filter rows where the country column equals \"USA\" exactly."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, abbreviation FROM airlines WHERE country = 'USA';",
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = \"USA\""
        ],
        "rule_sql": [
            "SELECT Airline AS \"Airline\", Abbreviation AS \"Abbreviation\" FROM AIRLINES WHERE Country = \"USA\""
        ]
    },
    "839": {
        "db_id": "orchestra",
        "question": "What is the name of the conductor who has worked the greatest number of years?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the `conductor` table instead of `conductors`. Do order by `Year_of_Work` instead of `years_worked` while maintaining the same DESC ordering and LIMIT 1 clause. The amended query now correctly references the proper table and column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about conductors: use the table \"conductor\" instead of \"conductors\". 2) When selecting the conductor's name: use the column \"Name\" instead of \"name\". 3) When ordering by years worked: use the column \"Year_of_Work\" instead of \"years_worked\" while maintaining descending order. 4) When finding the conductor with the greatest number of years worked: keep only the top result using LIMIT 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY years_worked DESC LIMIT 1;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1;"
        ]
    },
    "801": {
        "db_id": "world_1",
        "question": "Return the names and surface areas of the 5 largest countries.",
        "ground_truth": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
        "amends": [
            "Do use column names `Name` and `SurfaceArea` instead of `name` and `surface_area` to match the actual schema. Do order by `SurfaceArea DESC` instead of `ASC` to sort in descending order rather than ascending. Do query from table `country` instead of `countries` to reference the correct table name. The amended query now correctly retrieves the top 5 countries by surface area in descending order."
        ],
        "rules": [
            "1) When the question asks for \"names and surface areas\": use the exact column tokens \"Name\" and \"SurfaceArea\" from the country table. 2) When the question asks for the \"5 largest countries\": order by \"SurfaceArea\" in descending order and keep the first 5 rows. 3) When querying from the database: use the exact table name \"country\" instead of any other table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, surface_area FROM countries ORDER BY surface_area ASC LIMIT 5;",
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"
        ]
    },
    "9": {
        "db_id": "concert_singer",
        "question": "What are  the different countries with singers above age 20?",
        "ground_truth": "SELECT DISTINCT country FROM singer WHERE age  >  20",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause while keeping all other elements identical including the SELECT DISTINCT country and WHERE age > 20 filter, as the table name correction is the only change needed to match the schema."
        ],
        "rules": [
            "1) When the question asks about \"countries with singers\": use the exact table name \"singer\" instead of \"singers\" as specified in the schema. 2) When filtering for singers above age 20: apply the condition age > 20 to select only those rows. 3) When asking for different countries: use DISTINCT on the country column to return unique country values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT country FROM singers WHERE age > 20;",
            "SELECT DISTINCT Country FROM singer WHERE Age > 20"
        ],
        "rule_sql": [
            "SELECT DISTINCT Country FROM singer WHERE Age > 20;"
        ]
    },
    "577": {
        "db_id": "student_transcripts_tracking",
        "question": "How many different addresses do the students currently live?",
        "ground_truth": "SELECT count(DISTINCT current_address_id) FROM Students",
        "amends": [
            "Do use `count(DISTINCT current_address_id)` instead of `COUNT(*)` to count unique addresses rather than all rows. Do reference the `current_address_id` column instead of checking `address IS NOT NULL` to properly identify distinct address records. Do remove the `WHERE address IS NOT NULL` filter instead of keeping it since the distinct count inherently handles null values appropriately. The amended query now correctly counts distinct address identifiers rather than all student records with non-null address fields, matching the intended behavior."
        ],
        "rules": [
            "1) When counting different addresses that students currently live: use count(DISTINCT current_address_id) instead of COUNT(*) to count unique addresses rather than all rows. 2) When referencing address information: use the current_address_id column instead of checking address IS NOT NULL to properly identify distinct address records. 3) When handling null values in address counting: remove any WHERE address IS NOT NULL filter since the distinct count inherently handles null values appropriately."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE address IS NOT NULL",
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT current_address_id) FROM Students;"
        ]
    },
    "464": {
        "db_id": "wta_1",
        "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?",
        "ground_truth": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do reference `winner_rank_points` instead of `rank_points` in the SELECT list to correctly access the intended column from the matches table. The amended query now matches RIGHT_SQL's behavior by properly selecting the winner's rank points while maintaining the same grouping, ordering, and limiting logic.",
            "Do group by only `winner_name` instead of grouping by `winner_id`, `winner_name`, and `winner_rank_points`. Do maintain the same `SELECT` list with `winner_name` and `winner_rank_points` instead of changing it. Do keep the same `ORDER BY COUNT(*) DESC` and `LIMIT 1` instead of modifying them. The amended query now correctly aggregates by winner name only while preserving the selection of winner rank points, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"rank points\" of a player: use the exact column name \"winner_rank_points\" from the matches table to access the winner's rank points. 2) When counting matches won by players: count using the \"winner_name\" column to determine the number of wins per player. 3) When finding the player with the most wins: rank players by their win count in descending order and keep only the top-ranked player.",
            "1) When grouping by winner name to count matches won: group only by \"winner_name\" instead of including \"winner_id\" and \"winner_rank_points\" in the grouping. 2) When selecting columns after grouping by winner name: maintain the selection of both \"winner_name\" and \"winner_rank_points\" without changing the output columns. 3) When ordering results to find the player with most wins: order by the count of matches won in descending order and keep only the top result using LIMIT 1. 4) When counting matches won per player: count all rows for each winner name to determine the number of matches won."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name, rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_id, winner_name, winner_rank_points\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name, winner_rank_points\nFROM matches\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "398": {
        "db_id": "course_teach",
        "question": "What are the towns from which at least two teachers come from?",
        "ground_truth": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2",
        "amends": [
            "Do use column name `Hometown` instead of `town` and table name `teacher` instead of `teachers` to match the correct schema. Do change the comparison operator to `>= 2` instead of `> 1` to properly identify hometowns with at least two teachers, which correctly captures the same logical condition while using inclusive comparison."
        ],
        "rules": [
            "1) When the question mentions \"towns\": \"towns\" actually means \"Hometown\" in the teacher table. 2) When the question asks for \"at least two teachers\": use the comparison operator >= 2 to identify hometowns with at least two teachers. 3) When counting teachers per hometown: count using the Hometown column and group by Hometown to compute the number of teachers from each location. 4) When producing output: return only the Hometown column for locations that meet the condition of having >= 2 teachers."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT town FROM teachers GROUP BY town HAVING COUNT(*) > 1",
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ],
        "rule_sql": [
            "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2"
        ]
    },
    "279": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the name of the employee who got the highest one time bonus.",
        "ground_truth": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1",
        "amends": [
            "Do specify `t1.name` with table alias instead of just `name`. Do add `employee AS t1` and `evaluation AS t2` as FROM sources instead of just `employees`. Do add `JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID` instead of omitting the join. Do order by `t2.bonus` with table alias instead of just `bonus`. The amended query now correctly joins the employee and evaluation tables to access the bonus field and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the employee who got the highest one time bonus\": make sure the output order: t1.name. 2) When combining employee and evaluation tables: link rows where t1.Employee_ID = t2.Employee_ID and keep only matching pairs (inner match). 3) When the question mentions \"highest\" bonus: rank rows by t2.bonus in descending order and keep the first 1 row. 4) When selecting employee names: use t1.name with table alias instead of just name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM employees ORDER BY bonus DESC LIMIT 1;",
            "SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.Bonus DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT t1.Name\nFROM employee t1\nINNER JOIN evaluation t2 ON t1.Employee_ID = t2.Employee_ID\nORDER BY t2.Bonus DESC\nLIMIT 1;"
        ]
    },
    "739": {
        "db_id": "world_1",
        "question": "How many official languages are spoken in Afghanistan?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country` and `countrylanguage` tables with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying only the `languages` table. Do filter on `T1.Name = \"Afghanistan\"` and `IsOfficial = \"T\"` instead of filtering only on `country = 'Afghanistan'`. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly counts official languages for Afghanistan by properly joining the country and language tables with appropriate filtering conditions."
        ],
        "rules": [
            "1) When answering about \"official languages in Afghanistan\": make sure the output order: count of official languages. 2) When the question mentions \"Afghanistan\": \"Afghanistan\" actually means \"T1.Name\" in schema. 3) When the question mentions \"official languages\": \"official languages\" actually means \"T2.IsOfficial = 'T'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of official languages\": compute the number of rows using the canonical key token for languages (e.g., T2.CountryCode and T2.Language)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Afghanistan';",
            "SELECT COUNT(*) \nFROM country T1 \nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ]
    },
    "321": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all distinct template type codes for all templates.",
        "ground_truth": "SELECT DISTINCT template_type_code FROM Templates",
        "amends": [
            "Do select `template_type_code` instead of `template_type` and add `DISTINCT` instead of omitting it. Do reference table `Templates` instead of `templates` to match the correct case sensitivity. The amended query now correctly retrieves unique template type codes from the Templates table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"template type codes\": use the exact column name \"template_type_code\" from the Templates table. 2) When the question asks for \"distinct\" values: ensure only unique values of template_type_code are returned. 3) When referencing the Templates table: use the exact case-sensitive name \"Templates\" as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type FROM templates",
            "SELECT DISTINCT Template_Type_Code FROM Templates;"
        ],
        "rule_sql": [
            "SELECT DISTINCT template_type_code FROM Templates;"
        ]
    },
    "748": {
        "db_id": "world_1",
        "question": "What are the names of nations where both English and French are official languages?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "amends": [
            "Do use `INTERSECT` with two separate queries instead of a single `WHERE` clause with conflicting conditions. Do join `country AS T1` with `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `nations` table. Do filter for `T2.Language = \"English\"` and `T2.IsOfficial = \"T\"` in the first query instead of checking `official_languages = 'English'`. Do filter for `T2.Language = \"French\"` and `T2.IsOfficial = \"T\"` in the second query instead of checking `official_languages = 'French'`. Do select `T1.Name` from the joined tables instead of just `name` from a single table. The amended query now correctly identifies countries where both English and French are official languages by using an intersection of two separate queries with proper table joins and official language status checks."
        ],
        "rules": [
            "1) When answering about nations where both English and French are official languages: use an INTERSECT operation with two separate queries instead of a single WHERE clause with conflicting conditions. 2) When combining country and countrylanguage tables: join T1 (country) with T2 (countrylanguage) where T1.Code = T2.CountryCode. 3) When filtering for English as an official language: check T2.Language = \"English\" and T2.IsOfficial = \"T\". 4) When filtering for French as an official language: check T2.Language = \"French\" and T2.IsOfficial = \"T\". 5) When selecting the output: return T1.Name from the joined tables."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nations WHERE official_languages = 'English' AND official_languages = 'French';",
            "SELECT T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T'\nINTERSECT\nSELECT T1.Name \nFROM country T1 \nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
        ]
    },
    "614": {
        "db_id": "tvshow",
        "question": "What are all of the episodes ordered by ratings?",
        "ground_truth": "SELECT Episode FROM TV_series ORDER BY rating",
        "amends": [
            "Do select `Episode` instead of `*` for all columns. Do source from `TV_series` instead of `episodes` table. Do order by `rating` instead of `title DESC`."
        ],
        "rules": [
            "1) When selecting all columns from the TV_series table: use \"Episode\" instead of * to get only the episode column. 2) When querying episodes data: source from the \"TV_series\" table instead of an \"episodes\" table. 3) When ordering episodes by ratings: order by the \"rating\" column instead of \"title DESC\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM episodes ORDER BY title DESC;",
            "SELECT Episode FROM TV_series ORDER BY Rating;"
        ],
        "rule_sql": [
            "SELECT Episode FROM TV_series ORDER BY Rating;"
        ]
    },
    "559": {
        "db_id": "student_transcripts_tracking",
        "question": "Whose permanent address is different from his or her current address? List his or her first name.",
        "ground_truth": "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id",
        "amends": [
            "Do select from `Students` table instead of `people` table. Do filter with `current_address_id != permanent_address_id` instead of `permanent_address = current_address`. Do reference address ID columns instead of address value columns. The amended query now correctly identifies students whose current and permanent addresses differ by comparing their ID values rather than address content."
        ],
        "rules": [
            "1) When selecting from the database about students' addresses: use the \"Students\" table as the base table T1 instead of a \"people\" table. 2) When comparing permanent and current addresses: compare using the ID columns \"current_address_id\" and \"permanent_address_id\" instead of address value columns. 3) When filtering for different addresses: use the condition current_address_id != permanent_address_id to identify students whose permanent address differs from their current address. 4) When outputting results: include the \"first_name\" column from the Students table to list the student's first name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM people WHERE permanent_address = current_address;",
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ],
        "rule_sql": [
            "SELECT first_name FROM Students WHERE current_address_id != permanent_address_id"
        ]
    },
    "488": {
        "db_id": "wta_1",
        "question": "What is the first name, country code, and birth date of the player with the most winner rank points across all matches?",
        "ground_truth": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
        "amends": [
            "Do add `JOIN matches AS T2 ON T1.player_id = T2.winner_id` instead of querying only the `players` table without any join. Do reference columns with table aliases `T1.first_name`, `T1.country_code`, and `T1.birth_date` instead of unqualified column names. Do use `T2.winner_rank_points` in the `ORDER BY` clause instead of `winner_rank_points` which doesn't exist in the players table. The amended query now correctly joins players with matches to access winner ranking points and returns the intended result matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about player information with winner rank points: combine players table (T1) and matches table (T2) by linking rows where T1.player_id equals T2.winner_id, keeping only matching pairs. 2) When the question asks for \"most winner rank points\": rank rows by T2.winner_rank_points in descending order and keep the first 1 row. 3) When selecting output columns: return T1.first_name, T1.country_code, and T1.birth_date in that order. 4) When referring to columns: always use table aliases T1 for players table and T2 for matches table with exact column names as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, country_code, birth_date \nFROM players \nORDER BY winner_rank_points DESC \nLIMIT 1;",
            "SELECT T1.first_name, T1.country_code, T1.birth_date\nFROM players AS T1\nJOIN matches AS T2 ON T1.player_id = T2.winner_id\nORDER BY T2.winner_rank_points DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.country_code, T1.birth_date FROM players T1 JOIN matches T2 ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1"
        ]
    },
    "880": {
        "db_id": "network_1",
        "question": "Show me all grades that have at least 4 students.",
        "ground_truth": "SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4",
        "amends": [
            "Do reference the `Highschooler` table instead of `students` in the FROM clause. Do use `HAVING count(*) >= 4` instead of `WHERE student_count >= 4` to filter aggregated results. Do remove the `COUNT(*) as student_count` column from the SELECT list instead of including it, since only the `grade` grouping column is needed. Do remove the alias `student_count` instead of keeping it as the filter condition now directly uses the aggregate function. The amended query now correctly filters groups based on aggregate conditions using HAVING instead of WHERE and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"grades that have at least 4 students\": use the \"Highschooler\" table instead of \"students\" table. 2) When filtering groups based on aggregate conditions: use HAVING count(*) >= 4 instead of WHERE student_count >= 4. 3) When the question asks for \"all grades\" with a condition: only include the \"grade\" column in the output, not the count column. 4) When grouping by \"grade\": organize results by the \"grade\" column and compute the count of students per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) as student_count FROM students GROUP BY grade WHERE student_count >= 4;",
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler GROUP BY grade HAVING COUNT(*) >= 4"
        ]
    },
    "283": {
        "db_id": "employee_hire_evaluation",
        "question": "What is the name of the shop that is hiring the largest number of employees?",
        "ground_truth": "SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `hiring` table instead of `name` from the `shops` table. Do join `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying only the `shops` table. Do add `GROUP BY t1.shop_id` and aggregate with `count(*)` instead of using `employee_count` directly. Do order by `count(*) DESC` instead of `employee_count DESC` to count actual hires per shop. The amended query now correctly identifies the shop with the most hiring records rather than relying on a potentially incorrect employee_count field."
        ],
        "rules": [
            "1) When answering about \"shop hiring the largest number of employees\": make sure the output order: t2.name 2) When the question mentions \"shop name\": \"name\" actually means \"t2.name in schema\" 3) When combining hiring table and shops table for shared entities: link rows where t1.shop_id = t2.shop_id exactly as shown; keep only matching pairs (inner match) 4) When the question asks for \"count of employees hired per shop\": compute the number of rows using count(*) grouped by t1.shop_id 5) When the question mentions \"largest number\": rank rows by count(*) in descending direction and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM shops ORDER BY employee_count DESC LIMIT 1;",
            "SELECT t2.Name \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t1.Shop_ID \nORDER BY COUNT(*) DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.Name\nFROM hiring t1\nJOIN shop t2 ON t1.Shop_ID = t2.Shop_ID\nGROUP BY t1.Shop_ID\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1018": {
        "db_id": "singer",
        "question": "Show titles of songs and names of singers.",
        "ground_truth": "SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",
        "amends": [
            "Do specify explicit table aliases `T1` and `T2` instead of omitting them. Do use `JOIN` with an explicit `ON T1.Singer_ID = T2.Singer_ID` condition instead of querying a single table without joins. Do reference columns with table aliases as `T2.Title` and `T1.Name` instead of unqualified `title` and `name`. Do query from the `singer` table as `T1` and `song` table as `T2` instead of only the `songs` table. The amended query now correctly joins the singer and song tables to retrieve song titles with corresponding singer names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"titles of songs and names of singers\": make sure the output order: T2.Title, T1.Name 2) When combining singer table as T1 and song table as T2: link rows where T1.Singer_ID = T2.Singer_ID and keep only matching pairs (inner match) 3) When referencing columns from joined tables: always qualify column names with table aliases as T2.Title and T1.Name instead of unqualified column names 4) When querying multiple tables: always specify explicit table aliases T1 for singer table and T2 for song table instead of omitting them"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, name FROM songs",
            "SELECT T2.Title, T1.Name FROM singer T1 JOIN song T2 ON T1.Singer_ID = T2.Singer_ID"
        ],
        "rule_sql": [
            "SELECT T2.Title, T1.Name FROM singer AS T1 INNER JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID"
        ]
    },
    "290": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the total amount of bonus given in all the evaluations.",
        "ground_truth": "SELECT sum(bonus) FROM evaluation",
        "amends": [
            "Do use the column `bonus` instead of `salary` in the SELECT list aggregation. Do reference the table `evaluation` instead of `evaluations` in the FROM clause. The amended query now correctly calculates the sum of bonus amounts from the evaluation table."
        ],
        "rules": [
            "1) When the question asks for \"total amount of bonus\": use the exact column token \"bonus\" for aggregation instead of \"salary\". 2) When referencing the evaluation data: use the exact table name \"evaluation\" instead of \"evaluations\". 3) When calculating the total bonus amount: compute the sum of all values in the \"bonus\" column from the \"evaluation\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(salary) FROM evaluations;",
            "SELECT SUM(Bonus) AS Total_Bonus FROM evaluation;"
        ],
        "rule_sql": [
            "SELECT SUM(bonus) AS total_bonus FROM evaluation;"
        ]
    },
    "550": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
        "ground_truth": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "amends": [
            "Do add `JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id` instead of querying only the students table. Do change the state filter to `T2.state_province_county = 'NorthCarolina'` instead of `state = 'North Carolina'` since the state information is in the Addresses table. Do remove the `degree_program IS NULL` filter instead of keeping it, as the right query uses a different approach to filter students. Do add an `EXCEPT` clause with a subquery `SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id` instead of omitting it, which excludes enrolled students from the results. Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references for clarity and to handle multiple table instances. The amended query now correctly identifies North Carolina students who are not enrolled in any programs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students who live in North Carolina: use the Addresses table (T2) with state_province_county = 'NorthCarolina' instead of the students table for location filtering. 2) When combining students and addresses: link rows where T1.current_address_id = T2.address_id and keep only matching pairs (inner match). 3) When filtering for students not registered in any degree programs: exclude students who appear in the Student_Enrolment table by using an EXCEPT clause with SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id. 4) When handling the state value: use the exact literal 'NorthCarolina' (without space) as shown in the schema, not 'North Carolina'. 5) When using multiple table instances: maintain the alias plan where base students table is T1, addresses table is T2, and the exclusion subquery uses T3 for students and T4 for Student_Enrolment."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE state = 'North Carolina' AND degree_program IS NULL;",
            "SELECT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.last_name\nFROM Students AS T1\nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id\nWHERE T2.state_province_county = 'NorthCarolina'\nEXCEPT\nSELECT DISTINCT T3.last_name\nFROM Students AS T3\nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id"
        ]
    },
    "885": {
        "db_id": "network_1",
        "question": "What are the names of the high schoolers and how many friends does each have?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do specify `T2.name` from the `Highschooler` table instead of just `name` without table qualification. Do join `Friend AS T1` and `Highschooler AS T2` with an `INNER JOIN` on `T1.student_id = T2.id` instead of querying only the `high_schoolers` table. Do group by `T1.student_id` instead of grouping by `name` to ensure proper count aggregation per student. The amended query now correctly counts friends for each student by joining the Friend and Highschooler tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of high schoolers and how many friends each has\": make sure the output order: T2.name, COUNT(*) 2) When the question mentions \"high schoolers\": \"high schoolers\" actually means \"T2.name in schema\" from the Highschooler table 3) When combining Friend as T1 and Highschooler as T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"how many friends does each have\": compute the number of rows using T1.student_id as the grouping key to ensure proper count aggregation per student 5) When producing output: do not reorder columns beyond T2.name followed by the count of friends"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) FROM high_schoolers GROUP BY name;",
            "SELECT T2.name, COUNT(T1.friend_id) AS friend_count\nFROM Friend AS T1\nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) \nFROM Friend AS T1 \nINNER JOIN Highschooler AS T2 ON T1.student_id = T2.ID \nGROUP BY T1.student_id \nORDER BY T2.name, COUNT(*)"
        ]
    },
    "287": {
        "db_id": "employee_hire_evaluation",
        "question": "Find the number of employees hired in each shop; show the shop name as well.",
        "ground_truth": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
        "amends": [
            "Do select `count(*)` and `t2.name` instead of `shop_name` and `COUNT(*)`. Do join `hiring AS t1` with `shop AS t2` on `t1.shop_id = t2.shop_id` instead of querying only `employees` table. Do group by `t2.name` instead of `shop_id`. The amended query now correctly counts employees per shop name by joining the hiring and shop tables, matching the intended behavior.",
            "Do place the `count(*)` aggregate function first in the SELECT list instead of second, and do use lowercase `t2.name` instead of uppercase `t2.Name` while maintaining the same GROUP BY clause with lowercase `t2.name` instead of uppercase `t2.Name`. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about \"number of employees hired in each shop\": make sure the output order: shop name, then count of employees. 2) When the question mentions \"shop name\": \"shop name\" actually means \"t2.name\" in schema. 3) When combining hiring as T1 and shop as T2 for shared entities: link rows where T1.shop_id = T2.shop_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"count of employees\": compute the number of rows using the canonical key from the hiring table. 5) When the question says \"per shop\"/\"by shop\": organize results by t2.name and compute the count per group.",
            "1) When answering about \"number of employees hired in each shop\": make sure the output order: count(*) first, then shop name. 2) When referring to the shop name column: use lowercase \"t2.name\" instead of uppercase \"t2.Name\" for both SELECT and GROUP BY clauses. 3) When counting employees per shop: use count(*) to count all rows in the hiring table for each shop group."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shop_name, COUNT(*) FROM employees GROUP BY shop_id;",
            "SELECT t2.Name, COUNT(*) \nFROM hiring AS t1 \nJOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t2.Name",
            "SELECT count(*), t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID GROUP BY t2.name"
        ],
        "rule_sql": [
            "SELECT t2.name, COUNT(*) \nFROM hiring AS t1 \nINNER JOIN shop AS t2 ON t1.Shop_ID = t2.Shop_ID \nGROUP BY t2.name \nORDER BY COUNT(*), t2.name"
        ]
    },
    "811": {
        "db_id": "world_1",
        "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .",
        "ground_truth": "select sum(population) ,  avg(surfacearea) from country where continent  =  \"north america\" and surfacearea  >  3000",
        "amends": [
            "Do use `surfacearea` column name instead of `surface_area` to match the actual schema. Do remove the `AS total_population` and `AS avg_surface_area` aliases instead of keeping them. Do use double quotes `\"north america\"` instead of single quotes for the string literal. Do reference the `country` table instead of `countries` to use the correct table name. The amended query now correctly calculates the total population and average surface area for North American countries with surface area greater than 3000, matching the intended behavior.",
            "Do maintain the exact same query structure with identical SELECT list containing `SUM(Population)` and `AVG(SurfaceArea)`, identical FROM source `country`, identical WHERE filters `Continent = \"North America\"` and `SurfaceArea > 3000`, and identical aggregation behavior instead of making any changes, as both queries are functionally equivalent despite minor formatting differences in spacing and case. The amended query now matches RIGHT_SQL's behavior with no substantive changes required.",
            "Do use identical `SUM(Population)` and `AVG(SurfaceArea)` expressions instead of changing them, maintain the same `FROM country` source instead of altering it, preserve the exact `WHERE Continent = \"North America\" AND SurfaceArea > 3000` filter conditions instead of modifying them, and keep the same aggregation structure without adding GROUP BY or HAVING clauses instead of introducing them. The amended query now matches RIGHT_SQL's behavior with identical logic and results.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior with no functional differences.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent despite minor formatting differences.",
            "Do maintain the exact same SELECT list with `SUM(Population)` and `AVG(SurfaceArea)` instead of changing any aggregate functions or column references. Do preserve the FROM clause with single table `country` instead of adding or removing any data sources. Do keep the WHERE filter conditions exactly as `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying any predicate logic or values. Do maintain the same aggregation structure without GROUP BY/HAVING clauses instead of adding unnecessary grouping. The amended query now correctly matches the intended behavior by preserving all logical components unchanged from the original formulation.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent with only insignificant formatting differences.",
            "Do use identical SQL logic with the same `SUM(Population)` and `AVG(SurfaceArea)` aggregates instead of changing them. Do maintain the exact same `FROM country` source instead of altering it. Do preserve the identical `WHERE` filter conditions `Continent = \"North America\"` and `SurfaceArea > 3000` instead of modifying them. The amended query now matches RIGHT_SQL's behavior as both queries are functionally equivalent with only insignificant formatting differences."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) AS total_population, AVG(surface_area) AS avg_surface_area \nFROM countries \nWHERE continent = 'North America' AND surface_area > 3000;",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000",
            "SELECT SUM(Population), AVG(SurfaceArea) FROM country WHERE Continent = \"North America\" AND SurfaceArea > 3000"
        ],
        "rule_sql": []
    },
    "438": {
        "db_id": "wta_1",
        "question": "What is the average rank for winners in all matches?",
        "ground_truth": "SELECT avg(winner_rank) FROM matches",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(winner_rank) FROM matches WHERE winner_rank IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT AVG(winner_rank) AS average_winner_rank FROM matches WHERE winner_rank IS NOT NULL;"
        ]
    },
    "649": {
        "db_id": "poker_player",
        "question": "List the earnings of poker players in descending order.",
        "ground_truth": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC",
        "amends": [
            "Do select `Earnings` instead of `player_name, earnings` and remove the player_name column. Do reference table `poker_player` instead of `poker_players` with the correct table name. Do order by `Earnings DESC` instead of `earnings ASC` with the correct column name and descending order instead of ascending. The amended query now correctly selects only earnings from the poker_player table in descending order."
        ],
        "rules": [
            "1) When the question asks for \"earnings of poker players\": select only the \"Earnings\" column from the \"poker_player\" table. 2) When ordering earnings in descending order: sort the results by \"Earnings\" in descending direction (highest to lowest). 3) When the schema shows column names with exact case: use \"Earnings\" exactly as shown in the schema, not \"earnings\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, earnings FROM poker_players ORDER BY earnings ASC;",
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ],
        "rule_sql": [
            "SELECT Earnings FROM poker_player ORDER BY Earnings DESC;"
        ]
    },
    "100": {
        "db_id": "car_1",
        "question": "What is the name of the different car makers who produced a car in 1970?",
        "ground_truth": "SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';",
        "amends": [
            "Do add explicit table joins with `CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id = T2.Maker JOIN CAR_NAMES AS T3 ON T2.model = T3.model JOIN CARS_DATA AS T4 ON T3.MakeId = T4.id` instead of querying a single `cars` table. Do reference the maker column as `T1.Maker` instead of just `maker`. Do filter on `T4.year = '1970'` with string comparison instead of numeric `year = 1970`. The amended query now correctly joins multiple tables to establish the proper relationship between car makers and their 1970 models, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about car makers who produced cars in 1970: join tables CAR_MAKERS AS T1, MODEL_LIST AS T2, CAR_NAMES AS T3, and CARS_DATA AS T4 using the exact relationships T1.Id = T2.Maker, T2.model = T3.model, and T3.MakeId = T4.id. 2) When filtering for cars produced in 1970: use T4.year = '1970' with string comparison instead of numeric comparison. 3) When selecting car maker names: use T1.Maker as the exact column reference instead of just maker. 4) When ensuring distinct car makers: return only unique values of T1.Maker."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT maker FROM cars WHERE year = 1970;",
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Maker\nFROM car_makers AS T1\nJOIN model_list AS T2 ON T1.Id = T2.Maker\nJOIN car_names AS T3 ON T2.Model = T3.Model\nJOIN cars_data AS T4 ON T3.MakeId = T4.Id\nWHERE T4.Year = '1970';"
        ]
    },
    "389": {
        "db_id": "course_teach",
        "question": "Show the name of teachers aged either 32 or 33?",
        "ground_truth": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "amends": [
            "Do use `OR` between the age conditions instead of `AND` to find teachers who are either 32 or 33 years old instead of requiring both conditions simultaneously. Do reference the correct table name `teacher` instead of `teachers` and use proper column casing with `Name` and `Age` instead of lowercase `name` and `age`. The amended query now correctly returns teachers who are either 32 or 33 years old, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for teachers aged either 32 or 33: use OR between the age conditions instead of AND to find teachers who meet either condition. 2) When referencing the teacher table: use the exact table name \"teacher\" instead of \"teachers\". 3) When selecting the name column: use the exact column name \"Name\" with proper casing instead of lowercase \"name\". 4) When filtering by age: use the exact column name \"Age\" with proper casing instead of lowercase \"age\". 5) When specifying age values: use the exact literals \"32\" and \"33\" as shown in the schema sample values."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM teachers WHERE age = 32 AND age = 33;",
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ],
        "rule_sql": [
            "SELECT Name FROM teacher WHERE Age = '32' OR Age = '33';"
        ]
    },
    "795": {
        "db_id": "world_1",
        "question": "How many cities in each district have a population that is above the average population across all cities?",
        "ground_truth": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",
        "amends": [
            "Do use `count(*)` without an alias instead of `COUNT(*) as city_count`. Do capitalize `District` in the SELECT list instead of lowercase `district`. Do capitalize `Population` in the WHERE clause instead of lowercase `population`. Do capitalize `avg(Population)` in the subquery instead of `AVG(population)`. Do capitalize `District` in the GROUP BY clause instead of lowercase `district`. The amended query now correctly matches the behavior of the RIGHT_SQL with proper column capitalization while maintaining the same logical structure for counting cities by district where population exceeds the average.",
            "Do place `count(*)` before `District` in the SELECT list instead of the reverse order. Do maintain the same aggregate function `COUNT(*)` and grouping column `District` instead of changing them. Do keep the same FROM source `city` instead of modifying it. Do preserve the WHERE filter comparing `Population` to the subquery result instead of altering it. Do retain the identical subquery calculating `avg(Population)` from `city` instead of modifying it. Do maintain the GROUP BY clause on `District` instead of changing it. The amended query now matches RIGHT_SQL's behavior with identical logic despite the column ordering difference in the SELECT clause."
        ],
        "rules": [
            "1) When the question asks for \"cities in each district\": organize results by the exact column token \"District\" from table city and compute counts per group. 2) When the question mentions \"population\": \"population\" actually means column \"Population\" in table country. 3) When combining city and country tables for population data: link rows where the canonical keys are equal as shown in the schema (city and country join condition); keep only matching pairs (inner match). 4) When counting cities: compute the number of rows using the canonical key for cities. 5) When filtering for population above average: compare \"Population\" values against the average of all \"Population\" values from country table. 6) When producing output: make sure the output order is \"District\" followed by the count.",
            "1) When answering about \"How many cities in each district have a population that is above the average population across all cities?\": make sure the output order: count(*) before District. 2) When the question asks for \"count of cities\": compute the number of rows using the canonical key for cities. 3) When the question says \"per district\"/\"by district\": organize results by the token for District and compute requested aggregates per group. 4) When the question asks for cities with population above average: filter rows where Population > (SELECT AVG(Population) FROM city) instead of altering this condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT district, COUNT(*) as city_count\nFROM city\nWHERE population > (SELECT AVG(population) FROM city)\nGROUP BY district;",
            "SELECT District, COUNT(*) \nFROM city \nWHERE Population > (SELECT AVG(Population) FROM city) \nGROUP BY District",
            "SELECT count(*), District FROM city WHERE Population > (SELECT avg(Population) FROM city) GROUP BY District"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS city_count, c.District \nFROM city c\nJOIN country co ON c.CountryCode = co.Code\nWHERE c.Population > (SELECT AVG(Population) FROM city)\nGROUP BY c.District\nORDER BY city_count DESC, c.District;"
        ]
    },
    "915": {
        "db_id": "network_1",
        "question": "What is the average grade of students who have friends?",
        "ground_truth": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do select `avg(grade)` from `Highschooler` instead of `AVG(grade)` from `students`. Do use a subquery with `id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)` instead of filtering with `WHERE friend_count > 0`. Do join `Friend` table with `Highschooler` on `T1.student_id = T2.id` instead of relying on a direct `friend_count` column. The amended query now correctly identifies students who have friends by checking the Friend relationship table rather than assuming a friend_count column exists, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average grade of students who have friends\": make sure the output order: avg(grade). 2) When the question mentions \"students who have friends\": use a subquery with id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id) instead of filtering with friend_count > 0. 3) When combining Friend and Highschooler tables: link rows where T1.student_id = T2.id and keep only matching pairs (inner match). 4) When computing average grade: use avg(grade) from Highschooler table instead of AVG(grade) from students table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(grade) FROM students WHERE friend_count > 0",
            "SELECT AVG(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ],
        "rule_sql": [
            "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id)"
        ]
    },
    "541": {
        "db_id": "student_transcripts_tracking",
        "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.",
        "ground_truth": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use `JOIN` on `T1.student_id = T2.student_id` instead of `LEFT JOIN` on `s.id = e.student_id`. Do reference `T1.student_id` instead of `s.id` in the SELECT list and GROUP BY. Do use `count(*)` instead of `COUNT(e.program_id)` for enrollment counting. Do reference `Student_Enrolment AS T2` instead of `enrollments e` as the join table. Do include `T1.student_id` in the SELECT list instead of `s.student_id`. The amended query now correctly counts enrollments using an inner join and proper column references to match the intended behavior.",
            "Do remove `T1.first_name`, `T1.middle_name`, and `T1.last_name` from the GROUP BY clause instead of including them, since they are functionally dependent on `T1.student_id`. Do change the ORDER BY to reference `count(*)` directly instead of using the alias `enrollment_count`, as the alias is not available at that point in query processing. The amended query now correctly groups only by the primary key and orders by the aggregate function directly, matching the RIGHT_SQL's behavior.",
            "Do include `T1.student_id` in the SELECT list instead of omitting it, as it must be present when used in GROUP BY. Do use the same column reference `T1.student_id` in both SELECT and GROUP BY instead of having inconsistent column usage. Do maintain the aggregate function `count(*)` without an alias instead of adding `AS enrollment_count`, as the RIGHT_SQL uses the unaliased version. The amended query now correctly includes all necessary columns for grouping and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by this column and it must be included in the selection. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same JOIN condition on `T1.student_id = T2.student_id`, GROUP BY on `T1.student_id`, ORDER BY on `count(*) DESC`, and LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as it must be included when using GROUP BY on that column to ensure proper aggregation behavior. The amended query now correctly includes all necessary columns in both SELECT and GROUP BY clauses to match the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output. The amended query now correctly includes all necessary columns while maintaining the same join condition, grouping, ordering, and limit behavior as the RIGHT_SQL.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output for consistency and clarity. The amended query now correctly includes all referenced columns in the SELECT clause while maintaining the same join logic, grouping, ordering, and limit behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id` and grouping by `T1.student_id` with ordering by `count(*) DESC` and limiting to 1 result. The amended query now correctly includes all necessary columns while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the GROUP BY on `T1.student_id` with ORDER BY `count(*) DESC` and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the result set.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by this column and it must be included in the selection. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `T1.student_id = T2.student_id` and preserving the aggregation count with GROUP BY on `T1.student_id` and ORDER BY on `count(*) DESC` with LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including all necessary columns in the selection.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, as the GROUP BY clause groups by `T1.student_id` but the original SELECT list did not include this grouped column which would cause an error in strict SQL mode. The amended query now correctly includes all non-aggregated columns from the GROUP BY clause in the SELECT list, maintaining the same join condition, grouping, ordering, and limit behavior while fixing the column reference issue.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same JOIN condition on `T1.student_id = T2.student_id`, GROUP BY on `T1.student_id`, ORDER BY on `count(*) DESC`, and LIMIT 1. The amended query now correctly includes all necessary columns and matches the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id`, the same grouping by `T1.student_id`, the same ordering by `count(*) DESC`, and the same limit of `1` record. The amended query now correctly includes all necessary columns in the SELECT clause while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the GROUP BY column is properly included in the output while maintaining the same join condition using `JOIN` on `T1.student_id = T2.student_id` and grouping by `T1.student_id` with ordering by `count(*) DESC` and limiting to 1 result. The amended query now correctly includes all necessary columns while preserving the original logic and matching the RIGHT_SQL's behavior.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the grouping by `T1.student_id` with count aggregation and descending order by count with limit 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the result set.",
            "Do add `T1.student_id` to the SELECT list instead of omitting it, which ensures the grouped column is properly included in the output while maintaining the same join condition on `T1.student_id = T2.student_id` and preserving the GROUP BY on `T1.student_id` with ORDER BY `count(*) DESC` and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by including the grouped column in the selection."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.id, s.first_name, s.middle_name, s.last_name, COUNT(e.program_id) as enrollment_count, s.student_id\nFROM students s\nLEFT JOIN enrollments e ON s.id = e.student_id\nGROUP BY s.id\nORDER BY enrollment_count DESC\nLIMIT 1;",
            "SELECT \n    T1.student_id,\n    T1.first_name,\n    T1.middle_name,\n    T1.last_name,\n    COUNT(*) AS enrollment_count,\n    T1.student_id\nFROM \n    Students AS T1\nJOIN \n    Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY \n    T1.student_id, T1.first_name, T1.middle_name, T1.last_name\nORDER BY \n    enrollment_count DESC\nLIMIT 1",
            "SELECT \n    T1.student_id,\n    T1.first_name,\n    T1.middle_name,\n    T1.last_name,\n    COUNT(*) AS enrollment_count\nFROM \n    Students AS T1\nJOIN \n    Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY \n    T1.student_id\nORDER BY \n    COUNT(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1",
            "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, count(*)\nFROM Students AS T1\nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id\nGROUP BY T1.student_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "833": {
        "db_id": "orchestra",
        "question": "Return the maximum and minimum shares for performances that do not have the type \"Live final\".",
        "ground_truth": "SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != \"Live final\"",
        "amends": [
            "Do reference column `SHARE` instead of `shares` in both aggregate functions. Do use table `performance` instead of `performances` as the FROM source. Do change the WHERE filter to `TYPE != \"Live final\"` instead of `type = 'Live final'` to exclude rather than include those records. Do correct the column case to `SHARE` and table name to `performance` to match the actual schema. The amended query now correctly calculates maximum and minimum share values from the performance table excluding Live final entries, matching the RIGHT_SQL behavior."
        ],
        "rules": [
            "1) When the question asks for maximum and minimum shares: use MAX(\"SHARE\") and MIN(\"SHARE\") as the aggregate functions. 2) When the question specifies performances that do not have type \"Live final\": filter records using WHERE \"TYPE\" != \"Live final\" to exclude rather than include. 3) When referencing the performance table: use the exact table name \"performance\" (not \"performances\"). 4) When handling column names: use exact case-sensitive identifiers \"SHARE\" and \"TYPE\" with double quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(shares), MIN(shares) FROM performances WHERE type = 'Live final';",
            "SELECT MAX(SHARE) AS max_share, MIN(SHARE) AS min_share FROM performance WHERE Type != 'Live final'"
        ],
        "rule_sql": [
            "SELECT MAX(\"SHARE\") AS max_share, MIN(\"SHARE\") AS min_share FROM \"performance\" WHERE \"TYPE\" != \"Live final\""
        ]
    },
    "790": {
        "db_id": "world_1",
        "question": "What are the population, name and leader of the country with the largest area?",
        "ground_truth": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do select `Name`, `population`, and `HeadOfState` instead of `population`, `name`, and `leader`. Do reference table `country` instead of `countries`. Do order by `SurfaceArea` instead of `area`. The amended query now correctly selects the appropriate columns from the right table with proper column names and ordering criteria."
        ],
        "rules": [
            "1) When answering about \"country with the largest area\": use table \"country\" instead of \"countries\". 2) When selecting columns for population, name, and leader: use exact column tokens \"Name\", \"population\", and \"HeadOfState\" respectively. 3) When ordering by area to find the largest: use column \"SurfaceArea\" instead of \"area\" and order in descending direction. 4) When retrieving the top result: keep only the first row after ordering by \"SurfaceArea\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT population, name, leader FROM countries ORDER BY area DESC LIMIT 1;",
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name, Population, HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1;"
        ]
    },
    "450": {
        "db_id": "wta_1",
        "question": "How many matches were played in 2013 or 2016?",
        "ground_truth": "SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016",
        "amends": [
            "Do use `OR` operator between year conditions instead of `AND` operator, changing `year = 2013 AND year = 2016` to `YEAR = 2013 OR YEAR = 2016` to correctly count matches from either 2013 or 2016 instead of incorrectly requiring both conditions simultaneously. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for matches in multiple years using \"or\" logic: use OR operator between year conditions instead of AND operator to include matches from either year. 2) When counting matches: count all rows that satisfy the year condition using COUNT(*). 3) When handling year literals: use exact numeric values 2013 and 2016 without quotes as shown in the amends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 AND year = 2016;",
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2013 OR year = 2016"
        ]
    },
    "719": {
        "db_id": "world_1",
        "question": "How long is the people\u2019s average life expectancy in Central Africa?",
        "ground_truth": "SELECT avg(LifeExpectancy) FROM country WHERE Region  =  \"Central Africa\"",
        "amends": [
            "Do reference the `LifeExpectancy` column instead of `life_expectancy`, use the `country` table instead of `countries`, and filter on `Region` instead of `region` while maintaining the same aggregate function and filter logic. The amended query now correctly references the schema elements and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"life expectancy\": use the exact column name \"LifeExpectancy\" from the country table. 2) When the question mentions \"Central Africa\": use the exact literal value 'Central Africa' with the exact column name \"Region\" from the country table. 3) When the question asks for \"average life expectancy\": compute the average of the \"LifeExpectancy\" column values. 4) When filtering by region: only include rows where the \"Region\" column equals exactly 'Central Africa'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(life_expectancy) FROM countries WHERE region = 'Central Africa';",
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = 'Central Africa';"
        ],
        "rule_sql": [
            "SELECT AVG(LifeExpectancy) FROM country WHERE Region = 'Central Africa'"
        ]
    },
    "506": {
        "db_id": "battle_death",
        "question": "What are the notes of the death events which has substring 'East'?",
        "ground_truth": "SELECT note FROM death WHERE note LIKE '%East%'",
        "amends": [
            "Do reference the `note` column instead of `notes` in the SELECT list. Do query from the `death` table instead of `death_events` as the FROM source. Do filter on `note LIKE '%East%'` instead of `location LIKE '%East%'` in the WHERE clause. The amended query now correctly retrieves notes containing 'East' from the appropriate table and column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"notes\" of death events: use the exact column name \"note\" from the death table instead of \"notes\". 2) When querying death events: use the \"death\" table instead of \"death_events\" as the data source. 3) When filtering for events containing 'East': apply the filter condition \"note LIKE '%East%'\" instead of filtering on location columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT notes FROM death_events WHERE location LIKE '%East%';",
            "SELECT note FROM death WHERE note LIKE '%East%'"
        ],
        "rule_sql": [
            "SELECT note FROM death WHERE note LIKE '%East%'"
        ]
    },
    "297": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many documents do we have?",
        "ground_truth": "SELECT count(*) FROM Documents",
        "amends": [
            "Do use lowercase `count(*)` instead of uppercase `COUNT(*)` to match the function casing. Do reference the table as `Documents` with proper case instead of lowercase `documents` to maintain schema object naming consistency. The amended query now correctly matches the RIGHT_SQL's behavior with proper function and table name casing."
        ],
        "rules": [
            "1) When counting documents: use the exact table name \"Documents\" with proper case instead of lowercase \"documents\". 2) When using the count function: use lowercase \"count(*)\" instead of uppercase \"COUNT(*)\" to match function casing."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE id = 1;",
            "SELECT count(*) FROM Documents;"
        ],
        "rule_sql": [
            "SELECT count(*) FROM Documents;"
        ]
    },
    "1011": {
        "db_id": "singer",
        "question": "What is the name of the singer who is worth the most?",
        "ground_truth": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` and use the correct table name `singer` instead of `singers`. Do order by `Net_Worth_Millions` instead of `net_worth` to use the proper column name for sorting by net worth in millions. The amended query now correctly selects from the singer table and orders by the appropriate net worth column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about singers: use the exact table name \"singer\" instead of \"singers\". 2) When selecting the name of a singer: use the exact column name \"Name\" from the singer table. 3) When ordering by net worth to find the highest value: use the exact column name \"Net_Worth_Millions\" for sorting in descending order. 4) When finding the singer with the highest net worth: take only the first row after ordering by \"Net_Worth_Millions\" in descending order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM singers ORDER BY net_worth DESC LIMIT 1;",
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1;"
        ]
    },
    "463": {
        "db_id": "wta_1",
        "question": "Find the name and rank points of the winner who won the most times.",
        "ground_truth": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `winner_name` and `winner_rank_points` instead of `name` and `rank_points`. Do add `GROUP BY winner_name` instead of omitting it, as aggregation requires grouping. Do keep `ORDER BY count(*) DESC` and `LIMIT 1` unchanged. The amended query now correctly aggregates match counts per winner before ordering and limiting, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"name and rank points\": select \"winner_name\" and \"winner_rank_points\" from the matches table. 2) When counting the number of wins per winner: group the results by \"winner_name\" to aggregate match counts for each distinct winner. 3) When finding the winner with the most wins: order the results by the count of matches in descending order and keep only the first row (top result)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, rank_points FROM winners ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT winner_name, winner_rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name, winner_rank_points FROM matches GROUP BY winner_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "20": {
        "db_id": "concert_singer",
        "question": "How many concerts are there in year 2014 or 2015?",
        "ground_truth": "SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015",
        "amends": [
            "Do use `OR` instead of `AND` for the year filter to correctly count concerts from either 2014 or 2015 instead of incorrectly requiring concerts to be from both years simultaneously. Do reference table `concert` instead of `concerts` to match the correct table name. The amended query now correctly counts concerts from either 2014 or 2015, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about concerts: use the exact table name \"concert\" instead of \"concerts\". 2) When filtering for multiple years with \"or\" logic: use OR between year conditions instead of AND to include records from either year. 3) When counting concerts from year 2014 or 2015: filter where year equals 2014 OR year equals 2015 to correctly include concerts from either year rather than requiring both years simultaneously."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM concerts WHERE year = 2014 AND year = 2015;",
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM concert WHERE Year = '2014' OR Year = '2015';"
        ]
    },
    "592": {
        "db_id": "tvshow",
        "question": "What is the name and directors of all the cartoons that are ordered by air date?",
        "ground_truth": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",
        "amends": [
            "Do use column names `title` and `Directed_by` instead of `name` and `directors`. Do reference table `Cartoon` instead of `cartoons`. Do order by `Original_air_date` instead of `release_date`. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [
            "1) When the question asks for \"name\" of cartoons: use column \"title\" from table \"Cartoon\" instead. 2) When the question asks for \"directors\" of cartoons: use column \"Directed_by\" from table \"Cartoon\" instead. 3) When the question mentions ordering by \"air date\": use column \"Original_air_date\" from table \"Cartoon\" for ordering. 4) When answering about cartoons ordered by air date: make sure the output order includes \"title\" and \"Directed_by\" columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, directors FROM cartoons ORDER BY release_date;",
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ],
        "rule_sql": [
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ]
    },
    "65": {
        "db_id": "pets_1",
        "question": "Find the first name and age of students who have a dog but do not have a cat as a pet.",
        "ground_truth": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "amends": [
            "Do use explicit table aliases `T1.fname` and `T1.age` instead of direct column references `first_name` and `age`. Do join tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` with proper join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of querying a single table. Do filter on `T3.pettype = 'dog'` instead of `pet = 'dog'`. Do add a subquery exclusion with `T1.stuid NOT IN` to find students with dogs but not cats instead of the incorrect `pet != 'cat'` filter that would never match due to the contradictory `pet = 'dog'` condition. The amended query now correctly identifies students who have dogs but no cats by properly joining across multiple tables and using a subquery for exclusion logic."
        ],
        "rules": [
            "1) When answering about \"first name and age of students\": make sure the output order: T1.fname, T1.age\n2) When the question mentions \"students\": use table \"student\" with alias T1\n3) When combining tables for student-pet relationships: link T1 (student) and T2 (has_pet) where T1.stuid = T2.stuid, and link T2 and T3 (pets) where T3.petid = T2.petid, keeping only matching pairs (inner match)\n4) When filtering for students with dogs: use condition T3.pettype = 'dog' exactly as specified\n5) When excluding students with cats: use subquery exclusion where T1.stuid NOT IN (select stuid from has_pet join pets on pets.petid = has_pet.petid where pettype = 'cat')"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, age FROM students WHERE pet = 'dog' AND pet != 'cat';",
            "SELECT T1.Fname, T1.Age\nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'\nAND T1.StuID NOT IN (\n    SELECT T4.StuID\n    FROM Has_Pet AS T4\n    JOIN Pets AS T5 ON T5.PetID = T4.PetID\n    WHERE T5.PetType = 'cat'\n)"
        ],
        "rule_sql": [
            "SELECT T1.fname, T1.age\nFROM student T1\nINNER JOIN has_pet T2 ON T1.stuid = T2.stuid\nINNER JOIN pets T3 ON T3.petid = T2.petid\nWHERE T3.pettype = 'dog'\nAND T1.stuid NOT IN (\n    SELECT stuid \n    FROM has_pet \n    JOIN pets ON pets.petid = has_pet.petid \n    WHERE pettype = 'cat'\n)"
        ]
    },
    "803": {
        "db_id": "world_1",
        "question": "Return the names of the 3 most populated countries.",
        "ground_truth": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3",
        "amends": [
            "Do use `Name` instead of `name` for the column selection to match the correct case. Do order by `Population DESC` instead of `population ASC` to sort in descending order by the correct population column. Do reference table `country` instead of `countries` to use the correct table name. The amended query now correctly selects the top 3 countries by population in descending order."
        ],
        "rules": [
            "1) When the question asks for \"names of the 3 most populated countries\": use column \"Name\" from table \"country\" for output. 2) When ordering by population to find the most populated: sort by column \"Population\" in descending order. 3) When selecting the top 3 results: keep only the first 3 rows after sorting. 4) When referring to countries: use table \"country\" instead of \"countries\" as the correct table name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population ASC LIMIT 3;",
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"
        ]
    },
    "83": {
        "db_id": "pets_1",
        "question": "Find the last name of the student who has a cat that is age 3.",
        "ground_truth": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
        "amends": [
            "Do use explicit table aliases `T1.lname` instead of ambiguous `last_name`. Do join three tables `student AS T1`, `has_pet AS T2`, and `pets AS T3` instead of querying only the `students` table. Do use `JOIN` with proper join conditions `ON T1.stuid = T2.stuid` and `ON T3.petid = T2.petid` instead of assuming direct relationships. Do filter on `T3.pet_age = 3` and `T3.pettype = 'cat'` instead of filtering on non-existent columns `pet_type` and `pet_age` in the students table. Do remove `ORDER BY student_id DESC LIMIT 1` instead of keeping it since the correct query returns all matching records without ordering or limiting. The amended query now correctly joins the necessary tables and filters on the appropriate pet-related columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"last name of the student who has a cat that is age 3\": make sure the output order: T1.lname. 2) When the question mentions \"student\": use table \"student AS T1\" with column \"T1.lname\" for last name. 3) When the question mentions \"has a cat\": use table \"pets AS T3\" with filter \"T3.pettype = 'cat'\" exactly. 4) When the question mentions \"age 3\": use table \"pets AS T3\" with filter \"T3.pet_age = 3\" exactly. 5) When combining student, has_pet, and pets tables: link rows where \"T1.stuid = T2.stuid\" and \"T3.petid = T2.petid\" using inner matches only. 6) When producing output: do not add ORDER BY or LIMIT clauses since the question asks for all matching records without ranking or limiting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE pet_type = 'cat' AND pet_age = 3 ORDER BY student_id DESC LIMIT 1;",
            "SELECT T1.LName \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ],
        "rule_sql": [
            "SELECT T1.LName FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T3.PetID = T2.PetID WHERE T3.PetType = 'cat' AND T3.pet_age = 3"
        ]
    },
    "989": {
        "db_id": "dog_kennels",
        "question": "Tell me the age of the oldest dog.",
        "ground_truth": "SELECT max(age) FROM Dogs",
        "amends": [
            "Do use `max(age)` instead of `MIN(age)` to calculate the maximum age instead of the minimum age. Do capitalize `Dogs` instead of `dogs` to match the proper table name casing. The amended query now correctly returns the maximum age from the Dogs table instead of the minimum age."
        ],
        "rules": [
            "1) When the question asks for the \"oldest\" dog: use max(age) instead of min(age) to find the maximum age. 2) When referring to the table containing dog information: use the exact table name \"Dogs\" with proper capitalization as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(age) FROM dogs;",
            "SELECT MAX(age) FROM Dogs;"
        ],
        "rule_sql": [
            "SELECT MAX(age) AS oldest_age FROM Dogs;"
        ]
    },
    "528": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names of the sections in reverse alphabetical order?",
        "ground_truth": "SELECT section_name FROM Sections ORDER BY section_name DESC",
        "amends": [
            "Do select `section_name` instead of `name` from the `Sections` table instead of `sections`. Do order by `section_name DESC` instead of `name ASC`."
        ],
        "rules": [
            "1) When selecting section names from the Sections table: use the exact column name \"section_name\" instead of \"name\". 2) When ordering sections in reverse alphabetical order: sort by \"section_name\" in descending order instead of ascending order. 3) When referring to the table containing section information: use the exact table name \"Sections\" instead of \"sections\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sections ORDER BY name ASC;",
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ],
        "rule_sql": [
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ]
    },
    "527": {
        "db_id": "student_transcripts_tracking",
        "question": "List the section_name in reversed lexicographical order.",
        "ground_truth": "SELECT section_name FROM Sections ORDER BY section_name DESC",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT section_name FROM sections ORDER BY section_name ASC;"
        ],
        "rule_sql": [
            "SELECT section_name FROM Sections ORDER BY section_name DESC;"
        ]
    },
    "476": {
        "db_id": "wta_1",
        "question": "What is the code of the country with the most players?",
        "ground_truth": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do aggregate with `GROUP BY country_code` and order by `count(*) DESC` instead of selecting individual records ordered by `player_id DESC`. Do include the grouping and aggregation logic to find the most frequent country code instead of simply retrieving the last player's country. The amended query now correctly identifies the country with the highest number of players rather than just the most recent player's country, matching the intended behavior.",
            "Do remove `COUNT(*) as player_count` from the SELECT list instead of including it, and do reference `count(*)` directly in the ORDER BY clause instead of using the alias `player_count`. Do maintain the same GROUP BY on `country_code` and LIMIT 1, but now the query correctly returns only the country_code with the highest count of players rather than including both the country_code and the count value in the results. The amended query now matches RIGHT_SQL's behavior by returning just the country code with the maximum player count."
        ],
        "rules": [
            "1) When answering about \"the country with the most players\": group rows by the exact token \"country_code\" and count the number of players per group. 2) When counting players: use the canonical key \"player_id\" to count the number of distinct players. 3) When finding the country with the highest count: order the results by the count in descending direction and keep only the first row. 4) When producing output: return only the \"country_code\" column for the result.",
            "1) When answering about \"the country with the most players\": make sure the output order: only include the country_code column. 2) When counting players per country: use count(*) directly in the ORDER BY clause instead of creating an alias for it. 3) When grouping by country_code: organize results by the exact token \"country_code\" and compute the count of players per group. 4) When the question asks for \"the most players\": rank rows by count(*) in descending order and keep only the first 1 row. 5) When producing output for this question: do not include the count value in the results, only return the country_code."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_code FROM players ORDER BY player_id DESC LIMIT 1;",
            "SELECT country_code, COUNT(*) as player_count FROM players GROUP BY country_code ORDER BY player_count DESC LIMIT 1;",
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country_code FROM players GROUP BY country_code ORDER BY COUNT(*) DESC LIMIT 1;"
        ]
    },
    "899": {
        "db_id": "network_1",
        "question": "What are the ids of students who both have friends and are liked?",
        "ground_truth": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "amends": [
            "Do select `student_id` instead of `id` to match the column names in the source tables. Do use `INTERSECT` instead of multiple `IN` subqueries to find the intersection between friends and liked IDs more efficiently. Do reference tables `Friend` and `Likes` instead of `friends` and `likes` to use the correct table names. Do remove the redundant `WHERE` clause and subqueries instead of keeping the complex nested structure. The amended query now correctly identifies students who are both friends and liked by using set intersection semantics.",
            "Do reference `liked_id` from the Likes table instead of `student_id` in the second SELECT clause of the INTERSECT operation. This change correctly identifies the column containing the IDs of students who are liked rather than those who do the liking, ensuring the query properly intersects students who have friends with those who are liked by others. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for student IDs who are both friends and liked: use the exact table names \"Friend\" and \"Likes\" as specified in the schema. 2) When combining data from multiple tables for set operations: use INTERSECT semantics to find the common student IDs efficiently. 3) When selecting student identifiers: use the exact column name \"student_id\" from the Friend table to match the schema's column naming. 4) When referencing the liked students: use the exact column name \"liked_id\" from the Likes table to match the schema's column naming. 5) When producing output: maintain the exact column order and naming as specified in the question (student IDs only).",
            "1) When the question asks for students who are liked: use the \"liked_id\" column from the Likes table instead of \"student_id\" to identify students who are liked by others. 2) When combining results from Friend and Likes tables using INTERSECT: ensure both SELECT clauses reference the correct student identifier columns - \"student_id\" from Friend for students who have friends, and \"liked_id\" from Likes for students who are liked."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM students WHERE id IN (SELECT student_id FROM friends) AND id IN (SELECT liked_id FROM likes);",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT student_id FROM Likes",
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ],
        "rule_sql": [
            "SELECT student_id FROM Friend\nINTERSECT\nSELECT liked_id FROM Likes"
        ]
    },
    "465": {
        "db_id": "wta_1",
        "question": "Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.",
        "ground_truth": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT winner_name FROM matches WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT winner_name\nFROM matches\nWHERE tourney_name = 'Australian Open'\nORDER BY winner_rank_points DESC\nLIMIT 1;"
        ]
    },
    "214": {
        "db_id": "flight_2",
        "question": "Give the number of Jetblue Airways flights.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
        "amends": [
            "Do add a `JOIN` with `AIRLINES AS T2` on `T1.Airline = T2.uid` instead of querying only the `flights` table. Do filter on `T2.Airline = \"JetBlue Airways\"` instead of directly filtering `flights.airline = 'JetBlue Airways'` to properly reference the airline name through the joined relationship. Do use table alias `T1` for `FLIGHTS` instead of referencing the table directly without an alias. The amended query now correctly joins the airline reference table to filter by airline name rather than relying on potentially inconsistent airline identifiers in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of Jetblue Airways flights\": make sure the output order: count of flights. 2) When the question mentions \"Jetblue Airways\": \"Jetblue Airways\" actually means \"T2.Airline = 'JetBlue Airways'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.Airline = T2.uid exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of flights\": compute the number of rows using the canonical key token for flights (e.g., T1's primary key). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"JetBlue Airways\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'JetBlue Airways';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights T1\nINNER JOIN airlines T2 ON T1.Airline = T2.uid\nWHERE T2.Airline = 'JetBlue Airways'"
        ]
    },
    "529": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the semester which most student registered in? Show both the name and the id.",
        "ground_truth": "SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `r`. Do reference `T1.semester_name` and `T1.semester_id` in SELECT instead of unqualified `semester_name` and `semester_id`. Do join `Semesters AS T1` with `Student_Enrolment AS T2` instead of `students s` with `registrations r`. Do use join condition `T1.semester_id = T2.semester_id` instead of `s.student_id = r.student_id`. Do remove the `COUNT(*) as student_count` column from SELECT instead of including it. Do GROUP BY only `T1.semester_id` instead of both `semester_name` and `semester_id`. Do ORDER BY `count(*) DESC` instead of `student_count DESC`. The amended query now correctly identifies the semester with the most student enrollments by joining the appropriate tables and counting enrollments per semester."
        ],
        "rules": [
            "1) When answering about \"the semester which most student registered in\": make sure the output order: T1.semester_name, T1.semester_id\n2) When combining Semesters as T1 and Student_Enrolment as T2: link rows where T1.semester_id = T2.semester_id and keep only matching pairs (inner match)\n3) When the question asks for \"most student registered\": count the number of rows using T2.semester_id as the counting key per semester group\n4) When grouping by semester: organize results by T1.semester_id only instead of both semester_name and semester_id\n5) When ranking to find the semester with most registrations: rank rows by count(*) in descending order and keep the first 1 row\n6) When producing output: do not include the count column in the final result, only show T1.semester_name and T1.semester_id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT semester_name, semester_id, COUNT(*) as student_count\nFROM students s\nJOIN registrations r ON s.student_id = r.student_id\nGROUP BY semester_name, semester_id\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nJOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.semester_name, T1.semester_id\nFROM Semesters AS T1\nINNER JOIN Student_Enrolment AS T2 ON T1.semester_id = T2.semester_id\nGROUP BY T1.semester_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "807": {
        "db_id": "world_1",
        "question": "Count the number of countries in Asia.",
        "ground_truth": "SELECT count(*) FROM country WHERE continent  =  \"Asia\"",
        "amends": [
            "Do reference table `country` instead of `countries` and filter on `continent = \"Asia\"` instead of `continent = 'Europe'`."
        ],
        "rules": [
            "1) When answering about \"countries in Asia\": use table \"country\" instead of \"countries\". 2) When filtering for countries in Asia: use condition continent = \"Asia\" instead of continent = 'Europe'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE continent = 'Europe';",
            "SELECT COUNT(*) FROM country WHERE Continent = 'Asia';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM country WHERE continent = 'Asia';"
        ]
    },
    "379": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show the document id with paragraph text 'Brazil' and 'Ireland'.",
        "ground_truth": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs WHERE paragraph_text = 'Brazil' OR paragraph_text = 'Ireland'"
        ],
        "rule_sql": [
            "SELECT d.Document_ID\nFROM Documents d\nJOIN Paragraphs p1 ON d.Document_ID = p1.Document_ID\nJOIN Paragraphs p2 ON d.Document_ID = p2.Document_ID\nWHERE p1.Paragraph_Text = 'Brazil'\nAND p2.Paragraph_Text = 'Ireland';"
        ]
    },
    "776": {
        "db_id": "world_1",
        "question": "Which Asian countries have a population that is larger than any country in Africa?",
        "ground_truth": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT max(population) FROM country WHERE Continent  =  \"Africa\")",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM country WHERE continent = 'Asia' AND population > (SELECT MAX(population) FROM country WHERE continent = 'Africa')"
        ],
        "rule_sql": [
            "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Asia' \nAND c.Population > (SELECT MAX(africa.Population) FROM country africa WHERE africa.Continent = 'Africa')"
        ]
    },
    "47": {
        "db_id": "pets_1",
        "question": "Find the weight of the youngest dog.",
        "ground_truth": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1",
        "amends": [
            "Do select `weight` instead of `MAX(weight)` and change the source table from `dogs` to `pets`. Do remove the WHERE clause with subquery that found maximum weight for minimum age instead of keeping it. Do add `ORDER BY pet_age LIMIT 1` instead of omitting it to directly get the weight of the youngest pet. The amended query now correctly retrieves the weight of the youngest pet by ordering by age and taking the first result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the weight of the youngest dog\": make sure the output order: select only the \"weight\" column. 2) When the question mentions \"dogs\": \"dogs\" actually means \"pets\" in schema. 3) When the question asks for \"youngest\" (minimum age): order rows by \"pet_age\" in ascending direction and keep the first 1 row. 4) When handling text literals: do not change case, spacing, or punctuation."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(weight) FROM dogs WHERE age = (SELECT MIN(age) FROM dogs);",
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age LIMIT 1"
        ],
        "rule_sql": [
            "SELECT weight FROM Pets WHERE PetType = 'dog' ORDER BY pet_age ASC LIMIT 1"
        ]
    },
    "887": {
        "db_id": "network_1",
        "question": "Return the name of the high school student with the most friends.",
        "ground_truth": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `Highschooler` table instead of `name` from the `students` table. Do add `FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of omitting join relationships. Do add `GROUP BY T1.student_id` to aggregate by student instead of omitting grouping. Do change ordering to `ORDER BY count(*) DESC` based on friend count instead of `ORDER BY RANDOM()`. Do keep `LIMIT 1` to return one row but now based on highest friend count instead of random selection. The amended query now correctly identifies the student with the most friends by joining Friend and Highschooler tables, grouping by student, and ordering by friendship count descending."
        ],
        "rules": [
            "1) When answering about \"high school student with the most friends\": make sure the output order: T2.name. 2) When the question mentions \"high school student\": \"high school student\" actually means \"T2.name in Highschooler table\". 3) When combining T1 and T2 for shared entities: link rows where T1.student_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"count of friends\": compute the number of rows using the canonical key token T1.student_id. 5) When the question mentions \"most friends\" or \"highest\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM students ORDER BY RANDOM() LIMIT 1;",
            "SELECT T2.name\nFROM Friend AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name\nFROM Friend T1\nJOIN Highschooler T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "459": {
        "db_id": "wta_1",
        "question": "Find the first name and country code of the player who did the most number of tours.",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
        "amends": [
            "Do add `rankings` table with `JOIN` on `players.player_id = rankings.player_id` instead of querying only the `players` table. Do reference `T2.tours` in the `ORDER BY` clause instead of `tours` which would be ambiguous. Do include table aliases `T1` and `T2` for clarity instead of using unqualified column names. Do maintain the `LIMIT 1` clause to return only the top result. The amended query now correctly joins player and ranking data to find the player with the highest number of tours.",
            "Do place `T1.country_code` before `T1.first_name` in the SELECT list instead of the reverse order. Do add the `AS` keyword for table aliases instead of omitting it. Do use consistent spacing around the equals operator in the JOIN condition instead of inconsistent spacing. The amended query now correctly matches the RIGHT_SQL's behavior with identical column ordering and proper syntax formatting."
        ],
        "rules": [
            "1) When answering about \"the player who did the most number of tours\": make sure the output order: first_name, country_code. 2) When the question mentions \"tours\": \"tours\" actually means \"T2.tours in schema\". 3) When the question mentions \"most number of tours\": rank rows by T2.tours in descending direction and keep the first 1 row. 4) When combining players and rankings tables: link rows where players.player_id = rankings.player_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "1) When answering about \"the first name and country code of the player who did the most number of tours\": make sure the output order: T1.country_code, T1.first_name\n2) When combining players and rankings tables for shared entities: link rows where T1.player_id = T2.player_id exactly as shown; keep only matching pairs (inner match)\n3) When the question mentions \"most number of tours\": rank rows by T2.tours in descending order and keep the first 1 row"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, country_code FROM players ORDER BY tours DESC LIMIT 1;",
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nJOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1",
            "SELECT T1.country_code, T1.first_name\nFROM players AS T1\nJOIN rankings AS T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.country_code\nFROM players T1\nINNER JOIN rankings T2 ON T1.player_id = T2.player_id\nORDER BY T2.tours DESC\nLIMIT 1"
        ]
    },
    "152": {
        "db_id": "car_1",
        "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?",
        "ground_truth": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "amends": [
            "Do use explicit table aliases `T2.Model` instead of ambiguous `model`. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do join multiple tables `CAR_NAMES AS T1`, `MODEL_LIST AS T2`, `CAR_MAKERS AS T3`, and `CARS_DATA AS T4` instead of querying a single `cars` table. Do use proper join conditions `T1.Model = T2.Model`, `T2.Maker = T3.Id`, and `T1.MakeId = T4.Id` instead of simple column references. Do filter on `T3.FullName = 'General Motors'` instead of `maker = 'General Motors'` to use the correct table relationship. Do maintain the weight filter `T4.weight > 3500` but reference it through the proper table join. The amended query now correctly handles the multi-table relationships and returns distinct models as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"different models\": make sure to eliminate duplicates by using DISTINCT on T2.Model. 2) When the question mentions \"car maker General Motors\": \"General Motors\" actually means T3.FullName = 'General Motors' in the schema. 3) When the question mentions \"weighed more than 3500\": this means T4.weight > 3500 in the schema. 4) When combining multiple tables for this query: link rows where T1.Model = T2.Model, T2.Maker = T3.Id, and T1.MakeId = T4.Id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for table aliases T1, T2, T3, T4."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT model FROM cars WHERE maker = 'General Motors' OR weight > 3500",
            "SELECT DISTINCT T2.Model\nFROM CAR_NAMES AS T1\nJOIN MODEL_LIST AS T2 ON T1.Model = T2.Model\nJOIN CAR_MAKERS AS T3 ON T2.Maker = T3.Id\nLEFT JOIN CARS_DATA AS T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Model\nFROM car_names T1\nJOIN model_list T2 ON T1.Model = T2.Model\nJOIN car_makers T3 ON T2.Maker = T3.Id\nJOIN cars_data T4 ON T1.MakeId = T4.Id\nWHERE T3.FullName = 'General Motors' OR T4.Weight > 3500"
        ]
    },
    "760": {
        "db_id": "world_1",
        "question": "Find the city with the largest population that uses English.",
        "ground_truth": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T1.Population` instead of just `city` from the SELECT list. Do join `city AS T1` with `countrylanguage AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying only the `cities` table. Do filter on `T2.Language = \"English\"` instead of `language = 'English'` in the WHERE clause. Do order by `T1.Population DESC` instead of `population ASC` for descending order. The amended query now correctly retrieves city names with their populations where English is spoken, ordered by population in descending order to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"city with the largest population that uses English\": make sure the output order: T1.Name, T1.Population. 2) When the question mentions \"city\": \"city\" actually means \"T1.Name in schema\". 3) When the question mentions \"largest population\": rank rows by T1.Population in descending direction and keep the first 1 row. 4) When combining T1 and T2 for shared entities: link rows where T1.CountryCode = T2.CountryCode; keep only matching pairs (inner match). 5) When filtering for English language: use T2.Language = \"English\" exactly as specified with double quotes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM cities WHERE language = 'English' ORDER BY population ASC LIMIT 1;",
            "SELECT T1.Name, T1.Population \nFROM city AS T1 \nJOIN countrylanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.Language = \"English\" \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name, T1.Population\nFROM city T1\nINNER JOIN countrylanguage T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Language = \"English\"\nORDER BY T1.Population DESC\nLIMIT 1"
        ]
    },
    "314": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the template ids of any templates used in more than a single document?",
        "ground_truth": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1",
        "amends": [
            "Do change the HAVING clause condition to `count(*) > 1` instead of `COUNT(*) = 1`, which now correctly identifies template_ids that appear more than once in the Documents table rather than those appearing exactly once. The amended query now matches RIGHT_SQL's behavior by returning template_ids with multiple occurrences."
        ],
        "rules": [
            "1) When counting occurrences of template_id in the documents table: use COUNT(*) to count all rows for each template_id. 2) When identifying templates used in more than a single document: filter for template_ids where the count is greater than 1 (not equal to 1). 3) When answering about template ids of templates used in multiple documents: output only the template_id column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_id FROM documents GROUP BY template_id HAVING COUNT(*) = 1;",
            "SELECT Template_ID\nFROM Documents\nWHERE Template_ID IS NOT NULL\nGROUP BY Template_ID\nHAVING COUNT(*) > 1;"
        ],
        "rule_sql": [
            "SELECT Template_ID FROM Documents GROUP BY Template_ID HAVING COUNT(*) > 1"
        ]
    },
    "146": {
        "db_id": "car_1",
        "question": "In 1980, how many cars were made?",
        "ground_truth": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;",
        "amends": [
            "Do reference table `CARS_DATA` instead of `cars` to correctly access the source data. Do maintain the same filter condition `YEAR = 1980` and aggregate function `count(*)` as they remain functionally identical. The amended query now correctly counts records from the appropriate table while preserving the same filtering logic and aggregation behavior."
        ],
        "rules": [
            "1) When answering about \"how many cars were made in 1980\": use the exact table name \"CARS_DATA\" instead of \"cars\" to access the source data. 2) When filtering for year 1980: apply the exact condition YEAR = 1980 to select only records from that specific year. 3) When counting the number of cars: use count(*) to count all records that satisfy the year condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1980;",
            "SELECT COUNT(*) FROM cars_data WHERE Year = 1980;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM CARS_DATA WHERE Year = 1980;"
        ]
    },
    "817": {
        "db_id": "world_1",
        "question": "What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?",
        "ground_truth": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
        "amends": [
            "Do select `LANGUAGE`, `CountryCode`, and `max(Percentage)` instead of `country.code` and `countrylanguage.language`. Do use only the `countrylanguage` table instead of joining `country` and `countrylanguage` tables. Do add `GROUP BY CountryCode` instead of omitting grouping. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly calculates the maximum percentage for each language by country code and matches the RIGHT_SQL's behavior.",
            "Do maintain the original column order `CountryCode, Language` instead of reordering to `Language, CountryCode`. Do keep the same aggregate function `MAX(Percentage)` and grouping clause `GROUP BY CountryCode` without changes. The amended query now correctly preserves the original column sequence while maintaining identical logical behavior to the RIGHT_SQL.",
            "Do maintain the original column order `CountryCode, Language` instead of reordering to `Language, CountryCode`. Do keep the same aggregate function `MAX(Percentage)` and grouping clause `GROUP BY CountryCode` without changes. The amended query now correctly preserves the original column sequence while maintaining identical logical behavior to the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.code, countrylanguage.language \nFROM country \nJOIN countrylanguage ON country.code = countrylanguage.countrycode \nORDER BY country.code;",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode",
            "SELECT CountryCode, Language, MAX(Percentage) FROM countrylanguage GROUP BY CountryCode"
        ],
        "rule_sql": []
    },
    "868": {
        "db_id": "network_1",
        "question": "What grade is Kyle in?",
        "ground_truth": "SELECT grade FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [
            "Do reference the `Highschooler` table instead of the `students` table in the FROM clause. Do use double quotes `\"Kyle\"` instead of single quotes `'Kyle'` for the string literal in the WHERE filter. The amended query now correctly retrieves grades from the Highschooler table for students named Kyle."
        ],
        "rules": [
            "1) When answering about student grades: use the \"Highschooler\" table instead of any other table. 2) When filtering for a student named Kyle: use the exact string literal \"Kyle\" with double quotes in the filter condition. 3) When selecting grade information: retrieve the grade column from the Highschooler table for matching students."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade FROM students WHERE name = 'Kyle';",
            "SELECT grade FROM Highschooler WHERE name = \"Kyle\";"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler WHERE name = \"Kyle\";"
        ]
    },
    "568": {
        "db_id": "student_transcripts_tracking",
        "question": "How many transcripts are listed?",
        "ground_truth": "SELECT count(*) FROM Transcripts",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM Transcripts;"
        ]
    },
    "213": {
        "db_id": "flight_2",
        "question": "How many flights does airline 'JetBlue Airways' have?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
        "amends": [
            "Do join `AIRLINES AS T2` instead of omitting it, and do use `ON T1.Airline = T2.uid` instead of filtering directly on `airline = 'JetBlue Airways'`. Do filter on `T2.Airline = \"JetBlue Airways\"` instead of directly filtering the flights table, which correctly uses the airlines reference table for accurate airline identification. The amended query now matches RIGHT_SQL's behavior by properly joining to the airlines table and filtering through the reference relationship."
        ],
        "rules": [
            "1) When answering about \"how many flights does airline 'JetBlue Airways' have\": make sure to join the AIRLINES table as T2 to the flights table as T1 using the exact join condition T1.Airline = T2.uid. 2) When filtering for airline 'JetBlue Airways': use the exact literal \"JetBlue Airways\" with double quotes and filter on T2.Airline instead of directly on the flights table. 3) When counting flights: count using the canonical key from the flights table (T1) after properly joining with the airlines reference table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'JetBlue Airways';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid WHERE T2.Airline = \"JetBlue Airways\""
        ]
    },
    "876": {
        "db_id": "network_1",
        "question": "Show the number of high schoolers for each grade.",
        "ground_truth": "SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",
        "amends": [
            "Do reference the table as `Highschooler` instead of `high_schoolers` to match the correct table name. Do add a space after `grade` in the SELECT clause instead of omitting it for proper formatting. Do remove the `ORDER BY grade` clause instead of keeping it since the grouping already provides the desired ordering. The amended query now correctly counts students by grade from the Highschooler table without unnecessary ordering."
        ],
        "rules": [
            "1) When answering about \"number of high schoolers for each grade\": make sure the output order: grade, count of students. 2) When the question mentions \"high schoolers\": \"high schoolers\" actually means \"Highschooler\" in schema. 3) When the question asks for \"count of high schoolers per grade\": compute the number of rows using the canonical key for students from the Highschooler table, grouped by grade. 4) When grouping by grade: organize results by the exact token \"grade\" from the Highschooler table. 5) When producing output: do not include unnecessary ordering clauses since grouping by grade already provides the desired ordering."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade, COUNT(*) FROM high_schoolers GROUP BY grade ORDER BY grade;",
            "SELECT grade, COUNT(*) FROM Highschooler GROUP BY grade;"
        ],
        "rule_sql": [
            "SELECT grade, COUNT(ID) FROM Highschooler GROUP BY grade;"
        ]
    },
    "929": {
        "db_id": "dog_kennels",
        "question": "Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
        "ground_truth": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "amends": [
            "Do select `professional_id`, `role_code`, and `email_address` instead of `id`, `role`, and `email`. Do use `EXCEPT` set operation instead of `NOT IN` subquery. Do reference table as `Professionals` instead of `professionals`. Do join `Professionals AS T1` with `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of using a subquery with `professional_id` and `animal_type` filter. Do remove the `WHERE animal_type = 'dog'` condition instead of keeping it. The amended query now correctly excludes professionals who have any treatments rather than just those with dog treatments, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting professional information: use \"professional_id\", \"role_code\", and \"email_address\" as output columns instead of \"id\", \"role\", and \"email\". 2) When referencing the professionals table: use \"Professionals\" (with exact case) instead of \"professionals\". 3) When finding professionals without any treatments: use EXCEPT set operation instead of NOT IN subquery. 4) When combining Professionals and Treatments tables: join \"Professionals AS T1\" with \"Treatments AS T2\" on \"T1.professional_id = T2.professional_id\" for inner matching. 5) When excluding professionals with treatments: remove any animal_type filter condition since the question asks about professionals who did not perform any treatment, not just dog treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, role, email FROM professionals WHERE id NOT IN (SELECT professional_id FROM treatments WHERE animal_type = 'dog')",
            "SELECT professional_id, role_code, email_address FROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id"
        ],
        "rule_sql": [
            "SELECT professional_id, role_code, email_address\nFROM Professionals\nEXCEPT\nSELECT T1.professional_id, T1.role_code, T1.email_address\nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id"
        ]
    },
    "451": {
        "db_id": "wta_1",
        "question": "What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
        "ground_truth": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.country_code, p.first_name \nFROM players p\nJOIN matches m1 ON p.player_id = m1.winner_id\nJOIN matches m2 ON p.player_id = m2.winner_id\nWHERE m1.tourney_name = 'WTA Championships' \nAND m2.tourney_name = 'Australian Open';"
        ],
        "rule_sql": [
            "SELECT DISTINCT p.country_code, p.first_name\nFROM players p\nJOIN matches m ON p.player_id = m.winner_id\nWHERE m.tourney_name IN ('WTA Championships', 'Australian Open')\nGROUP BY p.player_id, p.country_code, p.first_name\nHAVING COUNT(DISTINCT m.tourney_name) = 2;"
        ]
    },
    "651": {
        "db_id": "poker_player",
        "question": "List the final tables made and the best finishes of poker players.",
        "ground_truth": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player",
        "amends": [
            "Do select `Final_Table_Made` and `Best_Finish` instead of `player_name`, `final_table`, and `best_finish`. Do query from `poker_player` instead of `poker_players`. Do remove the `ORDER BY player_name` clause instead of keeping it. The amended query now correctly selects the specified columns from the appropriate table without unnecessary ordering."
        ],
        "rules": [
            "1) When the question asks for \"final tables made\": select the exact column \"Final_Table_Made\" from table \"poker_player\". 2) When the question asks for \"best finishes\": select the exact column \"Best_Finish\" from table \"poker_player\". 3) When the question does not specify any ordering requirement: do not apply any sorting to the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, final_table, best_finish FROM poker_players ORDER BY player_name;",
            "SELECT Final_Table_Made, Best_Finish FROM poker_player;"
        ],
        "rule_sql": [
            "SELECT Final_Table_Made, Best_Finish FROM poker_player"
        ]
    },
    "231": {
        "db_id": "flight_2",
        "question": "Find the abbreviation and country of the airline that has fewest number of flights?",
        "ground_truth": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
        "amends": [
            "Do join `AIRLINES AS T1` with `FLIGHTS AS T2` on `T1.uid = T2.Airline` instead of omitting the join condition. Do group by `T1.Airline` instead of omitting grouping. Do order by `count(*)` instead of ordering by `COUNT(flights.id)` without grouping. Do reference columns with table aliases `T1.Abbreviation` and `T1.Country` instead of bare column names. The amended query now correctly aggregates flight counts per airline and returns the airline with the fewest flights, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the airline that has fewest number of flights\": join AIRLINES AS T1 with FLIGHTS AS T2 on T1.uid = T2.Airline to link airline and flight data. 2) When counting flights per airline: group by T1.Airline and count using count(*) to get the number of flights for each airline. 3) When finding the airline with the fewest flights: order by count(*) in ascending order and keep only the first row. 4) When selecting output columns: return T1.Abbreviation and T1.Country for the airline with the fewest flights."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT abbreviation, country FROM airlines ORDER BY COUNT(flights.id) ASC LIMIT 1;",
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Abbreviation, T1.Country\nFROM airlines AS T1\nJOIN flights AS T2 ON T1.uid = T2.Airline\nGROUP BY T1.Airline\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ]
    },
    "382": {
        "db_id": "course_teach",
        "question": "What is the total count of teachers?",
        "ground_truth": "SELECT count(*) FROM teacher",
        "amends": [
            "Do select from `teacher` table instead of `students` table. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total count of teachers\": make sure to count from the \"teacher\" table instead of the \"students\" table. 2) When counting teachers: use the canonical key for counting entities from the teacher table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students;",
            "SELECT COUNT(*) FROM teacher;"
        ],
        "rule_sql": [
            "SELECT COUNT(Teacher_ID) FROM teacher;"
        ]
    },
    "837": {
        "db_id": "orchestra",
        "question": "What are the names of conductors, sorted descending by the number of years they have worked?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Year_of_Work DESC",
        "amends": [
            "Do select `Name` instead of `name, years_worked` and remove the `years_worked` column from the output. Do reference table `conductor` instead of `conductors` as the data source. Do order by `Year_of_Work DESC` instead of `years_worked ASC` to sort in descending order by the correct column name. The amended query now correctly selects only the name column from the conductor table ordered by years of work in descending order, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"names of conductors\": make sure the output order: \"Name\" from table \"conductor\". 2) When the question mentions \"number of years they have worked\": \"years worked\" actually means \"Year_of_Work\" in schema. 3) When the question asks for sorting \"descending by the number of years\": rank rows by \"Year_of_Work\" in descending direction. 4) When selecting output columns: include only \"Name\" and remove \"Year_of_Work\" from the final output."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, years_worked FROM conductors ORDER BY years_worked ASC;",
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Year_of_Work DESC;"
        ]
    },
    "674": {
        "db_id": "poker_player",
        "question": "How many people are there of each nationality?",
        "ground_truth": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",
        "amends": [
            "Do group by `Nationality` instead of `name` to correctly aggregate counts by nationality rather than by individual names. Do capitalize `Nationality` in the SELECT list instead of using lowercase `nationality` for consistency with the GROUP BY clause. The amended query now correctly counts people by their nationality rather than by name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for counts by nationality: group by the exact column \"Nationality\" from the people table. 2) When counting people per group: use the canonical key for counting (typically the primary key or unique identifier) to count distinct individuals. 3) When selecting the nationality column: use the exact capitalization \"Nationality\" as shown in the schema to match the GROUP BY clause. 4) When the question asks \"how many people are there of each nationality\": organize results by \"Nationality\" and compute the count of people per nationality group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality, COUNT(*) FROM people GROUP BY name;",
            "SELECT Nationality, COUNT(*) AS count FROM people GROUP BY Nationality;"
        ],
        "rule_sql": [
            "SELECT Nationality, COUNT(People_ID) AS count_people FROM people GROUP BY Nationality;"
        ]
    },
    "905": {
        "db_id": "network_1",
        "question": "What are the names of high schoolers who have likes, and how many likes does each have?",
        "ground_truth": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
        "amends": [
            "Do select `T2.name` and `count(*)` without an alias instead of selecting `name` and `COUNT(*) as like_count`. Do join `Likes AS T1` with `Highschooler AS T2` on `T1.student_id = T2.id` instead of querying only `high_schoolers` table. Do group by `T1.student_id` instead of grouping by `name`. Do remove the `HAVING like_count > 0` condition instead of keeping it since all groups will have at least one count. Do remove the `ORDER BY like_count DESC` clause instead of including it. The amended query now correctly counts likes per student by joining the Likes table with Highschooler table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of high schoolers who have likes\": select \"T2\".\"name\" and count(*) without an alias. 2) When combining Likes and Highschooler tables: link rows where \"T1\".\"student_id\" = \"T2\".\"id\" and keep only matching pairs (inner match). 3) When counting likes per student: group by \"T1\".\"student_id\" instead of grouping by name. 4) When all groups will have at least one count: do not include a HAVING condition to filter out zero counts. 5) When the question does not specify ordering: do not include an ORDER BY clause."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) as like_count FROM high_schoolers GROUP BY name HAVING like_count > 0 ORDER BY like_count DESC;",
            "SELECT T2.name, COUNT(*)\nFROM Likes AS T1\nJOIN Highschooler AS T2 ON T1.student_id = T2.ID\nGROUP BY T1.student_id"
        ],
        "rule_sql": [
            "SELECT T2.name, COUNT(*) FROM Likes T1 JOIN Highschooler T2 ON T1.student_id = T2.ID GROUP BY T1.student_id"
        ]
    },
    "566": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the earliest date of a transcript release, and what details can you tell me?",
        "ground_truth": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
        "amends": [
            "Do select `transcript_date` and `other_details` instead of `MIN(release_date)`, `transcript_id`, and `content`. Do query from `Transcripts` instead of `transcripts`. Do remove the WHERE clause with subquery instead of filtering by maximum release date. Do add `ORDER BY transcript_date ASC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limitation. Do remove the aggregate function and grouping semantics instead of using MIN with non-aggregated columns. The amended query now correctly retrieves the earliest transcript details by date ordering rather than attempting to find minimum release date with incorrect aggregation logic."
        ],
        "rules": [
            "1) When answering about the earliest date of a transcript release: select \"transcript_date\" and \"other_details\" from \"Transcripts\" instead of MIN(release_date), transcript_id, and content. 2) When ordering by date to find the earliest transcript: order rows by \"transcript_date\" in ascending order and limit to the first 1 row. 3) When the question asks for details about the earliest transcript: include \"other_details\" column to provide additional information about the transcript. 4) When querying from the Transcripts table: use the exact table name \"Transcripts\" with proper capitalization as shown in the schema. 5) When finding the earliest date: do not use aggregate functions with non-aggregated columns or subqueries for maximum dates, instead use direct ordering and limiting."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(release_date) AS earliest_date, transcript_id, content FROM transcripts WHERE release_date = (SELECT MAX(release_date) FROM transcripts);",
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT transcript_date, other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1;"
        ]
    },
    "916": {
        "db_id": "network_1",
        "question": "Find the minimum grade of students who have no friends.",
        "ground_truth": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
        "amends": [
            "Do query the `Highschooler` table instead of the `students` table. Do use `min(grade)` with lowercase function name instead of `MIN(grade)`. Do change the subquery to use `Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.id` instead of `SELECT friend_id FROM friends`, adding proper table aliases and join conditions. Do reference `T1.student_id` in the subquery's SELECT list instead of `friend_id`. The amended query now correctly identifies students without friends by properly joining the Friend and Highschooler tables to validate friend relationships."
        ],
        "rules": [
            "1) When answering about \"minimum grade of students who have no friends\": query the \"Highschooler\" table instead of a \"students\" table. 2) When computing the minimum grade: use lowercase function name \"min(grade)\" instead of uppercase \"MIN(grade)\". 3) When identifying students without friends: use a subquery that joins \"Friend AS T1\" with \"Highschooler AS T2\" where \"T1.student_id = T2.id\" instead of a simple \"SELECT friend_id FROM friends\". 4) When referencing the friend relationship in the subquery: use \"T1.student_id\" instead of \"friend_id\" to properly identify students who have friends."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(grade) FROM students WHERE id NOT IN (SELECT friend_id FROM friends)",
            "SELECT min(grade) FROM Highschooler WHERE ID NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID)"
        ],
        "rule_sql": [
            "SELECT min(grade) FROM Highschooler WHERE ID NOT IN (SELECT T2.ID FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID)"
        ]
    },
    "525": {
        "db_id": "student_transcripts_tracking",
        "question": "What are the names and id of courses having at most 2 sections?",
        "ground_truth": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",
        "amends": [
            "Do use explicit table aliases `T1.course_name` and `T1.course_id` instead of bare column names `course_id, name`. Do add a `JOIN` to the `Sections` table `AS T2` instead of omitting it. Do use the correct join condition `T1.course_id = T2.course_id` instead of the incorrect `COUNT(sections)` filter. Do move the count filter to `HAVING count(*) <= 2` instead of placing it in the `WHERE` clause. Do add `GROUP BY T1.course_id` instead of omitting the grouping. The amended query now correctly counts sections per course and filters courses with two or fewer sections, matching the intended behavior.",
            "Do maintain the same `SELECT` list with `course_name, course_id` instead of changing the column order from `course_id, course_name`. Do keep the same `FROM` clause with `JOIN Sections AS T2` on `T1.course_id = T2.course_id` instead of altering the join condition. Do preserve the identical `GROUP BY T1.course_id` and `HAVING count(*) <= 2` clauses instead of modifying the aggregation logic. The amended query now correctly maintains the original behavior while fixing only the column ordering in the SELECT clause to match the RIGHT_SQL's output structure."
        ],
        "rules": [
            "1) When answering about courses and their sections: combine tables \"courses\" as T1 and \"Sections\" as T2 using the exact join condition T1.course_id = T2.course_id, keeping only matching pairs (inner match). 2) When the question asks for courses with \"at most 2 sections\": organize results by T1.course_id and compute count of sections per course, then filter to keep only groups where count(*) <= 2. 3) When selecting output columns: use explicit table aliases T1.course_id and T1.course_name instead of bare column names. 4) When grouping results: include GROUP BY T1.course_id to ensure proper aggregation by course. 5) When filtering aggregated results: place the count filter count(*) <= 2 in the HAVING clause instead of the WHERE clause.",
            "1) When answering about \"names and id of courses having at most 2 sections\": make sure the output order: course_name, course_id\n2) When combining Courses as T1 and Sections as T2: link rows where T1.course_id = T2.course_id and keep only matching pairs (inner match)\n3) When grouping by course: organize results by T1.course_id and compute requested aggregates per group\n4) When counting sections per course: compute the number of rows using the join relationship and ensure the count is less than or equal to 2"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT course_id, name FROM courses WHERE COUNT(sections) <= 2;",
            "SELECT T1.course_id, T1.course_name\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2",
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nJOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2"
        ],
        "rule_sql": [
            "SELECT T1.course_name, T1.course_id\nFROM Courses AS T1\nINNER JOIN Sections AS T2 ON T1.course_id = T2.course_id\nGROUP BY T1.course_id\nHAVING COUNT(*) <= 2\nORDER BY T1.course_name, T1.course_id"
        ]
    },
    "380": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
        "ground_truth": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "amends": [
            "Do use `INTERSECT` to find document IDs that contain both specified texts instead of using `OR` which finds documents containing either text. Do reference the correct column name `paragraph_text` instead of `text` in both SELECT statements. Do use proper table name capitalization `Paragraphs` instead of `paragraphs`. Do structure the query as two separate SELECT statements with INTERSECT instead of a single query with OR conditions. The amended query now correctly identifies documents that contain both 'Brazil' and 'Ireland' rather than documents containing either one, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [
            "1) When the question asks for documents containing multiple specific paragraph texts: use INTERSECT to find document IDs that satisfy all text conditions rather than OR which finds documents satisfying any condition. 2) When referring to paragraph text content: use the exact column name \"paragraph_text\" instead of \"text\". 3) When referencing the paragraphs table: use the exact table name \"Paragraphs\" with proper capitalization. 4) When finding documents containing both 'Brazil' and 'Ireland': structure the query as two separate SELECT statements that each filter for one text value, then intersect the results to get documents containing both texts."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT document_id FROM paragraphs WHERE text = 'Brazil' OR text = 'Ireland';",
            "SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Brazil'\nINTERSECT\nSELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Ireland'"
        ],
        "rule_sql": [
            "SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Brazil'\nINTERSECT\nSELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Ireland'"
        ]
    },
    "363": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Show all paragraph ids and texts for the document with name 'Welcome to NY'.",
        "ground_truth": "SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",
        "amends": [
            "Do join `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying `paragraphs` table directly without any join. Do select `T1.paragraph_text` instead of `text` to use the correct column name. Do filter on `T2.Document_Name = 'Welcome to NY'` instead of filtering directly on `document_name` in the paragraphs table. Do use table aliases `T1` and `T2` instead of no aliases for better clarity. The amended query now correctly joins through the document relationship to filter by document name instead of assuming the paragraphs table contains document names directly."
        ],
        "rules": [
            "1) When answering about \"paragraph ids and texts for the document with name 'Welcome to NY'\": make sure the output order: paragraph_id, paragraph_text. 2) When the question mentions \"document with name 'Welcome to NY'\": filter on T2.Document_Name = 'Welcome to NY' exactly as specified. 3) When combining paragraphs table T1 and Documents table T2: link rows where T1.document_id = T2.document_id and keep only matching pairs (inner match). 4) When the question asks for \"paragraph texts\": use T1.paragraph_text instead of text to use the correct column name."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT paragraph_id, text FROM paragraphs WHERE document_name = 'Welcome to NY'",
            "SELECT T1.Paragraph_ID, T1.Paragraph_Text \nFROM Paragraphs AS T1 \nJOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID \nWHERE T2.Document_Name = 'Welcome to NY'"
        ],
        "rule_sql": [
            "SELECT p.Paragraph_ID, p.Paragraph_Text FROM Paragraphs p INNER JOIN Documents d ON p.Document_ID = d.Document_ID WHERE d.Document_Name = 'Welcome to NY'"
        ]
    },
    "302": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the names and template ids for documents that contain the letter w in their description.",
        "ground_truth": "SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE \"%w%\"",
        "amends": [
            "Do use `document_name` instead of `name` in the SELECT list. Do use `Document_Description` instead of `description` in the WHERE filter. Do reference the table as `Documents` instead of `documents` in the FROM clause. Do use double quotes `\"%w%\"` instead of single quotes `'%w%'` for the LIKE pattern. The amended query now correctly references the actual column names and table name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for document names: use \"document_name\" instead of \"name\" in the output. 2) When filtering documents by description containing the letter w: use \"Document_Description\" instead of \"description\" and match using the pattern \"%w%\". 3) When referencing the documents table: use \"Documents\" instead of \"documents\" with proper case sensitivity. 4) When using string patterns in filters: use double quotes \"%w%\" instead of single quotes for the LIKE pattern."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, template_id FROM documents WHERE description LIKE '%w%';",
            "SELECT document_name, Template_ID FROM Documents WHERE Document_Description LIKE \"%w%\""
        ],
        "rule_sql": [
            "SELECT document_name, Template_ID FROM Documents WHERE Document_Description LIKE \"%w%\""
        ]
    },
    "17": {
        "db_id": "concert_singer",
        "question": "What is the average and maximum capacities for all stadiums ?",
        "ground_truth": "select avg(capacity) ,  max(capacity) from stadium",
        "amends": [
            "Do use `max(capacity)` instead of `min(capacity)` in the SELECT list to calculate the maximum capacity rather than the minimum. Do reference table `stadium` instead of `stadiums` to correctly identify the data source. The amended query now correctly calculates both average and maximum capacity values from the appropriate table."
        ],
        "rules": [
            "1) When calculating maximum capacity: use max(capacity) instead of min(capacity) to get the highest value. 2) When referencing the stadium data source: use table stadium instead of stadiums to correctly identify the data source."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(capacity), MIN(capacity) FROM stadiums;",
            "SELECT AVG(Capacity) AS Average_Capacity, MAX(Capacity) AS Maximum_Capacity FROM stadium;"
        ],
        "rule_sql": [
            "SELECT AVG(Capacity) AS Average_Capacity, MAX(Capacity) AS Maximum_Capacity FROM stadium;"
        ]
    },
    "154": {
        "db_id": "car_1",
        "question": "What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?",
        "ground_truth": "select distinct year from cars_data where weight between 3000 and 4000;",
        "amends": [
            "Do reference table `cars_data` instead of `cars` to access the correct data source. Do use `BETWEEN 3000 AND 4000` instead of `weight < 4000 OR weight > 3000` to properly filter for weights within the specified range rather than excluding them. The amended query now correctly returns distinct years for cars with weights between 3000 and 4000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"different years in which there were cars produced that weighed less than 4000 and also cars that weighed more than 3000\": make sure the output order: year. 2) When the question mentions \"cars\": \"cars\" actually means \"cars_data\" in schema. 3) When filtering for weights that are both less than 4000 and more than 3000: use weight values between 3000 and 4000 inclusive (3000 \u2264 weight \u2264 4000). 4) When selecting distinct years: return only unique year values from the filtered results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT year FROM cars WHERE weight < 4000 OR weight > 3000;",
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ],
        "rule_sql": [
            "SELECT DISTINCT Year FROM cars_data WHERE Weight BETWEEN 3000 AND 4000 ORDER BY Year;"
        ]
    },
    "328": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the version numbers and template type codes of templates with a version number greater than 5.",
        "ground_truth": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT version_number, template_type_code FROM templates WHERE version_number > 5;"
        ],
        "rule_sql": [
            "SELECT Version_Number, Template_Type_Code FROM Templates WHERE Version_Number > 5"
        ]
    },
    "738": {
        "db_id": "world_1",
        "question": "How many official languages does Afghanistan have?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
        "amends": [
            "Do join `country AS T1` and `countrylanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `languages` table. Do filter on `T1.Name = \"Afghanistan\"` instead of `country = 'Afghanistan'` and use `IsOfficial = \"T\"` instead of `status = 'official'`. Do remove the incorrect table reference and add the proper join condition to establish the relationship between country and language data. The amended query now correctly counts official languages for Afghanistan by joining the appropriate tables with proper key relationships."
        ],
        "rules": [
            "1) When answering about \"How many official languages does Afghanistan have?\": make sure the output order: count of official languages for Afghanistan. 2) When the question mentions \"Afghanistan\": \"Afghanistan\" actually means \"T1.Name = 'Afghanistan'\" in schema. 3) When the question mentions \"official languages\": \"official languages\" actually means \"T2.IsOfficial = 'T'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of official languages\": compute the number of rows using the canonical key relationship established by T1.Code = T2.CountryCode where T1.Name = 'Afghanistan' and T2.IsOfficial = 'T'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Afghanistan' AND status = 'official';",
            "SELECT COUNT(*) \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM country T1\nJOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.Name = 'Afghanistan' AND T2.IsOfficial = 'T'"
        ]
    },
    "209": {
        "db_id": "flight_2",
        "question": "How many flights arriving in Aberdeen city?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `FLIGHTS AS T1` with `AIRPORTS AS T2` on `T1.DestAirport = T2.AirportCode` instead of querying only the `flights` table. Do filter on `T2.City = \"Aberdeen\"` instead of filtering directly on `departure_city = 'Aberdeen'` to correctly identify flights departing from Aberdeen by joining with the airports table. Do use the `JOIN` operation to properly correlate flight destination airports with their corresponding city information instead of relying on a potentially incorrect or non-existent `departure_city` column. The amended query now correctly counts flights with destinations in Aberdeen by properly joining the flights and airports tables."
        ],
        "rules": [
            "1) When answering about flights arriving in a specific city: join FLIGHTS AS T1 with AIRPORTS AS T2 on T1.DestAirport = T2.AirportCode to correlate flight destinations with city information. 2) When the question mentions \"Aberdeen city\": filter on T2.City = \"Aberdeen\" to identify flights arriving in Aberdeen. 3) When counting flights: compute the number of rows using the joined table relationship between T1 and T2 where destination city matches the specified location."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_city = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights AS T1\nJOIN airports AS T2 ON T1.DestAirport = T2.AirportCode\nWHERE T2.City = 'Aberdeen'"
        ]
    },
    "351": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What is the template type code for template type description \"Book\".",
        "ground_truth": "SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  \"Book\"",
        "amends": [
            "Do reference table `Ref_template_types` instead of `template_types` in the FROM clause. Do use double quotes `\"Book\"` instead of single quotes `'Book'` for the string literal in the WHERE filter. The amended query now correctly references the intended table and uses proper string quotation to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about template type code for a specific template type description: reference the table \"Ref_template_types\" instead of \"template_types\" 2) When filtering by template type description \"Book\": use double quotes \"Book\" instead of single quotes 'Book' for the string literal"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM template_types WHERE template_type_description = 'Book';",
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""
        ],
        "rule_sql": [
            "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Description = \"Book\""
        ]
    },
    "505": {
        "db_id": "battle_death",
        "question": "Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.",
        "ground_truth": "SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'",
        "amends": [
            "Do use `EXCEPT` to exclude records instead of a simple `WHERE` filter. Do change the table name to `battle` instead of `battles`. Do add a join with `ship` table on `T1.id = T2.lost_in_battle` instead of omitting this relationship. Do move the location filter to the `ship` table condition `T2.location = 'English Channel'` instead of applying it directly to the battle table. Do remove the `ships_lost = 0` condition instead of keeping it, as the EXCEPT operation now properly handles the exclusion logic. The amended query now correctly excludes battles where ships were lost in the English Channel, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about battles with no ships lost: use EXCEPT operation to exclude battles where ships were lost instead of a simple WHERE filter. 2) When referring to the battles table: use the exact table name \"battle\" instead of \"battles\". 3) When combining battle and ship information: join tables where T1.id = T2.lost_in_battle to link ships to the battles they were lost in. 4) When filtering for location 'English Channel': apply the condition T2.location = 'English Channel' to the ship table instead of the battle table. 5) When determining ships lost: remove the ships_lost = 0 condition since the EXCEPT operation properly handles the exclusion logic for battles where ships were lost."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, result, bulgarian_commander FROM battles WHERE location = 'English Channel' AND ships_lost = 0;",
            "SELECT name, result, bulgarian_commander FROM battle\nEXCEPT\nSELECT T1.name, T1.result, T1.bulgarian_commander FROM battle T1\nJOIN ship T2 ON T1.id = T2.lost_in_battle\nWHERE T2.location = 'English Channel'"
        ],
        "rule_sql": [
            "SELECT name, result, bulgarian_commander FROM battle\nEXCEPT\nSELECT b.name, b.result, b.bulgarian_commander\nFROM battle b\nJOIN ship s ON b.id = s.lost_in_battle\nWHERE s.location = 'English Channel'"
        ]
    },
    "330": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the different template type codes, and how many templates correspond to each?",
        "ground_truth": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code, COUNT(*) FROM templates GROUP BY template_type_code;"
        ],
        "rule_sql": [
            "SELECT t.Template_Type_Code, COUNT(t.Template_ID) AS Template_Count\nFROM Templates t\nGROUP BY t.Template_Type_Code\nORDER BY t.Template_Type_Code;"
        ]
    },
    "443": {
        "db_id": "wta_1",
        "question": "Find the number of distinct name of losers.",
        "ground_truth": "SELECT count(DISTINCT loser_name) FROM matches",
        "amends": [
            "Do use `count(DISTINCT loser_name)` instead of `COUNT(name)` to count distinct values rather than all non-null values. Do query from `matches` table instead of `losers` table to access the correct data source. Do remove the unnecessary table reference `losers` instead of keeping it. The amended query now correctly counts distinct loser names from the matches table instead of counting all names from an incorrect table."
        ],
        "rules": [
            "1) When the question asks for \"distinct name of losers\": use \"loser_name\" from the \"matches\" table to count distinct values. 2) When counting distinct values: use count(DISTINCT loser_name) instead of COUNT(name) to ensure only unique values are counted. 3) When accessing data for losers: query from the \"matches\" table instead of the \"losers\" table to use the correct data source. 4) When the question mentions \"losers\": this refers to the \"loser_name\" column in the \"matches\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(name) FROM losers;",
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT loser_name) FROM matches;"
        ]
    },
    "205": {
        "db_id": "flight_2",
        "question": "How many flights have destination ATO?",
        "ground_truth": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
        "amends": [
            "Do reference the column as `DestAirport` instead of `destination` to match the correct column name in the schema. Do use double quotes `\"ATO\"` instead of single quotes `'ATO'` for the string literal value. Do maintain the same aggregate function `count(*)` and table reference `FLIGHTS` while correcting the column reference and string formatting. The amended query now correctly counts flights where the destination airport code matches ATO, matching the behavior of the right SQL."
        ],
        "rules": [
            "1) When the question asks about flights with destination ATO: use the exact column name \"DestAirport\" from the flights table instead of \"destination\". 2) When comparing airport codes in the flights table: use double quotes \"ATO\" for the literal value instead of single quotes 'ATO'. 3) When counting flights: use count(*) on the flights table to get the total number of flights matching the destination condition."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'ATO';",
            "SELECT COUNT(*) FROM flights WHERE DestAirport = \"ATO\";"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM flights WHERE DestAirport = \"ATO\";"
        ]
    },
    "912": {
        "db_id": "network_1",
        "question": "How many likes does Kyle have?",
        "ground_truth": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
        "amends": [
            "Do use `count(*)` with lowercase instead of `COUNT(*)` with uppercase. Do add `FROM Likes AS T1 JOIN Highschooler AS T2` instead of `FROM users`. Do add join condition `ON T1.student_id = T2.id` instead of omitting it. Do change filter to `WHERE T2.name = \"Kyle\"` instead of `WHERE name = 'Kyle'`. The amended query now correctly counts likes from the student named Kyle by joining the Likes and Highschooler tables instead of incorrectly querying a non-existent users table."
        ],
        "rules": [
            "1) When the question asks about \"likes\" for a student: use the \"Likes\" table as T1 and \"Highschooler\" table as T2 instead of a \"users\" table. 2) When combining T1 and T2 for shared entities: link rows where T1.student_id equals T2.id exactly and keep only matching pairs (inner match). 3) When filtering for a student named \"Kyle\": use the exact literal \"Kyle\" with double quotes in the condition T2.name = \"Kyle\". 4) When counting likes: use count(*) with lowercase instead of uppercase COUNT(*). 5) When answering about \"how many likes does Kyle have\": make sure to count all likes associated with the student named Kyle through the join relationship."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE name = 'Kyle';",
            "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id = T2.ID WHERE T2.name = \"Kyle\""
        ],
        "rule_sql": [
            "SELECT count(*) FROM Likes T1 JOIN Highschooler T2 ON T1.student_id = T2.ID WHERE T2.name = \"Kyle\""
        ]
    },
    "511": {
        "db_id": "student_transcripts_tracking",
        "question": "How is the math course described?",
        "ground_truth": "SELECT course_description FROM Courses WHERE course_name  =  'math'",
        "amends": [
            "Do select `course_description` instead of `description` to reference the correct column name. Do reference table `Courses` with proper capitalization instead of `courses` to match the actual table name. Do use filter `'math'` with lowercase instead of `'Math'` to ensure case-sensitive matching works correctly. The amended query now correctly retrieves the course description from the Courses table where the course name matches 'math' exactly as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for a course description: use the exact column name \"course_description\" from the Courses table. 2) When filtering by course name: use the exact literal value 'math' (lowercase) for case-sensitive matching. 3) When referencing the Courses table: use the exact table name \"Courses\" with proper capitalization."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM courses WHERE course_name = 'Math';",
            "SELECT course_description FROM Courses WHERE course_name = 'math';"
        ],
        "rule_sql": [
            "SELECT course_description FROM Courses WHERE course_name = 'math';"
        ]
    },
    "1028": {
        "db_id": "singer",
        "question": "Show the citizenship shared by singers with birth year before 1945 and after 1955.",
        "ground_truth": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "amends": [
            "Do use `INTERSECT` to find common citizenships instead of `OR` which would return all records matching either condition. Do reference the correct table name `singer` instead of `singers`. Do use proper column names `Citizenship` and `Birth_Year` with correct capitalization instead of lowercase `citizenship` and `birth_year`. Do split into two separate queries with `INTERSECT` to find citizenships that appear in both the pre-1945 and post-1955 birth year groups instead of using a single query with `OR` that returns citizenships from either group independently. The amended query now correctly identifies only those citizenships that have singers born both before 1945 AND after 1955, matching the RIGHT_SQL's set intersection behavior."
        ],
        "rules": [
            "1) When the question asks for a citizenship shared by singers meeting two different conditions: use INTERSECT to find citizenships that appear in both groups rather than OR which would return citizenships from either group independently. 2) When referencing the singer table: use the exact table name \"singer\" instead of \"singers\". 3) When selecting citizenship information: use the exact column name \"Citizenship\" with proper capitalization instead of lowercase \"citizenship\". 4) When filtering by birth year: use the exact column name \"Birth_Year\" with proper capitalization instead of lowercase \"birth_year\". 5) When finding singers born before 1945: create one query selecting \"Citizenship\" from \"singer\" where \"Birth_Year\" < 1945. 6) When finding singers born after 1955: create another query selecting \"Citizenship\" from \"singer\" where \"Birth_Year\" > 1955. 7) When combining the two groups: use INTERSECT between the two queries to find only citizenships that appear in both the pre-1945 and post-1955 birth year groups."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship FROM singers WHERE birth_year < 1945 OR birth_year > 1955;",
            "SELECT Citizenship FROM singer WHERE Birth_Year < 1945\nINTERSECT\nSELECT Citizenship FROM singer WHERE Birth_Year > 1955"
        ],
        "rule_sql": [
            "SELECT \"Citizenship\" FROM \"singer\" WHERE \"Birth_Year\" < 1945\nINTERSECT\nSELECT \"Citizenship\" FROM \"singer\" WHERE \"Birth_Year\" > 1955"
        ]
    },
    "332": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "Return the type code of the template type that the most templates belong to.",
        "ground_truth": "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `template_type_code` from the `Templates` table instead of `type_code` from `template_types`. Do add `GROUP BY template_type_code` to aggregate by the grouping column instead of omitting it. Do use the aggregate function `count(*)` in the ORDER BY clause instead of the invalid `COUNT(*)` without grouping. The amended query now correctly aggregates template counts by type and returns the most frequent template type, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the type code of the template type that the most templates belong to\": make sure the output order: template_type_code. 2) When the question asks for \"count of templates\": compute the number of rows using the canonical key token for templates (e.g., Templates.template_type_code). 3) When the question says \"per template_type_code\"/\"by template_type_code\": organize results by template_type_code and compute requested aggregates per group. 4) When the question mentions \"most templates\": rank rows by count(*) in descending direction and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code FROM template_types ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY COUNT(*) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code\nFROM Templates\nGROUP BY Template_Type_Code\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ]
    },
    "307": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "How many documents are using the template with type code 'PPT'?",
        "ground_truth": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'",
        "amends": [
            "Do add `JOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID` instead of querying only the `documents` table. Do change the filter to `T2.Template_Type_Code = 'PPT'` instead of `template_type = 'PPT'` since the template type information resides in the Templates table rather than the Documents table. Do include the table alias `AS T1` for the Documents table instead of omitting it. The amended query now correctly joins the Documents and Templates tables to filter documents based on their associated template type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"documents using template with type code 'PPT'\": join table \"Documents\" as T1 with table \"Templates\" as T2 using the exact key equality T1.Template_ID = T2.Template_ID and keep only matching pairs (inner match). 2) When the question mentions \"template with type code 'PPT'\": filter for rows where T2.Template_Type_Code exactly equals 'PPT' (preserving case and quotes). 3) When the question asks for \"count of documents\": compute the number of rows using the canonical key from the documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE template_type = 'PPT';",
            "SELECT COUNT(*) \nFROM Documents AS T1\nJOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Template_Type_Code = 'PPT'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Document_ID) \nFROM Documents AS T1\nINNER JOIN Templates AS T2 ON T1.Template_ID = T2.Template_ID\nWHERE T2.Template_Type_Code = 'PPT'"
        ]
    },
    "630": {
        "db_id": "tvshow",
        "question": "What is the produdction code and channel of the most recent cartoon ?",
        "ground_truth": "select production_code ,  channel from cartoon order by original_air_date desc limit 1",
        "amends": [
            "Do reference table `cartoon` instead of `cartoons` and use column `original_air_date` instead of `air_date` for ordering, while keeping the same `SELECT` list with `production_code` and `channel`, maintaining the `DESC` ordering and `LIMIT 1` clause. The amended query now correctly references the proper table name and date column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"cartoons\": use the exact table name \"cartoon\" instead of \"cartoons\". 2) When ordering by the most recent episode: use the column \"original_air_date\" instead of \"air_date\" and sort in descending order. 3) When selecting the most recent cartoon: keep only the top 1 row after ordering by original_air_date in descending order. 4) When outputting results: include the columns \"production_code\" and \"channel\" in that exact order."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT production_code, channel FROM cartoons ORDER BY air_date DESC LIMIT 1;",
            "SELECT production_code, channel FROM Cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT production_code, channel FROM cartoon ORDER BY original_air_date DESC LIMIT 1;"
        ]
    },
    "957": {
        "db_id": "dog_kennels",
        "question": "Find the first names of owners living in Virginia and the names of dogs they own.",
        "ground_truth": "SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT o.first_name, d.name FROM owners o JOIN dogs d ON o.owner_id = d.owner_id WHERE o.state = 'Virginia';"
        ],
        "rule_sql": [
            "SELECT o.first_name, d.name \nFROM Owners o\nJOIN Dogs d ON o.owner_id = d.owner_id\nWHERE o.state = 'Virginia'\nORDER BY o.first_name, d.name;"
        ]
    },
    "658": {
        "db_id": "poker_player",
        "question": "Return the maximum final tables made across all poker players who have earnings below 200000.",
        "ground_truth": "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000",
        "amends": [
            "Do use the correct table name `poker_player` instead of the incorrect `poker_players`. Do use the correct column name `Final_Table_Made` instead of the incorrect `final_tables`. Do use the correct aggregate function `max` (lowercase) instead of `MAX` (uppercase). Do use the correct comparison operator `<` instead of `>` to filter for earnings less than 200000 instead of greater than 200000. Do use the correct column name `Earnings` instead of `earnings` for the filter condition. The amended query now correctly retrieves the maximum number of final tables made by poker players with earnings below 200000, matching the intended behavior."
        ],
        "rules": [
            "1) When referring to poker players in the database: use the exact table name \"poker_player\" instead of \"poker_players\". 2) When the question mentions \"final tables made\": this corresponds to the exact column name \"Final_Table_Made\" in the poker_player table. 3) When filtering for players with earnings below 200000: use the exact column name \"Earnings\" with the comparison operator < 200000, not > 200000. 4) When computing the maximum value: use the aggregate function \"max\" (lowercase) on the \"Final_Table_Made\" column. 5) When answering about maximum final tables across players with earnings below 200000: compute max(\"Final_Table_Made\") from \"poker_player\" where \"Earnings\" < 200000."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(final_tables) FROM poker_players WHERE earnings > 200000;",
            "SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings < 200000"
        ],
        "rule_sql": [
            "SELECT MAX(\"Final_Table_Made\") FROM \"poker_player\" WHERE \"Earnings\" < 200000;"
        ]
    },
    "263": {
        "db_id": "employee_hire_evaluation",
        "question": "What is the number of employees from each city?",
        "ground_truth": "SELECT count(*) ,  city FROM employee GROUP BY city",
        "amends": [
            "Do place `city` after `count(*)` in the SELECT list instead of before it. Do use the correct table name `employee` instead of `employees` in the FROM clause. The amended query now correctly counts employees by city using the proper table reference and column ordering."
        ],
        "rules": [
            "1) When the question asks for \"number of employees from each city\": organize results by the token for \"city\" and compute the count of employees per group. 2) When producing output columns: place the count result before the city column in the output order. 3) When referring to the employee table: use the exact table name \"employee\" instead of \"employees\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM employees GROUP BY city;",
            "SELECT COUNT(*), City FROM employee GROUP BY City;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS employee_count, City FROM employee GROUP BY City;"
        ]
    },
    "686": {
        "db_id": "poker_player",
        "question": "Count the number of different nationalities.",
        "ground_truth": "SELECT count(DISTINCT Nationality) FROM people",
        "amends": [
            "Do use `count(DISTINCT Nationality)` instead of `COUNT(*)` to count distinct nationalities rather than all rows. Do include the `Nationality` column in the aggregate function instead of omitting it from the SELECT list. Do remove the `WHERE nationality IS NOT NULL` filter instead of keeping it, as counting distinct values inherently excludes NULLs. The amended query now correctly counts distinct nationalities and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting the number of different nationalities: use count(DISTINCT Nationality) instead of COUNT(*) to count distinct values rather than all rows. 2) When the question asks for \"different nationalities\": include the Nationality column in the aggregate function instead of omitting it from the output. 3) When counting distinct values: remove any WHERE Nationality IS NOT NULL filter as counting distinct values inherently excludes NULLs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE nationality IS NOT NULL;",
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT Nationality) FROM people;"
        ]
    },
    "939": {
        "db_id": "dog_kennels",
        "question": "Give me the description of the treatment type whose total cost is the lowest.",
        "ground_truth": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
        "amends": [
            "Do select `T1.treatment_type_description` instead of `description` and add a `JOIN` with `Treatments AS T2` on `T1.treatment_type_code = T2.treatment_type_code` instead of querying only `treatment_types`. Do add `GROUP BY T1.treatment_type_code` instead of omitting grouping and use `sum(cost_of_treatment)` for ordering instead of `total_cost`. Do order by `sum(cost_of_treatment) ASC` instead of `total_cost ASC` while keeping the `LIMIT 1`. The amended query now correctly calculates the total treatment cost per type before selecting the cheapest one, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"treatment type whose total cost is the lowest\": make sure the output order: T1.treatment_type_description. 2) When the question mentions \"description\": \"description\" actually means \"T1.treatment_type_description\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.treatment_type_code = T2.treatment_type_code; keep only matching pairs (inner match). 4) When the question says \"per treatment type\"/\"by treatment type\": organize results by T1.treatment_type_code and compute requested aggregates per group. 5) When the question asks for \"total cost\": compute sum(cost_of_treatment) instead of total_cost. 6) When the question asks for \"lowest\" total cost: rank rows by sum(cost_of_treatment) in ascending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM treatment_types ORDER BY total_cost ASC LIMIT 1;",
            "SELECT T1.treatment_type_description\nFROM Treatment_Types AS T1\nJOIN Treatments AS T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.treatment_type_description\nFROM Treatment_Types T1\nINNER JOIN Treatments T2 ON T1.treatment_type_code = T2.treatment_type_code\nGROUP BY T1.treatment_type_code, T1.treatment_type_description\nORDER BY SUM(T2.cost_of_treatment) ASC\nLIMIT 1;"
        ]
    },
    "162": {
        "db_id": "car_1",
        "question": "What is the number of countries with more than 2 car makers ?",
        "ground_truth": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2",
        "amends": [
            "Do join `car_makers` as `t2` on `t1.countryid = t2.country` instead of querying only the `countries` table. Do add `GROUP BY t1.countryid` instead of omitting grouping. Do move the count filter to `HAVING count(*) > 2` instead of using `WHERE car_makers > 2` which incorrectly references a column name rather than an aggregate result. The amended query now correctly counts car makers per country and filters for countries with more than 2 car makers, matching the intended behavior.",
            "Do remove the subquery wrapper instead of keeping it, as the outer `COUNT(*)` over the grouped results was incorrectly counting groups rather than individual countries. Do maintain the `JOIN` between `countries` and `car_makers` on `t1.CountryId = t2.Country` instead of changing the join condition. Do preserve the `GROUP BY t1.CountryId` and `HAVING COUNT(*) > 2` to filter for countries with more than two car makers, instead of altering the grouping or filtering logic. The amended query now correctly counts the number of countries that have more than two associated car makers, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"number of countries with more than 2 car makers\": make sure to join the car_makers table as T2 with countries as T1 using the exact key equality T1.countryid = T2.country. 2) When grouping by country to count car makers: organize results by T1.countryid and compute the count of car makers per country. 3) When filtering for countries with more than 2 car makers: apply the condition count(*) > 2 after grouping instead of before grouping. 4) When counting car makers per country: use the canonical counting approach by counting all rows in the car_makers table that match each country.",
            "1) When combining countries and car_makers tables: link rows where countries.CountryId equals car_makers.Country exactly as shown in the amends (t1.CountryId = t2.Country); keep only matching pairs (inner match). 2) When grouping by country: organize results by t1.CountryId and compute aggregates per country group. 3) When filtering for countries with more than 2 car makers: apply the condition COUNT(*) > 2 to filter country groups. 4) When counting the number of countries that satisfy the condition: compute the count of distinct t1.CountryId values that meet the filtering criteria."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE car_makers > 2;",
            "SELECT COUNT(*) \nFROM (\n    SELECT t1.CountryId \n    FROM countries t1 \n    JOIN car_makers t2 ON t1.CountryId = t2.Country \n    GROUP BY t1.CountryId \n    HAVING COUNT(*) > 2\n)",
            "SELECT COUNT(*) \nFROM countries t1 \nJOIN car_makers t2 ON t1.CountryId = t2.Country \nGROUP BY t1.CountryId \nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfCountries\nFROM (\n    SELECT t1.CountryId\n    FROM countries t1\n    INNER JOIN car_makers t2 ON t1.CountryId = t2.Country\n    GROUP BY t1.CountryId\n    HAVING COUNT(*) > 2\n)"
        ]
    },
    "346": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the codes of template types that are not used for any document?",
        "ground_truth": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "amends": [
            "Do use `EXCEPT` set operation instead of `NOT IN` with subquery for better performance and clarity. Do reference table `Templates` instead of `template_types` to match the correct schema. Do join `Templates AS T1` with `Documents AS T2` on `T1.template_id = T2.template_id` instead of using a subquery with `DISTINCT template_type_code FROM documents`. Do remove the `WHERE` clause with subquery entirely and replace it with the `EXCEPT` operation between two complete SELECT statements. The amended query now correctly identifies template types that exist in Templates but not in any Documents through proper table joins and set operations."
        ],
        "rules": [
            "1) When answering about \"codes of template types that are not used for any document\": make sure the output order: template_type_code. 2) When the question mentions \"template types\": \"template types\" actually means \"Templates table in schema\". 3) When the question mentions \"not used for any document\": use EXCEPT set operation to find template_type_code values that exist in Templates but not in Documents. 4) When combining T1 (Templates) and T2 (Documents) for shared entities: link rows where T1.template_id = T2.template_id; keep only matching pairs (inner match). 5) When producing output: do not reorder columns beyond template_type_code as required by the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT template_type_code FROM template_types WHERE template_type_code NOT IN (SELECT DISTINCT template_type_code FROM documents)",
            "SELECT Template_Type_Code FROM Templates\nEXCEPT\nSELECT DISTINCT T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID"
        ],
        "rule_sql": [
            "SELECT Template_Type_Code\nFROM Templates\nEXCEPT\nSELECT DISTINCT t.Template_Type_Code\nFROM Templates t\nINNER JOIN Documents d ON t.Template_ID = d.Template_ID\nORDER BY Template_Type_Code;"
        ]
    },
    "123": {
        "db_id": "car_1",
        "question": "What are the countries having at least one car maker? List name and id.",
        "ground_truth": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",
        "amends": [
            "Do use explicit `JOIN` syntax with `T1.CountryId = T2.Country` instead of a correlated subquery with `EXISTS`. Do add table aliases `T1` and `T2` instead of using full table names. Do include `GROUP BY T1.CountryId` instead of omitting aggregation. Do move the existence check to `HAVING count(*) >= 1` instead of using `WHERE EXISTS`. Do select `T1.CountryName` and `T1.CountryId` instead of `country_id, country_name`. The amended query now correctly identifies countries with car makers using proper join semantics and aggregation.",
            "Do maintain the same `SELECT` list order with `CountryName` first instead of `CountryId` first. Do use `AS` for table aliases with `COUNTRIES AS T1` instead of omitting the `AS` keyword. Do use uppercase table names `COUNTRIES` and `CAR_MAKERS` instead of lowercase. Do preserve the same join condition `T1.CountryId = T2.Country` and grouping structure with identical `HAVING` clause `count(*) >= 1`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When combining countries and car_makers tables: link rows where T1.CountryId = T2.Country and keep only matching pairs (inner match). 2) When answering about countries having at least one car maker: organize results by T1.CountryId and compute count of car makers per country. 3) When filtering for countries with at least one car maker: keep only groups where count(*) >= 1. 4) When selecting output columns: include T1.CountryName and T1.CountryId in the results. 5) When ordering output: present results in the order T1.CountryId, T1.CountryName as implied by the question asking for \"name and id\".",
            "1) When answering about countries having at least one car maker: make sure the output order is CountryName first, then CountryId. 2) When referring to table names: use uppercase identifiers \"COUNTRIES\" and \"CAR_MAKERS\" exactly as shown. 3) When combining COUNTRIES and CAR_MAKERS: link rows where T1.CountryId = T2.Country and keep only matching pairs (inner match). 4) When grouping by country: organize results by T1.CountryId and compute count of rows per group. 5) When filtering for countries with at least one car maker: keep only groups where the count of rows is greater than or equal to 1."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT country_id, country_name FROM countries WHERE EXISTS (SELECT 1 FROM car_makers WHERE car_makers.country_id = countries.country_id);",
            "SELECT T1.CountryId, T1.CountryName\nFROM countries T1\nJOIN car_makers T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING COUNT(*) >= 1",
            "SELECT T1.CountryName, T1.CountryId\nFROM COUNTRIES AS T1\nJOIN CAR_MAKERS AS T2 ON T1.CountryId = T2.Country\nGROUP BY T1.CountryId\nHAVING count(*) >= 1"
        ],
        "rule_sql": [
            "SELECT T1.CountryName, T1.CountryId \nFROM COUNTRIES T1 \nINNER JOIN CAR_MAKERS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId, T1.CountryName \nHAVING COUNT(*) >= 1 \nORDER BY T1.CountryId, T1.CountryName"
        ]
    },
    "184": {
        "db_id": "flight_2",
        "question": "What are the airline names and abbreviations for airlines in the USA?",
        "ground_truth": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"",
        "amends": [
            "Do use column aliases `Airline` and `Abbreviation` instead of the original column names `airline_name` and `abbreviation`. Do reference the table as `AIRLINES` instead of `airlines`. Do filter with country value `\"USA\"` instead of `'United States'` to match the correct country code format. The amended query now correctly retrieves US airlines using the standardized country code and proper column naming conventions."
        ],
        "rules": [
            "1) When the question asks for airline names and abbreviations: use column aliases \"Airline\" and \"Abbreviation\" as the output columns. 2) When referencing the airlines table: use the exact table name \"AIRLINES\" with proper case. 3) When filtering for airlines in the USA: use the exact country value \"USA\" instead of 'United States' to match the standardized country code format."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT airline_name, abbreviation FROM airlines WHERE country = 'United States';",
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = 'USA';"
        ],
        "rule_sql": [
            "SELECT Airline, Abbreviation FROM AIRLINES WHERE Country = 'USA'"
        ]
    },
    "531": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the description of the department whose name has the substring the computer?",
        "ground_truth": "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'",
        "amends": [
            "Do reference `department_description` in the SELECT list instead of `description`. Do reference `Departments` as the FROM source instead of `departments`. Do filter on `department_name LIKE '%computer%'` instead of `name LIKE '%computer%'`. The amended query now correctly matches the intended table structure and column names to produce the expected results."
        ],
        "rules": [
            "1) When the question asks for \"description of the department\": use the exact column token \"department_description\" instead of \"description\". 2) When referencing the departments table: use the exact table name \"Departments\" with proper capitalization. 3) When filtering for department names containing \"computer\": use the exact column token \"department_name\" with the pattern '%computer%' to find substring matches. 4) When answering about department descriptions: make sure the output order contains only the department_description column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM departments WHERE name LIKE '%computer%';",
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ],
        "rule_sql": [
            "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'"
        ]
    },
    "902": {
        "db_id": "network_1",
        "question": "Count the number of likes for each student id.",
        "ground_truth": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_id, COUNT(*) FROM likes GROUP BY student_id;"
        ],
        "rule_sql": [
            "SELECT student_id, COUNT(liked_id) AS like_count FROM Likes GROUP BY student_id;"
        ]
    },
    "799": {
        "db_id": "world_1",
        "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?",
        "ground_truth": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
        "amends": [
            "Do use `sum(Population)` and `avg(LifeExpectancy)` instead of `SUM(population)` and `AVG(life_expectancy)` with different column names. Do place `Continent` in the SELECT list instead of omitting it from the output. Do remove the `total_population` and `avg_life_expectancy` aliases instead of keeping them. Do use `HAVING avg(LifeExpectancy) < 72` instead of `WHERE avg_life_expectancy < 72` to properly filter aggregated results after grouping. Do reference table `country` instead of `countries`. The amended query now correctly filters on aggregated values using HAVING instead of WHERE and matches the RIGHT_SQL's behavior.",
            "Do place `Continent` at the end of the SELECT list instead of at the beginning. Do maintain the same aggregate functions `sum(Population)` and `avg(LifeExpectancy)` with identical GROUP BY and HAVING clauses using `avg(LifeExpectancy) < 72`. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [
            "1) When answering about continents with population and life expectancy: organize results by the exact column token \"Continent\" from table \"country\". 2) When computing total population: use sum(\"Population\") instead of sum(population) with exact column name. 3) When computing average life expectancy: use avg(\"LifeExpectancy\") instead of avg(life_expectancy) with exact column name. 4) When filtering for continents with average life expectancy less than 72: apply the condition avg(\"LifeExpectancy\") < 72 after grouping using HAVING instead of WHERE. 5) When referencing the table: use table name \"country\" instead of \"countries\" exactly as specified in the schema. 6) When producing output columns: include \"Continent\", sum(\"Population\"), and avg(\"LifeExpectancy\") without aliases total_population and avg_life_expectancy.",
            "1) When answering about \"different continents and the total population and average life expectancy\": make sure the output order: sum(Population), avg(LifeExpectancy), Continent\n2) When the question asks for \"continents that have an average life expectancy less than 72\": filter groups where avg(LifeExpectancy) < 72\n3) When the question says \"per continent\"/\"by continent\": organize results by Continent and compute requested aggregates per group"
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent, SUM(population) as total_population, AVG(life_expectancy) as avg_life_expectancy \nFROM countries \nWHERE avg_life_expectancy < 72 \nGROUP BY continent",
            "SELECT Continent, sum(Population), avg(LifeExpectancy) FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72",
            "SELECT sum(Population), avg(LifeExpectancy), Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy) < 72"
        ],
        "rule_sql": [
            "SELECT Continent, sum(\"Population\"), avg(\"LifeExpectancy\") FROM country GROUP BY Continent HAVING avg(\"LifeExpectancy\") < 72 ORDER BY sum(\"Population\"), avg(\"LifeExpectancy\"), Continent"
        ]
    },
    "210": {
        "db_id": "flight_2",
        "question": "Return the number of flights arriving in Aberdeen.",
        "ground_truth": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
        "amends": [
            "Do join `FLIGHTS` with `AIRPORTS` on `DestAirport = AirportCode` instead of querying `flights` alone. Do filter on `City = \"Aberdeen\"` instead of filtering directly on `departure_airport = 'Aberdeen'`. Do use proper table aliases `T1` and `T2` instead of omitting them. The amended query now correctly counts flights destined for Aberdeen by joining with the airports table to match on city name rather than assuming airport codes contain the city name."
        ],
        "rules": [
            "1) When answering about \"flights arriving in Aberdeen\": make sure the output order:COUNT(*) 2) When the question mentions \"Aberdeen\": \"Aberdeen\" actually means \"City = 'Aberdeen'\" in schema 3) When combining T1 (FLIGHTS) and T2 (AIRPORTS) for shared entities: link rows where T1.DestAirport = T2.AirportCode exactly as shown in the amends; keep only matching pairs (inner match) 4) When the question asks for \"number of flights\": compute the number of rows using the canonical key for flights"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_airport = 'Aberdeen';",
            "SELECT COUNT(*) FROM flights AS T1 JOIN airports AS T2 ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM flights f\nJOIN airports a ON f.DestAirport = a.AirportCode\nWHERE a.City = 'Aberdeen'"
        ]
    },
    "645": {
        "db_id": "tvshow",
        "question": "find the package option of the tv channel that do not have any cartoon directed by Ben Jones.",
        "ground_truth": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "amends": [
            "Do reference table `TV_Channel` instead of `tv_channels` and column `id` instead of `channel_id` in the main query. Do reference table `cartoon` instead of `cartoons` and column `channel` instead of `channel_id` in the subquery. Do use filter condition `directed_by = 'Ben Jones'` instead of `director = 'Ben Jones'` in the subquery's WHERE clause. The amended query now correctly matches the intended logic by using the proper table and column names from the schema."
        ],
        "rules": [
            "1) When answering about \"package option of the tv channel that do not have any cartoon directed by Ben Jones\": make sure the output order: package_option from TV_Channel\n2) When the question mentions \"tv channel\": \"tv channel\" actually means \"TV_Channel in schema\"\n3) When the question mentions \"cartoon directed by Ben Jones\": \"directed by Ben Jones\" actually means \"directed_by = 'Ben Jones' in cartoon table\"\n4) When combining TV_Channel and cartoon for shared entities: link rows where TV_Channel.id = cartoon.channel; keep only matching pairs (inner match)\n5) When filtering for channels without cartoons directed by Ben Jones: exclude channels where there exists a cartoon with directed_by = 'Ben Jones' and matching channel id"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT package_option FROM tv_channels WHERE channel_id NOT IN (SELECT channel_id FROM cartoons WHERE director = 'Ben Jones')",
            "SELECT Package_Option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE directed_by = 'Ben Jones')"
        ],
        "rule_sql": [
            "SELECT DISTINCT tc.Package_Option\nFROM TV_Channel tc\nWHERE tc.id NOT IN (\n    SELECT DISTINCT c.Channel\n    FROM Cartoon c\n    WHERE c.Directed_by = 'Ben Jones'\n)\nORDER BY tc.Package_Option;"
        ]
    },
    "137": {
        "db_id": "car_1",
        "question": "What is the average edispl of the cars of model volvo?",
        "ground_truth": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';",
        "amends": [
            "Do join `CAR_NAMES AS T1` to `CARS_DATA AS T2` on `T1.MakeId = T2.Id` instead of querying only the `cars` table. Do reference `T2.edispl` in the `AVG` function instead of just `edispl`. Do filter on `T1.Model = 'volvo'` instead of `model = 'volvo'` to correctly associate the model name with the appropriate table. The amended query now properly joins the necessary tables to match the model name with engine displacement data, ensuring accurate results."
        ],
        "rules": [
            "1) When answering about \"average edispl of cars of model volvo\": make sure the output order: AVG(T2.edispl) 2) When the question mentions \"model volvo\": \"model volvo\" actually means \"T1.Model = 'volvo'\" in schema 3) When combining CAR_NAMES AS T1 and CARS_DATA AS T2 for shared entities: link rows where T1.MakeId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match) 4) When computing average engine displacement: use T2.edispl as the exact column token for the average calculation"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(edispl) FROM cars WHERE model = 'volvo';",
            "SELECT AVG(T2.Edispl) \nFROM car_names AS T1 \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T1.Model = 'volvo'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.edispl) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
        ]
    },
    "591": {
        "db_id": "tvshow",
        "question": "list all cartoon titles and their directors ordered by their air date",
        "ground_truth": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",
        "amends": [
            "Do select `Directed_by` instead of `director` and order by `Original_air_date` instead of `title`. Do reference table `Cartoon` instead of `cartoons` and remove the column `title` from the SELECT list instead of including it. The amended query now correctly retrieves the directed by information ordered by original air date from the Cartoon table."
        ],
        "rules": [
            "1) When the question asks for cartoon titles and directors: select \"Directed_by\" from table \"Cartoon\" instead of \"director\" from \"cartoons\". 2) When ordering by air date: order by \"Original_air_date\" instead of \"title\". 3) When referencing the table: use \"Cartoon\" instead of \"cartoons\". 4) When selecting columns: do not include \"title\" in the output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, director FROM cartoons ORDER BY title;",
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ],
        "rule_sql": [
            "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date;"
        ]
    },
    "600": {
        "db_id": "tvshow",
        "question": "What is the content of the series Sky Radio?",
        "ground_truth": "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";",
        "amends": [
            "Do select `Content` instead of `*` to specify the exact column needed. Do query from `TV_Channel` instead of `series` to access the correct table containing the content data. Do filter on `series_name` instead of `title` to use the appropriate column name for series identification. Do use double quotes `\"Sky Radio\"` instead of single quotes for string literal consistency. The amended query now correctly retrieves content from the TV_Channel table filtered by series name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"content of the series\": make sure the output order: \"Content\" 2) When the question mentions \"series\": \"series\" actually means \"series_name in TV_Channel table\" 3) When filtering for a specific series name: use double quotes for string literals exactly as shown (e.g., \"Sky Radio\") 4) When selecting from the TV_Channel table: use the exact column name \"Content\" to retrieve the content data 5) When handling text literals: do not change case, spacing, or punctuation from the exact value \"Sky Radio\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM series WHERE title = 'Sky Radio';",
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ],
        "rule_sql": [
            "SELECT Content FROM TV_Channel WHERE series_name = \"Sky Radio\";"
        ]
    },
    "930": {
        "db_id": "dog_kennels",
        "question": "Which owner owns the most dogs? List the owner id, first name and last name.",
        "ground_truth": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do join `Dogs AS T1` to `Owners AS T2` on `T1.owner_id = T2.owner_id` instead of selecting from only `owners` table. Do select `T1.owner_id`, `T2.first_name`, and `T2.last_name` instead of including `COUNT(dog_id) as dog_count` in the SELECT list. Do use `count(*)` in the ORDER BY clause instead of ordering by the aliased `dog_count`. Do remove the explicit aggregation column from GROUP BY and instead group by `T1.owner_id` only. The amended query now correctly joins the Dogs and Owners tables to find the owner with the most dogs while properly handling the relationship between these tables."
        ],
        "rules": [
            "1) When answering about \"which owner owns the most dogs\": make sure the output order: owner_id, first_name, last_name. 2) When combining Dogs and Owners tables: link rows where T1.owner_id = T2.owner_id and keep only matching pairs (inner match). 3) When counting dogs per owner: compute the number of rows using the canonical key T1.owner_id for grouping. 4) When the question asks for \"most dogs\": rank owners by dog count in descending order and keep the first 1 row. 5) When selecting owner information: use T1.owner_id from Dogs table and T2.first_name, T2.last_name from Owners table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner_id, first_name, last_name, COUNT(dog_id) as dog_count FROM owners GROUP BY owner_id ORDER BY dog_count DESC LIMIT 1;",
            "SELECT T2.owner_id, T2.first_name, T2.last_name\nFROM Dogs AS T1\nJOIN Owners AS T2 ON T1.owner_id = T2.owner_id\nGROUP BY T1.owner_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT d.owner_id, o.first_name, o.last_name\nFROM Dogs d\nINNER JOIN Owners o ON d.owner_id = o.owner_id\nGROUP BY d.owner_id, o.first_name, o.last_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "1024": {
        "db_id": "singer",
        "question": "Show the names of singers and the total sales of their songs.",
        "ground_truth": "SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",
        "amends": [
            "Do reference `T1.Name` and `sum(T2.Sales)` instead of `singer_name` and `SUM(sales)`. Do join `singer AS T1` with `song AS T2` on `T1.Singer_ID = T2.Singer_ID` instead of querying only the `songs` table. Do group by `T1.Name` instead of `singer_name`. The amended query now correctly aggregates sales by singer name using the proper table relationships."
        ],
        "rules": [
            "1) When answering about \"names of singers and the total sales of their songs\": make sure the output order: T1.Name, sum(T2.Sales). 2) When the question mentions \"singers\": \"singers\" actually means \"T1.Name in schema\". 3) When the question mentions \"total sales\": \"total sales\" actually means \"sum(T2.Sales) in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.Singer_ID = T2.Singer_ID; keep only matching pairs (inner match). 5) When the question says \"per singer\"/\"by singer\": organize results by T1.Name and compute sum(T2.Sales) per group."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT singer_name, SUM(sales) FROM songs GROUP BY singer_name;",
            "SELECT T1.Name, SUM(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name"
        ],
        "rule_sql": [
            "SELECT T1.Name, SUM(T2.Sales) \nFROM singer T1 \nJOIN song T2 ON T1.Singer_ID = T2.Singer_ID \nGROUP BY T1.Name"
        ]
    },
    "678": {
        "db_id": "poker_player",
        "question": "Return the nationalities for which there are two or more people.",
        "ground_truth": "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM people GROUP BY nationality HAVING COUNT(*) > 1;"
        ],
        "rule_sql": [
            "SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*) >= 2"
        ]
    },
    "969": {
        "db_id": "dog_kennels",
        "question": "Find the number of professionals who have ever treated dogs.",
        "ground_truth": "SELECT count(DISTINCT professional_id) FROM Treatments",
        "amends": [
            "Do count `DISTINCT professional_id` instead of `COUNT(*)` to count unique professionals rather than all records. Do query from the `Treatments` table instead of the `professionals` table to access the correct data source for treatment-related information. Do remove the `WHERE pet_type = 'dog'` filter instead of keeping it since the right query does not include any filtering conditions. Do change the aggregate function to count distinct professional identifiers instead of counting all rows to accurately measure the number of unique professionals providing treatments."
        ],
        "rules": [
            "1) When counting professionals who have provided treatments: count distinct \"professional_id\" values instead of counting all rows to get unique professionals. 2) When accessing treatment-related information: use the \"Treatments\" table as the data source instead of the \"professionals\" table. 3) When the question asks about professionals who have \"ever treated dogs\": do not apply any filtering conditions since we want to count all professionals who have provided any treatments."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM professionals WHERE pet_type = 'dog';",
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT professional_id) FROM Treatments;"
        ]
    },
    "758": {
        "db_id": "world_1",
        "question": "Which languages are spoken by only one country in republic governments?",
        "ground_truth": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
        "amends": [
            "Do use table alias `T2` for the language table instead of `cl` and reference `T2.Language` in SELECT instead of `language`. Do join `country AS T1` instead of `country c` and use `T1.Code = T2.CountryCode` instead of `cl.country_code = c.code` for the join condition. Do reference `T1.GovernmentForm` instead of `c.government` in the WHERE filter while keeping the same 'Republic' value. Do maintain the same GROUP BY on language and HAVING COUNT(*) = 1 condition. The amended query now correctly matches the RIGHT_SQL's behavior with proper table references and join conditions."
        ],
        "rules": [
            "1) When answering about languages spoken by only one country in republic governments: make sure the output order: T2.Language\n2) When combining country table (T1) and language table (T2): link rows where T1.Code = T2.CountryCode and keep only matching pairs (inner match)\n3) When filtering for republic governments: use T1.GovernmentForm = 'Republic' exactly as specified\n4) When grouping by language: organize results by T2.Language and compute aggregates per language group\n5) When counting countries per language: compute the number of rows using the canonical key and ensure the count equals exactly 1"
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as country_count \nFROM country_language cl \nJOIN country c ON cl.country_code = c.code \nWHERE c.government = 'Republic' \nGROUP BY language \nHAVING COUNT(*) = 1;",
            "SELECT T2.Language\nFROM country AS T1\nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = 'Republic'\nGROUP BY T2.Language\nHAVING COUNT(*) = 1"
        ],
        "rule_sql": [
            "SELECT T2.Language\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T1.GovernmentForm = 'Republic'\nGROUP BY T2.Language\nHAVING COUNT(T1.Code) = 1\nORDER BY T2.Language"
        ]
    },
    "558": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the first, middle, and last name of the earliest school graduate?",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
        "amends": [
            "Do query the `Students` table instead of the `graduates` table. Do order by `date_left` instead of `graduation_date`. The amended query now correctly retrieves student names from the appropriate table using the correct date column for ordering."
        ],
        "rules": [
            "1) When answering about \"earliest school graduate\": use the \"Students\" table instead of \"graduates\" table. 2) When ordering by graduation date to find the earliest graduate: use the \"date_left\" column for ordering instead of \"graduation_date\". 3) When retrieving student names: select \"first_name\", \"middle_name\", and \"last_name\" columns from the \"Students\" table. 4) When finding the earliest record: order by \"date_left\" in ascending order and take the first row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM graduates ORDER BY graduation_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students WHERE date_left IS NOT NULL ORDER BY date_left ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_left ASC LIMIT 1;"
        ]
    },
    "419": {
        "db_id": "museum_visit",
        "question": "find the id, name and age for visitors who visited some museums more than once.",
        "ground_truth": "SELECT t1.id ,  t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t1.id HAVING count(*)  >  1",
        "amends": [
            "Do use explicit table aliases `t1` and `t2` instead of bare table names. Do join `visitor AS t1` with `visit AS t2` on `t1.id = t2.visitor_id` instead of using a subquery with `museum_id` filtering. Do group by `t1.id` instead of grouping by `visitor_id, museum_id` in the subquery. Do move the count condition to `HAVING count(*) > 1` instead of using `HAVING COUNT(*) > 1` in a subquery. Do remove the `museum_id` filter entirely instead of including it in the subquery condition. The amended query now correctly identifies visitors with multiple visits by joining directly between visitor and visit tables and grouping by visitor ID."
        ],
        "rules": [
            "1) When answering about \"visitors who visited some museums more than once\": make sure the output order: id, name, age. 2) When combining visitor and visit tables: link rows where t1.id = t2.visitor_id and keep only matching pairs (inner match). 3) When grouping by visitor: organize results by t1.id and compute requested aggregates per group. 4) When counting visits per visitor: compute the number of rows using the canonical key t1.id and keep only groups where count(*) > 1. 5) When the question asks for \"id, name and age\": select exactly t1.id, t1.name, t1.age from the visitor table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name, age FROM visitors WHERE museum_id IN (SELECT museum_id FROM visits GROUP BY visitor_id, museum_id HAVING COUNT(*) > 1);",
            "SELECT t1.ID, t1.Name, t1.Age\nFROM visitor AS t1\nJOIN visit AS t2 ON t1.ID = t2.visitor_ID\nGROUP BY t1.ID\nHAVING COUNT(*) > 1"
        ],
        "rule_sql": [
            "SELECT t1.ID, t1.Name, t1.Age\nFROM visitor t1\nINNER JOIN visit t2 ON t1.ID = t2.visitor_ID\nGROUP BY t1.ID\nHAVING COUNT(*) > 1\nORDER BY t1.ID, t1.Name, t1.Age;"
        ]
    },
    "490": {
        "db_id": "wta_1",
        "question": "How many players are there for each hand type?",
        "ground_truth": "SELECT count(*) ,  hand FROM players GROUP BY hand",
        "amends": [
            "Do use `hand` instead of `hand_type` as the grouping column. Do place `count(*)` as the first column in the SELECT list instead of second. Do remove the alias `hand_type` and use the actual column name `hand` instead. The amended query now correctly groups by the actual column name and presents the count as the first result column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"hand type\": use the exact column token \"hand\" from the players table. 2) When grouping by hand type: organize results by the \"hand\" column and compute counts per group. 3) When counting players: compute the number of rows using the canonical key for players. 4) When presenting results for \"how many players are there for each hand type\": place the count result as the first output column followed by the hand type column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT hand_type, COUNT(*) FROM players GROUP BY hand_type;",
            "SELECT COUNT(*), hand FROM players GROUP BY hand;"
        ],
        "rule_sql": [
            "SELECT COUNT(player_id) AS player_count, hand FROM players GROUP BY hand;"
        ]
    },
    "923": {
        "db_id": "dog_kennels",
        "question": "Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.",
        "ground_truth": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "amends": [
            "Do use `professional_id` instead of `id` and `cell_number` instead of `cell_phone` in the SELECT list. Do change the table name to `Professionals` instead of `professionals`. Do replace the WHERE clause with a UNION operation instead of using OR logic. Do add a second query that joins `Professionals AS T1` with `Treatments AS T2` on `T1.professional_id = T2.professional_id` instead of omitting this join. Do move the count condition to `HAVING count(*) > 2` instead of keeping it in the WHERE clause. Do use proper table aliases and group by `T1.professional_id` instead of not grouping. The amended query now correctly separates Indiana professionals from those with more than 2 treatments using UNION instead of incorrect OR logic that would miss the join requirement."
        ],
        "rules": [
            "1) When selecting professional information: use \"professional_id\" instead of \"id\" and \"cell_number\" instead of \"cell_phone\" in the output columns. 2) When referring to the professionals table: use the exact table name \"Professionals\" with proper capitalization. 3) When finding professionals who live in Indiana or have performed more than two treatments: use a UNION operation instead of OR logic to combine two separate result sets. 4) When counting treatments per professional: join \"Professionals AS T1\" with \"Treatments AS T2\" on \"T1.professional_id = T2.professional_id\" using an inner match. 5) When filtering professionals by treatment count: group by \"T1.professional_id\" and use \"HAVING count(*) > 2\" instead of a WHERE clause condition. 6) When the question mentions \"state of Indiana\": use the exact literal value 'Indiana' with proper capitalization for state comparison."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, last_name, cell_phone FROM professionals WHERE state = 'Indiana' OR treatment_count > 2",
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ],
        "rule_sql": [
            "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana'\nUNION\nSELECT T1.professional_id, T1.last_name, T1.cell_number \nFROM Professionals AS T1\nINNER JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id\nGROUP BY T1.professional_id\nHAVING COUNT(*) > 2"
        ]
    },
    "420": {
        "db_id": "museum_visit",
        "question": "What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?",
        "ground_truth": "SELECT t2.visitor_id ,  t1.name ,  t1.Level_of_membership FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t2.visitor_id ORDER BY sum(t2.Total_spent) DESC LIMIT 1",
        "amends": [
            "Do select `t2.visitor_id`, `t1.name`, and `t1.Level_of_membership` instead of `v.id`, `v.name`, and `v.membership_level`. Do use table aliases `t1` for `visitor` and `t2` for `visit` instead of `v` for `visitors` and `t` for `tickets`. Do join `visit` table instead of `tickets` table. Do reference `t2.Total_spent` in the aggregate instead of `t.price`. Do order by `sum(t2.Total_spent) DESC` instead of `total_spent ASC`. Do remove the explicit `GROUP BY` clause for name and membership level instead of including them. The amended query now correctly identifies the highest spending visitor by joining the appropriate tables and using the correct spending column with descending order."
        ],
        "rules": [
            "1) When joining tables for visitor spending analysis: use table alias t1 for visitor table and t2 for visit table instead of v for visitors and t for tickets. 2) When selecting visitor information: select t2.visitor_id, t1.name, and t1.Level_of_membership instead of v.id, v.name, and v.membership_level. 3) When calculating total spending: reference t2.Total_spent in the aggregate instead of t.price. 4) When ordering results by spending: order by sum(t2.Total_spent) DESC instead of total_spent ASC to find largest amounts. 5) When grouping results: remove the explicit GROUP BY clause for name and membership level instead of including them."
        ],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT v.id, v.name, v.membership_level, SUM(t.price) as total_spent\nFROM visitors v\nJOIN tickets t ON v.id = t.visitor_id\nGROUP BY v.id, v.name, v.membership_level\nORDER BY total_spent ASC\nLIMIT 1;",
            "SELECT t2.visitor_ID, t1.Name, t1.Level_of_membership\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nGROUP BY t2.visitor_ID\nORDER BY SUM(t2.Total_spent) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t2.visitor_ID, t1.Name, t1.Level_of_membership\nFROM visitor t1\nJOIN visit t2 ON t1.ID = t2.visitor_ID\nORDER BY SUM(t2.Total_spent) DESC\nLIMIT 1;"
        ]
    },
    "113": {
        "db_id": "car_1",
        "question": "How many car makers are there in france?",
        "ground_truth": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';",
        "amends": [
            "Do add a `JOIN` with `COUNTRIES` table on `T1.Country = T2.CountryId` instead of querying only the `car_makers` table. Do filter on `T2.CountryName = 'france'` instead of directly filtering on `country = 'France'` to properly match country names through the relationship table. Do use table aliases `T1` and `T2` instead of referencing tables directly without aliases. The amended query now correctly joins the country reference table to filter by country name instead of relying on potentially inconsistent country codes in the main table."
        ],
        "rules": [
            "1) When answering about \"car makers in france\": make sure to join T1 (car_makers) with T2 (COUNTRIES) using the exact join condition T1.Country = T2.CountryId. 2) When filtering by country name: use T2.CountryName = 'france' exactly as specified (lowercase 'france'). 3) When counting car makers: use the canonical key from T1 (car_makers table) to count the number of rows. 4) When combining tables for shared entities: perform an inner match where T1.Country equals T2.CountryId and keep only matching pairs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM car_makers WHERE country = 'France';",
            "SELECT COUNT(*) \nFROM car_makers T1\nJOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM car_makers T1\nINNER JOIN countries T2 ON T1.Country = T2.CountryId\nWHERE T2.CountryName = 'france'"
        ]
    },
    "26": {
        "db_id": "concert_singer",
        "question": "Which year has most number of concerts?",
        "ground_truth": "SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select only `YEAR` instead of both `year` and `concert_count`. Do use `concert` as the table name instead of `concerts`. Do order by `count(*) DESC` instead of `concert_count ASC` to find the year with the most concerts rather than the fewest. Do remove the explicit alias `concert_count` since it's not needed in the ORDER BY clause. The amended query now correctly identifies the year with the highest number of concerts by counting records per year and ordering descending by count."
        ],
        "rules": [
            "1) When answering about \"which year has most number of concerts\": make sure the output order: YEAR. 2) When the question mentions \"concerts\": \"concerts\" actually means \"concert\" in schema. 3) When the question asks for \"most number of concerts\": count the number of rows using the canonical key and order by count(*) DESC to find the year with the highest count. 4) When producing output: do not include explicit aliases like concert_count in the final output columns."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, COUNT(*) as concert_count FROM concerts GROUP BY year ORDER BY concert_count ASC LIMIT 1;",
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Year FROM concert GROUP BY Year ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "247": {
        "db_id": "flight_2",
        "question": "What are flight numbers of flights departing from Airport \"APG\"?",
        "ground_truth": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
        "amends": [
            "Do reference column `FlightNo` instead of `flight_number` in the SELECT list. Do reference table `FLIGHTS` instead of `flights` in the FROM clause. Do use filter condition `SourceAirport = \"APG\"` instead of `departure_airport = 'APG'` in the WHERE clause. The amended query now correctly retrieves flight numbers from the FLIGHTS table where the source airport matches APG, using the proper column names and table reference as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about flight numbers: use column \"FlightNo\" from table \"FLIGHTS\" as the output column. 2) When the question mentions \"departing from Airport\": this corresponds to filtering where column \"SourceAirport\" equals the exact literal \"APG\". 3) When selecting from the flights table: use the exact table name \"FLIGHTS\" with proper case and quoting as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE departure_airport = 'APG';",
            "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport = \"APG\""
        ],
        "rule_sql": [
            "SELECT \"FlightNo\" FROM \"FLIGHTS\" WHERE \"SourceAirport\" = 'APG'"
        ]
    },
    "825": {
        "db_id": "orchestra",
        "question": "What are the names of conductors, ordered by age?",
        "ground_truth": "SELECT Name FROM conductor ORDER BY Age ASC",
        "amends": [
            "Do select `Name` instead of `name` and order by `Age ASC` instead of `name`. Do use table `conductor` instead of `conductors`."
        ],
        "rules": [
            "1) When the question asks for conductor names: use the exact column token \"Name\" from table \"conductor\" instead of \"name\". 2) When ordering conductors by age: order by column \"Age ASC\" instead of by name. 3) When referring to the conductors table: use table name \"conductor\" instead of \"conductors\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM conductors ORDER BY name;",
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ],
        "rule_sql": [
            "SELECT Name FROM conductor ORDER BY Age ASC;"
        ]
    },
    "348": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the type codes and descriptions for all template types?",
        "ground_truth": "SELECT template_type_code ,  template_type_description FROM Ref_template_types",
        "amends": [
            "Do use table `Ref_template_types` instead of `template_types`. Do select column `template_type_code` instead of `type_code` and `template_type_description` instead of `description`. Do remove the `WHERE type_code IS NOT NULL` filter instead of keeping it, as the right query retrieves all records without null filtering. The amended query now correctly references the proper table and column names to match the intended schema structure."
        ],
        "rules": [
            "1) When answering about \"type codes and descriptions for all template types\": use table \"Ref_template_types\" as the base table T1. 2) When selecting the type code column: use \"template_type_code\" from T1 instead of \"type_code\". 3) When selecting the description column: use \"template_type_description\" from T1 instead of \"description\". 4) When retrieving all records: do not apply any null filtering condition on type codes."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT type_code, description FROM template_types WHERE type_code IS NOT NULL",
            "SELECT Template_Type_Code, Template_Type_Description FROM Ref_Template_Types;"
        ],
        "rule_sql": [
            "SELECT template_type_code, template_type_description FROM Ref_Template_Types"
        ]
    },
    "533": {
        "db_id": "student_transcripts_tracking",
        "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.",
        "ground_truth": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
        "amends": [
            "Do add `Student_Enrolment` table with `JOIN` on `T1.student_id = T2.student_id` instead of omitting it. Do change the aggregation to group by `T1.student_id` instead of `semester`. Do move the count condition to `HAVING count(*) = 2` instead of placing it in `WHERE COUNT(degree_program) = 2`. Do remove the `degree_program` column reference and use `count(*)` instead. Do add table aliases `T1` and `T2` with proper qualification instead of using unqualified column names. The amended query now correctly identifies students with exactly two enrollments by joining the enrollment table and using proper aggregation with HAVING clause.",
            "Do include only `T1.student_id` in the GROUP BY clause instead of grouping by both `s.student_id` and `se.semester_id`. Do use `count(*) = 2` in the HAVING clause instead of `COUNT(DISTINCT se.degree_program_id) = 2` to count total enrollment records rather than distinct degree programs. Do remove the unnecessary `se.semester_id` from the GROUP BY since the aggregation logic focuses on student-level enrollment counts rather than semester-based degree program analysis. The amended query now correctly identifies students with exactly two enrollment records regardless of semester or degree program, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students enrolled in 2 degree programs: make sure to join the Student_Enrolment table using T1.student_id = T2.student_id instead of using only the students table. 2) When grouping for enrollment counts: group by T1.student_id instead of semester. 3) When filtering for exactly 2 enrollments: use HAVING count(*) = 2 instead of WHERE COUNT(degree_program) = 2. 4) When counting enrollments: use count(*) instead of count(degree_program). 5) When using multiple tables: add table aliases T1 and T2 with proper qualification instead of using unqualified column names.",
            "1) When grouping students by their enrollment records: use only \"T1.student_id\" in the grouping clause, not additional columns like semester_id. 2) When counting enrollment records for students: use count(*) = 2 to count total enrollment records rather than counting distinct degree programs. 3) When the question asks about students enrolled in 2 degree programs: interpret this as students having exactly two enrollment records total across all semesters and degree programs."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name, student_id \nFROM students \nWHERE COUNT(degree_program) = 2 \nGROUP BY semester;",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id, se.semester_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2",
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nHAVING COUNT(*) = 2"
        ],
        "rule_sql": [
            "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment T1 ON s.student_id = T1.student_id\nJOIN Student_Enrolment T2 ON s.student_id = T2.student_id\nWHERE T1.student_enrolment_id != T2.student_enrolment_id\nGROUP BY s.student_id\nHAVING COUNT(*) = 2"
        ]
    },
    "60": {
        "db_id": "pets_1",
        "question": "What are the students' first names who have both cats and dogs as pets?",
        "ground_truth": "SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog'",
        "amends": [
            "Do use `T1.Fname` instead of `first_name` for the column selection. Do join `student AS T1` with `has_pet AS T2` on `T1.stuid = T2.stuid` and then join `pets AS T3` on `T3.petid = T2.petid` instead of querying a single `students` table. Do filter for `T3.pettype = 'cat'` in one query branch and `T3.pettype = 'dog'` in another instead of using contradictory `AND` conditions `pet_type = 'cat' AND pet_type = 'dog'`. Do use `INTERSECT` to find students who have both cat and dog pets instead of trying to find records where a single pet is both a cat and dog simultaneously. The amended query now correctly identifies students who have both types of pets by intersecting two separate queries for each pet type."
        ],
        "rules": [
            "1) When the question asks for \"students' first names\": use the exact column token \"T1.Fname\" for output. 2) When combining student and pet information: join \"student AS T1\" with \"has_pet AS T2\" where \"T1.stuid = T2.stuid\" and then join \"pets AS T3\" where \"T3.petid = T2.petid\", keeping only matching rows (inner match). 3) When finding students with cats: filter for \"T3.pettype = 'cat'\" exactly as specified. 4) When finding students with dogs: filter for \"T3.pettype = 'dog'\" exactly as specified. 5) When identifying students who have both cats and dogs: use INTERSECT to combine results from the cat query and dog query instead of using contradictory AND conditions on the same column."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet_type = 'cat' AND pet_type = 'dog'",
            "SELECT T1.Fname\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'\nINTERSECT\nSELECT T1.Fname\nFROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT T1.Fname FROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'cat'\nINTERSECT\nSELECT T1.Fname FROM student AS T1\nJOIN has_pet AS T2 ON T1.StuID = T2.StuID\nJOIN pets AS T3 ON T3.PetID = T2.PetID\nWHERE T3.PetType = 'dog'"
        ]
    },
    "366": {
        "db_id": "cre_Doc_Template_Mgt",
        "question": "What are the paragraph texts for the document with the name 'Customer reviews'?",
        "ground_truth": "SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  \"Customer reviews\"",
        "amends": [
            "Do reference `T1.paragraph_text` from the `Paragraphs` table instead of directly selecting `paragraph_text` from `documents`. Do join `Paragraphs AS T1` with `Documents AS T2` on `T1.document_id = T2.document_id` instead of querying only the `documents` table. Do filter on `T2.document_name = \"Customer reviews\"` instead of `name = 'Customer reviews'` to properly reference the document name column. The amended query now correctly retrieves paragraph text by joining the Paragraphs and Documents tables and filtering on the document name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"paragraph texts for the document with the name 'Customer reviews'\": make sure the output order: T1.paragraph_text. 2) When the question mentions \"document with the name 'Customer reviews'\": \"name\" actually means \"T2.document_name in schema\" and use the exact literal \"Customer reviews\". 3) When combining T1 (Paragraphs) and T2 (Documents) for shared entities: link rows where T1.document_id = T2.document_id; keep only matching pairs (inner match). 4) When selecting paragraph text: reference T1.paragraph_text from the Paragraphs table instead of directly selecting from documents table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT paragraph_text FROM documents WHERE name = 'Customer reviews';",
            "SELECT T1.Paragraph_Text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Document_Name = 'Customer reviews'"
        ],
        "rule_sql": [
            "SELECT T1.paragraph_text \nFROM Paragraphs T1\nINNER JOIN Documents T2 ON T1.document_id = T2.document_id\nWHERE T2.document_name = 'Customer reviews'\nORDER BY T1.paragraph_text"
        ]
    },
    "632": {
        "db_id": "tvshow",
        "question": "What are the package options and the name of the series for the TV Channel that supports high definition TV?",
        "ground_truth": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"",
        "amends": [
            "Do reference the table as `TV_Channel` instead of `tv_channels` to match the correct table name. Do use the column name `package_option` instead of `package_options` to select the correct singular column. Do filter on `hight_definition_TV = \"yes\"` instead of `supports_hd = 'yes'` to use the proper column name and double quotes for the string literal. The amended query now correctly retrieves package options and series names from the TV_Channel table where high definition TV is supported."
        ],
        "rules": [
            "1) When referencing the TV channels table: use the exact table name \"TV_Channel\" with double quotes and proper capitalization. 2) When selecting package options: use the column name \"package_option\" (singular) with double quotes. 3) When filtering for high definition TV support: use the column name \"hight_definition_TV\" with double quotes and the literal value \"yes\" with double quotes. 4) When answering about TV channels that support high definition: make sure the output order includes \"package_option\" followed by \"series_name\"."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT package_options, series_name FROM tv_channels WHERE supports_hd = 'yes';",
            "SELECT Package_Option, series_name FROM TV_Channel WHERE Hight_definition_TV = \"yes\";"
        ],
        "rule_sql": [
            "SELECT \"package_option\", \"series_name\" FROM \"TV_Channel\" WHERE \"hight_definition_TV\" = \"yes\""
        ]
    },
    "829": {
        "db_id": "orchestra",
        "question": "Return the record companies of orchestras, sorted descending by the years in which they were founded.",
        "ground_truth": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC",
        "amends": [
            "Do reference the `Record_Company` column instead of `record_company` and remove the `founded_year` column instead of including it. Do use the `orchestra` table instead of `orchestras` as the data source. Do order by `Year_of_Founded` instead of `founded_year` and use `DESC` ordering instead of `ASC`. The amended query now correctly selects only the record company column from the orchestra table ordered by year of founding in descending order."
        ],
        "rules": [
            "1) When answering about \"record companies of orchestras\": make sure the output order: \"Record_Company\" only. 2) When the question mentions \"record companies\": \"record companies\" actually means \"Record_Company\" in schema. 3) When the question mentions \"years in which they were founded\": \"years in which they were founded\" actually means \"Year_of_Founded\" in schema. 4) When the question says \"sorted descending by the years\": rank rows by \"Year_of_Founded\" in descending order. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation for values like 'Mercury Records', 'Columbia Masterworks', 'Philips', 'Kultur', 'Decca Records'."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT record_company, founded_year FROM orchestras ORDER BY founded_year ASC;",
            "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC;"
        ],
        "rule_sql": [
            "SELECT \"Record_Company\" FROM \"orchestra\" ORDER BY \"Year_of_Founded\" DESC;"
        ]
    },
    "181": {
        "db_id": "flight_2",
        "question": "What is the abbreviation of Airline \"JetBlue Airways\"?",
        "ground_truth": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  \"JetBlue Airways\"",
        "amends": [
            "Do reference the column `Abbreviation` instead of `abbreviation` to match the correct case sensitivity. Do reference the table `AIRLINES` instead of `Airlines` to match the correct table name case. Do use the filter condition `Airline = \"JetBlue Airways\"` instead of `name = 'JetBlue Airways'` to reference the correct column name and use double quotes instead of single quotes for the string literal. The amended query now correctly retrieves the abbreviation for JetBlue Airways by using the proper column and table names with appropriate case sensitivity and string quoting."
        ],
        "rules": [
            "1) When the question asks for abbreviation of an airline: use the exact column token \"Abbreviation\" from table \"AIRLINES\" with proper case sensitivity. 2) When filtering for airline name \"JetBlue Airways\": use the exact column token \"Airline\" with double quotes around the literal value \"JetBlue Airways\". 3) When referencing table names: use the exact table name \"AIRLINES\" with proper case sensitivity as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT abbreviation FROM Airlines WHERE name = 'JetBlue Airways';",
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\""
        ],
        "rule_sql": [
            "SELECT Abbreviation FROM AIRLINES WHERE Airline = \"JetBlue Airways\";"
        ]
    },
    "652": {
        "db_id": "poker_player",
        "question": "What are the final tables made and best finishes for all poker players?",
        "ground_truth": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player",
        "amends": [
            "Do reference the correct table name `poker_player` instead of the incorrect `poker_players`. Do use the correct column names `Final_Table_Made` and `Best_Finish` instead of the incorrect `player_name`, `final_table`, and `best_finish`. Do maintain the `ORDER BY Best_Finish DESC` clause as it correctly sorts the results. The amended query now correctly selects the intended columns from the proper table while preserving the sorting logic."
        ],
        "rules": [
            "1) When the question asks about poker players: use the exact table name \"poker_player\" instead of any variations like \"poker_players\". 2) When selecting final tables made: use the exact column name \"Final_Table_Made\" with the correct case and spelling. 3) When selecting best finishes: use the exact column name \"Best_Finish\" with the correct case and spelling. 4) When ordering results by best finish: sort by \"Best_Finish\" in descending order (highest to lowest values)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, final_table, best_finish FROM poker_players ORDER BY best_finish DESC;",
            "SELECT Final_Table_Made, Best_Finish FROM poker_player ORDER BY Best_Finish DESC;"
        ],
        "rule_sql": [
            "SELECT Final_Table_Made, Best_Finish FROM poker_player ORDER BY Best_Finish DESC;"
        ]
    },
    "703": {
        "db_id": "world_1",
        "question": "Give the names of the nations that were founded after 1950.",
        "ground_truth": "SELECT Name FROM country WHERE IndepYear  >  1950",
        "amends": [
            "Do select `Name` instead of `name` and use table `country` instead of `nations`. Do filter on `IndepYear > 1950` instead of `founded_year < 1950`, changing both the column reference and the comparison operator direction. The amended query now correctly retrieves countries with independence years after 1950 from the appropriate table."
        ],
        "rules": [
            "1) When the question asks for \"nations\": use table \"country\" instead of \"nations\" as the main data source. 2) When the question asks for \"names\": select column \"Name\" from table \"country\" instead of \"name\". 3) When the question asks for nations \"founded after 1950\": filter using column \"IndepYear > 1950\" instead of \"founded_year < 1950\", changing both the column reference and comparison operator direction to get values greater than 1950."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM nations WHERE founded_year < 1950;",
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ],
        "rule_sql": [
            "SELECT Name FROM country WHERE IndepYear > 1950"
        ]
    },
    "53": {
        "db_id": "pets_1",
        "question": "Find the number of dog pets that are raised by female students (with sex F).",
        "ground_truth": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
        "amends": [
            "Do use a three-table join chain starting with `student` instead of a direct two-table join between `pets` and `students`. Do join through `has_pet` as an intermediate table with `ON T1.stuid = T2.stuid` instead of directly joining `pets` to `students`. Do then join `pets` with `ON T2.petid = T3.petid` instead of `ON p.owner_id = s.student_id`. Do filter on `T1.sex = 'F'` instead of `s.sex = 'M'` to count female students instead of male students. Do filter on `T3.pettype = 'dog'` instead of `p.type = 'dog'` using the correct column name. The amended query now correctly counts female students who own dogs through the proper relationship table structure."
        ],
        "rules": [
            "1) When answering about \"number of dog pets raised by female students\": make sure the output order: count of dog pets owned by female students. 2) When the question mentions \"dog pets\": \"dog\" actually means \"pettype = 'dog'\" in schema. 3) When the question mentions \"female students\": \"female\" actually means \"sex = 'F'\" in schema. 4) When combining tables for student-pet relationships: use a three-table join chain starting with \"student\" as T1, then \"has_pet\" as T2 with ON T1.stuid = T2.stuid, then \"pets\" as T3 with ON T2.petid = T3.petid. 5) When filtering for dog pets: use T3.pettype = 'dog' exactly as specified. 6) When filtering for female students: use T1.sex = 'F' exactly as specified. 7) When counting dog pets owned by female students: compute the number of rows using the proper join chain that connects female students to their dog pets through the has_pet relationship table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM pets p JOIN students s ON p.owner_id = s.student_id WHERE p.type = 'dog' AND s.sex = 'M';",
            "SELECT COUNT(*) \nFROM Student s\nJOIN Has_Pet hp ON s.StuID = hp.StuID\nJOIN Pets p ON hp.PetID = p.PetID\nWHERE s.Sex = 'F' AND p.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Student AS T1\nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID\nJOIN Pets AS T3 ON T2.PetID = T3.PetID\nWHERE T1.Sex = 'F' AND T3.PetType = 'dog'"
        ]
    },
    "562": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the id, line 1, and line 2 of the address with the most students?",
        "ground_truth": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do add `T1.address_id` and remove `id` in the SELECT list instead of using the original column name. Do add `FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id = T2.current_address_id` instead of just selecting from `addresses` without joining. Do add `GROUP BY T1.address_id` to aggregate by address instead of omitting grouping. Do change the ORDER BY to `count(*) DESC` instead of `student_count DESC` to count actual students per address. Do keep `LIMIT 1` to return the single address with the most students. The amended query now correctly identifies the address with the highest student count by joining and counting relationships instead of relying on a potentially non-existent student_count column."
        ],
        "rules": [
            "1) When answering about \"address with the most students\": make sure the output order: T1.address_id, T1.line_1, T1.line_2. 2) When the question asks for \"most students\": count the number of students using T2.current_address_id as the counting key. 3) When combining Addresses and Students tables: link rows where T1.address_id = T2.current_address_id and keep only matching pairs (inner match). 4) When grouping by address: organize results by T1.address_id and compute the count of students per group. 5) When ranking addresses by student count: rank rows by count(*) in descending order and keep the first 1 row."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, line_1, line_2 FROM addresses ORDER BY student_count DESC LIMIT 1;",
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses AS T1\nJOIN Students AS T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY count(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.address_id, T1.line_1, T1.line_2\nFROM Addresses T1\nINNER JOIN Students T2 ON T1.address_id = T2.current_address_id\nGROUP BY T1.address_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "276": {
        "db_id": "employee_hire_evaluation",
        "question": "Which shops' number products is above the average? Give me the shop names.",
        "ground_truth": "SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop)",
        "amends": [
            "Do reference column `name` instead of `shop_name` and use `number_products` instead of `products` in the main query. Do reference table `shop` instead of `shops` in both the main query and subquery. Do use the aggregate function `avg()` instead of `AVG()` and reference `number_products` instead of `products` in the subquery. Do remove the incorrect `COUNT()` function wrapping around `number_products` in the main filter condition instead of using it, as the comparison should be between the column value and the average rather than counting products. The amended query now correctly compares each shop's product count against the average product count across all shops."
        ],
        "rules": [
            "1) When the question mentions \"shop names\": use the exact column token \"name\" from the \"shop\" table. 2) When the question asks for shops where \"number products is above the average\": compare the \"number_products\" column value directly against the average of \"number_products\" across all shops, without using COUNT() function. 3) When computing the average for comparison: calculate the average of \"number_products\" from the \"shop\" table using avg() function. 4) When referencing tables: use \"shop\" table instead of \"shops\" in both main query and subquery."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT shop_name FROM shops WHERE COUNT(products) > (SELECT AVG(COUNT(products)) FROM shops);",
            "SELECT name FROM shop WHERE number_products > (SELECT AVG(number_products) FROM shop)"
        ],
        "rule_sql": [
            "SELECT name FROM shop WHERE number_products > (SELECT AVG(number_products) FROM shop)"
        ]
    },
    "516": {
        "db_id": "student_transcripts_tracking",
        "question": "What is the name and id of the department with the most number of degrees ?",
        "ground_truth": "select t2.department_name ,  t1.department_id from degree_programs as t1 join departments as t2 on t1.department_id  =  t2.department_id group by t1.department_id order by count(*) desc limit 1",
        "amends": [
            "Do join `degree_programs as t1` with `departments as t2` on `t1.department_id = t2.department_id` instead of querying only the `departments` table. Do add `GROUP BY t1.department_id` to aggregate by department instead of omitting grouping. Do use `count(*)` to count all degree programs instead of `COUNT(degrees)` which references an undefined column. Do select `t2.department_name` and `t1.department_id` from the joined tables instead of selecting columns directly from a single table. The amended query now correctly counts degree programs per department and returns the department with the most programs, matching the intended behavior.",
            "Do remove `COUNT(*) as degree_count` from the SELECT list instead of including it, and do move the `COUNT(*)` expression to the ORDER BY clause instead of keeping it in SELECT. Do keep `t2.department_name` and `t1.department_id` in SELECT instead of removing them. Do maintain the same FROM clause with `JOIN` on `t1.department_id = t2.department_id` instead of changing it. Do preserve the GROUP BY on `t1.department_id` instead of modifying it. Do change ORDER BY to use `COUNT(*) desc` instead of `degree_count DESC` to properly sort by the aggregate count. Do keep LIMIT 1 instead of changing it. The amended query now correctly returns the department with the most degree programs by counting records in the grouping rather than selecting the count value."
        ],
        "rules": [
            "1) When answering about \"department with the most number of degrees\": join degree_programs as T1 with departments as T2 on T1.department_id = T2.department_id using inner match. 2) When counting degree programs per department: use count(*) to count all rows in T1 grouped by T1.department_id. 3) When selecting department information: output T2.department_name and T1.department_id from the joined tables. 4) When finding the department with the most degrees: order results by the count in descending order and keep only the top 1 row.",
            "1) When counting degree programs per department: use COUNT(*) to count the number of rows in each group instead of selecting the count value in the output. 2) When ordering by the count of degree programs: use COUNT(*) DESC in the ORDER BY clause instead of referencing an alias from the SELECT list. 3) When selecting department information: include t2.department_name and t1.department_id in the output columns. 4) When grouping by department: use GROUP BY t1.department_id to organize results by department identifier. 5) When finding the department with the most degrees: use LIMIT 1 to return only the top result after ordering by count in descending order. 6) When joining Degree_Programs and Departments: link tables using t1.department_id = t2.department_id to match department records."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT department_name, department_id FROM departments ORDER BY COUNT(degrees) DESC LIMIT 1;",
            "SELECT t2.department_name, t1.department_id, COUNT(*) as degree_count\nFROM Degree_Programs as t1\nJOIN Departments as t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY degree_count DESC\nLIMIT 1;",
            "SELECT t2.department_name, t1.department_id\nFROM Degree_Programs AS t1\nJOIN Departments AS t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.department_name, t1.department_id\nFROM Degree_Programs t1\nINNER JOIN Departments t2 ON t1.department_id = t2.department_id\nGROUP BY t1.department_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ]
    },
    "814": {
        "db_id": "world_1",
        "question": "Which language is spoken by the largest number of countries?",
        "ground_truth": "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1",
        "amends": [
            "Do select `LANGUAGE` instead of `language, COUNT(*) as country_count` to return only the language column rather than both language and count. Do use table `countrylanguage` instead of `countries` to access the correct data source containing language information. Do group by `LANGUAGE` instead of `language` to maintain consistent case handling. Do order by `count(*) DESC` instead of `country_count DESC` to directly reference the aggregate function rather than an alias. The amended query now correctly identifies the most common language by counting occurrences in the appropriate table and returns only the language value itself."
        ],
        "rules": [
            "1) When answering about \"which language is spoken by the largest number of countries\": make sure the output order: only return the LANGUAGE column. 2) When the question mentions \"countries\": \"countries\" actually means \"countrylanguage in schema\". 3) When the question asks for \"largest number of countries\" for languages: rank rows by count(*) in descending direction and keep the first 1 row. 4) When the question asks for \"count of countries\" per language: compute the number of rows using the canonical key for countries (not specified in amends, but use count(*) as shown). 5) When the question says \"per language\"/\"by language\": organize results by the token for LANGUAGE and compute count(*) per group. 6) When choosing identifier delimiters: do not replace the exact case shown in amends - use LANGUAGE (uppercase) not language (lowercase)."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, COUNT(*) as country_count FROM countries GROUP BY language ORDER BY country_count DESC LIMIT 1;",
            "SELECT Language FROM countrylanguage GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY COUNT(*) DESC LIMIT 1"
        ]
    },
    "872": {
        "db_id": "network_1",
        "question": "Show the ID of the high schooler named Kyle.",
        "ground_truth": "SELECT ID FROM Highschooler WHERE name  =  \"Kyle\"",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM Highschooler WHERE name = 'Kyle';"
        ],
        "rule_sql": [
            "SELECT ID FROM Highschooler WHERE name = 'Kyle';"
        ]
    },
    "40": {
        "db_id": "concert_singer",
        "question": "What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?",
        "ground_truth": "SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",
        "amends": [
            "Do reference table `singer` instead of `singers` in the FROM clause. Do filter on column `song_name` instead of `title` in the WHERE condition with the LIKE pattern '%Hey%'. The amended query now correctly retrieves artist names and countries from the singer table based on song titles containing 'Hey'."
        ],
        "rules": [
            "1) When answering about singers and their countries: use table \"singer\" (not \"singers\") to get name and country information. 2) When filtering for songs with 'Hey' in the title: use column \"song_name\" (not \"title\") with the exact pattern '%Hey%' to match song titles containing the word 'Hey'. 3) When the question asks for name and country of origin: output columns should be \"name\" and \"country\" in that order from the \"singer\" table."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country FROM singers WHERE title LIKE '%Hey%';",
            "SELECT Name, Country FROM singer WHERE Song_Name LIKE '%Hey%';"
        ],
        "rule_sql": [
            "SELECT name, country FROM singer WHERE song_name LIKE '%Hey%';"
        ]
    },
    "867": {
        "db_id": "network_1",
        "question": "What is the grade of each high schooler?",
        "ground_truth": "SELECT grade FROM Highschooler",
        "amends": [
            "Do select only `grade` instead of both `name` and `grade`. Do reference the table as `Highschooler` instead of `high_schoolers`. Do remove the `WHERE grade > 12` filter instead of keeping it. The amended query now correctly selects only the grade column from the Highschooler table without any filtering conditions."
        ],
        "rules": [
            "1) When answering about \"grade of each high schooler\": make sure the output order: grade. 2) When the question mentions \"high schooler\": \"high schooler\" actually means \"Highschooler\" in schema. 3) When selecting from the Highschooler table: do not apply any filtering conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, grade FROM high_schoolers WHERE grade > 12;",
            "SELECT grade FROM Highschooler;"
        ],
        "rule_sql": [
            "SELECT grade FROM Highschooler ORDER BY grade;"
        ]
    },
    "59": {
        "db_id": "pets_1",
        "question": "Find the first name of students who have both cat and dog pets .",
        "ground_truth": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "amends": [
            "Do use `t1.fname` from the `student` table instead of `first_name` from a non-existent `students` table. Do join three tables (`student`, `has_pet`, and `pets`) with proper relationships through `stuid` and `petid` instead of querying a single table with a direct `pet` column. Do filter for `t3.pettype = 'cat'` in one branch and `t3.pettype = 'dog'` in another instead of using `OR` conditions on a single column. Do use `INTERSECT` to find students who have both cats and dogs instead of using `OR` which would find students with either pets. The amended query now correctly identifies students who own both cats and dogs by intersecting two separate queries for each pet type."
        ],
        "rules": [
            "1) When the question asks for \"first name of students\": use \"t1.fname\" from the \"student\" table instead of \"first_name\" from a non-existent \"students\" table. 2) When combining student and pet information: link \"student\" (T1), \"has_pet\" (T2), and \"pets\" (T3) tables where T1.stuid = T2.stuid and T2.petid = T3.petid to establish proper relationships. 3) When filtering for cat pets: use condition \"t3.pettype = 'cat'\" exactly as specified. 4) When filtering for dog pets: use condition \"t3.pettype = 'dog'\" exactly as specified. 5) When finding students who have both cat and dog pets: use INTERSECT between the results for cat pets and dog pets instead of OR conditions which would find students with either pet."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM students WHERE pet = 'cat' OR pet = 'dog';",
            "SELECT t1.Fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'cat'\nINTERSECT\nSELECT t1.Fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'dog'"
        ],
        "rule_sql": [
            "SELECT t1.fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'cat'\nINTERSECT\nSELECT t1.fname\nFROM Student t1\nJOIN Has_Pet t2 ON t1.StuID = t2.StuID\nJOIN Pets t3 ON t2.PetID = t3.PetID\nWHERE t3.PetType = 'dog'"
        ]
    },
    "245": {
        "db_id": "flight_2",
        "question": "What are flight numbers of Airline \"United Airlines\"?",
        "ground_truth": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  \"United Airlines\"",
        "amends": [
            "Do join `AIRLINES` as `T2` on `T2.uid = T1.Airline` instead of querying only the `flights` table. Do reference `T1.FlightNo` instead of `flight_number` and filter on `T2.Airline = \"United Airlines\"` instead of `airline = 'Delta Airlines'`. The amended query now correctly joins to the airlines table to filter by airline name rather than assuming the airline name is stored directly in the flights table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about flight numbers of an airline: make sure the output order: T1.FlightNo 2) When the question mentions \"United Airlines\": \"United Airlines\" actually means T2.Airline = \"United Airlines\" in schema 3) When combining T1 and T2 for shared entities: link rows where T2.uid = T1.Airline and keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like \"United Airlines\""
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT flight_number FROM flights WHERE airline = 'Delta Airlines';",
            "SELECT T1.FlightNo FROM flights T1 JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'"
        ],
        "rule_sql": [
            "SELECT T1.FlightNo FROM flights T1 INNER JOIN airlines T2 ON T2.uid = T1.Airline WHERE T2.Airline = \"United Airlines\""
        ]
    },
    "417": {
        "db_id": "museum_visit",
        "question": "What are the opening year and staff number of the museum named Plaza Museum?",
        "ground_truth": "SELECT Num_of_Staff ,  Open_Year FROM museum WHERE name  =  'Plaza Museum'",
        "amends": [
            "Do use column aliases `Num_of_Staff` and `Open_Year` instead of the original column names `staff_number` and `opening_year`. Do reference the table as `museum` instead of `museums` while maintaining the same `WHERE` filter condition `name = 'Plaza Museum'`. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column selection and table reference.",
            "Do reverse the column order by selecting `Num_of_Staff, Open_Year` instead of `Open_Year, Num_of_Staff`. Do use lowercase `name` in the WHERE clause instead of uppercase `Name` while maintaining the same filter condition `= 'Plaza Museum'`. The amended query now matches RIGHT_SQL's behavior with identical column output and filtering logic."
        ],
        "rules": [
            "1) When the question asks about \"opening year\" and \"staff number\": use the exact column aliases \"Num_of_Staff\" and \"Open_Year\" instead of the original column names. 2) When referencing the museums table: use the exact table name \"museum\" instead of \"museums\". 3) When filtering for the museum named \"Plaza Museum\": use the exact literal value 'Plaza Museum' with the condition name = 'Plaza Museum'.",
            "1) When the question asks for opening year and staff number of a museum: make sure the output order is Num_of_Staff, Open_Year instead of Open_Year, Num_of_Staff. 2) When filtering by museum name: use lowercase name in the WHERE clause instead of uppercase Name while maintaining the exact filter condition = 'Plaza Museum'. 3) When handling text literals: preserve the exact case, spacing, and punctuation of 'Plaza Museum' without modification."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT opening_year, staff_number FROM museums WHERE name = 'Plaza Museum';",
            "SELECT Open_Year, Num_of_Staff FROM museum WHERE Name = 'Plaza Museum';",
            "SELECT Num_of_Staff, Open_Year FROM museum WHERE name = 'Plaza Museum'"
        ],
        "rule_sql": [
            "SELECT Num_of_Staff, Open_Year FROM museum WHERE name = 'Plaza Museum'"
        ]
    },
    "555": {
        "db_id": "student_transcripts_tracking",
        "question": "Who is the first student to register? List the first name, middle name and last name.",
        "ground_truth": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",
        "amends": [
            "Do reference the `date_first_registered` column instead of `registration_date` in the ORDER BY clause, as the correct column name differs from what was originally specified. The table name should be referenced as `Students` (with capital S) instead of `students` (with lowercase s) to match the correct schema. All other elements including the SELECT list columns (`first_name`, `middle_name`, `last_name`), the LIMIT 1 constraint, and the ascending sort order remain unchanged. The amended query now correctly sorts by the appropriate registration date column and references the proper table name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about the first student to register: sort by the exact column \"date_first_registered\" in ascending order to find the earliest registration. 2) When referencing the student table: use the exact table name \"Students\" (with capital S) as shown in the schema. 3) When selecting student name information: include the exact columns \"first_name\", \"middle_name\", and \"last_name\" in that order. 4) When limiting to the first result: return only the single top row after sorting by registration date."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, middle_name, last_name FROM students ORDER BY registration_date ASC LIMIT 1;",
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1;"
        ]
    },
    "752": {
        "db_id": "world_1",
        "question": "What are the regions that use English or Dutch?",
        "ground_truth": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "amends": [
            "Do select `DISTINCT T1.Region` instead of `region` without distinct. Do join `country AS T1` with `countrylanguage AS T2` instead of querying only `countries`. Do use `LEFT JOIN` on `T1.Code = T2.CountryCode` instead of no join condition. Do filter with `T2.Language = \"English\" OR T2.Language = \"Dutch\"` instead of `language = 'English' AND language = 'Dutch'` which would never return results. The amended query now correctly finds regions where either English or Dutch is spoken, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"regions that use English or Dutch\": make sure the output order: T1.Region\n2) When the question mentions \"regions\": \"regions\" actually means \"T1.Region in schema\"\n3) When combining T1 and T2 for shared entities: link rows where T1.Code = T2.CountryCode exactly as shown in the amends; keep only matching pairs (inner match).\n4) When filtering for languages: use T2.Language = \"English\" OR T2.Language = \"Dutch\" with exact literals \"English\" and \"Dutch\" as shown in the amends.\n5) When selecting regions: use DISTINCT T1.Region to ensure each region appears only once in the results."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT region FROM countries WHERE language = 'English' AND language = 'Dutch';",
            "SELECT DISTINCT T1.Region FROM country AS T1 LEFT JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Region\nFROM country T1\nINNER JOIN countrylanguage T2 ON T1.Code = T2.CountryCode\nWHERE T2.Language = 'English' OR T2.Language = 'Dutch'\nORDER BY T1.Region"
        ]
    },
    "1001": {
        "db_id": "singer",
        "question": "What is the count of singers?",
        "ground_truth": "SELECT count(*) FROM singer",
        "amends": [
            "Do reference the `singer` table instead of the `singers` table. Do remove the `WHERE age > 100` filter instead of keeping it. The amended query now correctly counts all records in the singer table without any age restriction, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"count of singers\": use the exact table name \"singer\" instead of \"singers\". 2) When counting all records in a table: do not apply any WHERE filter conditions unless explicitly specified in the question."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM singers WHERE age > 100;",
            "SELECT COUNT(*) FROM singer;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM singer;"
        ]
    },
    "631": {
        "db_id": "tvshow",
        "question": "Find the package choice and series name of the TV channel that has high definition TV.",
        "ground_truth": "SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  \"yes\"",
        "amends": [
            "Do use `package_option` instead of `package_choice` in the SELECT list. Do reference table `TV_Channel` instead of `tv_channels` in the FROM clause. Do filter on `hight_definition_TV = \"yes\"` instead of `high_definition = 'yes'` in the WHERE clause, correcting both the column name and using double quotes instead of single quotes for the string literal. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"package choice\": use the exact column token \"package_option\" from table \"TV_Channel\". 2) When filtering for high definition TV: use the exact column token \"hight_definition_TV\" and the exact string literal \"yes\" with double quotes. 3) When referencing the TV channels table: use the exact table name \"TV_Channel\" with the correct case and quotes as shown in the schema."
        ],
        "amend_res": 1,
        "rule_res": 1,
        "amend_sql": [
            "SELECT package_choice, series_name FROM tv_channels WHERE high_definition = 'yes';",
            "SELECT package_option, series_name FROM TV_Channel WHERE hight_definition_TV = \"yes\""
        ],
        "rule_sql": [
            "SELECT \"Package_Option\", \"series_name\" FROM \"TV_Channel\" WHERE \"Hight_definition_TV\" = \"yes\";"
        ]
    }
}